/* -*- Mode: C; c-basic-offset: 4 -*-
 * pygtk- Python bindings for the GTK toolkit.
 * Copyright (C) 1998-2003  James Henstridge
 *
 *   gtkcontainer.override: overrides for various container widgets.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA
 */
%%
ignore
  gtk_container_get_toplevels
  gtk_container_add_child_arg_type
  gtk_container_query_child_args
  gtk_container_child_args_collect
  gtk_container_child_arg_get_info
  gtk_container_foreach_full
  gtk_container_add_with_args
  gtk_container_addv
  gtk_container_child_set_valist
  gtk_container_child_get_valist
  gtk_container_class_find_child_property
%%
override gtk_container_children noargs
static PyObject *
_wrap_gtk_container_children(PyGObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkContainer.get_children"))
        return NULL;
    return _wrap_gtk_container_get_children(self);
}
%%
override gtk_container_get_children noargs
static PyObject *
_wrap_gtk_container_get_children(PyGObject *self)
{
    GList *list, *tmp;
    PyObject *py_list;

    list = gtk_container_get_children(GTK_CONTAINER(self->obj));

    if ((py_list = PyList_New(0)) == NULL) {
        g_list_free(list);
        return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        PyObject *gtk_obj = pygobject_new(G_OBJECT(tmp->data));

        if (gtk_obj == NULL) {
            g_list_free(list);
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_Append(py_list, gtk_obj);
        Py_DECREF(gtk_obj);
    }
    g_list_free(list);
    return py_list;
}
%%
override gtk_container_set_focus_chain kwargs
static PyObject *
_wrap_gtk_container_set_focus_chain(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "focusable_widgets", NULL };
    PyObject *py_focusable_widgets;
    gint len, i;
    GList *focusable_widgets = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkContainer.set_focus_chain", kwlist,
                                     &py_focusable_widgets))
        return NULL;
    if (!PySequence_Check(py_focusable_widgets)) {
        PyErr_SetString(PyExc_TypeError,
                        "focusable_widgets must be a sequence");
        return NULL;
    }
    len = PySequence_Length(py_focusable_widgets);
    for (i = 0; i < len; i++) {
        PyObject *item = PySequence_GetItem(py_focusable_widgets, i);

        if (!pygobject_check(item, &PyGtkWidget_Type)) {
            PyErr_SetString(PyExc_TypeError,
                            "focusable_widgets members must be GtkWidgets");
            Py_DECREF(item);
            return NULL;
        }
        focusable_widgets = g_list_prepend(focusable_widgets,
                                           pygobject_get(item));
        Py_DECREF(item);
    }
    focusable_widgets = g_list_reverse(focusable_widgets);
    gtk_container_set_focus_chain(GTK_CONTAINER(self->obj), focusable_widgets);
    g_list_free(focusable_widgets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_container_get_focus_chain noargs
static PyObject *
_wrap_gtk_container_get_focus_chain(PyGObject *self)
{
    GList *list = NULL;

    if (gtk_container_get_focus_chain(GTK_CONTAINER(self->obj), &list)) {
        PyObject *py_list;
        GList *tmp;

        if ((py_list = PyList_New(0)) == NULL) {
            g_list_free(list);
            return NULL;
        }
        for (tmp = list; tmp != NULL; tmp = tmp->next) {
            PyObject *gtk_obj = pygobject_new(G_OBJECT(tmp->data));

            if (gtk_obj == NULL) {
                g_list_free(list);
                Py_DECREF(py_list);
                return NULL;
            }
            PyList_Append(py_list, gtk_obj);
            Py_DECREF(gtk_obj);
        }
        g_list_free(list);
        return py_list;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_container_child_get_property
static PyObject *
_wrap_gtk_container_child_get_property(PyGObject *self, PyObject *args)
{
    PyGObject *pychild;
    gchar *property_name;
    GtkContainer *container;
    GtkWidget *child;
    GList *children;
    GObjectClass *class;
    GParamSpec *pspec;
    GValue value = { 0, } ;
    PyObject *ret;

    if (!PyArg_ParseTuple(args, "O!s:GtkContainer.child_get_property",
                          &PyGtkWidget_Type, &pychild,
                          &property_name)) {
        return NULL;
    }

    container = GTK_CONTAINER(self->obj);
    child = GTK_WIDGET(pychild->obj);

    children = gtk_container_get_children(container);
    if (g_list_find(children, child) == NULL) {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a child");
        return NULL;
    }

    class = G_OBJECT_GET_CLASS(container);
    pspec = gtk_container_class_find_child_property(class, property_name);
    if (!pspec) {
        gchar buf[512];
        g_snprintf(buf, sizeof(buf),
                   "container does not support property `%s'",
                   property_name);

        PyErr_SetString(PyExc_TypeError, buf);
        return NULL;
    }

    g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));

    gtk_container_child_get_property(container,
                                     child,
                                     property_name,
                                     &value);

    ret = pyg_value_as_pyobject(&value, TRUE);
    g_value_unset(&value);

    return ret;
}
%%
override gtk_container_child_set_property
static PyObject *
_wrap_gtk_container_child_set_property(PyGObject *self, PyObject *args)
{
    gchar *property_name;
    PyGObject *pychild;
    GtkContainer *container;
    GtkWidget *child;
    GList *children;
    PyGObject *pyvalue;
    GObjectClass *class;
    GParamSpec *pspec;
    GValue value = { 0, } ;

    if (!PyArg_ParseTuple(args, "O!sO:GtkContainer.child_set_property",
                          &PyGtkWidget_Type, &pychild,
                          &property_name, &pyvalue)) {
        return NULL;
    }

    container = GTK_CONTAINER(self->obj);
    child = GTK_WIDGET(pychild->obj);

    children = gtk_container_get_children(container);
    if (g_list_find(children, child) == NULL) {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a child");
        return NULL;
    }

    class = G_OBJECT_GET_CLASS(self->obj);
    pspec = gtk_container_class_find_child_property(class, property_name);
    if (!pspec) {
        gchar buf[512];
        g_snprintf(buf, sizeof(buf),
                   "container does not support property `%s'",
                   property_name);
        PyErr_SetString(PyExc_TypeError, buf);

        return NULL;
    }

    g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));

    pyg_value_from_pyobject(&value, (PyObject*)pyvalue);

    gtk_container_child_set_property(container,
                                     child,
                                     property_name,
                                     &value);
    g_value_unset(&value);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_container_child_set
static PyObject *
_wrap_gtk_container_child_set(PyGObject *self, PyObject *args)
{
    PyGObject *pychild;
    GtkContainer *container;
    GtkWidget *child;
    GList *children;
    GObjectClass *class;
    int len, i;

    if ((len = PyTuple_Size(args)) < 1) {
        PyErr_SetString(PyExc_TypeError, "requires at least one argument");
        return NULL;
    }
    pychild = (PyGObject*)PyTuple_GetItem(args, 0);
    if (!pygobject_check(pychild, &PyGtkWidget_Type)) {
        PyErr_SetString(PyExc_TypeError,
                        "first argument should be a GtkWidget");
        return NULL;
    }

    container = GTK_CONTAINER(self->obj);
    child = GTK_WIDGET(pychild->obj);

    children = gtk_container_get_children(container);
    if (g_list_find(children, child) == NULL) {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a child");
        return NULL;
    }

    if ((len - 1) % 2) {
        PyErr_SetString(PyExc_TypeError,
                        "Argument list must be column, value pairs.  No -1 "
                        "termination is needed.");
        return NULL;
    }

    class = G_OBJECT_GET_CLASS(self->obj);
    for (i = 1; i < len; i+=2) {
        PyObject *py_property = PyTuple_GetItem(args, i);
        PyObject *py_value = PyTuple_GetItem(args, i + 1);
        gchar *property_name;
        GParamSpec *pspec;
        GValue value = { 0 };

        if (!PyString_Check(py_property)) {
            PyErr_SetString(PyExc_TypeError,
                            "Expected string argument for property.");
            return NULL;
        }

        property_name = PyString_AsString(py_property);

        pspec = gtk_container_class_find_child_property(class, property_name);
        if (!pspec) {
            gchar buf[512];
            g_snprintf(buf, sizeof(buf),
                       "container does not support property `%s'",
                       property_name);
            PyErr_SetString(PyExc_TypeError, buf);

            return NULL;
        }

        g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));

        pyg_value_from_pyobject(&value, (PyObject*)py_value);

        gtk_container_child_set_property(container, child, property_name, &value);

        g_value_unset(&value);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_container_child_get
static PyObject *
_wrap_gtk_container_child_get(PyGObject *self, PyObject *args)
{
    PyGObject *pychild;
    GtkContainer *container;
    GtkWidget *child;
    GList *children;
    GObjectClass *class;
    int len, i;
    PyObject *tuple;

    if ((len = PyTuple_Size(args)) < 1) {
        PyErr_SetString(PyExc_TypeError, "requires at least one argument");
        return NULL;
    }
    pychild = (PyGObject*)PyTuple_GetItem(args, 0);
    if (!pygobject_check(pychild, &PyGtkWidget_Type)) {
        PyErr_SetString(PyExc_TypeError,
                        "first argument should be a GtkWidget");
        return NULL;
    }

    container = GTK_CONTAINER(self->obj);
    child = GTK_WIDGET(pychild->obj);

    children = gtk_container_get_children(container);
    if (g_list_find(children, child) == NULL) {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a child");
        return NULL;
    }

    tuple = PyTuple_New(len-1);
    class = G_OBJECT_GET_CLASS(self->obj);
    for (i = 1; i < len; i++) {
        PyObject *py_property = PyTuple_GetItem(args, i);
        gchar *property_name;
        GParamSpec *pspec;
        GValue value = { 0 };
        PyObject *item;

        if (!PyString_Check(py_property)) {
            PyErr_SetString(PyExc_TypeError,
                            "Expected string argument for property.");
            return NULL;
        }

        property_name = PyString_AsString(py_property);

        pspec = gtk_container_class_find_child_property(class, property_name);
        if (!pspec) {
            gchar buf[512];
            g_snprintf(buf, sizeof(buf),
                       "container does not support property `%s'",
                       property_name);
            PyErr_SetString(PyExc_TypeError, buf);

            return NULL;
        }

        g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));

        gtk_container_child_get_property(container, child, property_name, &value);

        item = pyg_value_as_pyobject(&value, TRUE);
        PyTuple_SetItem(tuple, i-1, item);
        Py_INCREF(item);

        g_value_unset(&value);
    }

    Py_INCREF(tuple);
    return tuple;
}
%%
override gtk_container_add_with_properties
static PyObject *
_wrap_gtk_container_add_with_properties(PyGObject *self, PyObject *args)
{
    PyGObject *pychild;
    GtkContainer *container;
    GtkWidget *child;
    GObjectClass *class;
    int len, i;

    if ((len = PyTuple_Size(args)) < 1) {
        PyErr_SetString(PyExc_TypeError, "requires at least one argument");
        return NULL;
    }
    pychild = (PyGObject*)PyTuple_GetItem(args, 0);
    if (!pygobject_check(pychild, &PyGtkWidget_Type)) {
        PyErr_SetString(PyExc_TypeError,
                        "first argument should be a GtkWidget");
        return NULL;
    }

    container = GTK_CONTAINER(self->obj);
    child = GTK_WIDGET(pychild->obj);

    if ((len - 1) % 2) {
        PyErr_SetString(PyExc_TypeError,
                        "Argument list must be column, value pairs.  No -1 "
                        "termination is needed.");
        return NULL;
    }

    gtk_widget_freeze_child_notify(child);

    gtk_container_add(container, child);

    class = G_OBJECT_GET_CLASS(self->obj);
    for (i = 1; i < len; i+=2) {
        PyObject *py_property = PyTuple_GetItem(args, i);
        PyObject *py_value = PyTuple_GetItem(args, i + 1);
        gchar *property_name;
        GParamSpec *pspec;
        GValue value = { 0 };

        if (!PyString_Check(py_property)) {
            PyErr_SetString(PyExc_TypeError,
                            "Expected string argument for property.");
            return NULL;
        }

        property_name = PyString_AsString(py_property);

        pspec = gtk_container_class_find_child_property(class, property_name);
        if (!pspec) {
            gchar buf[512];
            g_snprintf(buf, sizeof(buf),
                       "container does not support property `%s'",
                       property_name);
            PyErr_SetString(PyExc_TypeError, buf);

            return NULL;
        }

        g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));

        pyg_value_from_pyobject(&value, (PyObject*)py_value);

        gtk_container_child_set_property(container, child, property_name, &value);

        g_value_unset(&value);
    }

    gtk_widget_thaw_child_notify(child);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_container_foreach
static void
pygtk_container_for_common_marshal(GtkWidget *widget,
				   gpointer data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = data;
    PyObject *py_widget, *retobj;

    g_assert(cunote->func);

    state = pyg_gil_state_ensure();

    py_widget = pygobject_new((GObject*)widget);
    if (cunote->data)
        retobj = PyEval_CallFunction(cunote->func, "(NO)",
                                     py_widget, cunote->data);
    else
        retobj = PyEval_CallFunction(cunote->func, "(N)",
                                     py_widget);

    if (retobj == NULL) {
        PyErr_Print();
    }

    Py_XDECREF(retobj);

    pyg_gil_state_release(state);
}
static PyObject *
pygtk_container_for_common(PyGObject *self, PyObject *args, unsigned for_index)
{
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify cunote;
    static struct {
        char *parse_arg;
        void (*for_func)(GtkContainer *container, GtkCallback callback,
                          gpointer callback_data);
    } table[] = {
            { "O|O:GtkContainer.foreach", gtk_container_foreach },
            { "O|O:GtkContainer.forall", gtk_container_forall }
    };

    g_assert(for_index < countof(table));

    if (!PyArg_ParseTuple(args, table[for_index].parse_arg,
                          &pyfunc, &pyarg))
         return NULL;
 
    cunote.func = pyfunc;
    cunote.data = pyarg;
    table[for_index].for_func(GTK_CONTAINER(self->obj),
			      pygtk_container_for_common_marshal,
			      &cunote);

    Py_INCREF(Py_None);
    return Py_None;
}
static PyObject *
_wrap_gtk_container_foreach(PyGObject *self, PyObject *args)
{
    return pygtk_container_for_common(self, args, PYGTK_CONTAINER_FOREACH);
}
%%
override gtk_container_forall
static PyObject *
_wrap_gtk_container_forall(PyGObject *self, PyObject *args)
{
    return pygtk_container_for_common(self, args, PYGTK_CONTAINER_FORALL);
}
%%
override gtk_container_class_list_child_properties kwargs
static PyObject *
_wrap_gtk_container_class_list_child_properties (PyObject *self, PyObject *args,
					      PyObject*kwargs)
{
    static char *kwlist[] = { "klass", NULL };
    GParamSpec **specs;
    PyObject *py_itype, *list;
    GType itype;
    GObjectClass *class;
    guint nprops;
    guint i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:gtk.container_class_list_child_properties", kwlist,
				     &py_itype))
	return NULL;
    
    if ((itype = pyg_type_from_object(py_itype)) == 0)
	return NULL;

    if (!g_type_is_a(itype, G_TYPE_OBJECT)) {
	PyErr_SetString(PyExc_TypeError, "type must be derived from GObject");
	return NULL;
    }

    class = g_type_class_ref(itype);
    if (!class) {
	PyErr_SetString(PyExc_RuntimeError,
			"could not get a reference to type class");
	return NULL;
    }

    specs = gtk_container_class_list_child_properties(class, &nprops);
    list = PyTuple_New(nprops);
    if (list == NULL) {
	g_free(specs);
	g_type_class_unref(class);
	return NULL;
    }
    
    for (i = 0; i < nprops; i++) {
	PyTuple_SetItem(list, i, pyg_param_spec_new(specs[i]));
    }
    
    g_free(specs);
    g_type_class_unref(class);

    return list;
}
%%
override gtk_container_class_install_child_property kwargs
static PyObject *
_wrap_gtk_container_class_install_child_property (PyObject *self,
					       PyObject *args,
					       PyObject* kwargs)
{
    static char *kwlist[] = { "klass", "property_id", "pspec", NULL };
    PyObject *py_itype, *property;
    GType itype;
    GtkContainerClass *class;
    guint property_id;
    GParamSpec *pspec;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OiO:container_class_install_child_property",
				     kwlist,
				     &py_itype, &property_id, &property))
	return NULL;


    if ((itype = pyg_type_from_object(py_itype)) == 0)
	return NULL;

    if (!g_type_is_a(itype, GTK_TYPE_CONTAINER)) {
	PyErr_SetString(PyExc_TypeError, "type must be derived from GtkContainer");
	return NULL;
    }

    class = g_type_class_ref(itype);
    if (!class) {
	PyErr_SetString(PyExc_RuntimeError,
			"could not get a reference to type class");
	return NULL;
    }

    pspec = pyg_param_spec_from_object(property);
    if(!pspec) {
	g_type_class_unref(class);
	return NULL;
    }

    if (gtk_container_class_find_child_property(G_OBJECT_CLASS(class), pspec->name)) {
	PyErr_Format(PyExc_TypeError,
		     "there is already a '%s' property installed", pspec->name);
	g_type_class_unref(class);
	return NULL;
    }
    
    gtk_container_class_install_child_property(class, property_id, pspec);
	
    g_type_class_unref(class);

    Py_INCREF(Py_None);
    return Py_None;
}
