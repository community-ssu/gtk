/* -*- Mode: C; c-basic-offset: 4 -*-
 * pygtk- Python bindings for the GTK toolkit.
 * Copyright (C) 1998-2003  James Henstridge
 *
 *   gtk.override: overrides for the gtk module.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA
 */
%%
headers
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"
#include <gtk/gtk.h>
#include <gtk/gtktreeitem.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <gdk-pixbuf/gdk-pixdata.h>
#include "pygtk-private.h"

#define PYGTK_CONTAINER_FOREACH 0
#define PYGTK_CONTAINER_FORALL 1
#define countof(array) (sizeof(array)/sizeof(array[0]))

/* make GDK_DISPLAY() the case macro */
#undef GDK_DISPLAY
#define GDK_DISPLAY(object) (GDK_DISPLAY_OBJECT(object))

/* from the gdk portion ... */
extern PyTypeObject PyGdkColormap_Type;
extern PyTypeObject PyGdkGC_Type;
extern PyTypeObject PyGdkWindow_Type;
extern PyTypeObject PyGdkPixmap_Type;
extern PyTypeObject PyGdkImage_Type;
extern PyTypeObject PyGdkPixbuf_Type;
extern PyTypeObject PyGdkPixbufAnimation_Type;
extern PyTypeObject PyGdkDragContext_Type;
extern PyTypeObject PyGdkDrawable_Type;
extern PyTypeObject PyGdkDisplay_Type;
extern PyTypeObject PyGdkScreen_Type;
extern PyTypeObject PyGdkRectangle_Type;
extern PyTypeObject PyGdkDevice_Type;


static gboolean
pygtk_util_pyobject_as_double(PyObject *obj, gdouble *value, const char *argument_name)
{
    PyObject *number;

    if (!PyNumber_Check(obj)) {
        PyErr_Format(PyExc_TypeError, "'%s' must be a number", argument_name);
        return FALSE;
    }
    number = PyNumber_Float(obj);
    if (!number) {
        PyErr_Format(PyExc_TypeError, "Could not convert '%s' to a float", argument_name);
        return FALSE;
    }
    *value = PyFloat_AsDouble(number);
    Py_DECREF(number);
    return TRUE;
}

%%
include 
  gtkclist.override
  gtkcontainer.override
  gtkctree.override
  gtkstyle.override
  gtktextview.override
  gtktreeview.override
  gtkwidget.override
  gtkwindow.override
%%
modulename gtk
%%
import gobject.GObject as PyGObject_Type
import atk.Object as PyAtkObject_Type
import pango.Context as PyPangoContext_Type
import pango.Font as PyPangoFont_Type
import pango.Layout as PyPangoLayout_Type

%%
ignore
  gtk_accel_group_add
  gtk_accel_group_connect
  gtk_accel_group_create_add
  gtk_accel_group_create_remove
  gtk_accel_group_disconnect
  gtk_accel_group_entries_from_object
  gtk_accel_group_get_entry
  gtk_accel_group_handle_add
  gtk_accel_group_handle_remove
  gtk_accel_group_lock_entry
  gtk_accel_group_ref
  gtk_accel_group_remove
  gtk_accel_groups_activate
  gtk_accel_group_unlock_entry
  gtk_accel_group_unref
  gtk_action_group_add_actions_full
  gtk_action_group_add_toggle_actions_full
  gtk_action_group_add_radio_actions_full
  gtk_binding_set_by_class
  gtk_binding_set_clear
  gtk_binding_set_find
  gtk_binding_set_new
  gtk_button_new_from_stock
  gtk_button_new_with_label
  gtk_button_new_with_mnemonic
  gtk_check_button_new_with_label
  gtk_check_button_new_with_mnemonic
  gtk_check_menu_item_new_with_label
  gtk_check_menu_item_new_with_mnemonic
  gtk_clipboard_set_with_owner
  gtk_color_button_new_with_color
  gtk_color_selection_set_color
  gtk_color_selection_get_color
  gtk_combo_box_get_row_separator_func
  gtk_dialog_new
  gtk_drag_dest_handle_event
  gtk_drag_source_handle_event
  gtk_draw_hline
  gtk_draw_vline
  gtk_draw_shadow
  gtk_draw_polygon
  gtk_draw_arrow
  gtk_draw_diamond
  gtk_draw_box
  gtk_draw_flat_box
  gtk_draw_check
  gtk_draw_option
  gtk_draw_tab
  gtk_draw_shadow_gap
  gtk_draw_box_gap
  gtk_draw_extension
  gtk_draw_focus
  gtk_draw_slider
  gtk_draw_handle
  gtk_draw_expander
  gtk_draw_layout
  gtk_draw_resize_grip
  gtk_draw_string
  gtk_entry_new_with_max_length
  gtk_entry_select_region
  gtk_exit
  gtk_false
  gtk_file_chooser_button_new_with_backend
  gtk_file_chooser_button_new_with_dialog
  gtk_file_chooser_dialog_new_with_backend
  gtk_file_chooser_error_quark
  gtk_file_chooser_dialog_widget_new_with_backend
  gtk_file_system_error_quark
  gtk_file_paths_copy
  gtk_file_paths_free
  gtk_font_button_new_with_font
  gtk_gc_get
  gtk_gc_release
  gtk_get_event_widget
  gtk_icon_theme_error_quark
  gtk_idle_add
  gtk_idle_add_full
  gtk_idle_add_priority
  gtk_idle_remove
  gtk_idle_remove_by_data
  gtk_icon_view_new_with_model
  gtk_image_item_menu_new_with_label
  gtk_image_menu_item_new_from_stock
  gtk_image_menu_item_new_with_mnemonic
  gtk_init
  gtk_init_abi_check
  gtk_init_check
  gtk_init_check_abi_check
  gtk_input_add_full
  gtk_input_remove
  gtk_item_factory_create_item
  gtk_item_factory_create_items_ac
  gtk_item_factory_create_menu_entries
  gtk_item_factory_delete_entries
  gtk_item_factory_delete_entry
  gtk_item_factory_popup_data
  gtk_item_factory_popup_with_data
  gtk_item_factory_set_translate_func
  gtk_key_snooper_install
  gtk_key_snooper_remove
  gtk_list_item_new_with_label
  gtk_list_remove_items_no_unref
  gtk_menu_append
  gtk_menu_bar_append
  gtk_menu_bar_insert
  gtk_menu_bar_prepend
  gtk_menu_insert
  gtk_menu_item_new_with_label
  gtk_menu_item_new_with_mnemonic
  gtk_menu_prepend
  gtk_menu_tool_button_new_from_stock
  gtk_object_add_arg_type 
  gtk_object_arg_get
  gtk_object_arg_get_info
  gtk_object_args_collect 
  gtk_object_arg_set
  gtk_object_get
  gtk_object_get_data
  gtk_object_get_data_by_id
  gtk_object_get_user_data
  gtk_object_getv
  gtk_object_new 
  gtk_object_newv 
  gtk_object_query_args
  gtk_object_ref
  gtk_object_remove_data_by_id
  gtk_object_remove_no_notify_by_id
  gtk_object_set
  gtk_object_set_data
  gtk_object_set_data_by_id
  gtk_object_set_data_by_id_full
  gtk_object_set_data_full
  gtk_object_set_user_data
  gtk_object_setv
  gtk_object_sink
  gtk_object_unref
  gtk_object_weakref
  gtk_object_weakunref
  gtk_plug_construct
  gtk_plug_construct_for_display
  gtk_preview_uninit
  gtk_preview_get_info
  gtk_progress_bar_new
  gtk_propagate_event
  gtk_quit_remove_by_data
  gtk_radio_button_group
  gtk_radio_menu_item_group
  gtk_radio_menu_item_new_with_label
  gtk_radio_menu_item_new_with_mnemonic
  gtk_range_default_htrough_click
  gtk_range_default_vtrough_click
  gtk_range_trough_click
  gtk_selection_clear
  gtk_selection_data_copy
  gtk_selection_data_free
  gtk_selection_incr_event
  gtk_selection_notify
  gtk_selection_property_notify
  gtk_selection_request
  gtk_set_locale
  gtk_timeout_remove
  gtk_toggle_button_new_with_label
  gtk_toggle_button_new_with_mnemonic
  gtk_toggle_tool_button_new_from_stock
  gtk_tool_button_new_from_stock
  gtk_trace_referencing
  gtk_tree_remove_items
  gtk_true 
  gtk_type_check_class_cast
  gtk_type_check_object_cast
  gtk_type_register_enum
  gtk_type_register_flags
  gtk_rc_find_pixmap_in_path
  gtk_rc_scanner_new
  gtk_rc_parse_color
  gtk_rc_parse_state
  gtk_rc_parse_priority
  gtk_rc_property_parse_color
  gtk_rc_property_parse_enum
  gtk_rc_property_parse_flags
  gtk_rc_property_parse_requisition
  gtk_rc_property_parse_border
  gtk_target_list_new
  gtk_target_list_ref
  gtk_target_list_unref
  gtk_target_list_add
  gtk_target_list_add_table
  gtk_target_list_remove
  gtk_target_list_find
%%
ignore-glob
  _*
  *_get_type
  *_ref
  *_unref
  gtk_arg_*
  gtk_args_*
  gtk_init_add_*
  gtk_marshal_*
  gtk_pattern_*
  gtk_radio_button_new_*
  gtk_radio_tool_button_new_*
  gtk_quit_add_*
  gtk_signal_*
  gtk_timeout_add*
%%
ignore-win32
  GTK_TYPE_PLUG
  GTK_TYPE_SOCKET
  gtk_socket_new
  gtk_socket_steal
  gtk_socket_add_id
  gtk_socket_get_id
  GtkSocket__proxy_do_plug_added
  GtkSocket__proxy_do_plug_removed
  gtk_plug_new
  gtk_plug_new_for_display
  gtk_plug_get_id
  GtkPlug__proxy_do_embedded
%%
override gtk_paint_polygon kwargs
static PyObject *
_wrap_gtk_paint_polygon(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "state_type", "shadow_type", "area", "widget", "detail", "points", "fill", NULL };
    PyObject *window, *py_state_type, *py_shadow_type, *py_area;
    GtkStateType state_type;
    GtkShadowType shadow_type;
    GdkRectangle area;
    PyObject *widget;
    const gchar *detail;
    PyObject *py_points;
    gint npoints, i;
    GdkPoint *points;
    gboolean fill;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                    "O!OOOO!zOi:GdkStyle.paint_polygon",
                                     kwlist, &PyGdkWindow_Type, &window,
                                     &py_state_type, &py_shadow_type, &py_area,
                                     &PyGtkWidget_Type, &widget, &detail,
                                     &py_points, &fill))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type,
                           (gint *)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type,
                           (gint *)&shadow_type))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    if (!PySequence_Check(py_points)) {
        PyErr_SetString(PyExc_TypeError, "points must be a sequence");
        return NULL;
    }
    npoints = PySequence_Length(py_points);
    points = g_new(GdkPoint, npoints);
    for (i = 0; i < npoints; i++) {
        PyObject *item = PySequence_GetItem(py_points, i);
        Py_DECREF(item);
        if (!PyArg_ParseTuple(item, "hh", &points[i].x, &points[i].y)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "sequence members must be 2-tuples");
            g_free(points);
            return NULL;
        }
    }
    gtk_paint_polygon(GTK_STYLE(self->obj), GDK_WINDOW(pygobject_get(window)),
                      state_type, shadow_type, &area,
                      GTK_WIDGET(pygobject_get(widget)), detail,
                      points, npoints, fill);
    g_free(points);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override-attr GtkSelectionData.data
static PyObject *
_wrap_gtk_selection_data__get_data(PyGObject *self, void *closure)
{
    if (pyg_boxed_get(self, GtkSelectionData)->length >= 0) {
        return PyString_FromStringAndSize(
                        pyg_boxed_get(self, GtkSelectionData)->data,
                        pyg_boxed_get(self, GtkSelectionData)->length);
    } else {
        Py_INCREF(Py_None);
        return Py_None;
    }
}
%%
override gtk_selection_data_set kwargs
static PyObject *
_wrap_gtk_selection_data_set(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "type", "format", "data", NULL };
    PyObject *py_type;
    GdkAtom type;
    int format, length;
    guchar *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "Ois#:GtkSelectionData.set", kwlist,
                                     &py_type, &format, &data, &length))
        return NULL;
    type = pygdk_atom_from_pyobject(py_type);
    if (PyErr_Occurred())
        return NULL;

    gtk_selection_data_set(pyg_boxed_get(self, GtkSelectionData),
                           type, format, data, length);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_selection_data_get_text noargs
static PyObject *
_wrap_gtk_selection_data_get_text(PyObject *self)
{
    guchar *ret;

    ret = gtk_selection_data_get_text(pyg_boxed_get(self, GtkSelectionData));
    if (ret) {
        PyObject *py_ret = PyUnicode_DecodeUTF8(ret, strlen(ret), "strict");
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_selection_data_get_targets noargs
static PyObject *
_wrap_gtk_selection_data_get_targets(PyObject *self)
{
    GdkAtom *targets;
    gint n_atoms;

    if (gtk_selection_data_get_targets(pyg_boxed_get(self, GtkSelectionData),
                                       &targets, &n_atoms)) {
        PyObject *ret;
        gint i;

        ret = PyTuple_New(n_atoms);
        for (i = 0; i < n_atoms; i++)
            PyTuple_SetItem(ret, i, PyString_FromString(gdk_atom_name(targets[i])));
        g_free(targets);
        return ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_clipboard_set_with_data kwargs
static void
clipboard_get_func(GtkClipboard *clipboard, GtkSelectionData *selection_data,
		   guint info, gpointer user_data)
{
    PyObject *callback, *args, *ret;
    PyGILState_STATE state;

    state = pyg_gil_state_ensure();
    callback = PyTuple_GetItem((PyObject *)user_data, 0);
    args = Py_BuildValue("(NNiO)",
			 pygobject_new((GObject *)clipboard),
			 pyg_boxed_new(GTK_TYPE_SELECTION_DATA,
				       selection_data, FALSE, FALSE),
			 info, PyTuple_GetItem((PyObject *)user_data, 2));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
	PyErr_Print();
    Py_XDECREF(ret);
    pyg_gil_state_release(state);
}
static void
clipboard_clear_func(GtkClipboard *clipboard, gpointer user_data)
{
    PyGILState_STATE state;
    PyObject *callback, *args, *ret;

    state = pyg_gil_state_ensure();
    callback = PyTuple_GetItem((PyObject *)user_data, 1);
    args = Py_BuildValue("(NO)",
			 pygobject_new((GObject *)clipboard),
			 PyTuple_GetItem((PyObject *)user_data, 2));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
	PyErr_Print();
    Py_XDECREF(ret);
    Py_DECREF((PyObject *)user_data);
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_clipboard_set_with_data(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "targets", "get_func", "clear_func", "user_data", NULL };
    PyObject *py_targets, *get_func, *clear_func = Py_None, *user_data = Py_None;
    GtkTargetEntry *targets;
    gint n_targets, i;
    gboolean ret;
    PyObject *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO|OO:GtkClipboard.set_with_data",kwlist,
                                     &py_targets, &get_func, &clear_func,
				     &user_data))
        return NULL;
    if (!PyCallable_Check(get_func)) {
	PyErr_SetString(PyExc_TypeError, "get_func must be callable");
	return NULL;
    }
    if (clear_func != Py_None && !PyCallable_Check(clear_func)) {
	PyErr_SetString(PyExc_TypeError,"clear_func must be callable or None");
	return NULL;
    }
    if (!(py_targets = PySequence_Fast(py_targets, "targets must be a sequence")))
	return NULL;
    n_targets = PySequence_Fast_GET_SIZE(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_Fast_GET_ITEM(py_targets, i);
        if (!PyArg_ParseTuple(item, "sii", &targets[i].target,
                              &targets[i].flags, &targets[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(targets);
	    Py_DECREF(py_targets);
            return NULL;
        }
    }
    data = Py_BuildValue("(OOO)", get_func, clear_func, user_data);
    ret = gtk_clipboard_set_with_data(GTK_CLIPBOARD(self->obj),
				      targets, n_targets,
				      clipboard_get_func, clipboard_clear_func,
				      data);
    g_free(targets);
    Py_DECREF(py_targets);
    if (!ret) {
	Py_DECREF(data);
    }

    return PyBool_FromLong(ret);
}
%%
override gtk_label_get noargs
static PyObject *
_wrap_gtk_label_get(PyGObject *self)
{
    gchar *text = NULL;

    gtk_label_get(GTK_LABEL(self->obj), &text);
    if (text)
        return PyString_FromString(text);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_label_get_selection_bounds noargs
static PyObject *
_wrap_gtk_label_get_selection_bounds(PyGObject *self)
{
    int start, end;

    if (!gtk_label_get_selection_bounds(GTK_LABEL(self->obj), &start, &end)) {
       return Py_BuildValue ("()");
    }

    return Py_BuildValue("(ii)", start, end);
}
%%
override gtk_label_get_layout_offsets noargs
static PyObject *
_wrap_gtk_label_get_layout_offsets(PyGObject *self)
{
    gint x;
    gint y;

    gtk_label_get_layout_offsets(GTK_LABEL(self->obj), &x, &y);
    return Py_BuildValue("(ii)", x, y);
}
%%
override gtk_spin_button_get_increments noargs
static PyObject *
_wrap_gtk_spin_button_get_increments(PyGObject *self)
{
    gdouble step;
    gdouble page;

    gtk_spin_button_get_increments(GTK_SPIN_BUTTON(self->obj), &step, &page);
    return Py_BuildValue("(dd)", step, page);
}
%%
override gtk_spin_button_get_range noargs
static PyObject *
_wrap_gtk_spin_button_get_range(PyGObject *self)
{
    gdouble min;
    gdouble max;

    gtk_spin_button_get_range(GTK_SPIN_BUTTON(self->obj), &min, &max);
    return Py_BuildValue("(dd)", min, max);
}
%%
override gtk_box_query_child_packing kwargs
static PyObject *
_wrap_gtk_box_query_child_packing(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *pychild;
    GtkWidget *child;
    GList *children;
    gboolean expand, fill;
    guint padding;
    GtkPackType pack_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!:GtkBox.query_child_packing", kwlist,
                                     &PyGtkWidget_Type, &pychild)) {
        return NULL;
    }

    child = GTK_WIDGET(pychild->obj);
    children = gtk_container_get_children(GTK_CONTAINER(self->obj));
    if (g_list_find(children, child) == NULL) {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a child");
        return NULL;
    }
    gtk_box_query_child_packing(GTK_BOX(self->obj),
                                child, &expand, &fill,
                                &padding, &pack_type);
    return Py_BuildValue("(iiiN)", (int)expand, (int)fill, padding,
			 pyg_enum_from_gtype(GTK_TYPE_PACK_TYPE, pack_type));
}
%%
override gtk_combo_set_popdown_strings kwargs
static PyObject *
_wrap_gtk_combo_set_popdown_strings(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "strings", NULL };
    PyObject *list;
    GList *glist = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkCombo.set_popdown_strings", kwlist,
                                     &list))
        return NULL;
    if (!PySequence_Check(list)) {
        PyErr_SetString(PyExc_TypeError, "first argument must be a sequence");
        return NULL;
    }
    len = PySequence_Length(list);
    for (i = 0; i < len; i++) {
        PyObject *item = PySequence_GetItem(list, i);

        Py_DECREF(item);
        if (!PyString_Check(item) && !PyUnicode_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "sequence item not a string or unicode object");
            g_list_free(glist);
            return NULL;
        }
        glist = g_list_append(glist, PyString_AsString(item));
    }
    gtk_combo_set_popdown_strings(GTK_COMBO(self->obj), glist);
    g_list_free(glist);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_curve_get_vector kwargs
static PyObject *
_wrap_gtk_curve_get_vector(PyGObject *self, PyObject *args,
                           PyObject *kwargs)
{
    static char *kwlist[] = { "size", NULL };
    int size = -1, i;
    gfloat *vector;
    PyObject *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|i:GtkCurve.get_vector", kwlist,
                                     &size))
        return NULL;
    if (size < 0) size = GTK_CURVE(self->obj)->num_points;
    vector = g_new(gfloat, size);
    gtk_curve_get_vector(GTK_CURVE(self->obj), size, vector);
    ret = PyTuple_New(size);
    for (i = 0; i < size; i++)
        PyTuple_SetItem(ret, i, PyFloat_FromDouble(vector[i]));
    g_free(vector);
    return ret;
}
%%
override gtk_curve_set_vector kwargs
static PyObject *
_wrap_gtk_curve_set_vector(PyGObject *self, PyObject *args,
                           PyObject *kwargs)
{
    static char *kwlist[] = { "vector", NULL };
    PyObject *seq;
    int size, i;
    gfloat *vector;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkCurve.set_vector",
                                     kwlist, &seq))
        return NULL;
    if (!PySequence_Check(seq)) {
        PyErr_SetString(PyExc_TypeError, "1st argument is not a sequence");
        return NULL;
    }
    size = PySequence_Length(seq);
    vector = g_new(gfloat, size);
    for (i = 0; i < size; i++) {
        PyObject *item = PySequence_GetItem(seq, i);

        Py_DECREF(item);
        item = PyNumber_Float(item); /* item has a ref now */
        if (item == NULL) {
            g_free(vector);
            return NULL;
        }
        vector[i] = PyFloat_AsDouble(item);
        Py_DECREF(item);
    }
    gtk_curve_set_vector(GTK_CURVE(self->obj), size, vector);
    g_free(vector);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_binding_entry_add_signal
static PyObject *
_wrap_gtk_binding_entry_add_signal(PyGObject *self, PyObject *args)
{
    PyObject *first;
    gint len, i;
    PyObject *class;
    guint keyval, modifiers;
    gchar *signal_name;
    GType class_type;
    GtkBindingSet *bset = NULL;
    GSList *slist = NULL;
    gchar *errmsg;

    len = PyTuple_Size(args);
    if (len < 4) {
        PyErr_SetString(PyExc_TypeError, "binding_entry_add_signal requires at"
                        " least 4 arguments");
        return NULL;
    }
    first = PySequence_GetSlice(args, 0, 4);
    if (!PyArg_ParseTuple(first, "Oiis:binding_entry_add_signal", &class,
                          &keyval, &modifiers, &signal_name)) {
        Py_DECREF(first);
        return NULL;
    }
    Py_DECREF(first);

    class_type = pyg_type_from_object(class);
    if (class_type == 0)
        return NULL;

    bset = gtk_binding_set_by_class(gtk_type_class(class_type));

    /* extra args */
    if ((len-4)%2) {
        PyErr_SetString(PyExc_ValueError,
                        "GtkBindingSet.add_signal requires an even number"
                        " of parameter pairs following the first four args");
        return NULL;
    }
    for (i=4; i < len; i+=2) {
        PyObject *item;
        GType arg_type;
        GtkBindingArg *arg = NULL;

        item = PyTuple_GET_ITEM(args, i);
        arg_type = pyg_type_from_object(item);
        if (!arg_type) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "GtkBindingSet.add_signal parameter types"
                            " must be int");
            goto arg_error;
        }
        arg = g_new0 (GtkBindingArg, 1);
        slist = g_slist_prepend(slist, arg);

        arg->arg_type = arg_type;
        switch (GTK_FUNDAMENTAL_TYPE(arg->arg_type)) {
        case GTK_TYPE_CHAR:
        case GTK_TYPE_UCHAR:
        case GTK_TYPE_INT:
        case GTK_TYPE_UINT:
        case GTK_TYPE_BOOL:
        case GTK_TYPE_ENUM:
        case GTK_TYPE_FLAGS:
        case GTK_TYPE_LONG:
        case GTK_TYPE_ULONG:
            arg->arg_type = GTK_TYPE_LONG;
            item = PyTuple_GET_ITEM(args, i+1);
            if (!PyInt_Check(item)) {
                errmsg = g_strdup_printf("GtkBindingSet.add_signal "
                                         "arg[%u] must be int", i+1);
                PyErr_SetString(PyExc_TypeError, errmsg);
                g_free(errmsg);
                goto arg_error;
            }
            arg->d.long_data = (glong)PyInt_AsLong(item);
            break;
        case GTK_TYPE_FLOAT:
        case GTK_TYPE_DOUBLE:
            arg->arg_type = GTK_TYPE_DOUBLE;
            item = PyTuple_GET_ITEM(args, i+1);
            if (!PyFloat_Check(item)) {
                errmsg = g_strdup_printf("GtkBindingSet.add_signal "
                                         "arg[%u] must be float", i+1);
                PyErr_SetString(PyExc_TypeError, errmsg);
                g_free(errmsg);
                goto arg_error;
            }
            arg->d.long_data = (gdouble)PyFloat_AsDouble(item);
            break;
        case GTK_TYPE_STRING:
            arg->arg_type = GTK_TYPE_STRING;
            if (arg->arg_type != GTK_TYPE_IDENTIFIER)
                arg->arg_type = GTK_TYPE_STRING;
            item = PyTuple_GET_ITEM(args, i+1);
            if (!PyString_Check(item)) {
                errmsg = g_strdup_printf("GtkBindingSet.add_signal arg[%u] "
                                         "must be non-empty string", i+1);
                PyErr_SetString(PyExc_TypeError, errmsg);
                g_free(errmsg);
                goto arg_error;
            }
            arg->d.string_data = (gchar*)PyString_AsString(item);
            if (!arg->d.string_data) {
                errmsg = g_strdup_printf("GtkBindingSet.add_signal arg[%u] "
                                         "must be non-empty string", i+1);
                PyErr_SetString(PyExc_TypeError, errmsg);
                g_free(errmsg);
                goto arg_error;
            }
            break;
        default:
            errmsg = g_strdup_printf("GtkBindingSet.add_signal unsupported "
                                     "type %10s for arg[%u]",
                                     gtk_type_name(arg->arg_type), i+1);
            PyErr_SetString(PyExc_TypeError, errmsg);
            g_free(errmsg);
            goto arg_error;
        } /* switch */
    }

    slist = g_slist_reverse (slist);
    gtk_binding_entry_add_signall (bset, keyval,modifiers, signal_name, slist);

    g_slist_foreach(slist, (GFunc)g_free, NULL);
    g_slist_free(slist);

    Py_INCREF(Py_None);
    return Py_None;

arg_error:
    if (slist) {
        g_slist_foreach(slist, (GFunc)g_free, NULL);
        g_slist_free(slist);
    }
    return NULL;
}
%%
override gtk_main noargs
static PyObject *
_wrap_gtk_main(PyObject *self)
{
    // Call enable_threads again to ensure that the thread state is recorded
    if (_PyGObject_API->threads_enabled)
	pyg_enable_threads();

    pyg_begin_allow_threads;
    gtk_main();
    pyg_end_allow_threads;
    if (PyErr_Occurred())
        return NULL;
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_main_iteration kwargs
static PyObject *
_wrap_gtk_main_iteration(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = {"block", NULL};
    int block = 1, ret;

    if(!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:main_iteration", kwlist,
                                    &block))
        return NULL;
    pyg_begin_allow_threads;
    ret = gtk_main_iteration_do(block);
    pyg_end_allow_threads;

    return PyBool_FromLong(ret);
}
%%
override gtk_main_quit args
static PyObject *
_wrap_gtk_main_quit(PyObject *self, PyObject *args)
{
    /* args is just ignored, so obj.connect(signal, func) always works */

    /* Sanity check to make sure we're in a mainloop */
    if (gtk_main_level() == 0) {
	PyErr_SetString(PyExc_RuntimeError,
			"called outside of a mainloop");
	return NULL;
    }
	
    gtk_main_quit();
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_main_iteration_do kwargs
static PyObject *
_wrap_gtk_main_iteration_do(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = {"block", NULL};
    int block = 1, ret;

    if(!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:main_iteration_do",
                                    kwlist, &block))
        return NULL;

    pyg_begin_allow_threads;
    ret = gtk_main_iteration_do(block);
    pyg_end_allow_threads;

    return PyBool_FromLong(ret);
}
%%
override gtk_quit_add
static gboolean
quit_handler_marshal(gpointer user_data)
{
    PyGILState_STATE state;
    PyObject *tuple, *ret;
    gboolean res;

    g_return_val_if_fail(user_data != NULL, FALSE);

    state = pyg_gil_state_ensure();

    tuple = (PyObject *)user_data;
    ret = PyObject_CallObject(PyTuple_GetItem(tuple, 0),
                              PyTuple_GetItem(tuple, 1));
    if (!ret) {
        PyErr_Print();
        res = FALSE;
    } else {
        res = PyObject_IsTrue(ret);
        Py_DECREF(ret);
    }
    pyg_gil_state_release(state);

    return res;
}

static PyObject *
_wrap_gtk_quit_add(PyObject *self, PyObject *args)
{
    gint main_level;
    PyObject *first, *callback, *cbargs = NULL, *data;
    gint len;

    len = PyTuple_Size(args);
    if (len < 2) {
        PyErr_SetString(PyExc_TypeError,
                        "quit_add requires at least 2 args");
        return NULL;
    }
    first = PySequence_GetSlice(args, 0, 2);
    if (!PyArg_ParseTuple(first, "iO:quit_add", &main_level, &callback)) {
        Py_DECREF(first);
        return NULL;
    }
    Py_DECREF(first);
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "second argument not callable");
        return NULL;
    }

    cbargs = PySequence_GetSlice(args, 2, len);
    if (cbargs == NULL)
      return NULL;

    data = Py_BuildValue("(ON)", callback, cbargs);
    if (data == NULL)
      return NULL;
    return PyInt_FromLong(gtk_quit_add_full(main_level, quit_handler_marshal,
                                            NULL, data, pyg_destroy_notify));
}
%%
override gtk_get_current_event_state noargs
static PyObject *
_wrap_gtk_get_current_event_state (PyGObject *self)
{
    GdkModifierType state = 0;

    if (gtk_get_current_event_state (&state)) {
	return pyg_flags_from_gtype (GDK_TYPE_MODIFIER_TYPE, state);
    } else {
	Py_INCREF (Py_None);
	return Py_None;
    }
}
%%
override gtk_editable_insert_text kwargs
static PyObject *
_wrap_gtk_editable_insert_text(PyGObject *self, PyObject *args,
                               PyObject *kwargs)
{
    static char *kwlist[] = { "text", "position", NULL };
    char *text;
    int len, position=0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "s#|i:GtkEditable.insert_text",
                                     kwlist, &text, &len, &position))
        return NULL;
    gtk_editable_insert_text(GTK_EDITABLE(self->obj), text, len, &position);
    return PyInt_FromLong(position);
}
%%
override gtk_editable_get_selection_bounds noargs
static PyObject *
_wrap_gtk_editable_get_selection_bounds(PyGObject *self, PyObject *args)
{
    int start, end;

    if (!gtk_editable_get_selection_bounds(GTK_EDITABLE(self->obj), &start, &end)) {
            return Py_BuildValue ("()");
    }

    return Py_BuildValue ("(ii)", start, end);
}
%%
override gtk_entry_get_layout_offsets noargs
static PyObject *
_wrap_gtk_entry_get_layout_offsets(PyGObject *self, PyObject *args)
{
    int x, y;

    gtk_entry_get_layout_offsets(GTK_ENTRY(self->obj), &x, &y);

    return Py_BuildValue ("(ii)", x, y);
}
%%
override gtk_item_factory_create_items kwargs
static void
pygtk_item_factory_cb(PyGtkCustomNotify *cunote,
                      guint action, GtkWidget *widget)
{
    PyGILState_STATE state;
    PyObject *ret;

    state = pyg_gil_state_ensure();
    if (cunote->data)
        ret = PyObject_CallFunction(cunote->func, "OiO", cunote->data, action,
                                    pygobject_new((GObject *)widget));
    else
        ret = PyObject_CallFunction(cunote->func, "iO", action,
                                    pygobject_new((GObject *)widget));
    if (ret == NULL) {
        PyErr_Print();
    } else
        Py_DECREF(ret);
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_item_factory_create_items(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "entries", "callback_data", NULL };
    PyObject *list, *cb, *cbdata = NULL;
    GtkItemFactoryEntry ent;
    PyObject *extra_data = NULL;
    GtkItemFactory *ifact;
    int i, len;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:GtkItemFactory.create_items", kwlist,
                                     &list, &cbdata))
        return NULL;

    if (!PySequence_Check(list)) {
        PyErr_SetString(PyExc_TypeError, "entries must be a sequence");
        return NULL;
    }

    ifact = GTK_ITEM_FACTORY(self->obj);
    len = PySequence_Size(list);
    for (i = 0; i < len; i++) {
        PyGtkCustomNotify *cunote = NULL;
        PyObject *item = PySequence_GetItem(list, i);
        Py_DECREF(item);

        memset(&ent, 0, sizeof(ent));
        cb = Py_None;

        if (!PyArg_ParseTuple(item, "s|zOizO", &(ent.path), &(ent.accelerator),
                              &cb, &(ent.callback_action), &(ent.item_type),
                              &extra_data)) {
            return NULL;
        }

        if (cb == Py_None) {
            ent.callback = NULL;
        } else {
            ent.callback = (GtkItemFactoryCallback)pygtk_item_factory_cb;
            cunote = g_new0(PyGtkCustomNotify, 1);
            cunote->func = cb;
            cunote->data = cbdata;
            Py_XINCREF(cunote->func);
            Py_XINCREF(cunote->data);
        }

        if (extra_data != NULL) {
            if (PyString_Check(extra_data)) {
                ent.extra_data = PyString_AsString(extra_data);
            } else if (pygobject_check(extra_data, &PyGdkPixbuf_Type)) {
		/* create_items actually expects inline image data 
		 * so let's create it for the user from the pixbuf
		 * it's not optimal but it's convenient
		 */  
		GdkPixdata pixdata; 
		GdkPixbuf * pixbuf;
		guint8 * serialstr;
		guint len;
		
		pixbuf = GDK_PIXBUF(pygobject_get(extra_data));
		gdk_pixdata_from_pixbuf(&pixdata, pixbuf, FALSE);
		serialstr = gdk_pixdata_serialize(&pixdata, &len);
                ent.extra_data = serialstr;
            } else {
                PyErr_SetString(PyExc_TypeError,
                                "last argument must be a GdkPixBuf or a string");
                return NULL;
            }
        }
        if (cunote != NULL) {
	    PyGILState_STATE state;
	    state = pyg_gil_state_ensure();
            g_object_weak_ref(G_OBJECT(ifact),
                              (GWeakNotify) pygtk_custom_destroy_notify,
                              cunote);
	    pyg_gil_state_release(state);
        }

        gtk_item_factory_create_item(ifact, &ent, cunote, 1);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_menu_popup kwargs
static void
pygtk_menu_position(GtkMenu *menu, int *x, int *y, gboolean *push_in,
                    PyObject *func)
{
    PyObject *ret;
    PyGILState_STATE state;

    state = pyg_gil_state_ensure();
    ret = PyObject_CallFunction(func, "O", pygobject_new((GObject *)menu));
    if (ret == NULL || !PyArg_ParseTuple(ret, "iii", x, y, push_in)) {
        PyErr_Print();
        Py_XDECREF(ret);
    } else {
        Py_DECREF(ret);
    }
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_menu_popup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent_menu_shell", "parent_menu_item", "func",
                       "button", "activate_time", NULL };
    PyGObject *py_pms, *py_pmi;
    GtkWidget *pms = NULL, *pmi = NULL;
    PyObject *func;
    int button;
    guint32 time;
    PyObject *pytime;
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,  "OOOiO:GtkMenu.popup",
                                     kwlist, &py_pms, &py_pmi, &func,
                                     &button, &pytime))
        return NULL;
    if (pygobject_check(py_pms, &PyGtkWidget_Type))
        pms = GTK_WIDGET(py_pms->obj);
    else if ((PyObject *)py_pms != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a GtkWidget or None");
        return NULL;
    }
    if (pygobject_check(py_pmi, &PyGtkWidget_Type))
        pmi = GTK_WIDGET(py_pmi->obj);
    else if ((PyObject *)py_pmi != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "second argument must be a GtkWidget or None");
        return NULL;
    }
    if (!PyCallable_Check(func) && func != Py_None) {
        PyErr_SetString(PyExc_TypeError, "third argument not callable");
        return NULL;
    }
    if (PyLong_Check(pytime)) {
	time = PyLong_AsUnsignedLong(pytime);
	if (PyErr_Occurred())
	    return NULL;
    } else if (PyInt_Check(pytime)) {
	time = PyInt_AsLong(pytime);
    } else {
        PyErr_SetString(PyExc_TypeError,
                        "last argument must be int or long");
        return NULL;
    }
    if (func != Py_None) {
        Py_INCREF(func);
        gtk_menu_popup(GTK_MENU(self->obj), pms, pmi,
                       (GtkMenuPositionFunc)pygtk_menu_position,
                       func, button, time);
    } else
        gtk_menu_popup(GTK_MENU(self->obj), pms, pmi, NULL,NULL, button,time);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_pixmap_get noargs
static PyObject *
_wrap_gtk_pixmap_get(PyGObject *self)
{
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    gtk_pixmap_get(GTK_PIXMAP(self->obj), &pixmap, &mask);
    return Py_BuildValue("(NN)", pygobject_new((GObject *)pixmap),
                         pygobject_new((GObject *)mask));
}

%%
override gtk_button_new kwargs
static int
_wrap_gtk_button_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", "stock", "use_underline", NULL };
    gchar *text = NULL, *stock = NULL;
    PyObject *py_use_underline = Py_True;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|zzO:OGtkButton.__init__",
                                     kwlist, &text, &stock, &py_use_underline))
        return -1;
    if (stock)
        self->obj = g_object_new(pyg_type_from_object((PyObject*) self),
                                 "label", stock, "use-stock", TRUE,
                                 "use-underline", TRUE, NULL);
    else if (text)
        self->obj = g_object_new(pyg_type_from_object((PyObject*) self),
                                 "label", text, "use-underline",
                                 PyObject_IsTrue(py_use_underline), NULL);
    else
        self->obj = g_object_new(pyg_type_from_object((PyObject*) self), NULL);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkButton object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_button_get_alignment noargs
static PyObject *
_wrap_gtk_button_get_alignment(PyGObject *self)
{
    gfloat xalign, yalign;

    gtk_button_get_alignment(GTK_BUTTON(self->obj), &xalign, &yalign);
    return Py_BuildValue("(ff)", xalign, yalign);
}
%%
override gtk_button_box_get_child_size noargs
static PyObject *
_wrap_gtk_button_box_get_child_size(PyGObject *self)
{
    gint min_width;
    gint min_height;

    if (PyErr_Warn(PyExc_DeprecationWarning, "don't use this") < 0)
        return NULL;
    gtk_button_box_get_child_size(GTK_BUTTON_BOX(self->obj), &min_width, &min_height);
    return Py_BuildValue("(ii)", min_width, min_height);
}
%%
override gtk_button_box_get_child_ipadding noargs
static PyObject *
_wrap_gtk_button_box_get_child_ipadding(PyGObject *self)
{
    gint ipad_x;
    gint ipad_y;

    if (PyErr_Warn(PyExc_DeprecationWarning, "don't use this") < 0)
        return NULL;
    gtk_button_box_get_child_ipadding(GTK_BUTTON_BOX(self->obj), &ipad_x, &ipad_y);
    return Py_BuildValue("(ii)", ipad_x, ipad_y);
}
%%
override gtk_toggle_button_new kwargs
static int
_wrap_gtk_toggle_button_new(PyGObject *self, PyObject*args, PyObject*kwargs)
{
    static char *kwlist[] = { "label", "use_underline", NULL };
    gchar *text = NULL;
    PyObject *py_use_underline = Py_True;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|zO):GtkToggleButton.__init__", kwlist,
                                     &text, &py_use_underline))
        return -1;
    if (text)
        self->obj = g_object_new(pyg_type_from_object((PyObject*) self),
                                 "label", text, "use-underline",
                                 PyObject_IsTrue(py_use_underline), NULL);
    else
        self->obj = g_object_new(pyg_type_from_object((PyObject*) self), NULL);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkToggleButton object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_check_button_new kwargs
static int
_wrap_gtk_check_button_new(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "label", "use_underline", NULL };
    gchar *text = NULL;
    PyObject *py_use_underline = Py_True;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|zO:GtkCheckButton.__init__",
                                     kwlist, &text, &py_use_underline))
        return -1;
    if (text)
        self->obj = g_object_new(pyg_type_from_object((PyObject*) self),
                                 "label", text, "use-underline",
                                 PyObject_IsTrue(py_use_underline), NULL);
    else
        self->obj = g_object_new(pyg_type_from_object((PyObject*) self), NULL);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkCheckButton object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_radio_button_new kwargs
static int
_wrap_gtk_radio_button_new(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "group", "label", "use_underline", NULL };
    PyObject *py_group = Py_None;
    gchar *label = NULL;
    GtkRadioButton *group;
    PyObject *py_use_underline = Py_True;

    if (!PyArg_ParseTupleAndKeywords(args,kwargs,"|OzO:GtkRadioButton.__init__",
                                     kwlist, &py_group, &label,
                                     &py_use_underline))
        return -1;
    if (py_group == Py_None)
        group = NULL;
    else if (pygobject_check(py_group, &PyGtkRadioButton_Type))
        group = GTK_RADIO_BUTTON(pygobject_get(py_group));
    else {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a GtkRadioButton or None");
        return -1;
    }
    /* various configs for create radio buttons ... */
    if (label == NULL) {
        if (group == NULL)
            self->obj = g_object_new(pyg_type_from_object((PyObject*) self), NULL);
        else
            self->obj = g_object_new(pyg_type_from_object((PyObject*) self),
                                     "group", group, NULL);
    } else {
        if (group == NULL)
            self->obj = g_object_new(pyg_type_from_object((PyObject*) self),
                                     "label", label, "use-underline",
                                     PyObject_IsTrue(py_use_underline), NULL);
        else
            self->obj = g_object_new(pyg_type_from_object((PyObject*) self),
                                     "label", label, "group", group,
                                     "use-underline",
                                     PyObject_IsTrue(py_use_underline), NULL);
    }
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkRadioButton object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_radio_button_get_group noargs
static PyObject *
_wrap_gtk_radio_button_get_group(PyGObject *self) {
    PyObject *py_list;
    GSList *list, *tmp;
    PyObject *gtk_obj;

    list = gtk_radio_button_get_group(GTK_RADIO_BUTTON(self->obj));

    if ((py_list = PyList_New(0)) == NULL) {
        return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        gtk_obj = pygobject_new(G_OBJECT(tmp->data));
        if (gtk_obj == NULL) {
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_Append(py_list, gtk_obj);
        Py_DECREF(gtk_obj);
    }
    return py_list;
}
%%
override gtk_radio_button_set_group kwargs
static PyObject *
_wrap_gtk_radio_button_set_group(PyGObject *self, PyObject *args,
				 PyObject *kwargs) {
    static char *kwlist[] = { "group", NULL };
    PyObject *py_group;
    GSList *list;
    GtkRadioButton *group;

    if (!PyArg_ParseTupleAndKeywords(args,kwargs,"O!:GtkRadioButton.set_group",
                                     kwlist, &PyGtkRadioButton_Type,
				     &py_group))
        return NULL;
    group = GTK_RADIO_BUTTON(pygobject_get(py_group));
    list = gtk_radio_button_get_group(group);
    gtk_radio_button_set_group(GTK_RADIO_BUTTON(self->obj), list);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_item_new kwargs
static int
_wrap_gtk_list_item_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (PyErr_Warn(PyExc_DeprecationWarning, "use gtk.TreeView") < 0)
        return -1;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|z:GtkListItem.__init__",
                                     kwlist, &text))
        return -1;
    if (text)
        self->obj = (GObject *)gtk_list_item_new_with_label(text);
    else
        self->obj = (GObject *)gtk_list_item_new();
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkListItem object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_menu_item_new kwargs
static int
_wrap_gtk_menu_item_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", "use_underline", NULL };
    gchar *text = NULL;
    PyObject *py_use_underline = Py_True;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|zO:GtkMenuItem.__init__",
                                     kwlist, &text, &py_use_underline))
        return -1;
    self->obj = g_object_new(pyg_type_from_object((PyObject*) self), NULL);
    if (text) {
        GtkWidget *accel_label;
        accel_label = g_object_new(GTK_TYPE_ACCEL_LABEL, NULL);
        gtk_misc_set_alignment(GTK_MISC(accel_label), 0.0, 0.5);
        gtk_container_add(GTK_CONTAINER(self->obj), accel_label);
        if (PyObject_IsTrue(py_use_underline))
            gtk_label_set_text_with_mnemonic(GTK_LABEL(accel_label), text);
        else
            gtk_label_set_text(GTK_LABEL(accel_label), text);
        gtk_accel_label_set_accel_widget(GTK_ACCEL_LABEL(accel_label),
                                         GTK_WIDGET(self->obj));
        gtk_widget_show(accel_label);
     }
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkMenuItem object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_menu_attach_to_widget kwargs
static void
pygtk_menu_detach (GtkWidget *attach_widget, GtkMenu *menu)
{
    PyGILState_STATE state;
    PyObject *func;
    PyObject *ret;

    func = g_object_get_data (G_OBJECT (menu), "pygtk_menu_detach_func");

    if (!func)
        return;

    state = pyg_gil_state_ensure();

    ret = PyObject_CallFunction (func, "OO",
                                 pygobject_new ((GObject *) menu),
                                 pygobject_new ((GObject *) attach_widget));
    if (ret == NULL) {
        PyErr_Print ();
        Py_XDECREF (ret);
    }
    else
        Py_DECREF (ret);

    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_menu_attach_to_widget (PyGObject *self, PyObject *args,
                                 PyObject *kwargs)
{
    static char *kwlist[] = { "attach_widget", "detach_func", NULL };
    PyGObject *py_attach_widget;
    PyObject *detach_func;
    GtkWidget *attach_widget;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O!O:GtkMenu.attach_to_widget",
                                      kwlist, &PyGtkWidget_Type,
                                      &py_attach_widget, &detach_func))
        return NULL;

    attach_widget = GTK_WIDGET (py_attach_widget->obj);

    if (!PyCallable_Check (detach_func) && detach_func != Py_None) {
        PyErr_SetString (PyExc_TypeError, "second argument not callable");
        return NULL;
    }

    if (detach_func != Py_None) {
        Py_INCREF (detach_func);
        g_object_set_data_full (self->obj,
                                "pygtk_menu_detach_func",
                                detach_func,
                                pyg_destroy_notify);
    }
    else
        g_object_set_data (self->obj, "pygtk_menu_detach_func", NULL);

    gtk_menu_attach_to_widget (GTK_MENU (self->obj), attach_widget,
                               (GtkMenuDetachFunc) pygtk_menu_detach);

    Py_INCREF (Py_None);
    return Py_None;
}
%%
override gtk_check_menu_item_new kwargs
static int
_wrap_gtk_check_menu_item_new(PyGObject *self, PyObject *args,
                              PyObject *kwargs)
{
    static char *kwlist[] = { "label", "use_underline", NULL };
    gchar *text = NULL;
    PyObject *py_use_underline = Py_True;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|zO:GtkCheckMenuItem.__init__", kwlist,
                                     &text, &py_use_underline))
        return -1;
    self->obj = g_object_new(pyg_type_from_object((PyObject*) self), NULL);
    if (text) {
        GtkWidget *accel_label;
        accel_label = g_object_new(GTK_TYPE_ACCEL_LABEL, NULL);
        gtk_misc_set_alignment(GTK_MISC(accel_label), 0.0, 0.5);
        gtk_container_add(GTK_CONTAINER(self->obj), accel_label);
        if (PyObject_IsTrue(py_use_underline))
            gtk_label_set_text_with_mnemonic(GTK_LABEL(accel_label), text);
        else
            gtk_label_set_text(GTK_LABEL(accel_label), text);
        gtk_accel_label_set_accel_widget(GTK_ACCEL_LABEL(accel_label),
                                         GTK_WIDGET(self->obj));
        gtk_widget_show(accel_label);
    }
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkCheckMenuItem object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_radio_menu_item_new kwargs
static int
_wrap_gtk_radio_menu_item_new(PyGObject *self, PyObject *args,
                              PyObject *kwargs)
{
    static char *kwlist[] = { "group", "label", "use_underline", NULL };
    gchar *text = NULL;
    PyObject *py_group = Py_None;
    GtkRadioMenuItem *group;
    PyObject *py_use_underline = Py_True;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|OzO:GtkRadioMenuItem.__init__", kwlist,
                                     &py_group, &text, &py_use_underline))
        return -1;
    if (py_group == Py_None)
        group = NULL;
    else if (pygobject_check(py_group, &PyGtkRadioMenuItem_Type))
        group = GTK_RADIO_MENU_ITEM(pygobject_get(py_group));
    else {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a GtkRadioMenuItem or None");
        return -1;
    }

    self->obj = g_object_new(pyg_type_from_object((PyObject*) self), NULL);

    if (text) {
        GtkWidget *accel_label;
        accel_label = g_object_new(GTK_TYPE_ACCEL_LABEL, NULL);
        gtk_misc_set_alignment(GTK_MISC(accel_label), 0.0, 0.5);
        gtk_container_add(GTK_CONTAINER(self->obj), accel_label);
        if (PyObject_IsTrue(py_use_underline))
            gtk_label_set_text_with_mnemonic(GTK_LABEL(accel_label), text);
        else
            gtk_label_set_text(GTK_LABEL(accel_label), text);
        gtk_accel_label_set_accel_widget(GTK_ACCEL_LABEL(accel_label),
                                         GTK_WIDGET(self->obj));
        gtk_widget_show(accel_label);
    }
    if (group)
        gtk_radio_menu_item_set_group(GTK_RADIO_MENU_ITEM(self->obj),
                                      gtk_radio_menu_item_get_group(group));
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkRadioMenuItem object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_image_menu_item_new kwargs
static int
_wrap_gtk_image_menu_item_new(PyGObject *self, PyObject *args,PyObject *kwargs)
{
    static char *kwlist[] = { "stock_id", "accel_group", NULL };
    gchar *stock_id = NULL;
    PyObject *py_accel_group = Py_None;
    GtkAccelGroup *accel_group= NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|zO:GtkImageMenuItem.__init__",kwlist,
                                     &stock_id, &py_accel_group))
        return -1;
    if (pygobject_check(py_accel_group, &PyGtkAccelGroup_Type))
        accel_group = GTK_ACCEL_GROUP(pygobject_get(py_accel_group));

    if (stock_id)
        self->obj = (GObject *)gtk_image_menu_item_new_from_stock(stock_id,
                                                                  accel_group);
    else
        self->obj = (GObject *)gtk_image_menu_item_new();

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkImageMenuItem object");
        return -1;
    }

    if (pyg_type_from_object((PyObject *) self) != GTK_TYPE_IMAGE_MENU_ITEM) {
        PyErr_SetString(PyExc_RuntimeError, "__gobject_init__ must be used "
                        "when subclassing gtk.ImageMenuItem");
        return -1;
    }

    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override-slot GtkRequisition.tp_as_sequence
static int
_wrap_gtk_requisition_length(PyGBoxed *self)
{
    return 2;
}
static PyObject *
_wrap_gtk_requisition_getitem(PyGBoxed *self, int pos)
{
    GtkRequisition *requisition;

    if (pos < 0) pos += 2;
    if (pos < 0 || pos >= 2) {
        PyErr_SetString(PyExc_IndexError, "index out of range");
        return NULL;
    }
    requisition = pyg_boxed_get(self, GtkRequisition);
    switch (pos) {
    case 0: return PyInt_FromLong(requisition->width);
    case 1: return PyInt_FromLong(requisition->height);
    default:
        g_assert_not_reached();
        return NULL;
    }
}
static int
_wrap_gtk_requisition_setitem(PyGBoxed *self, int pos, PyObject *value)
{
    GtkRequisition *requisition;
    gint val;

    if (pos < 0) pos += 2;
    if (pos < 0 || pos >= 2) {
        PyErr_SetString(PyExc_IndexError, "index out of range");
        return -1;
    }
    requisition = pyg_boxed_get(self, GtkRequisition);
    val = PyInt_AsLong(value);
    if (PyErr_Occurred())
        return -1;
    switch(pos) {
    case 0: requisition->width      = val; break;
    case 1: requisition->height     = val; break;
    default:
        g_assert_not_reached();
        return -1;
    }
    return 0;
}
static PySequenceMethods _wrap_gtk_requisition_tp_as_sequence = {
    (inquiry)_wrap_gtk_requisition_length,
    (binaryfunc)0,
    (intargfunc)0,
    (intargfunc)_wrap_gtk_requisition_getitem,
    (intintargfunc)0,
    (intobjargproc)_wrap_gtk_requisition_setitem,
    (intintobjargproc)0
};
%%
override-attr GtkRequisition.width
static int
_wrap_gtk_requisition__set_width(PyGBoxed *self, PyObject *value, void *closure)
{
    gint val;

    val = PyInt_AsLong(value);
    if (PyErr_Occurred())
        return -1;
    pyg_boxed_get(self, GtkRequisition)->width = val;
    return 0;
}
%%
override-attr GtkRequisition.height
static int
_wrap_gtk_requisition__set_height(PyGBoxed *self, PyObject *value, void *closure)
{
    gint val;

    val = PyInt_AsLong(value);
    if (PyErr_Occurred())
        return -1;
    pyg_boxed_get(self, GtkRequisition)->height = val;
    return 0;
}
%%
override gtk_toolbar_append_item kwargs
static PyObject *
_wrap_gtk_toolbar_append_item(PyGObject *self, PyObject *args,
                              PyObject *kwargs)
{
    static char *kwlist[] = { "text", "tooltip_text", "tooltip_private_text",
                              "icon", "callback", "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyGObject *py_icon;
    PyObject *callback, *param = NULL, *py_ret;
    GtkWidget *icon = NULL, *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "zzzOO|O:GtkToolbar.append_item", kwlist,
                                     &text, &tooltip_text,
                                     &tooltip_private_text, &py_icon,
                                     &callback, &param))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
        icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "forth argument must be a GtkWidget or None");
        return NULL;
    }
    ret = gtk_toolbar_append_item(GTK_TOOLBAR(self->obj), text, tooltip_text,
                                  tooltip_private_text, icon, NULL, NULL);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback)) {
        GClosure *closure;

        closure = pyg_closure_new(callback, param, NULL);
        g_signal_connect_closure(ret, "clicked", closure, FALSE);
        pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
%%
override gtk_toolbar_prepend_item kwargs
static PyObject *
_wrap_gtk_toolbar_prepend_item(PyGObject *self, PyObject *args,
                               PyObject *kwargs)
{
    static char *kwlist[] = { "text", "tooltip_text", "tooltip_private_text",
                              "icon", "callback", "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyGObject *py_icon;
    PyObject *callback, *param, *py_ret;
    GtkWidget *icon = NULL, *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "zzzOOO:GtkToolbar.prepend_item", kwlist,
                                     &text, &tooltip_text,
                                     &tooltip_private_text, &py_icon,
                                     &callback, &param))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
        icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "forth argument must be a GtkWidget or None");
        return NULL;
    }
    ret = gtk_toolbar_prepend_item(GTK_TOOLBAR(self->obj), text, tooltip_text,
                                  tooltip_private_text, icon, NULL, NULL);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback)) {
        GClosure *closure;

        closure = pyg_closure_new(callback, param, NULL);
        g_signal_connect_closure(ret, "clicked", closure, FALSE);
        pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
%%
override gtk_toolbar_insert_item kwargs
static PyObject *
_wrap_gtk_toolbar_insert_item(PyGObject *self, PyObject *args,
                              PyObject *kwargs)
{
    static char *kwlist[] = { "text", "tooltip_text", "tooltip_private_text",
                              "icon", "callback", "user_data", "position",
                              NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyGObject *py_icon;
    PyObject *callback, *param, *py_ret;
    GtkWidget *icon = NULL, *ret;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "zzzOOOi:GtkToolbar.insert_item", kwlist,
                                     &text, &tooltip_text,
                                     &tooltip_private_text, &py_icon,
                                     &callback, &param, &position))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
        icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "forth argument must be a GtkWidget or None");
        return NULL;
    }
    ret = gtk_toolbar_insert_item(GTK_TOOLBAR(self->obj), text, tooltip_text,
                                  tooltip_private_text, icon, NULL, NULL,
                                  position);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback)) {
        GClosure *closure;

        closure = pyg_closure_new(callback, param, NULL);
        g_signal_connect_closure(ret, "clicked", closure, FALSE);
        pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
%%
override gtk_toolbar_insert_stock kwargs
static PyObject *
_wrap_gtk_toolbar_insert_stock(PyGObject *self, PyObject *args,
                              PyObject *kwargs)
{
    static char *kwlist[] = { "stock_id", "tooltip_text", "tooltip_private_text",
                              "callback", "user_data", "position",
                              NULL };
    char *stock_id, *tooltip_text, *tooltip_private_text;
    PyObject *callback, *param, *py_ret;
    GtkWidget *ret;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "zzzOOi:GtkToolbar.insert_stock", kwlist,
                                     &stock_id, &tooltip_text,
                                     &tooltip_private_text,
                                     &callback, &param, &position))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;

    ret = gtk_toolbar_insert_stock(GTK_TOOLBAR(self->obj), stock_id, tooltip_text,
                                  tooltip_private_text, NULL, NULL,
                                  position);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback)) {
        GClosure *closure;

        closure = pyg_closure_new(callback, param, NULL);
        g_signal_connect_closure(ret, "clicked", closure, FALSE);
        pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
%%
override gtk_toolbar_append_element kwargs
static PyObject *
_wrap_gtk_toolbar_append_element(PyGObject *self, PyObject *args,
                                 PyObject *kwargs)
{
    static char *kwlist[] = { "type", "widget", "text", "tooltip_text",
                              "tooltip_private_text", "icon", "callback",
                              "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyObject *py_type, *callback, *param, *py_ret;
    PyGObject *py_widget, *py_icon;
    GtkWidget *widget = NULL, *icon = NULL, *ret;
    GtkToolbarChildType type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOzzzOOO:GtkToolbar.append_element",
                                     kwlist,
                                     &py_type, &py_widget,
                                     &text, &tooltip_text,
                                     &tooltip_private_text, &py_icon,
                                     &callback, &param))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,
                           py_type, (gint *)&type))
        return NULL;
    if (pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "second argument must be a GtkWidget or None");
        return NULL;
    }
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
        icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "sixth argument must be a GtkWidget or None");
        return NULL;
    }
    ret = gtk_toolbar_append_element(GTK_TOOLBAR(self->obj), type, widget,
                                     text, tooltip_text, tooltip_private_text,
                                     icon, NULL, NULL);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback) &&
        (type == GTK_TOOLBAR_CHILD_BUTTON ||
         type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
         type == GTK_TOOLBAR_CHILD_RADIOBUTTON)) {
        GClosure *closure;

        closure = pyg_closure_new(callback, param, NULL);
        g_signal_connect_closure(ret, "clicked", closure, FALSE);
        pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
%%
override gtk_toolbar_prepend_element kwargs
static PyObject *
_wrap_gtk_toolbar_prepend_element(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    static char *kwlist[] = { "type", "widget", "text", "tooltip_text",
                              "tooltip_private_text", "icon", "callback",
                              "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyObject *py_type, *callback, *param, *py_ret;
    PyGObject *py_widget, *py_icon;
    GtkWidget *widget = NULL, *icon = NULL, *ret;
    GtkToolbarChildType type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOzzzOOO:GtkToolbar.prepend_element",
                                     kwlist,
                                     &py_type, &py_widget,
                                     &text, &tooltip_text,
                                     &tooltip_private_text, &py_icon,
                                     &callback, &param))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,
                           py_type, (gint *)&type))
        return NULL;
    if (pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "second argument must be a GtkWidget or None");
        return NULL;
    }
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
        icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "sixth argument must be a GtkWidget or None");
        return NULL;
    }
    ret = gtk_toolbar_prepend_element(GTK_TOOLBAR(self->obj), type, widget,
                                      text, tooltip_text, tooltip_private_text,
                                      icon, NULL, NULL);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback) &&
        (type == GTK_TOOLBAR_CHILD_BUTTON ||
         type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
         type == GTK_TOOLBAR_CHILD_RADIOBUTTON)) {
        GClosure *closure;

        closure = pyg_closure_new(callback, param, NULL);
        g_signal_connect_closure(ret, "clicked", closure, FALSE);
        pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
%%
override gtk_toolbar_insert_element kwargs
static PyObject *
_wrap_gtk_toolbar_insert_element(PyGObject *self, PyObject *args,
                                 PyObject *kwargs)
{
    static char *kwlist[] = { "type", "widget", "text", "tooltip_text",
                              "tooltip_private_text", "icon", "callback",
                              "user_data", "position", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyObject *py_type, *callback, *param, *py_ret;
    PyGObject *py_widget, *py_icon;
    GtkWidget *widget = NULL, *icon = NULL, *ret;
    GtkToolbarChildType type;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOzzzOOOi:GtkToolbar.insert_element",
                                     kwlist,
                                     &py_type, &py_widget,
                                     &text, &tooltip_text,
                                     &tooltip_private_text, &py_icon,
                                     &callback, &param, &position))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,
                           py_type, (gint *)&type))
        return NULL;
    if (pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "second argument must be a GtkWidget or None");
        return NULL;
    }
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
        icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "sixth argument must be a GtkWidget or None");
        return NULL;
    }
    ret = gtk_toolbar_insert_element(GTK_TOOLBAR(self->obj), type, widget,
                                     text, tooltip_text, tooltip_private_text,
                                     icon, NULL, NULL, position);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback) &&
        (type == GTK_TOOLBAR_CHILD_BUTTON ||
         type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
         type == GTK_TOOLBAR_CHILD_RADIOBUTTON)) {
        GClosure *closure;

        closure = pyg_closure_new(callback, param, NULL);
        g_signal_connect_closure(ret, "clicked", closure, FALSE);
        pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
%%
override gtk_notebook_query_tab_label_packing kwargs
static PyObject *
_wrap_gtk_notebook_query_tab_label_packing(PyGObject *self, PyObject *args,
                                           PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;
    gboolean expand, fill;
    GtkPackType pack_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkNotebook.query_tab_label_packing",
                                     kwlist, &child))
        return NULL;
    if (!pygobject_check(child, &PyGtkWidget_Type)) {
        PyErr_SetString(PyExc_TypeError, "child must be a GtkWidget");
        return NULL;
    }
    gtk_notebook_query_tab_label_packing(GTK_NOTEBOOK(self->obj),
                                         GTK_WIDGET(child->obj),
                                         &expand, &fill, &pack_type);
    return Py_BuildValue("(iiN)", expand, fill,
			 pyg_enum_from_gtype(GTK_TYPE_PACK_TYPE, pack_type));
}
%%
override gtk_list_insert_items kwargs
static PyObject *
_wrap_gtk_list_insert_items(PyGObject *self, PyObject *args,
                            PyObject *kwargs)
{
    static char *kwlist[] = { "items", "position", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int position, len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!i:GtkList.insert_items",
                                     kwlist, &PyList_Type, &py_items,
                                     &position))
        return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
        PyObject *item = PyList_GetItem(py_items, i);
        if (!pygobject_check(item, &PyGtkListItem_Type)) {
            PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
            g_list_free(items);
            return NULL;
        }
        items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_insert_items(GTK_LIST(self->obj), items, position);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_append_items kwargs
static PyObject *
_wrap_gtk_list_append_items(PyGObject *self, PyObject *args,
                            PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkList.append_items",
                                     kwlist, &PyList_Type, &py_items))
        return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
        PyObject *item = PyList_GetItem(py_items, i);
        if (!pygobject_check(item, &PyGtkListItem_Type)) {
            PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
            g_list_free(items);
            return NULL;
        }
        items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_append_items(GTK_LIST(self->obj), items);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_prepend_items kwargs
static PyObject *
_wrap_gtk_list_prepend_items(PyGObject *self, PyObject *args,
                             PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkList.preppend_items",
                                     kwlist, &PyList_Type, &py_items))
        return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
        PyObject *item = PyList_GetItem(py_items, i);
        if (!pygobject_check(item, &PyGtkListItem_Type)) {
            PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
            g_list_free(items);
            return NULL;
        }
        items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_prepend_items(GTK_LIST(self->obj), items);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_remove_items kwargs
static PyObject *
_wrap_gtk_list_remove_items(PyGObject *self, PyObject *args,
                            PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkList.remove_items",
                                     kwlist, &PyList_Type, &py_items))
        return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
        PyObject *item = PyList_GetItem(py_items, i);
        if (!pygobject_check(item, &PyGtkListItem_Type)) {
            PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
            g_list_free(items);
            return NULL;
        }
        items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_remove_items(GTK_LIST(self->obj), items);
    g_list_free(items);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override-attr GtkList.selection
static PyObject *
_wrap_gtk_list__get_selection(PyGObject *self, void *closure)
{
    GList *selection;
    PyObject *item, *ret = PyList_New(0);

    if (ret == NULL)
        return NULL;

    for (selection = GTK_LIST(self->obj)->selection; selection != NULL;
         selection = selection->next) {
        item = pygobject_new((GObject *) GTK_LIST_ITEM(selection->data));

        if (!item) {
            Py_DECREF(ret);
            return NULL;
        }

        PyList_Append(ret, item);
        Py_DECREF(item);
    }
    return ret;
}
%%
override gtk_list_get_selection noargs
static PyObject *
_wrap_gtk_list__get_selection(PyGObject *self, void *closure);
static PyObject *
_wrap_gtk_list_get_selection(PyGObject *self)
{
    return _wrap_gtk_list__get_selection(self, NULL);
}
%%
override gtk_color_selection_get_current_color noargs
static PyObject *
_wrap_gtk_color_selection_get_current_color(PyGObject *self)
{
    GdkColor colour = { 0, };

    gtk_color_selection_get_current_color(GTK_COLOR_SELECTION(self->obj),
                                          &colour);
    return pyg_boxed_new(GDK_TYPE_COLOR, &colour, TRUE, TRUE);
}
%%
override gtk_color_selection_get_previous_color noargs
static PyObject *
_wrap_gtk_color_selection_get_previous_color(PyGObject *self)
{
    GdkColor colour = { 0, };

    gtk_color_selection_get_previous_color(GTK_COLOR_SELECTION(self->obj),
                                           &colour);
    return pyg_boxed_new(GDK_TYPE_COLOR, &colour, TRUE, TRUE);
}
%%
override gtk_calendar_get_date noargs
static PyObject *
_wrap_gtk_calendar_get_date(PyGObject *self)
{
    guint year, month, day;

    gtk_calendar_get_date(GTK_CALENDAR(self->obj), &year, &month, &day);
    return Py_BuildValue("(iii)", year, month, day);
}
%%
override gtk_drag_dest_set kwargs
static PyObject *
_wrap_gtk_drag_dest_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "flags", "targets", "actions", NULL };
    PyObject *py_flags, *py_targets, *py_actions;
    GtkDestDefaults flags;
    GtkTargetEntry *targets;
    GdkDragAction actions;
    gint n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOO:GtkWidget.drag_dest_set", kwlist,
                                     &py_flags, &py_targets, &py_actions))
        return NULL;
    if (pyg_flags_get_value(GTK_TYPE_DEST_DEFAULTS, py_flags, (gint *)&flags))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
                             py_actions, (gint *)&actions))
        return NULL;
    if (!PySequence_Check(py_targets)) {
        PyErr_SetString(PyExc_TypeError, "targets must be a sequence");
        return NULL;
    }
    n_targets = PySequence_Length(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_GetItem(py_targets, i);
        Py_DECREF(item);
        if (!PyArg_ParseTuple(item, "sii", &targets[i].target,
                              &targets[i].flags, &targets[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(targets);
            return NULL;
        }
    }
    gtk_drag_dest_set(GTK_WIDGET(self->obj), flags, targets, n_targets,
                      actions);
    g_free(targets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_drag_dest_find_target kwargs
static PyObject *
_wrap_gtk_drag_dest_find_target(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "context", "target_list", NULL };
    PyObject *context, *py_targets;
    gint i, n_targets;
    GtkTargetEntry *targets;
    GtkTargetList *target_list;
    GdkAtom atom;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!O:GtkWidget.drag_dest_find_target",
                                     kwlist, &PyGdkDragContext_Type, &context,
                                     &py_targets))
        return NULL;
    if (!(py_targets = PySequence_Fast(py_targets, "targets must be a sequence")))
	return NULL;
    n_targets = PySequence_Fast_GET_SIZE(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_Fast_GET_ITEM(py_targets, i);
        if (!PyArg_ParseTuple(item, "sii", &targets[i].target,
                              &targets[i].flags, &targets[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(targets);
	    Py_DECREF(py_targets);
            return NULL;
        }
    }
    target_list = gtk_target_list_new(targets, n_targets);
    g_free(targets);

    atom = gtk_drag_dest_find_target(GTK_WIDGET(self->obj),
                                     GDK_DRAG_CONTEXT(pygobject_get(context)),
                                     target_list);
    gtk_target_list_unref(target_list);
    Py_DECREF(py_targets);

    return PyString_FromString(gdk_atom_name(atom));
}
%%
override gtk_drag_dest_get_target_list noargs
static PyObject *
_wrap_gtk_drag_dest_get_target_list(PyGObject *self)
{
    GtkTargetList *target_list;
    PyObject *ret;
    GList *tmp;

    target_list = gtk_drag_dest_get_target_list(GTK_WIDGET(self->obj));

    if (!target_list) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    ret = PyList_New(0);
    for (tmp = target_list->list; tmp != NULL; tmp = tmp->next) {
        GtkTargetPair *pair = tmp->data;
        PyObject *item;

        item = Py_BuildValue("(Nii)", PyString_FromString(gdk_atom_name(pair->target)),
                             pair->flags, pair->info);
        PyList_Append(ret, item);
        Py_DECREF(item);
    }
    return ret;
}
%%
override gtk_drag_dest_set_target_list kwargs
static PyObject *
_wrap_gtk_drag_dest_set_target_list(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "target_list", NULL };
    PyObject *py_targets;
    gint i, n_targets;
    GtkTargetEntry *targets;
    GtkTargetList *target_list;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkWidget.drag_dest_set_target_list",
                                     kwlist, &py_targets))
        return NULL;
    if (!(py_targets = PySequence_Fast(py_targets, "targets must be a sequence")))
	return NULL;
    n_targets = PySequence_Fast_GET_SIZE(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_Fast_GET_ITEM(py_targets, i);
        if (!PyArg_ParseTuple(item, "sii", &targets[i].target,
                              &targets[i].flags, &targets[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(targets);
	    Py_DECREF(py_targets);
            return NULL;
        }
    }
    target_list = gtk_target_list_new(targets, n_targets);
    g_free(targets);

    gtk_drag_dest_set_target_list(GTK_WIDGET(self->obj), target_list);
    gtk_target_list_unref(target_list);
    Py_DECREF(py_targets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_drag_source_set kwargs
static PyObject *
_wrap_gtk_drag_source_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "start_button_mask", "targets", "actions", NULL };
    PyObject *py_sbmask, *py_targets, *py_actions;
    GdkModifierType sbmask;
    GtkTargetEntry *targets;
    GdkDragAction actions;
    gint n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOO:GtkWidget.drag_source_set", kwlist,
                                     &py_sbmask, &py_targets, &py_actions))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE,
                             py_sbmask, (gint *)&sbmask))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
                             py_actions, (gint *)&actions))
        return NULL;
    if (!(py_targets = PySequence_Fast(py_targets, "targets must be a sequence")))
	return NULL;
    n_targets = PySequence_Fast_GET_SIZE(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_Fast_GET_ITEM(py_targets, i);
        if (!PyArg_ParseTuple(item, "sii", &targets[i].target,
                              &targets[i].flags, &targets[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(targets);
	    Py_DECREF(py_targets);
            return NULL;
        }
    }
    gtk_drag_source_set(GTK_WIDGET(self->obj), sbmask, targets, n_targets,
                        actions);
    g_free(targets);
    Py_DECREF(py_targets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_drag_begin kwargs
static PyObject *
_wrap_gtk_drag_begin(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "targets", "actions", "button", "event", NULL };
    PyObject *py_targets, *py_actions, *event;
    GtkTargetEntry *tents;
    GtkTargetList *targets;
    GdkDragAction actions;
    gint button, n_targets, i;
    GdkDragContext *context;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOiO:GtkWidget.drag_begin", kwlist,
                                     &py_targets, &py_actions, &button,
                                     &event))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
                             py_actions, (gint *)&actions))
        return NULL;
    if (!pyg_boxed_check(event, GDK_TYPE_EVENT)) {
        PyErr_SetString(PyExc_TypeError, "event must be a GdkEvent");
        return NULL;
    }
    if (!(py_targets = PySequence_Fast(py_targets, "targets must be a sequence")))
	return NULL;
    n_targets = PySequence_Fast_GET_SIZE(py_targets);
    tents = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_Fast_GET_ITEM(py_targets, i);
        if (!PyArg_ParseTuple(item, "sii", &tents[i].target,
                              &tents[i].flags, &tents[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(tents);
	    Py_DECREF(py_targets);
            return NULL;
        }
    }
    targets = gtk_target_list_new(tents, n_targets);
    g_free(tents);
    context = gtk_drag_begin(GTK_WIDGET(self->obj), targets, actions, button,
                             pyg_boxed_get(event, GdkEvent));
    gtk_target_list_unref(targets);
    Py_DECREF(py_targets);
    return pygobject_new((GObject *)context);
}
%%
override gtk_selection_add_targets kwargs
static PyObject *
_wrap_gtk_selection_add_targets(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "selection", "targets", NULL };
    PyObject *py_targets, *py_selection;
    GtkTargetEntry *targets;
    GdkAtom selection;
    int n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO:GtkWidget.selection_add_targets",
                                     kwlist, &py_selection, &py_targets))
        return NULL;
    selection = pygdk_atom_from_pyobject(py_selection);
    if (PyErr_Occurred())
        return NULL;

    if (!(py_targets = PySequence_Fast(py_targets, "targets must be a sequence")))
	return NULL;
    n_targets = PySequence_Fast_GET_SIZE(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_Fast_GET_ITEM(py_targets, i);
        if (!PyArg_ParseTuple(item, "sii", &targets[i].target,
                              &targets[i].flags, &targets[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(targets);
	    Py_DECREF(py_targets);
            return NULL;
        }
    }
    gtk_selection_add_targets(GTK_WIDGET(self->obj), selection,
                              targets, n_targets);
    g_free(targets);
    Py_DECREF(py_targets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_text_child_anchor_get_widgets noargs
static PyObject *
_wrap_gtk_text_child_anchor_get_widgets(PyGObject *self)
{
    GList *list, *tmp;
    PyObject *ret;

    list = gtk_text_child_anchor_get_widgets(GTK_TEXT_CHILD_ANCHOR(self->obj));

    ret = PyList_New(0);
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        GtkWidget *widget = tmp->data;
        PyObject *item = pygobject_new((GObject *)widget);

        PyList_Append(ret, item);
        Py_DECREF(item);
    }
    g_list_free(list);
    return ret;
}
%%
override gtk_dialog_new_with_buttons kwargs
static int
_wrap_gtk_dialog_new_with_buttons(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    gchar *title = NULL;
    PyGObject *py_window = NULL;
    PyObject *py_flags = NULL, *py_buttons = Py_None;
    GtkDialogFlags flags = 0;
    int len, i;
    GtkWindow *parent;
    PyGILState_STATE state;
    
    static char *kwlist[] = { "title", "parent", "flags", "buttons", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|sOOO!:GtkDialog.__init__", kwlist,
                                     &title, &py_window, &py_flags,
                                     &PyTuple_Type, &py_buttons))
        return -1;

    if (py_window == NULL || (PyObject*)py_window == Py_None)
	parent = NULL;
    else if (pygobject_check(py_window, &PyGtkWindow_Type))
	parent = GTK_WINDOW(py_window->obj);
    else {
        PyErr_SetString(PyExc_TypeError, "parent must be a GtkWindow or None");
        return -1;
    }

    if (pyg_flags_get_value(GTK_TYPE_DIALOG_FLAGS, py_flags, (gint *)&flags))
        return -1;
    if (py_buttons != Py_None)
        len = PyTuple_Size(py_buttons);
    else
        len = 0;

    if (len % 2) {
        PyErr_SetString(PyExc_RuntimeError,
                        "buttons tuple must contain text/response id pairs");
        return -1;
    }
    
    self->obj = g_object_new(pyg_type_from_object((PyObject*) self), NULL);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkDialog object");
        return -1;
    }

  if (title)
    gtk_window_set_title (GTK_WINDOW (self->obj), title);

  if (parent)
    gtk_window_set_transient_for (GTK_WINDOW (self->obj), parent);

  if (flags & GTK_DIALOG_MODAL)
    gtk_window_set_modal (GTK_WINDOW (self->obj), TRUE);
  
  if (flags & GTK_DIALOG_DESTROY_WITH_PARENT)
    gtk_window_set_destroy_with_parent (GTK_WINDOW (self->obj), TRUE);

  if (flags & GTK_DIALOG_NO_SEPARATOR)
    gtk_dialog_set_has_separator (GTK_DIALOG (self->obj), FALSE);
    
    for (i = 0; i < len; i += 2) {
        PyObject *text = PyTuple_GetItem(py_buttons, i);
        PyObject *id = PyTuple_GetItem(py_buttons, i + 1);
        if (!PyString_Check(text)) {
            gtk_object_destroy(GTK_OBJECT(self->obj));
            self->obj = NULL;
            PyErr_SetString(PyExc_RuntimeError,
                            "first member of each text/response id pair "
                            "must be a string");
            return -1;
        }
        if (!PyInt_Check(id)) {
            gtk_object_destroy(GTK_OBJECT(self->obj));
            self->obj = NULL;
            PyErr_SetString(PyExc_RuntimeError,
                            "second member of each text/response id pair "
                            "must be a number");
            return -1;
        }
        gtk_dialog_add_button(GTK_DIALOG(self->obj), PyString_AsString(text),
                              PyInt_AsLong(id));
    }
    
    state = pyg_gil_state_ensure();
    g_object_ref(self->obj); /* we don't own the first reference of windows */
    pyg_gil_state_release(state);

    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_dialog_run noargs
static PyObject *
_wrap_gtk_dialog_run(PyGObject *self)
{
    gint retval;

    pyg_begin_allow_threads;
    retval = gtk_dialog_run(GTK_DIALOG(self->obj));
    pyg_end_allow_threads;
    return PyInt_FromLong(retval);
}
%%
override gtk_dialog_add_buttons
static PyObject *
_wrap_gtk_dialog_add_buttons(PyGObject *self, PyObject *args)
{
    GtkDialog *dialog;
    int i, len;

    dialog = GTK_DIALOG(self->obj);

    len = PyTuple_Size(args);
    if (len % 2 != 0) {
	PyErr_SetString(PyExc_TypeError,
			"must pass an even number of arguments");
	return NULL;
    }
    
    for (i = 0; i < len; i+= 2) {
	PyObject *curr_args = PyTuple_GetSlice(args, i, i + 2);
	gchar *text;
	gint response_id;
	
	if (!PyArg_ParseTuple(curr_args, "si", &text, &response_id))
	    return NULL;
	
	gtk_dialog_add_button(dialog, text, response_id);
    }
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_message_dialog_new kwargs
static int
_wrap_gtk_message_dialog_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GtkButtonsType buttons = GTK_BUTTONS_NONE;
    static char *kwlist[] = { "parent", "flags", "type", "buttons", "message_format", NULL };
    PyObject *py_flags = NULL, *py_type = NULL, *py_buttons = NULL;
    GtkDialogFlags flags = 0;
    GtkWindow *parent = NULL;
    GtkMessageType type = GTK_MESSAGE_INFO;
    PyGObject *py_parent = NULL;
    char *message_format = NULL;
    PyGILState_STATE state;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OOOOz:GtkMessageDialog.__init__", kwlist, &py_parent, &py_flags, &py_type, &py_buttons, &message_format))
        return -1;
    if ((PyObject *)py_parent == Py_None)
        parent = NULL;
    else if (py_parent && pygobject_check(py_parent, &PyGtkWindow_Type))
        parent = GTK_WINDOW(py_parent->obj);
    else if (py_parent) {
        PyErr_SetString(PyExc_TypeError, "parent should be a GtkWindow or None");
        return -1;
    }
    if (pyg_flags_get_value(GTK_TYPE_DIALOG_FLAGS, py_flags, (gint *)&flags))
        return -1;
    if (pyg_enum_get_value(GTK_TYPE_MESSAGE_TYPE, py_type, (gint *)&type))
        return -1;
    if (pyg_enum_get_value(GTK_TYPE_BUTTONS_TYPE, py_buttons, (gint *)&buttons))
        return -1;

      /* Note: with current API (gtk 2.4), it is impossible to
       * construct a GtkMessageDialog through g_object_new(), because
       * there is no 'message' property and the label field is
       * private */
    if (message_format)
        self->obj = (GObject *)gtk_message_dialog_new(parent, flags, type,
                                                      buttons, "%s",
                                                      message_format);
    else
        self->obj = (GObject *)gtk_message_dialog_new(parent, flags, type,
                                                      buttons, message_format);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkMessageDialog object");
        return -1;
    }
    state = pyg_gil_state_ensure();
    g_object_ref(self->obj); /* we don't own the first reference of windows */
    pyg_gil_state_release(state);

    if (pyg_type_from_object((PyObject *) self) != GTK_TYPE_MESSAGE_DIALOG) {
        PyErr_SetString(PyExc_RuntimeError, "__gobject_init__ must be used "
                        "when subclassing gtk.MessageDialog");
        return -1;
    }

    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_progress_bar_new_with_adjustment kwargs
static int
_wrap_gtk_progress_bar_new_with_adjustment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GtkAdjustment *adjustment = NULL;
    static char *kwlist[] = { "adjustment", NULL };
    PyGObject *py_adjustment = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:GtkProgressBar.__init__", kwlist, &py_adjustment))
        return -1;
    if ((PyObject *)py_adjustment == Py_None)
        adjustment = NULL;
    else if (py_adjustment && pygobject_check(py_adjustment, &PyGtkAdjustment_Type))
        adjustment = GTK_ADJUSTMENT(py_adjustment->obj);
    else if (py_adjustment) {
        PyErr_SetString(PyExc_TypeError, "adjustment should be a GtkAdjustment or None");
	return -1;
    }


    if (adjustment)
        self->obj = g_object_new(pyg_type_from_object((PyObject *)self),
                                 "adjustment", adjustment, NULL);
    else
        self->obj = g_object_new(pyg_type_from_object((PyObject *)self), NULL);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkProgressBar object");
	return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_rc_set_default_files kwargs
static PyObject *
_wrap_gtk_rc_set_default_files(PyGObject *self, PyObject *args,
                               PyObject *kwargs)
{
    gchar **filenames = NULL;
    static char *kwlist[] = { "filenames", NULL };
    PyObject *py_filenames = NULL;
    int i, n_files;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:rc_set_default_files",
                                     kwlist, &py_filenames))
        return NULL;

    if (!PySequence_Check(py_filenames)) {
        PyErr_SetString(PyExc_TypeError, "filenames must be a sequence");
        return NULL;
    }

    n_files = PySequence_Length(py_filenames);
    filenames = g_new(gchar *, n_files + 1);
    for (i = 0; i < n_files; i++) {
        PyObject *item = PySequence_GetItem(py_filenames, i);
        Py_DECREF(item); /* PySequence_GetItem INCREF's */
        filenames[i] = PyString_AsString(item);
    }
    filenames[n_files] = NULL;

    gtk_rc_set_default_files(filenames);

    g_free(filenames);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_rc_get_default_files noargs
static PyObject *
_wrap_gtk_rc_get_default_files(PyGObject *self)
{
    gchar **filenames = NULL, **tmp;
    int i = 0, j;
    PyObject *ret;

    filenames = gtk_rc_get_default_files();

    tmp = filenames;
    while (*tmp)
        tmp++, i++;

    ret = PyTuple_New(i);
    for (j = 0; j < i; j++)
        PyTuple_SetItem(ret, j, PyString_FromString(filenames[j]));

    return ret;
}
%%
override gtk_icon_set_new_from_pixbuf kwargs
static int
_wrap_gtk_icon_set_new_from_pixbuf(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pixbuf", NULL };
    PyGObject *pixbuf = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:GtkIconSet.__init__", kwlist, &pixbuf))
        return -1;
    if (pixbuf && !pygobject_check(pixbuf, &PyGdkPixbuf_Type)) {
        PyErr_SetString(PyExc_TypeError, "pixbuf should be a GdkPixbuf");
        return -1;
    }
    self->gtype = GTK_TYPE_ICON_SET;
    self->free_on_dealloc = FALSE;
    if (pixbuf)
        self->boxed = gtk_icon_set_new_from_pixbuf(GDK_PIXBUF(pixbuf->obj));
    else
        self->boxed = gtk_icon_set_new();

    if (!self->boxed) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkIconSet object");
        return -1;
    }
    self->free_on_dealloc = TRUE;
    return 0;
}
%%
override gtk_icon_set_get_sizes noargs
static PyObject *
_wrap_gtk_icon_set_get_sizes(PyGObject *self)
{
    GtkIconSize *sizes;
    int i, n_sizes;
    PyObject *ret;

    gtk_icon_set_get_sizes(pyg_boxed_get(self, GtkIconSet), &sizes, &n_sizes);

    ret = PyTuple_New(n_sizes);
    for (i = 0; i < n_sizes; i++)
        PyTuple_SetItem(ret, i, PyInt_FromLong(sizes[i]));
    g_free(sizes);

    return ret;
}
%%
override gtk_stock_add kwargs
static PyObject *
_wrap_gtk_stock_add(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    PyObject *py_item;
    GtkStockItem *items = NULL;
    int i, len;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:stock_add", kwlist,
                                     &py_items))
        return NULL;

    if (!PySequence_Check(py_items)) {
        PyErr_SetString(PyExc_TypeError,
                        "items must be a sequence of five-element tuples");
        return NULL;
    }

    len = PySequence_Length(py_items);
    if (len > 0) {
        items = g_new(GtkStockItem, len);
        for (i = 0; i < len; i++) {
            py_item = PySequence_GetItem(py_items, i);
	    Py_DECREF(py_item);
            if (!py_item) goto error;
            if (!PyArg_ParseTuple(py_item, "zziiz",
                                  &items[i].stock_id, &items[i].label,
                                  &items[i].modifier, &items[i].keyval,
                                  &items[i].translation_domain)) {
                PyErr_Clear();
                PyErr_SetString(PyExc_TypeError, "items sequence members "
                                "must be of form (stock_id, label, modifiers, "
                                "keyval, domain)");
                goto error;
            }
        }
        gtk_stock_add(items, PySequence_Length(py_items));
        g_free(items);
    }
    Py_INCREF(Py_None);
    return Py_None;
 error:
    g_free(items);
    return NULL;
}
%%
override gtk_stock_list_ids noargs
static PyObject *
_wrap_gtk_stock_list_ids(PyGObject *self)
{
    GSList *ids;
    PyObject *list;
    int i = 0;

    ids = gtk_stock_list_ids();

    list = PyList_New(g_slist_length(ids));
    for (; ids; ids = ids->next, i++) {
        PyList_SetItem(list, i, PyString_FromString(ids->data));
        g_free(ids->data);
    }
    g_slist_free(ids);

    return list;
}
%%
override gtk_stock_lookup args
static PyObject *
_wrap_gtk_stock_lookup(PyGObject *self, PyObject *args)
{
    gchar *stock_id;
    GtkStockItem item;

    if (!PyArg_ParseTuple(args, "s:gtk.stock_lookup",
                          &stock_id)) {
        return NULL;
    }

    if(gtk_stock_lookup(stock_id, &item)) {
        return Py_BuildValue("zzNiz",
                             item.stock_id,
                             item.label,
                             pyg_flags_from_gtype(GDK_TYPE_MODIFIER_TYPE,
                                                  item.modifier),
                             item.keyval,
                             item.translation_domain);
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_layout_get_size noargs
static PyObject *
_wrap_gtk_layout_get_size(PyGObject *self)
{
    guint width, height;
    gtk_layout_get_size(GTK_LAYOUT(self->obj), &width, &height);

    return Py_BuildValue("(ii)", width, height);
}
%%
override gtk_frame_get_label_align noargs
static PyObject *
_wrap_gtk_frame_get_label_align(PyGObject *self)
{
    gfloat xalign, yalign;

    gtk_frame_get_label_align(GTK_FRAME(self->obj), &xalign, &yalign);
    return Py_BuildValue("(ff)", xalign, yalign);
}
%%
override gtk_misc_get_alignment noargs
static PyObject *
_wrap_gtk_misc_get_alignment(PyGObject *self)
{
    gfloat xalign, yalign;

    gtk_misc_get_alignment(GTK_MISC(self->obj), &xalign, &yalign);
    return Py_BuildValue("(ff)", xalign, yalign);
}
%%
override gtk_misc_get_padding noargs
static PyObject *
_wrap_gtk_misc_get_padding(PyGObject *self)
{
    gint xpad, ypad;

    gtk_misc_get_padding(GTK_MISC(self->obj), &xpad, &ypad);
    return Py_BuildValue("(ii)", xpad, ypad);
}
%%
override gtk_ruler_get_range noargs
static PyObject *
_wrap_gtk_ruler_get_range(PyGObject *self)
{
    gdouble lower, upper, position, max_size;

    gtk_ruler_get_range(GTK_RULER(self->obj), &lower, &upper, &position,
                        &max_size);
    return Py_BuildValue("(dddd)", lower, upper, position, max_size);
}
%%
override gtk_im_context_get_preedit_string noargs
static PyObject *
_wrap_gtk_im_context_get_preedit_string(PyGObject *self)
{
    gchar *str;
    PangoAttrList *attrs;
    gint cursor_pos;
    PyObject *ret;

    gtk_im_context_get_preedit_string(GTK_IM_CONTEXT(self->obj),
                                      &str, &attrs, &cursor_pos);

    ret = Py_BuildValue("(sNi)", str,
                        pyg_boxed_new(PANGO_TYPE_ATTR_LIST, attrs, FALSE,TRUE),
                        cursor_pos);
    g_free(str);

    return ret;
}
%%
override gtk_im_context_filter_keypress kwargs
static PyObject *
_wrap_gtk_im_context_filter_keypress(PyGObject *self, PyObject *args,
                                     PyObject *kwargs)
{
    static char *kwlist[] = { "key", NULL };
    PyObject *key;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkIMContext.filter_keypress", kwlist,
                                     &key))
        return NULL;

    if (!pyg_boxed_check(key, GDK_TYPE_EVENT)) {
        PyErr_SetString(PyExc_TypeError, "key must be a GdkEvent");
        return NULL;
    }

    ret = gtk_im_context_filter_keypress(GTK_IM_CONTEXT(self->obj),
                                         pyg_boxed_get(key, GdkEventKey));
    return PyBool_FromLong(ret);
}
%%
override gtk_im_context_get_surrounding noargs
static PyObject *
_wrap_gtk_im_context_get_surrounding(PyGObject *self)
{
    gchar *text;
    gint cursor_index;

    if (gtk_im_context_get_surrounding(GTK_IM_CONTEXT(self->obj),
                                       &text, &cursor_index)) {
        PyObject *ret = Py_BuildValue("(si)", text, cursor_index);

        g_free(text);
        return ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override-attr GtkTooltips.active_tips_data
static PyObject *
_wrap_gtk_tooltips__get_active_tips_data(PyGObject *self, void *closure)
{
    GtkTooltips *tips = GTK_TOOLTIPS(self->obj);
    GtkTooltipsData *data = tips->active_tips_data;

    if (data == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    return Py_BuildValue("NNss",
                         pygobject_new((GObject *)data->tooltips),
                         pygobject_new((GObject *)data->widget),
                         data->tip_text,
                         data->tip_private);
}
%%
override-attr GtkTooltips.tips_data_list
static PyObject *
_wrap_gtk_tooltips__get_tips_data_list(PyGObject *self, void *closure)
{
    GList *list = GTK_TOOLTIPS(self->obj)->tips_data_list;
    gint         i, length;
    PyObject    *pylist;
    GList *iter;

    length = g_list_length(list);
    pylist = PyList_New(length);

    i = 0;
    for (iter = list; iter; iter = iter->next) {
        GtkTooltipsData *data = (GtkTooltipsData*)iter->data;
        PyObject *item = Py_BuildValue("NNss",
                               pygobject_new((GObject *)data->tooltips),
                               pygobject_new((GObject *)data->widget),
                               data->tip_text,
                               data->tip_private);
        PyList_SetItem(pylist, i, item);
        Py_INCREF(item);
    }
    return pylist;
}
%%
override-attr GtkAdjustment.value
static int
_wrap_gtk_adjustment__set_value(PyGObject *self, PyObject *value,
                                void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);

    if (!pygtk_util_pyobject_as_double(value, &adjustment->value, "value"))
        return -1;
    gtk_adjustment_value_changed(adjustment);
    return 0;
}
%%
override-attr GtkAdjustment.lower
static int
_wrap_gtk_adjustment__set_lower(PyGObject *self, PyObject *value,
                                void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);

    if (!pygtk_util_pyobject_as_double(value, &adjustment->lower, "lower"))
        return -1;
    gtk_adjustment_changed(adjustment);
    return 0;
}
%%
override-attr GtkAdjustment.upper
static int
_wrap_gtk_adjustment__set_upper(PyGObject *self, PyObject *value,
                                void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);

    if (!pygtk_util_pyobject_as_double(value, &adjustment->upper, "upper"))
        return -1;
    gtk_adjustment_changed(adjustment);
    return 0;
}
%%
override-attr GtkAdjustment.step_increment
static int
_wrap_gtk_adjustment__set_step_increment(PyGObject *self, PyObject *value,
                                         void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);

    if (!pygtk_util_pyobject_as_double(value, &adjustment->step_increment,
                                       "step_increment"))
        return -1;
    gtk_adjustment_changed(adjustment);
    return 0;
}
%%
override-attr GtkAdjustment.page_increment
static int
_wrap_gtk_adjustment__set_page_increment(PyGObject *self, PyObject *value,
                                         void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);

    if (!pygtk_util_pyobject_as_double(value, &adjustment->page_increment,
                                       "page_increment"))
        return -1;
    gtk_adjustment_changed(adjustment);
    return 0;
}
%%
override-attr GtkAdjustment.page_size
static int
_wrap_gtk_adjustment__set_page_size(PyGObject *self, PyObject *value,
                                         void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);

    if (!pygtk_util_pyobject_as_double(value, &adjustment->page_size, "page_size"))
        return -1;
    gtk_adjustment_changed(adjustment);
    return 0;
}
%%
override gtk_adjustment_set_all kwargs
static PyObject *
_wrap_gtk_adjustment_set_all(PyGObject *self,
			     PyObject *args,
                             PyObject *kwargs)
{
    static char *kwlist[] = { "value", "lower", "upper", "step_increment",
			      "page_increment", "page_size", NULL };
    GtkAdjustment *adj = GTK_ADJUSTMENT(self->obj);
    double *value = &adj->value, *lower = &adj->lower, *upper = &adj->upper;
    double *step_increment = &adj->step_increment;
    double *page_increment = &adj->page_increment;
    double *page_size = &adj->page_size;
    double old_value = *value, old_lower = *lower, old_upper = *upper;
    double old_step_increment = *step_increment;
    double old_page_increment = *page_increment;
    double old_page_size = *page_size;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|dddddd:gtk_adjustment_set_all",
				     kwlist,
				     value, lower, upper, step_increment,
				     page_increment, page_size)) {
        adj->value = old_value;
        adj->lower = old_lower;
        adj->upper = old_upper;
        adj->step_increment = old_step_increment;
        adj->page_increment = old_page_increment;
        adj->page_size = old_page_size;
        return NULL;
    }
    
    if (adj->value != old_value)
        gtk_adjustment_value_changed(adj);
    if (adj->lower != old_lower || adj->upper != old_upper
	|| adj->step_increment != old_step_increment
	|| adj->page_increment != old_page_increment
	|| adj->page_size != old_page_size)
        gtk_adjustment_changed(adj);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_file_selection_get_selections noargs
static PyObject *
_wrap_gtk_file_selection_get_selections(PyGObject *self)
{
    gchar **filenames = NULL;
    int size;
    int i;
    PyObject *ret;

    filenames = gtk_file_selection_get_selections(
        GTK_FILE_SELECTION(self->obj));

    for (i = 0; filenames[i]; i++);
    size = i;

    ret = PyTuple_New(size);
    for (i = 0; i < size; i++)
        PyTuple_SetItem(ret, i, PyString_FromString(filenames[i]));

    return ret;
}
%%
override gtk_icon_size_lookup kwargs
static PyObject *
_wrap_gtk_icon_size_lookup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_size", NULL };
    PyObject *py_icon_size;
    GtkIconSize icon_size;
    gint width, height;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:icon_size_lookup",
                                     kwlist, &py_icon_size))
        return NULL;

    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_icon_size,
                           (gint *) &icon_size))
        return NULL;

    gtk_icon_size_lookup(icon_size, &width, &height);

    return Py_BuildValue("(ii)", width, height);
}
%%
override gtk_image_get_pixmap noargs
static PyObject *
_wrap_gtk_image_get_pixmap(PyGObject *self)
{
    GdkPixmap *pixmap;
    GdkBitmap *mask;
    GtkImageType type;

    type = gtk_image_get_storage_type(GTK_IMAGE(self->obj));
    if (!(type == GTK_IMAGE_PIXMAP || type == GTK_IMAGE_EMPTY)) {
	 PyErr_SetString(PyExc_ValueError, "image should be a GdkPixmap or empty");
        return NULL;
    }
    gtk_image_get_pixmap(GTK_IMAGE(self->obj), &pixmap, &mask);
    return Py_BuildValue("(NN)", pygobject_new((GObject *)pixmap),
			 pygobject_new((GObject *)mask));
}
%%
override gtk_image_get_image noargs
static PyObject *
_wrap_gtk_image_get_image(PyGObject *self)
{
    GdkImage *image;
    GdkBitmap *mask;
    GtkImageType type;

    type = gtk_image_get_storage_type(GTK_IMAGE(self->obj));
    if (!(type == GTK_IMAGE_IMAGE || type == GTK_IMAGE_EMPTY)) {
	 PyErr_SetString(PyExc_ValueError, "image should be a GdkImage or empty");
        return NULL;
    }
    gtk_image_get_image(GTK_IMAGE(self->obj), &image, &mask);
    return Py_BuildValue("(NN)", pygobject_new((GObject *)image),
			 pygobject_new((GObject *)mask));
}
%%
override gtk_image_get_stock noargs
static PyObject *
_wrap_gtk_image_get_stock(PyGObject *self)
{
    gchar *stock_id;
    GtkIconSize size;
    GtkImageType type;

    type = gtk_image_get_storage_type(GTK_IMAGE(self->obj));
    if (!(type == GTK_IMAGE_STOCK || type == GTK_IMAGE_EMPTY)) {
	 PyErr_SetString(PyExc_ValueError, "image should be a stock icon or empty");
        return NULL;
    }
    gtk_image_get_stock(GTK_IMAGE(self->obj), &stock_id, &size);

    if (stock_id) {
	return Py_BuildValue("(NN)",
			     PyString_FromString(stock_id),
			     pyg_enum_from_gtype(GTK_TYPE_ICON_SIZE, size));
    } else {
	Py_INCREF(Py_None);
	return Py_BuildValue("(ON)",
			     Py_None,
			     pyg_enum_from_gtype(GTK_TYPE_ICON_SIZE, size));
    }
}
%%
override gtk_image_get_icon_set noargs
static PyObject *
_wrap_gtk_image_get_icon_set(PyGObject *self)
{
    GtkIconSet *icon_set;
    GtkIconSize size;
    GtkImageType type;

    type = gtk_image_get_storage_type(GTK_IMAGE(self->obj));
    if (!(type == GTK_IMAGE_ICON_SET || type == GTK_IMAGE_EMPTY)) {
	 PyErr_SetString(PyExc_ValueError, "image should be a GtkIconSet or empty");
        return NULL;
    }
    gtk_image_get_icon_set(GTK_IMAGE(self->obj), &icon_set, &size);
    return Py_BuildValue("(NN)", pygobject_new((GObject *)icon_set),
			 pyg_enum_from_gtype(GTK_TYPE_ICON_SIZE, size));
}
%%
override gtk_image_get noargs
static PyObject *
_wrap_gtk_image_get(PyGObject *self)
{
    return _wrap_gtk_image_get_image(self);
}
%%
override gtk_image_get_pixbuf noargs
static PyObject *
_wrap_gtk_image_get_pixbuf(PyGObject *self)
{
    GdkPixbuf *ret;
    GtkImageType type;

    type = gtk_image_get_storage_type(GTK_IMAGE(self->obj));
    if (!(type == GTK_IMAGE_PIXBUF || type == GTK_IMAGE_EMPTY)) {
	 PyErr_SetString(PyExc_ValueError, "image should be a GdkPixbuf or empty");
        return NULL;
    }
    ret = gtk_image_get_pixbuf(GTK_IMAGE(self->obj));
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}
%%
override gtk_image_get_animation noargs
static PyObject *
_wrap_gtk_image_get_animation(PyGObject *self)
{
    GdkPixbufAnimation *ret;
    GtkImageType type;

    type = gtk_image_get_storage_type(GTK_IMAGE(self->obj));
    if (!(type == GTK_IMAGE_ANIMATION || type == GTK_IMAGE_EMPTY)) {
	 PyErr_SetString(PyExc_ValueError, "image should be a GdkPixbufAnimation or empty");
        return NULL;
    }

    ret = gtk_image_get_animation(GTK_IMAGE(self->obj));
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}
%%
override gtk_radio_button_set_group kwargs
static PyObject *
_wrap_gtk_radio_button_set_group(PyGObject *self, PyObject *args,
				 PyObject *kwargs) {
    static char *kwlist[] = { "group", NULL };
    PyObject *py_group;
    GSList *list;
    GtkRadioButton *group;

    if (!PyArg_ParseTupleAndKeywords(args,kwargs,"O!:GtkRadioButton.set_group",
                                     kwlist, &PyGtkRadioButton_Type,
				     &py_group))
        return NULL;
    group = GTK_RADIO_BUTTON(pygobject_get(py_group));
    list = gtk_radio_button_get_group(group);
    if (list == gtk_radio_button_get_group(GTK_RADIO_BUTTON(self->obj))) {
        PyErr_SetString(PyExc_ValueError, "radio button already in group");
        return NULL;
    }
    gtk_radio_button_set_group(GTK_RADIO_BUTTON(self->obj), list);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_radio_menu_item_get_group noargs
static PyObject *
_wrap_gtk_radio_menu_item_get_group(PyGObject *self) {
    PyObject *py_list;
    GSList *list, *tmp;
    PyObject *gtk_obj;

    list = gtk_radio_menu_item_get_group(GTK_RADIO_MENU_ITEM(self->obj));

    if ((py_list = PyList_New(0)) == NULL) {
        return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        gtk_obj = pygobject_new(G_OBJECT(tmp->data));
        if (gtk_obj == NULL) {
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_Append(py_list, gtk_obj);
        Py_DECREF(gtk_obj);
    }
    return py_list;
}
%%
override gtk_radio_menu_item_set_group kwargs
static PyObject *
_wrap_gtk_radio_menu_item_set_group(PyGObject *self, PyObject *args,
				    PyObject *kwargs) {
    static char *kwlist[] = { "group", NULL };
    PyObject *py_group;
    GSList *list;
    GtkRadioMenuItem *group;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!:GtkRadioMenuItem.set_group",
                                     kwlist, &PyGtkRadioMenuItem_Type,
				     &py_group))
        return NULL;
    group = GTK_RADIO_MENU_ITEM(pygobject_get(py_group));
    list = gtk_radio_menu_item_get_group(group);
    if (list == gtk_radio_menu_item_get_group(GTK_RADIO_MENU_ITEM(self->obj))) {
        PyErr_SetString(PyExc_ValueError, "radio menu item already in group");
        return NULL;
    }
    gtk_radio_menu_item_set_group(GTK_RADIO_MENU_ITEM(self->obj), list);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_scrolled_window_get_policy  noargs
static PyObject *
_wrap_gtk_scrolled_window_get_policy(PyGObject *self)
{
    GtkPolicyType hscrollbar_policy, vscrollbar_policy;

    gtk_scrolled_window_get_policy(GTK_SCROLLED_WINDOW(self->obj),
				   &hscrollbar_policy, &vscrollbar_policy);
    return Py_BuildValue("(NN)",
			 pyg_enum_from_gtype(GTK_TYPE_POLICY_TYPE, hscrollbar_policy),
			 pyg_enum_from_gtype(GTK_TYPE_POLICY_TYPE, vscrollbar_policy));
}
%%
override gtk_tooltips_data_get kwargs
static PyObject *
_wrap_gtk_tooltips_data_get(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", NULL };
    PyGObject *widget;
    GtkTooltipsData *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!:GtkTooltips.data_get",
				     kwlist, &PyGtkWidget_Type, &widget))
        return NULL;

    data = gtk_tooltips_data_get(GTK_WIDGET(widget->obj));

    if (!data) {
	Py_INCREF(Py_None);
	return Py_None;
    }

    return Py_BuildValue("NNss",
			 pygobject_new((GObject *)data->tooltips),
			 pygobject_new((GObject *)data->widget),
			 data->tip_text,
			 data->tip_private);
}
%%
override gtk_tooltips_data_get1 kwargs
static PyObject *
_wrap_gtk_tooltips_data_get1(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "use tooltips_data_get") < 0)
        return NULL;

    return _wrap_gtk_tooltips_data_get(self, args, kwargs);
}
%%
override gtk_accelerator_parse kwargs
static PyObject *
_wrap_gtk_accelerator_parse(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accelerator", NULL };
    gchar *accel;
    guint keyval;
    GdkModifierType modifier;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s:Gtk.accelerator_parse",
				     kwlist, &accel))
        return NULL;

    gtk_accelerator_parse((const gchar *)accel, &keyval, &modifier);

    return Py_BuildValue("iN", keyval,
                         pyg_flags_from_gtype(GDK_TYPE_MODIFIER_TYPE,
                                              modifier));
}
%%
override gtk_accel_map_lookup_entry kwargs
static PyObject *
_wrap_gtk_accel_map_lookup_entry(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "accel_path", NULL };
    gchar *accel_path;
    GtkAccelKey accel_key;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s:gtk.accel_map_lookup_entry",
				     kwlist, &accel_path))
        return NULL;

    if (gtk_accel_map_lookup_entry((const gchar *)accel_path, &accel_key))
	return Py_BuildValue("iN", accel_key.accel_key,
			     pyg_flags_from_gtype(GDK_TYPE_MODIFIER_TYPE, accel_key.accel_mods));

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_accel_map_load_fd kwargs
static PyObject *
_wrap_gtk_accel_map_load_fd(PyGObject *self, PyObject *args,
			    PyObject *kwargs)
{
    static char *kwlist[] = { "fd", NULL };
    gint fd;
    PyObject *py_fd;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:gtk.accel_map_load_fd",
				     kwlist, &py_fd))
        return NULL;

    if ((fd = PyObject_AsFileDescriptor(py_fd)) != -1)
	gtk_accel_map_load_fd(fd);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_accel_map_save_fd kwargs
static PyObject *
_wrap_gtk_accel_map_save_fd(PyGObject *self, PyObject *args,
			    PyObject *kwargs)
{
    static char *kwlist[] = { "fd", NULL };
    gint fd;
    PyObject *py_fd;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:gtk.accel_map_save_fd",
				     kwlist, &py_fd))
        return NULL;

    if ((fd = PyObject_AsFileDescriptor(py_fd)) != -1)
	gtk_accel_map_save_fd(fd);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_color_selection_palette_from_string kwargs
static PyObject *
_wrap_gtk_color_selection_palette_from_string(PyGObject *self, PyObject *args,
					      PyObject *kwargs)
{
    static char *kwlist[] = { "str", NULL };
    gchar *str;
    GdkColor *colors;
    gint i, n_colors;
    PyObject *py_list;

    if (!PyArg_ParseTupleAndKeywords(
	args, kwargs, "s:gtk.color_selection_palette_from_string",
	kwlist, &str))
        return NULL;

    if (!gtk_color_selection_palette_from_string(str, &colors, &n_colors)) {
	Py_INCREF(Py_None);
	return Py_None;
    }

    if ((py_list = PyList_New(n_colors)) == NULL) {
	g_free(colors);
	return NULL;
    }

    for (i = 0; i < n_colors; i++) {
	PyObject *item = pyg_boxed_new(GDK_TYPE_COLOR, &colors[i], TRUE, TRUE);

	PyList_SetItem(py_list, i, item);
    }
    g_free(colors);

    return py_list;
}
%%
override gtk_color_selection_palette_to_string kwargs
static PyObject *
_wrap_gtk_color_selection_palette_to_string(PyGObject *self, PyObject *args,
					      PyObject *kwargs)
{
    static char *kwlist[] = { "colors", NULL };
    gchar *str;
    GdkColor *colors;
    gint i, n_colors;
    PyObject *py_colors, *ret;

    if (!PyArg_ParseTupleAndKeywords(
	args, kwargs, "O:gtk.color_selection_palette_to_string",
	kwlist, &py_colors))
        return NULL;

    n_colors = PySequence_Length(py_colors);
    if ((colors = g_new0(GdkColor, n_colors)) == NULL)
	return NULL;

    for (i = 0; i < n_colors; i++) {
        PyObject *item = PySequence_GetItem(py_colors, i);
	if (!pyg_boxed_check(item, GDK_TYPE_COLOR)) {
	    PyErr_SetString(PyExc_TypeError,
			    "colors must contain gtk.gdk.Colors");
	    g_free(colors);
	    Py_DECREF(item);
	    return NULL;
	}
	colors[i] = *pyg_boxed_get(item, GdkColor);
	Py_DECREF(item);
    }

    str = gtk_color_selection_palette_to_string(colors, n_colors);
    ret = PyString_FromString(str);
    g_free(colors);
    g_free(str);

    return ret;
}

%%
override gtk_binding_entry_remove kwargs
static PyObject *
_wrap_gtk_binding_entry_remove(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "class_type", "keyval", "modifiers", NULL };
    int keyval;
    PyObject *py_modifiers = NULL;
    GdkModifierType modifiers;
    PyObject *class;
    GType class_type;
    GtkBindingSet *bset = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OiO:gtk_binding_entry_remove",
				     kwlist, &class, &keyval, &py_modifiers))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, py_modifiers, (gint *)&modifiers))
        return NULL;

    class_type = pyg_type_from_object(class);
    if (class_type == 0)
        return NULL;

    bset = gtk_binding_set_by_class(gtk_type_class(class_type));
    gtk_binding_entry_remove(bset, keyval, modifiers);
    Py_INCREF(Py_None);
    return Py_None;
}

%%
define GtkAccelGroup.connect_group kwargs
static PyObject *
_wrap_gtk_accel_group_connect_group(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accel_key", "accel_mods", "accel_flags", "callback", NULL };
    int accel_key;
    PyObject *py_accel_mods = NULL, *py_accel_flags = NULL, *py_callback;
    GdkModifierType accel_mods;
    GtkAccelFlags accel_flags;
    GClosure *closure;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "iOOO:GtkAccelGroup.connect", kwlist,
				     &accel_key, &py_accel_mods, &py_accel_flags,
				     &py_callback))
        return NULL;
    if (!PyCallable_Check(py_callback)) {
	PyErr_SetString(PyExc_TypeError, "callback argument not callable");
	return NULL;
    }
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, py_accel_mods, (gint *)&accel_mods))
        return NULL;
    if (pyg_flags_get_value(GTK_TYPE_ACCEL_FLAGS, py_accel_flags, (gint *)&accel_flags))
        return NULL;
    closure = pyg_closure_new(py_callback, NULL, NULL);
    pygobject_watch_closure((PyObject *)self, closure);
    gtk_accel_group_connect(GTK_ACCEL_GROUP(self->obj), accel_key,
			    accel_mods, accel_flags, closure);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_file_chooser_dialog_new kwargs
static int
_wrap_gtk_file_chooser_dialog_new(PyGObject *self,
				  PyObject *args,
                                  PyObject *kwargs)
{
    static char *kwlist[] = { "title", "parent", "action", "buttons", "backend", NULL };
    gchar *title = NULL;
    PyGObject *py_window = NULL;
    PyObject *py_buttons = Py_None;
    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
    GtkWindow *parent = NULL;
    gchar *backend = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|sOiO!s:GtkFileChooserDialog.__init__", kwlist,
                                     &title, &py_window, &action,
                                     &PyTuple_Type, &py_buttons,
				     &backend))
        return -1;

    if (py_window == NULL || (PyObject*)py_window == Py_None)
	parent = NULL;
    else if (pygobject_check(py_window, &PyGtkWindow_Type))
	parent = GTK_WINDOW(py_window->obj);
    else {
        PyErr_SetString(PyExc_TypeError, "parent must be a GtkWindow or None");
        return -1;
    }

    if (py_buttons != Py_None)
        len = PyTuple_Size(py_buttons);
    else
        len = 0;

    if (len % 2) {
        PyErr_SetString(PyExc_RuntimeError,
                        "buttons tuple must contain text/response id pairs");
        return -1;
    }

    self->obj = g_object_new(pyg_type_from_object((PyObject*) self),
                             "title", title, 
                             "action", action,
			     "file-system-backend", backend,
                             NULL);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkFileChooserDialog object");
        return -1;
    }

  if (parent)
    gtk_window_set_transient_for (GTK_WINDOW (self->obj), parent);

  for (i = 0; i < len; i += 2) {
        PyObject *text = PyTuple_GetItem(py_buttons, i);
        PyObject *id = PyTuple_GetItem(py_buttons, i + 1);
        if (!PyString_Check(text)) {
            gtk_object_destroy(GTK_OBJECT(self->obj));
            self->obj = NULL;
            PyErr_SetString(PyExc_RuntimeError,
                            "first member of each text/response id pair "
                            "must be a string");
            return -1;
        }
        if (!PyInt_Check(id)) {
            gtk_object_destroy(GTK_OBJECT(self->obj));
            self->obj = NULL;
            PyErr_SetString(PyExc_RuntimeError,
                            "second member of each text/response id pair "
                            "must be a number");
            return -1;
        }
        gtk_dialog_add_button(GTK_DIALOG(self->obj), PyString_AsString(text),
                              PyInt_AsLong(id));
    }
    pyg_begin_allow_threads;
    g_object_ref(self->obj); /* we don't own the first reference of windows */
    pyg_end_allow_threads;
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_ui_manager_get_action_groups noargs
static PyObject *
_wrap_gtk_ui_manager_get_action_groups(PyGObject *self)
{
    GList *list, *tmp;
    PyObject *ret;

    list = gtk_ui_manager_get_action_groups(GTK_UI_MANAGER(self->obj));
    
    ret = PyList_New(0);
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        PyObject *item = pygobject_new(G_OBJECT(tmp->data));

        PyList_Append(ret, item);
        Py_DECREF(item);
    }
    
    return ret;
}
%%
override gtk_ui_manager_get_toplevels kwargs
static PyObject *
_wrap_gtk_ui_manager_get_toplevels(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "types", NULL };
    GtkUIManagerItemType types;
    PyObject *py_types = NULL;
    GSList *list, *tmp;
    PyObject *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkUIManager.get_toplevels", kwlist,
				     &py_types))
        return NULL;
    
    if (pyg_flags_get_value(GTK_TYPE_UI_MANAGER_ITEM_TYPE, py_types, (gint *)&types))
        return NULL;

    list = gtk_ui_manager_get_toplevels(GTK_UI_MANAGER(self->obj), types);
    
    ret = PyList_New(0);
    for (tmp = list; tmp; tmp = tmp->next) {
        PyObject *item = pygobject_new(G_OBJECT(tmp->data));

        PyList_Append(ret, item);
        Py_DECREF(item);
    }
    
    return ret;
}
%%
override gtk_action_group_add_actions kwargs
static PyObject *
_wrap_gtk_action_group_add_actions (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "entries", "user_data", NULL };
    PyGILState_STATE state;
    PyObject *entries, *extra_args = NULL;
    int len, i;
    PyObject *item;
    GtkActionEntry entry;
    GtkAction *action;
    PyObject *callback, *py_action;
    GClosure *closure;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O:GtkActionGroup.add_actions",
				     kwlist, &entries, &extra_args))
        return NULL;
    
    if (!PySequence_Check(entries)) {
        PyErr_SetString(PyExc_TypeError, "entries must be a sequence");
        return NULL;
    }

    state = pyg_gil_state_ensure();
    
    len = PySequence_Size(entries);
    for (i = 0; i < len; i++) {
	item = PySequence_GetItem(entries, i);
        Py_DECREF(item);

        memset(&entry, 0, sizeof(entry));
        callback = Py_None;
	
        if (!PyArg_ParseTuple(item, "s|zzzzO", &(entry.name), &(entry.stock_id),
			      &(entry.label), &(entry.accelerator), &(entry.tooltip),
			      &callback)) {
            return NULL;
        }

	action = gtk_action_new(entry.name, entry.label, entry.tooltip,
				entry.stock_id);
	if (action == NULL) {
	    PyErr_SetString(PyExc_RuntimeError,
			    "could not create GtkAction object");
	    return NULL;
	}
	    
	py_action = pygobject_new((GObject *)action);
	if (callback != Py_None) {
	    if (PyCallable_Check(callback)) {
		closure = pyg_closure_new(callback, extra_args, NULL);
		g_signal_connect_closure(action, "activate", closure, FALSE);
		pygobject_watch_closure(py_action, closure);
	    } else {
		PyErr_SetString(PyExc_TypeError,
				"One or more entry is missing a callback type");
		g_object_unref (action);
		Py_DECREF (py_action);
		return NULL;
	    }
	}
	
	gtk_action_group_add_action_with_accel (GTK_ACTION_GROUP(self->obj),
						GTK_ACTION(action),
						entry.accelerator);
	
	g_object_unref(action);
	Py_DECREF (py_action);
    }

    pyg_gil_state_release(state);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_action_group_add_toggle_actions kwargs
static PyObject *
_wrap_gtk_action_group_add_toggle_actions (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "entries", "user_data", NULL };
    PyGILState_STATE state;
    PyObject *entries, *extra_args = NULL;
    int len, i;
    PyObject *item;
    GtkToggleActionEntry entry;
    GtkToggleAction *action;
    PyObject *callback, *py_action;
    GClosure *closure;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O:GtkActionGroup.add_toggle_actions",
				     kwlist, &entries, &extra_args))
        return NULL;
    
    if (!PySequence_Check(entries)) {
        PyErr_SetString(PyExc_TypeError, "entries must be a sequence");
        return NULL;
    }

    state = pyg_gil_state_ensure();

    len = PySequence_Size(entries);
    for (i = 0; i < len; i++) {
	item = PySequence_GetItem(entries, i);
        Py_DECREF(item);

        memset(&entry, 0, sizeof(entry));
        callback = Py_None;
	
        if (!PyArg_ParseTuple(item, "s|zzzzOi", &(entry.name), &(entry.stock_id),
			      &(entry.label), &(entry.accelerator), &(entry.tooltip),
			      &callback, &(entry.is_active))) {
            return NULL;
        }

	action = gtk_toggle_action_new(entry.name, entry.label, entry.tooltip,
				       entry.stock_id);
	if (action == NULL) {
	    PyErr_SetString(PyExc_RuntimeError,
			    "could not create GtkToggleAction object");
	    return NULL;
	}

	gtk_toggle_action_set_active(action, entry.is_active);
	py_action = pygobject_new((GObject *)action);
	if (callback != Py_None && PyCallable_Check(callback)) {
	    closure = pyg_closure_new(callback, extra_args, NULL);
	    g_signal_connect_closure(action, "activate", closure, FALSE);
	    pygobject_watch_closure(py_action, closure);
	}
	
	gtk_action_group_add_action_with_accel (GTK_ACTION_GROUP(self->obj),
						GTK_ACTION(action),
						entry.accelerator);
	
	g_object_unref (action);
	Py_DECREF (py_action);
    }

    pyg_gil_state_release(state);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_action_group_add_radio_actions kwargs
static PyObject *
_wrap_gtk_action_group_add_radio_actions (PyGObject *self, PyObject *args,
					  PyObject *kwargs)
{
    static char *kwlist[] = { "entries", "value", "on_change", "user_data", NULL };
    PyGILState_STATE state;
    PyObject *entries, *extra_args = NULL;
    int len, i;
    PyObject *item;
    GtkRadioActionEntry entry;
    GtkRadioAction *action, *first_action = NULL;
    PyObject *callback = Py_None;
    GClosure *closure;
    GSList * group = NULL;
    gint value = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O|iOO:GtkActionGroup.add_radio_actions",
				     kwlist, &entries, &value, &callback, &extra_args))
        return NULL;
    
    if (!PySequence_Check(entries)) {
        PyErr_SetString(PyExc_TypeError, "entries must be a sequence");
        return NULL;
    }

    state = pyg_gil_state_ensure();
    
    len = PySequence_Size(entries);
    for (i = 0; i < len; i++) {
	item = PySequence_GetItem(entries, i);
        Py_DECREF(item);

        memset(&entry, 0, sizeof(entry));
	
        if (!PyArg_ParseTuple(item, "s|zzzzi", &(entry.name),
			      &(entry.stock_id),
			      &(entry.label), &(entry.accelerator),
			      &(entry.tooltip),
			      &(entry.value))) {
            return NULL;
        }

	action = gtk_radio_action_new(entry.name, entry.label, entry.tooltip,
				      entry.stock_id, entry.value);
	if (action == NULL) {
	    PyErr_SetString(PyExc_RuntimeError,
			    "could not create GtkRadioAction object");
	    return NULL;
	}

	gtk_radio_action_set_group(action, group);
	group = gtk_radio_action_get_group(action);

	if (value == entry.value)
	    gtk_toggle_action_set_active(GTK_TOGGLE_ACTION(action), TRUE);

	gtk_action_group_add_action_with_accel (GTK_ACTION_GROUP(self->obj),
						GTK_ACTION(action),
						entry.accelerator);
	
	if (i == 0)
	    first_action = action;
	else
	    g_object_unref (action);
    }

    if (first_action && callback != Py_None && PyCallable_Check(callback)) {
	PyObject *py_action;

	closure = pyg_closure_new(callback, extra_args, NULL);
	g_signal_connect_closure(first_action, "changed", closure, FALSE);
	py_action = pygobject_new((GObject *)first_action);
	pygobject_watch_closure(py_action, closure);
	g_object_unref(first_action);
	Py_DECREF (py_action);
    }
    
    pyg_gil_state_release(state);
	
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_ui_manager_add_ui_from_string kwargs
static PyObject *
_wrap_gtk_ui_manager_add_ui_from_string(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "buffer", NULL };
    char *buffer;
    int length, ret;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s#:GtkUIManager.add_ui_from_string",
				     kwlist, &buffer, &length))
        return NULL;
    
    ret = gtk_ui_manager_add_ui_from_string(GTK_UI_MANAGER(self->obj),
					    buffer, length, &error);
    if (pyg_error_check(&error))
        return NULL;
    return PyInt_FromLong(ret);
}
%%
override gtk_action_group_list_actions noargs
static PyObject *
_wrap_gtk_action_group_list_actions(PyGObject *self)
{
    GList *l, *actions;
    PyObject *item, *ret;

    ret = PyList_New(0);
    if (ret == NULL)
	return NULL;
    
    actions = gtk_action_group_list_actions(GTK_ACTION_GROUP(self->obj));

    for (l = actions; l; l = l->next) {
        item = pygobject_new((GObject *) GTK_ACTION(l->data));

        if (!item) {
            Py_DECREF(ret);
            return NULL;
        }

        PyList_Append(ret, item);
        Py_DECREF(item);
    }

    g_list_free(actions);
    
    return ret;
}
%%
override gtk_alignment_get_padding noargs
static PyObject *
_wrap_gtk_alignment_get_padding(PyGObject *self)
{
    guint top, bottom, left, right;

    gtk_alignment_get_padding(GTK_ALIGNMENT(self->obj), &top, &bottom, &left,
			      &right);
    return Py_BuildValue("(iiii)", top, bottom, left, right);
}
%%
override gtk_accel_group_connect_by_path kwargs
static PyObject *
_wrap_gtk_accel_group_connect_by_path(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accel_path", "callback", NULL };
    gchar *accel_path;
    PyObject *py_callback;
    GClosure *closure;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "sO:GtkAccelGroup.connect_by_path", kwlist,
				     &accel_path, &py_callback))
        return NULL;
    if (!PyCallable_Check(py_callback)) {
	PyErr_SetString(PyExc_TypeError, "callback argument not callable");
	return NULL;
    }
    closure = pyg_closure_new(py_callback, NULL, NULL);
    pygobject_watch_closure((PyObject *)self, closure);
    gtk_accel_group_connect_by_path(GTK_ACCEL_GROUP(self->obj), accel_path,
				    closure);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_color_button_new kwargs
static int
_wrap_gtk_color_button_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "color", NULL };
    GdkColor *color = NULL;
    PyObject *pycolor = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|O:GtkColorButton.__init__",
                                     kwlist, &pycolor))
        return -1;
    if (pycolor) {
 	if (!pyg_boxed_check(pycolor, GDK_TYPE_COLOR)) {
	    PyErr_SetString(PyExc_TypeError,
			    "color should be a gtk.gdk.Color");
 		return -1;
	    }
        color = pyg_boxed_get(pycolor, GdkColor);
	self->obj = g_object_new(pyg_type_from_object((PyObject*) self),
                                 "color", color, NULL);
    } else {
	self->obj = g_object_new(pyg_type_from_object((PyObject*) self), NULL);
    }
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkColorButton object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_color_button_get_color noargs
static PyObject *
_wrap_gtk_color_button_get_color(PyGObject *self)
{
    GdkColor color = {0, 0, 0, 0};
 
    gtk_color_button_get_color(GTK_COLOR_BUTTON(self->obj), &color);
    return pyg_boxed_new(GDK_TYPE_COLOR, &color, TRUE, TRUE);
}
%%
override gtk_combo_box_new kwargs
static int
_wrap_gtk_combo_box_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "model", NULL };
    PyGObject *pymodel = NULL;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:GtkComboBox.__init__",
				     kwlist, &pymodel))
        return -1;
    if (pymodel == NULL || (PyObject *)pymodel == Py_None)
	self->obj = g_object_new(pyg_type_from_object((PyObject*) self), NULL);
    else if (pygobject_check(pymodel, &PyGtkTreeModel_Type))
	self->obj = g_object_new(pyg_type_from_object((PyObject*) self),
                                 "model", GTK_TREE_MODEL(pymodel->obj), NULL);
    else {
	PyErr_SetString(PyExc_TypeError,
			"model must be a gtk.TreeModel or None");
	return -1;
    }
 
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkComboBox object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_combo_box_get_active_iter noargs
static PyObject *
_wrap_gtk_combo_box_get_active_iter(PyGObject *self)
{
    GtkTreeIter iter;
    gboolean ret;

    ret = gtk_combo_box_get_active_iter(GTK_COMBO_BOX(self->obj), &iter);

    if (ret)
	return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_cell_layout_set_attributes kwargs
static PyObject *
_wrap_gtk_cell_layout_set_attributes(PyGObject *self, PyObject *args,
                                          PyObject *kwargs)
{
    PyObject *py_cell, *key, *item;
    GtkCellRenderer *cell;
    gint i = 0;

    if (!PyArg_ParseTuple(args, "O!:GtkCellLayout.set_attributes",
                          &PyGtkCellRenderer_Type, &py_cell))
        return NULL;
    cell = GTK_CELL_RENDERER(pygobject_get(py_cell));
    gtk_cell_layout_clear_attributes(GTK_CELL_LAYOUT(self->obj), cell);
    if (kwargs) {
        while (PyDict_Next(kwargs, &i, &key, &item)) {
            gchar *attr = PyString_AsString(key);

            if (!PyInt_Check(item)) {
                gchar err[128];
                g_snprintf(err, sizeof(err),
                           "%s must be an integer column number", attr);
                PyErr_SetString(PyExc_TypeError, err);
                return NULL;
            }
            gtk_cell_layout_add_attribute(GTK_CELL_LAYOUT(self->obj),
					  cell, attr, PyInt_AsLong(item));
        }
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_combo_box_entry_new kwargs
static int
_wrap_gtk_combo_box_entry_new(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "model", "column", NULL };
    PyGObject *pymodel = NULL;
    gint column = 0;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|Oi:GtkComboBoxEntry.__init__",
				     kwlist, &pymodel, &column))
        return -1;
    if ((PyObject*)pymodel == Py_None || pymodel == NULL)
	self->obj = g_object_new(pyg_type_from_object((PyObject*) self), NULL);
    else if (pygobject_check(pymodel, &PyGtkTreeModel_Type)) {
	gint ncol = gtk_tree_model_get_n_columns(GTK_TREE_MODEL(pymodel->obj));

	if (column < 0 || column >= ncol) {
	    PyErr_SetString(PyExc_ValueError, "column value out of range");
	    return -1;
	}
	self->obj = g_object_new(pyg_type_from_object((PyObject*) self),
                                 "model", GTK_TREE_MODEL(pymodel->obj),
                                 "text-column", column, NULL);
    } else {
	PyErr_SetString(PyExc_TypeError,
			"model must be a gtk.TreeModel or None");
	return -1;
    }
 
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkComboBoxEntry object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_entry_completion_set_match_func args
static gboolean
pygtk_entry_completion_match_func_cb(GtkEntryCompletion *completion,
				      const gchar *key,
				      GtkTreeIter *iter,
				      gpointer user_data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = user_data;
    PyObject *py_completion, *py_iter;
    gboolean ret = FALSE;
    PyObject *retobj;
 
    g_assert(cunote->func);

    state = pyg_gil_state_ensure();
 
    py_completion = pygobject_new((GObject *)completion);
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, TRUE, TRUE);

    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(NsNO)", py_completion,
                                     key, py_iter, cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(NsN)", py_completion,
                                     key, py_iter);
    }

    if (retobj != NULL) {
	ret = PyObject_IsTrue(retobj);
        Py_DECREF(retobj);
    } else {
	PyErr_Print();
    }
 
    pyg_gil_state_release(state);
    return ret;
}
static PyObject *
_wrap_gtk_entry_completion_set_match_func(PyGObject *self, PyObject *args)
{
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify *cunote;
 
    if (!PyArg_ParseTuple(args,
                          "O|O:GtkEntryCompletion.set_match_func",
                          &pyfunc, &pyarg))
        return NULL;
 
    if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object");
        return NULL;
    }
    cunote = g_new0(PyGtkCustomNotify, 1);
    cunote->func = pyfunc;
    cunote->data = pyarg;
    Py_INCREF(cunote->func);
    Py_XINCREF(cunote->data);

    gtk_entry_completion_set_match_func(GTK_ENTRY_COMPLETION(self->obj),
					pygtk_entry_completion_match_func_cb,
					cunote, pygtk_custom_destroy_notify);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_file_chooser_get_filenames noargs
static PyObject *
_wrap_gtk_file_chooser_get_filenames(PyGObject *self)
{
    PyObject *py_list;
    GSList *slist, *tmp;
    int i, slen;

    slist = gtk_file_chooser_get_filenames(GTK_FILE_CHOOSER(self->obj));
    slen = g_slist_length(slist);
    if ((py_list = PyList_New(slen)) == NULL)
        return NULL;

    for (i = 0, tmp = slist; i < slen && tmp != NULL; tmp = tmp->next, i++) {
        PyObject *obj = PyString_FromString((char *)tmp->data);
        if (obj == NULL) {
	    g_slist_foreach(slist, (GFunc)g_free, NULL);
	    g_slist_free(slist);
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_SetItem(py_list, i, obj);
    }
    g_slist_foreach(slist, (GFunc)g_free, NULL);
    g_slist_free(slist);
    return py_list;
}
%%
override gtk_file_chooser_get_uris noargs
static PyObject *
_wrap_gtk_file_chooser_get_uris(PyGObject *self)
{
    PyObject *py_list;
    GSList *slist, *tmp;
    int i, slen;

    slist = gtk_file_chooser_get_uris(GTK_FILE_CHOOSER(self->obj));
    slen = g_slist_length(slist);
    if ((py_list = PyList_New(slen)) == NULL)
        return NULL;

    for (i = 0, tmp = slist; i < slen && tmp != NULL; tmp = tmp->next, i++) {
        PyObject *obj = PyString_FromString((char *)tmp->data);
        if (obj == NULL) {
	    g_slist_foreach(slist, (GFunc)g_free, NULL);
	    g_slist_free(slist);
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_SetItem(py_list, i, obj);
    }
    g_slist_foreach(slist, (GFunc)g_free, NULL);
    g_slist_free(slist);
    return py_list;
}
%%
override gtk_file_chooser_list_filters noargs
static PyObject *
_wrap_gtk_file_chooser_list_filters(PyGObject *self)
{
    PyObject *py_list;
    GSList *slist, *tmp;
    int i, slen;

    slist = gtk_file_chooser_list_filters(GTK_FILE_CHOOSER(self->obj));
    slen = g_slist_length(slist);
    if ((py_list = PyList_New(slen)) == NULL)
        return NULL;

    for (i = 0, tmp = slist; i < slen && tmp != NULL; tmp = tmp->next, i++) {
        PyObject *obj = pygobject_new(G_OBJECT(tmp->data));
        if (obj == NULL) {
	    g_slist_free(slist);
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_SetItem(py_list, i, obj);
    }
    g_slist_free(slist);
    return py_list;
}
%%
override gtk_file_chooser_list_shortcut_folder_uris noargs
static PyObject *
_wrap_gtk_file_chooser_list_shortcut_folder_uris(PyGObject *self)
{
    PyObject *py_list;
    GSList *slist, *tmp;
    int i, slen;

    slist = gtk_file_chooser_list_shortcut_folder_uris(GTK_FILE_CHOOSER(self->obj));

    slen = g_slist_length(slist);
    if ((py_list = PyList_New(slen)) == NULL)
        return NULL;

    for (i = 0, tmp = slist; i < slen && tmp != NULL; tmp = tmp->next, i++) {
        PyObject *obj = PyString_FromString((char *)tmp->data);
        if (obj == NULL) {
	    g_slist_foreach(slist, (GFunc)g_free, NULL);
	    g_slist_free(slist);
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_SetItem(py_list, i, obj);
    }
    g_slist_foreach(slist, (GFunc)g_free, NULL);
    g_slist_free(slist);
    return py_list;
}
%%
override gtk_file_chooser_list_shortcut_folders noargs
static PyObject *
_wrap_gtk_file_chooser_list_shortcut_folders(PyGObject *self)
{
    PyObject *py_list;
    GSList *slist, *tmp;
    int i, slen;

    slist = gtk_file_chooser_list_shortcut_folders(GTK_FILE_CHOOSER(self->obj));
    slen = g_slist_length(slist);
    if ((py_list = PyList_New(slen)) == NULL)
        return NULL;

    for (i = 0, tmp = slist; i < slen && tmp != NULL; tmp = tmp->next, i++) {
        PyObject *obj = PyString_FromString((char *)tmp->data);
        if (obj == NULL) {
	    g_slist_foreach(slist, (GFunc)g_free, NULL);
	    g_slist_free(slist);
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_SetItem(py_list, i, obj);
    }
    g_slist_foreach(slist, (GFunc)g_free, NULL);
    g_slist_free(slist);
    return py_list;
}
%%
override gtk_file_chooser_widget_new kwargs
static int
_wrap_gtk_file_chooser_widget_new(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "action", "backend", NULL };
    PyObject *py_action = NULL;
    gchar * backend = NULL;
    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|Oz:GtkFileChooserWidget.__init__",
				     kwlist, &py_action, &backend))
        return -1;
    if (py_action && pyg_enum_get_value(GTK_TYPE_FILE_CHOOSER_ACTION,
					py_action, (gint *)&action))
        return -1;
    self->obj = g_object_new(pyg_type_from_object((PyObject*) self),
                             "action", action, "file-system-backend", backend,
                             NULL);
 
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkFileChooserWidget object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_file_filter_filter kwargs
static PyObject *
_wrap_gtk_file_filter_filter(PyGObject *self, PyObject *args,
			     PyObject *kwargs)
{
    static char *kwlist[] = { "filter_info", NULL };
    GtkFileFilterInfo filter_info = { 0, NULL, NULL, NULL, NULL };
    PyObject *py_filter_info, *obj;
    PyObject *pyret = Py_False;
    int size;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!:GtkFileFilter.filter", kwlist,
				     &PyTuple_Type, &py_filter_info))
        return NULL;

    size = PyTuple_Size(py_filter_info);
    if (size != 4) {
	PyErr_SetString(PyExc_RuntimeError,
                        "filter_info tuple must contain 4 items"
			" each of type string or None");
	return NULL;
    }

    if ((obj = PyTuple_GetItem(py_filter_info, 0)) != Py_None) {
	if (!PyString_Check(obj))
	    goto error;
	filter_info.filename = PyString_AsString(obj);
	filter_info.contains |= GTK_FILE_FILTER_FILENAME;
    }
    if ((obj = PyTuple_GetItem(py_filter_info, 1)) != Py_None) {
	if (!PyString_Check(obj))
	    goto error;
	filter_info.uri = PyString_AsString(obj);
	filter_info.contains |= GTK_FILE_FILTER_URI;
    }
    if ((obj = PyTuple_GetItem(py_filter_info, 2)) != Py_None) {
	if (!PyString_Check(obj))
	    goto error;
	filter_info.display_name = PyString_AsString(obj);
	filter_info.contains |= GTK_FILE_FILTER_DISPLAY_NAME;
    }
    if ((obj = PyTuple_GetItem(py_filter_info, 3)) != Py_None) {
	if (!PyString_Check(obj))
	    goto error;
	filter_info.mime_type = PyString_AsString(obj);
	filter_info.contains |= GTK_FILE_FILTER_MIME_TYPE;
    }

    if (gtk_file_filter_filter(GTK_FILE_FILTER(self->obj), &filter_info))
	pyret = Py_True;
    Py_INCREF(pyret);
    return pyret;

 error:
    PyErr_SetString(PyExc_TypeError, "filter_info 4-tuple items"
		    " must be of type string or None");
    return NULL;
}
%%
override gtk_file_filter_add_custom args
static gboolean
pygtk_file_filter_add_custom_cb(const GtkFileFilterInfo *filter_info,
				gpointer user_data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = user_data;
    gboolean ret = FALSE;
    PyObject *retobj, *py_filter_info, *py_obj;
 
    g_assert(cunote->func);

    state = pyg_gil_state_ensure();

    py_filter_info = PyTuple_New(4);

    if (filter_info->filename
	&& (filter_info->contains & GTK_FILE_FILTER_FILENAME)) {
	py_obj = PyString_FromString(filter_info->filename);
    } else {
	Py_INCREF(Py_None);
	py_obj = Py_None;
    }
    PyTuple_SetItem(py_filter_info, 0, py_obj);
    if (filter_info->uri
	&& (filter_info->contains & GTK_FILE_FILTER_URI)) {
	py_obj = PyString_FromString(filter_info->uri);
    } else {
	Py_INCREF(Py_None);
	py_obj = Py_None;
    }
    PyTuple_SetItem(py_filter_info, 1, py_obj);
    if (filter_info->display_name
	&& (filter_info->contains & GTK_FILE_FILTER_DISPLAY_NAME)) {
	py_obj = PyString_FromString(filter_info->display_name);
    } else {
	Py_INCREF(Py_None);
	py_obj = Py_None;
    }
    PyTuple_SetItem(py_filter_info, 2, py_obj);
    if (filter_info->mime_type
	&& (filter_info->contains & GTK_FILE_FILTER_MIME_TYPE)) {
	py_obj = PyString_FromString(filter_info->mime_type);
    } else {
	Py_INCREF(Py_None);
	py_obj = Py_None;
    }
    PyTuple_SetItem(py_filter_info, 3, py_obj);
 
    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(NO)", py_filter_info,
				     cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(N)", py_filter_info);
    }

    if (retobj != NULL) {
	ret = PyObject_IsTrue(retobj);
        Py_DECREF(retobj);
    } else {
	PyErr_Print();
    }
 
    pyg_gil_state_release(state);
    return ret;
}
static PyObject *
_wrap_gtk_file_filter_add_custom(PyGObject *self, PyObject *args)
{
    PyObject *pyfunc, *pyflags, *pyarg = NULL;
    PyGtkCustomNotify *cunote;
    GtkFileFilterFlags flags;
 
    if (!PyArg_ParseTuple(args,
                          "OO|O:GtkEntryCompletion.set_match_func",
                          &pyflags, &pyfunc, &pyarg))
        return NULL;
 
    if (pyg_flags_get_value(GTK_TYPE_FILE_FILTER_FLAGS, pyflags,
			   (gint *)&flags))
        return NULL;

    if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object");
        return NULL;
    }
    cunote = g_new0(PyGtkCustomNotify, 1);
    cunote->func = pyfunc;
    cunote->data = pyarg;
    Py_INCREF(cunote->func);
    Py_XINCREF(cunote->data);

    gtk_file_filter_add_custom(GTK_FILE_FILTER(self->obj), flags,
			       pygtk_file_filter_add_custom_cb,
			       cunote, pygtk_custom_destroy_notify);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_font_button_new kwargs
static int
_wrap_gtk_font_button_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "fontname", NULL };
    gchar * fontname = NULL;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|z:GtkFontButton.__init__",
				     kwlist, &fontname))
        return -1;

    if (fontname == NULL)
	self->obj = g_object_new(pyg_type_from_object((PyObject*) self), NULL);
    else
	self->obj = g_object_new(pyg_type_from_object((PyObject*) self),
                                 "font-name", fontname, NULL);
 
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkFontButton object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_action_get_proxies noargs
static PyObject *
_wrap_gtk_action_get_proxies(PyGObject *self)
{
    PyObject *py_list;
    GSList *slist, *tmp;
    int i, slen;

    slist = gtk_action_get_proxies(GTK_ACTION(self->obj));
    slen = g_slist_length(slist);
    if ((py_list = PyList_New(slen)) == NULL)
        return NULL;

    for (i = 0, tmp = slist; i < slen && tmp != NULL; tmp = tmp->next, i++) {
        PyObject *obj = pygobject_new(G_OBJECT(tmp->data));
        if (obj == NULL) {
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_SetItem(py_list, i, obj);
    }
    return py_list;
}
%%
override gtk_clipboard_wait_for_targets noargs
static PyObject *
_wrap_gtk_clipboard_wait_for_targets(PyGObject *self)
{
    GtkSelectionData *data;

    /* have to work around GTK+ bug #139883 */
    data = gtk_clipboard_wait_for_contents(GTK_CLIPBOARD(self->obj),
					   gdk_atom_intern("TARGETS", FALSE));

    if (data) {
	gint n_targets = 0;
	GdkAtom *targets = NULL;
    
	if (gtk_selection_data_get_targets(data, &targets, &n_targets)) {
	    PyObject *ret;
	    int i;

	    ret = PyTuple_New(n_targets);
	    for (i = 0; i < n_targets; i++)
		PyTuple_SetItem(ret, i, PyString_FromString(gdk_atom_name(targets[i])));
	    g_free(targets);
	    gtk_selection_data_free(data);
	    return ret;
	}
	gtk_selection_data_free(data);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_clipboard_request_contents kwargs
static void
clipboard_request_contents_cb(GtkClipboard *clipboard,
			      GtkSelectionData *selection_data,
			      gpointer user_data)
{
    PyGILState_STATE state;
    PyObject *callback, *args, *ret;

    state = pyg_gil_state_ensure();
    callback = PyTuple_GetItem((PyObject *)user_data, 0);
    args = Py_BuildValue("(NNO)",
			 pygobject_new((GObject *)clipboard),
			 pyg_boxed_new(GTK_TYPE_SELECTION_DATA,
				       selection_data, TRUE, TRUE),
			 PyTuple_GetItem((PyObject *)user_data, 1));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
	PyErr_Print();
    Py_XDECREF(ret);
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_clipboard_request_contents(PyGObject *self, PyObject *args,
				     PyObject *kwargs)
{
    static char *kwlist[] = { "target", "callback", "user_data", NULL };
    PyObject *py_target, *callback, *data, *user_data = Py_None;
    GdkAtom target;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO|O:GtkClipboard.request_contents",
				     kwlist, &py_target, &callback,
				     &user_data))
        return NULL;
    if (!PyCallable_Check(callback)) {
	PyErr_SetString(PyExc_TypeError, "callback must be callable");
	return NULL;
    }
    target = pygdk_atom_from_pyobject(py_target);
    if (PyErr_Occurred())
        return NULL;

    data = Py_BuildValue("(OO)", callback, user_data);
    gtk_clipboard_request_contents(GTK_CLIPBOARD(self->obj), target,
				   clipboard_request_contents_cb,
				   (gpointer)data);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_clipboard_request_text kwargs
static void
clipboard_request_text_cb(GtkClipboard *clipboard,
			  const gchar *text,
			  gpointer user_data)
{
    PyGILState_STATE state;
    PyObject *callback, *args, *ret, *py_text;

    if (text) {
        py_text = PyString_FromString(text);
    } else {
        py_text = Py_None;
        Py_INCREF(Py_None);
    }

    state = pyg_gil_state_ensure();
    callback = PyTuple_GetItem((PyObject *)user_data, 0);
    args = Py_BuildValue("(NNO)",
			 pygobject_new((GObject *)clipboard),
                         py_text,
			 PyTuple_GetItem((PyObject *)user_data, 1));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
	PyErr_Print();
    Py_XDECREF(ret);
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_clipboard_request_text(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "callback", "user_data", NULL };
    PyObject *callback, *data, *user_data = Py_None;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:GtkClipboard.request_text",
				     kwlist, &callback, &user_data))
        return NULL;
    if (!PyCallable_Check(callback)) {
	PyErr_SetString(PyExc_TypeError, "callback must be callable");
	return NULL;
    }

    data = Py_BuildValue("(OO)", callback, user_data);
    gtk_clipboard_request_text(GTK_CLIPBOARD(self->obj),
			       clipboard_request_text_cb,
			       (gpointer)data);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_clipboard_request_targets kwargs
static void
clipboard_request_targets_cb(GtkClipboard *clipboard,
			     GdkAtom *atoms,
			     gint n_atoms,
			     gpointer user_data)
{
    PyGILState_STATE state;
    PyObject *callback, *args, *ret, *py_atoms;
    int i;

    state = pyg_gil_state_ensure();
    callback = PyTuple_GetItem((PyObject *)user_data, 0);
    if (atoms) {
        py_atoms = PyTuple_New(n_atoms);
        for (i = 0; i < n_atoms; i++)
            PyTuple_SetItem(py_atoms, i, PyString_FromString(gdk_atom_name(atoms[i])));
    } else
        py_atoms = PyTuple_New(0);
    args = Py_BuildValue("(NNO)",
			 pygobject_new((GObject *)clipboard),
			 py_atoms,
			 PyTuple_GetItem((PyObject *)user_data, 1));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
	PyErr_Print();
    Py_XDECREF(ret);
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_clipboard_request_targets(PyGObject *self, PyObject *args,
				     PyObject *kwargs)
{
    static char *kwlist[] = { "callback", "user_data", NULL };
    PyObject *callback, *data, *user_data = Py_None;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:GtkClipboard.request_targets",
				     kwlist, &callback, &user_data))
        return NULL;
    if (!PyCallable_Check(callback)) {
	PyErr_SetString(PyExc_TypeError, "callback must be callable");
	return NULL;
    }

    data = Py_BuildValue("(OO)", callback, user_data);
    gtk_clipboard_request_targets(GTK_CLIPBOARD(self->obj),
				   clipboard_request_targets_cb,
				   (gpointer)data);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_icon_size_lookup_for_settings kwargs
static PyObject *
_wrap_gtk_icon_size_lookup_for_settings(PyGObject *self, PyObject *args,
					PyObject *kwargs)
{
    static char *kwlist[] = { "settings", "icon_size", NULL };
    PyObject *py_settings, *py_icon_size;
    GtkSettings *settings;
    GtkIconSize icon_size;
    gint width, height;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!O:icon_size_lookupfor settings",
                                     kwlist, &PyGtkSettings_Type,
				     &py_settings, &py_icon_size))
        return NULL;

    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_icon_size,
                           (gint *) &icon_size))
        return NULL;

    settings = GTK_SETTINGS(pygobject_get(py_settings));
    if (gtk_icon_size_lookup_for_settings(settings, icon_size,
					  &width, &height))
	return Py_BuildValue("(ii)", width, height);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_icon_theme_set_search_path kwargs
static PyObject *
_wrap_gtk_icon_theme_set_search_path(PyGObject *self, PyObject *args,
				     PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    int i, len;
    PyObject *py_seq;
    gchar **paths;

    if (!PyArg_ParseTupleAndKeywords(args,kwargs,
				     "O:GtkIconTheme.set_search_path",
                                     kwlist, &py_seq))
        return NULL;

    if (!PySequence_Check(py_seq) || (len = PySequence_Size(py_seq)) < 0) {
	PyErr_SetString(PyExc_ValueError,
			"path should be a sequence of strings");
	return NULL;
    }

    paths = g_new(gchar *, len);
    for (i = 0; i < len; i++) {
	PyObject *py_path = PySequence_GetItem(py_seq, i);
	if (!PyString_Check(py_path)) {
	    PyErr_SetString(PyExc_ValueError, "path items must be strings");
	    Py_DECREF(py_path);
	    g_free(paths);
	    return NULL;
	}
	paths[i] = PyString_AsString(py_path);
	Py_DECREF(py_path);
    }

    gtk_icon_theme_set_search_path(GTK_ICON_THEME(self->obj),
				   (const gchar **)paths, len);

    g_free(paths);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_icon_theme_get_search_path noargs
static PyObject *
_wrap_gtk_icon_theme_get_search_path(PyGObject *self)
{
    gchar **paths;
    gint n_items;
    PyObject *py_tuple;
    int i;

    gtk_icon_theme_get_search_path(GTK_ICON_THEME(self->obj),
				   &paths, &n_items);

    py_tuple = PyTuple_New(n_items);
    for (i = 0; i < n_items; i++)
	PyTuple_SetItem(py_tuple, i, PyString_FromString(paths[i]));

    g_strfreev(paths);

    return py_tuple;
}
%%
override gtk_icon_theme_list_icons kwargs
static PyObject *
_wrap_gtk_icon_theme_list_icons(PyGObject *self, PyObject *args,
				PyObject *kwargs)
{
    static char *kwlist[] = { "context", NULL };
    GList *icons;
    gchar *context = NULL;
    int i;
    guint len;
    PyObject *py_icons;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|z:GtkIconTheme.list_icons",
                                     kwlist, &context))
        return NULL;

    icons = gtk_icon_theme_list_icons(GTK_ICON_THEME(self->obj), context);
    len = g_list_length(icons);

    py_icons = PyTuple_New(len);

    for (i = 0; i < len; i++) {
	char *name = (char *)g_list_nth_data(icons, i);

	PyTuple_SetItem(py_icons, i, PyString_FromString(name));
    }
    g_list_foreach(icons, (GFunc)g_free, NULL);
    g_list_free(icons);

    return py_icons;
}
%%
override gtk_icon_info_get_embedded_rect noargs
static PyObject *
_wrap_gtk_icon_info_get_embedded_rect(PyGObject *self)
{
    GdkRectangle rect;
    int ret;

    ret = gtk_icon_info_get_embedded_rect(pyg_boxed_get(self, GtkIconInfo),
					  &rect);

    if (ret)
	return pyg_boxed_new(GDK_TYPE_RECTANGLE, &rect, TRUE, TRUE);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_icon_info_get_attach_points noargs
static PyObject *
_wrap_gtk_icon_info_get_attach_points(PyGObject *self)
{
    GdkPoint *points;
    gint n_points;
    int ret;
    PyObject *py_points;

    ret = gtk_icon_info_get_attach_points(pyg_boxed_get(self, GtkIconInfo),
					  &points, &n_points);
    if (ret) {
	int i;

	py_points = PyTuple_New(n_points);
	for (i = 0; i < n_points; i++)
	    PyTuple_SetItem(py_points, i, Py_BuildValue("(ii)",
							points[i].x,
							points[i].y));
	g_free(points);
	return py_points;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_radio_action_set_group kwargs
static PyObject *
_wrap_gtk_radio_action_set_group(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "group", NULL };
    GSList *list;
    GtkRadioAction *group;
    PyObject *py_group;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!:GtkRadioAction.set_group", kwlist,
				     &PyGtkRadioAction_Type, &py_group))
        return NULL;

    group = GTK_RADIO_ACTION(pygobject_get(py_group));
    list = gtk_radio_action_get_group(group);
    gtk_radio_action_set_group(GTK_RADIO_ACTION(self->obj), list);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_radio_action_get_group noargs
static PyObject *
_wrap_gtk_radio_action_get_group(PyGObject *self) {
    PyObject *py_list;
    GSList *list, *tmp;
    PyObject *gtk_obj;

    list = gtk_radio_action_get_group(GTK_RADIO_ACTION(self->obj));

    if ((py_list = PyList_New(0)) == NULL) {
        return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        gtk_obj = pygobject_new(G_OBJECT(tmp->data));
        if (gtk_obj == NULL) {
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_Append(py_list, gtk_obj);
        Py_DECREF(gtk_obj);
    }
    return py_list;
}
%%
override gtk_radio_tool_button_new kwargs
static int
_wrap_gtk_radio_tool_button_new(PyGObject *self, PyObject *args,
                              PyObject *kwargs)
{
    static char *kwlist[] = { "group", "stock_id", NULL };
    gchar *stock = NULL;
    PyObject *py_widget = Py_None;
    GtkRadioToolButton *widget = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|Oz:GtkRadioToolButton.__init__", kwlist,
                                     &py_widget, &stock))
        return -1;

    if (py_widget != Py_None) {
	if (pygobject_check(py_widget, &PyGtkRadioToolButton_Type))
	    widget = GTK_RADIO_TOOL_BUTTON(pygobject_get(py_widget));
	else {
	    PyErr_SetString(PyExc_TypeError,
			    "first argument must be a GtkRadioToolButton or None");
	    return -1;
	}
    }

    /* various configs for create radio tool buttons ... */
    if (stock == NULL) {
        if (widget == NULL)
            self->obj = g_object_new(pyg_type_from_object((PyObject*) self), NULL);
        else
            self->obj = g_object_new(pyg_type_from_object((PyObject*) self),
                                     "group", widget, NULL);
    } else {
        if (widget == NULL)
            self->obj = g_object_new(pyg_type_from_object((PyObject*) self),
                                     "stock-id", stock, NULL);
        else
            self->obj = g_object_new(pyg_type_from_object((PyObject*) self),
                                     "stock-id", stock, "group", widget, NULL);
    }
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkRadioToolButton object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_radio_tool_button_set_group kwargs
static PyObject *
_wrap_gtk_radio_tool_button_set_group(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "group", NULL };
    GSList *list;
    GtkRadioToolButton *group;
    PyObject *py_group;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!:GtkRadioToolButton.set_group", kwlist,
				     &PyGtkRadioToolButton_Type, &py_group))
        return NULL;

    group = GTK_RADIO_TOOL_BUTTON(pygobject_get(py_group));
    list = gtk_radio_tool_button_get_group(group);
    gtk_radio_tool_button_set_group(GTK_RADIO_TOOL_BUTTON(self->obj), list);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_radio_tool_button_get_group noargs
static PyObject *
_wrap_gtk_radio_tool_button_get_group(PyGObject *self) {
    PyObject *py_list;
    GSList *list, *tmp;
    PyObject *gtk_obj;

    list = gtk_radio_tool_button_get_group(GTK_RADIO_TOOL_BUTTON(self->obj));

    if ((py_list = PyList_New(0)) == NULL) {
        return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        gtk_obj = pygobject_new(G_OBJECT(tmp->data));
        if (gtk_obj == NULL) {
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_Append(py_list, gtk_obj);
        Py_DECREF(gtk_obj);
    }
    return py_list;
}
%%
override gtk_scale_get_layout_offsets noargs
static PyObject *
_wrap_gtk_scale_get_layout_offsets(PyGObject *self)
{
    gint x = 0, y = 0;

    gtk_scale_get_layout_offsets(GTK_SCALE(self->obj), &x, &y);

    return Py_BuildValue("(ii)", x, y);
}
%%
override gtk_toggle_tool_button_new kwargs
static int
_wrap_gtk_toggle_tool_button_new(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "stock_id", NULL };
    char *stock_id = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|z:GtkToggleToolButton.__init__",
				     kwlist, &stock_id))
        return -1;

    if (stock_id)
	self->obj = g_object_new(pyg_type_from_object((PyObject*) self),
                                 "stock-id", stock_id, NULL);
    else
	self->obj = g_object_new(pyg_type_from_object((PyObject*) self), NULL);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkToggleToolButton object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_tool_button_new kwargs
static int
_wrap_gtk_tool_button_new(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist1[] = { "stock_id", NULL };
    static char *kwlist2[] = { "icon_widget", "label", NULL };
    PyGObject *py_icon_widget = NULL;
    GtkWidget *icon_widget = NULL;
    char *label = NULL;
    char *stock_id = NULL;

    if (PyArg_ParseTupleAndKeywords(args, kwargs,
				    "s:GtkToolButton.__init__", kwlist1,
				    &stock_id)) {
	self->obj = g_object_new(pyg_type_from_object((PyObject*) self),
                                 "stock-id", stock_id, NULL);
    } else {
	PyErr_Clear();
	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "|Oz:GtkToolButton.__init__", kwlist2,
					 &py_icon_widget, &label)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "Usage: one of:\n"
			    "  gtk.ToolButton(icon_widget=None, label=None)\n"
			    "  gtk.ToolButton(stock_id)");
	    return -1;
	}

	if (py_icon_widget && (PyObject *)py_icon_widget != Py_None) {
	    if (!pygobject_check(py_icon_widget, &PyGtkWidget_Type)) {
		PyErr_SetString(PyExc_TypeError,
			    "Usage: one of:\n"
			    "  gtk.ToolButton(icon_widget=None, label=None)\n"
			    "  gtk.ToolButton(stock_id)");
		return -1;
	    }
	    icon_widget = GTK_WIDGET(py_icon_widget->obj);
	}
	self->obj = g_object_new(pyg_type_from_object((PyObject*) self),
                                 "icon-widget", icon_widget,
                                 "label", label, NULL);
    }

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkToolButton object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_tooltips_get_info_from_tip_window noargs
static PyObject *
_wrap_gtk_tooltips_get_info_from_tip_window(PyGObject *self)
{
    gboolean ret;
    GtkWidget *widget;
    GtkTooltips *tooltips;

    ret = gtk_tooltips_get_info_from_tip_window(GTK_WINDOW(self->obj),
						&tooltips, &widget);
    if (ret)
	return Py_BuildValue("(NN)",
			     pygobject_new((GObject *)tooltips),
			     pygobject_new((GObject *)widget));
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_menu_item_toggle_size_request noargs
static PyObject *
_wrap_gtk_menu_item_toggle_size_request(PyGObject *self)
{
    gint requisition;

    gtk_menu_item_toggle_size_request(GTK_MENU_ITEM(self->obj), &requisition);

    return PyInt_FromLong(requisition);
}
%%
override gtk_entry_new kwargs
static int
_wrap_gtk_entry_new(PyGObject * self, PyObject * args, PyObject * kwargs)
{
    static char *kwlist[] = { "max", NULL };
    int max = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:GtkEntry.__init__",
                                     kwlist, &max))
	return -1;
    self->obj = g_object_new(pyg_type_from_object((PyObject *)self),
                             "max-length", max, NULL);
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkEntry object");
	return -1;
    }
    pygobject_register_wrapper((PyObject *) self);
    return 0;
}

%%
override gtk_accel_groups_from_object
static PyObject *
_wrap_gtk_accel_groups_from_object(PyGObject *self, PyObject *args)
{
    PyGObject *obj;
    PyObject *py_list;
    GSList *list, *tmp;
    PyObject *item;

    if (!PyArg_ParseTuple(args, "O!:accel_group_from_object",
			  &PyGObject_Type, &obj))
	return NULL;
    
    list = gtk_accel_groups_from_object(G_OBJECT(obj->obj));

    if ((py_list = PyList_New(0)) == NULL) {
        return NULL;
    }
    
    for (tmp = list; tmp; tmp = tmp->next) {
        item = pygobject_new(G_OBJECT(tmp->data));
        if (item == NULL) {
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_Append(py_list, item);
        Py_DECREF(item);
    }
    
    return py_list;
}
%%
override gtk_table_new kwargs
static int
_wrap_gtk_table_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    char *arg_names[] = {"rows", "columns", "homogeneous", NULL };
    int rows = 1, cols = 1;
    PyObject *homogeneous = Py_False;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|iiO:gtk.Table.__init__", arg_names,
                                     &rows, &cols, &homogeneous))
        return -1;
    self->obj = g_object_new(obj_type, "n_rows", rows, "n_columns", cols,
                             "homogeneous", PyObject_IsTrue(homogeneous), NULL);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create gtk.Table object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_pixmap_new kwargs
static int
_wrap_gtk_pixmap_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pixmap", "mask", NULL };
    PyGObject *pixmap, *py_mask;
    GdkPixmap *mask = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!O:GtkPixmap.__init__",
                                     kwlist, &PyGdkPixmap_Type, &pixmap, &py_mask))
        return -1;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkImage") < 0)
        return -1;
    if (py_mask && pygobject_check(py_mask, &PyGdkPixmap_Type))
        mask = GDK_PIXMAP(py_mask->obj);
    else if ((PyObject *)py_mask != Py_None) {
        PyErr_SetString(PyExc_TypeError, "mask should be a GdkPixmap or None");
        return -1;
    }

    self->obj = g_object_new(pyg_type_from_object((PyObject *)self), NULL);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkPixmap object");
        return -1;
    }

    gtk_pixmap_set(GTK_PIXMAP(self->obj), GDK_PIXMAP(pixmap->obj), mask);

    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_plug_new kwargs
static int
_wrap_gtk_plug_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "socket_id", "display", NULL };
    PyObject *py_socket_id = NULL;
    gulong socket_id;
    PyGObject *display = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!|O!:GtkPlug.__init__", kwlist,
                                     &PyLong_Type, &py_socket_id,
                                     &PyGdkDisplay_Type, &display))
        return -1;

    socket_id = PyLong_AsUnsignedLong(py_socket_id);

    self->obj = g_object_new(pyg_type_from_object((PyObject *)self), NULL);

    if (display)
        gtk_plug_construct_for_display(GTK_PLUG(self->obj),
                                       GDK_DISPLAY(display->obj), socket_id);
    else
        gtk_plug_construct(GTK_PLUG(self->obj), socket_id);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkPlug object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_adjustment_new kwargs
static int
_wrap_gtk_adjustment_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    char *kwlist[] = {"value", "lower", "upper", "step_incr",
                      "page_incr", "page_size", NULL };
    gdouble value = 0;
    gdouble lower = 0;
    gdouble upper = 0;
    gdouble step_incr = 0;
    gdouble page_incr = 0;
    gdouble page_size = 0;
    GType obj_type = pyg_type_from_object((PyObject *) self);
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|dddddd:gtk.Adjustment.__init__" ,
                                     kwlist, &value, &lower, &upper, &step_incr,
                                     &page_incr, &page_size))
        return -1;

    self->obj = g_object_new(obj_type, "lower", lower, "upper", upper,
                             "step_increment", step_incr,
                             "page_increment", page_incr,
                             "page_size", page_size,
                             "value", value, NULL);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create gtk.Adjustment object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override-slot GtkMisc.tp_init
static int
_wrap_gtk_misc_tp_init(PyObject *self, PyObject *args, PyObject *kwargs)
{
    return PyGtkWidget_Type.tp_init(self, args, kwargs);
}
%%
override-slot GtkBin.tp_init
static int
_wrap_gtk_bin_tp_init(PyObject *self, PyObject *args, PyObject *kwargs)
{
    return PyGtkContainer_Type.tp_init(self, args, kwargs);
}
%%
override-slot GtkItem.tp_init
static int
_wrap_gtk_item_tp_init(PyObject *self, PyObject *args, PyObject *kwargs)
{
    return PyGtkBin_Type.tp_init(self, args, kwargs);
}
%%
override-slot GtkBox.tp_init
static int
_wrap_gtk_box_tp_init(PyObject *self, PyObject *args, PyObject *kwargs)
{
    return PyGtkContainer_Type.tp_init(self, args, kwargs);
}
%%
override-slot GtkButtonBox.tp_init
static int
_wrap_gtk_button_box_tp_init(PyObject *self, PyObject *args, PyObject *kwargs)
{
    return PyGtkBox_Type.tp_init(self, args, kwargs);
}
%%
override-slot GtkSeparator.tp_init
static int
_wrap_gtk_separator_tp_init(PyObject *self, PyObject *args, PyObject *kwargs)
{
    return PyGtkWidget_Type.tp_init(self, args, kwargs);
}
%%
override gtk_alignment_new kwargs
static int
_wrap_gtk_alignment_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    char *kwlist[] = {"xalign", "yalign", "xscale", "yscale", NULL };
    gdouble xalign = 0;
    gdouble yalign = 0;
    gdouble xscale = 0;
    gdouble yscale = 0;
    GType obj_type = pyg_type_from_object((PyObject *) self);
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|dddd:gtk.Alignment.__init__" ,
                                     kwlist, &xalign, &yalign, &xscale, &yscale))
        return -1;

    self->obj = g_object_new(obj_type,
                             "xalign", xalign, "yalign", yalign,
                             "xscale", xscale, "yscale", yscale, NULL);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create gtk.Alignment object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_about_dialog_set_authors kwargs
static PyObject *
_wrap_gtk_about_dialog_set_authors(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    gchar **authors = NULL;
    static char *kwlist[] = { "authors", NULL };
    PyObject *py_authors = NULL;
    int i, n_authors;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
				     "O:GtkAboutDialog.set_authors",
                                     kwlist, &py_authors))
        return NULL;

    if (!PySequence_Check(py_authors)) {
        PyErr_SetString(PyExc_TypeError, "authors must be a sequence");
        return NULL;
    }

    n_authors = PySequence_Length(py_authors);
    authors = g_new(gchar *, n_authors + 1);
    for (i = 0; i < n_authors; i++) {
        PyObject *item = PySequence_GetItem(py_authors, i);
        Py_DECREF(item); /* PySequence_GetItem INCREF's */
        authors[i] = PyString_AsString(item);
    }
    authors[n_authors] = NULL;

    gtk_about_dialog_set_authors(GTK_ABOUT_DIALOG(self->obj),
                                 (const char **)authors);

    g_free(authors);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_about_dialog_get_authors noargs
static PyObject *
_wrap_gtk_about_dialog_get_authors(PyGObject *self)
{
    gchar **authors, **tmp;
    int i = 0, j;
    PyObject *ret;

    authors = (gchar **)gtk_about_dialog_get_authors(GTK_ABOUT_DIALOG(self->obj));
    if (!authors)
	return PyTuple_New(0);
    
    tmp = authors;
    while (*tmp)
        tmp++, i++;

    ret = PyTuple_New(i);
    for (j = 0; j < i; j++)
        PyTuple_SetItem(ret, j, PyString_FromString(authors[j]));

    return ret;
}
%%
override gtk_about_dialog_set_documenters kwargs
static PyObject *
_wrap_gtk_about_dialog_set_documenters(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    gchar **documenters = NULL;
    static char *kwlist[] = { "documenters", NULL };
    PyObject *py_documenters = NULL;
    int i, n_documenters;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
				     "O:GtkAboutDialog.set_documenters",
                                     kwlist, &py_documenters))
        return NULL;

    if (!PySequence_Check(py_documenters)) {
        PyErr_SetString(PyExc_TypeError, "documenters must be a sequence");
        return NULL;
    }

    n_documenters = PySequence_Length(py_documenters);
    documenters = g_new(gchar *, n_documenters + 1);
    for (i = 0; i < n_documenters; i++) {
        PyObject *item = PySequence_GetItem(py_documenters, i);
        Py_DECREF(item); /* PySequence_GetItem INCREF's */
        documenters[i] = PyString_AsString(item);
    }
    documenters[n_documenters] = NULL;

    gtk_about_dialog_set_documenters(GTK_ABOUT_DIALOG(self->obj),
                                     (const char **)documenters);

    g_free(documenters);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_about_dialog_get_documenters noargs
static PyObject *
_wrap_gtk_about_dialog_get_documenters(PyGObject *self)
{
    gchar **documenters, **tmp;
    int i = 0, j;
    PyObject *ret;

    documenters = (gchar **)gtk_about_dialog_get_documenters(GTK_ABOUT_DIALOG(self->obj));
    if (!documenters)
	return PyTuple_New(0);
    
    tmp = documenters;
    while (*tmp)
        tmp++, i++;

    ret = PyTuple_New(i);
    for (j = 0; j < i; j++)
        PyTuple_SetItem(ret, j, PyString_FromString(documenters[j]));

    return ret;
}
%%
override gtk_about_dialog_set_artists kwargs
static PyObject *
_wrap_gtk_about_dialog_set_artists(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    gchar **artists = NULL;
    static char *kwlist[] = { "artists", NULL };
    PyObject *py_artists = NULL;
    int i, n_artists;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
				     "O:GtkAboutDialog.set_artists",
                                     kwlist, &py_artists))
        return NULL;

    if (!PySequence_Check(py_artists)) {
        PyErr_SetString(PyExc_TypeError, "artists must be a sequence");
        return NULL;
    }

    n_artists = PySequence_Length(py_artists);
    artists = g_new(gchar *, n_artists + 1);
    for (i = 0; i < n_artists; i++) {
        PyObject *item = PySequence_GetItem(py_artists, i);
        Py_DECREF(item); /* PySequence_GetItem INCREF's */
        artists[i] = PyString_AsString(item);
    }
    artists[n_artists] = NULL;

    gtk_about_dialog_set_artists(GTK_ABOUT_DIALOG(self->obj),
                                 (const char **)artists);

    g_free(artists);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_about_dialog_get_artists noargs
static PyObject *
_wrap_gtk_about_dialog_get_artists(PyGObject *self)
{
    gchar **artists, **tmp;
    int i = 0, j;
    PyObject *ret;

    artists = (gchar **)gtk_about_dialog_get_artists(GTK_ABOUT_DIALOG(self->obj));
    if (!artists)
	return PyTuple_New(0);
    
    tmp = artists;
    while (*tmp)
        tmp++, i++;

    ret = PyTuple_New(i);
    for (j = 0; j < i; j++)
        PyTuple_SetItem(ret, j, PyString_FromString(artists[j]));

    return ret;
}
%%
override gtk_selection_data_set_uris kwargs
static PyObject *
_wrap_gtk_selection_data_set_uris(PyGBoxed *self, PyObject *args,
				  PyObject *kwargs)
{
    gchar **uris = NULL;
    static char *kwlist[] = { "uris", NULL };
    PyObject *py_uris = NULL;
    int i, n_uris;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
				     "O:GtkSelectionData.set_uris",
                                     kwlist, &py_uris))
        return NULL;

    if (!PySequence_Check(py_uris)) {
        PyErr_SetString(PyExc_TypeError, "uris must be a sequence");
        return NULL;
    }

    n_uris = PySequence_Length(py_uris);
    uris = g_new(gchar *, n_uris + 1);
    for (i = 0; i < n_uris; i++) {
        PyObject *item = PySequence_GetItem(py_uris, i);
        Py_DECREF(item); /* PySequence_GetItem INCREF's */
        uris[i] = PyString_AsString(item);
    }
    uris[n_uris] = NULL;

    gtk_selection_data_set_uris(pyg_boxed_get(self, GtkSelectionData), uris);

    g_free(uris);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_selection_data_get_uris noargs
static PyObject *
_wrap_gtk_selection_data_get_uris(PyGBoxed *self)
{
    gchar **uris, **tmp;
    int i = 0, j;
    PyObject *ret;

    uris = gtk_selection_data_get_uris(pyg_boxed_get(self, GtkSelectionData));
    if (!uris)
	return PyTuple_New(0);
    
    tmp = uris;
    while (*tmp)
        tmp++, i++;

    ret = PyTuple_New(i);
    for (j = 0; j < i; j++)
        PyTuple_SetItem(ret, j, PyString_FromString(uris[j]));

    return ret;
}
%%
override gtk_drag_source_get_target_list noargs
static PyObject *
_wrap_gtk_drag_source_get_target_list(PyGObject *self)
{
    GtkTargetList *target_list;
    PyObject *ret;
    GList *tmp;

    target_list = gtk_drag_source_get_target_list(GTK_WIDGET(self->obj));

    if (!target_list) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    ret = PyList_New(0);
    for (tmp = target_list->list; tmp != NULL; tmp = tmp->next) {
        GtkTargetPair *pair = tmp->data;
        PyObject *item;

        item = Py_BuildValue("(Nii)",
                             PyString_FromString(gdk_atom_name(pair->target)),
                             pair->flags, pair->info);
        PyList_Append(ret, item);
        Py_DECREF(item);
    }
    return ret;
}
%%
override gtk_drag_source_set_target_list kwargs
static PyObject *
_wrap_gtk_drag_source_set_target_list(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "target_list", NULL };
    PyObject *py_targets;
    gint i, n_targets;
    GtkTargetEntry *targets;
    GtkTargetList *target_list;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkWidget.drag_source_set_target_list",
                                     kwlist, &py_targets))
        return NULL;
    if (!(py_targets = PySequence_Fast(py_targets,
                                       "targets must be a sequence")))
	return NULL;
    n_targets = PySequence_Fast_GET_SIZE(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_Fast_GET_ITEM(py_targets, i);
        if (!PyArg_ParseTuple(item, "sii", &targets[i].target,
                              &targets[i].flags, &targets[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(targets);
	    Py_DECREF(py_targets);
            return NULL;
        }
    }
    target_list = gtk_target_list_new(targets, n_targets);
    g_free(targets);

    gtk_drag_source_set_target_list(GTK_WIDGET(self->obj), target_list);
    gtk_target_list_unref(target_list);
    Py_DECREF(py_targets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_cell_view_set_value kwargs
static PyObject *
_wrap_gtk_cell_view_set_value(PyGObject *self, PyObject *args,
                              PyObject *kwargs)
{
    static char *kwlist[] = { "renderer", "property", "value", NULL };
    PyObject *pyrenderer, *pyvalue;
    GtkCellRenderer *renderer;
    gchar *property;
    GParamSpec *pspec;
    GValue value = { 0 };
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!sO:GtkCellView.set_value",
                                     kwlist,
                                     &PyGtkCellRenderer_Type, &pyrenderer,
                                     &property, &pyvalue))
        return NULL;
 
    renderer = GTK_CELL_RENDERER(pygobject_get(pyrenderer));
    pspec = g_object_class_find_property(G_OBJECT_GET_CLASS(renderer),
                                         property);
    if (!pspec) {
         PyErr_Format(PyExc_TypeError,
                      "property %s is not defined for the renderer",
                      property);
        return NULL;
    }
    g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));
    if (pyg_value_from_pyobject(&value, pyvalue)) {
        PyErr_Format(PyExc_TypeError,
                     "value is of the wrong type for property %s",
                     property);
        return NULL;
    }
    gtk_cell_view_set_value(GTK_CELL_VIEW(self->obj), renderer,
                            property, &value);
    g_value_unset(&value);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_cell_view_set_values kwargs
static PyObject *
_wrap_gtk_cell_view_set_values(PyGObject *self, PyObject *args,
                               PyObject *kwargs)
{
    PyObject *pyrenderer, *key, *item;
    GtkCellRenderer *renderer;
    GtkCellView *view;
    gchar *property;
    GParamSpec *pspec;
    GValue value = { 0 };
    gint i = 0;

    if (!PyArg_ParseTuple(args, "O!:GtkCellView.set_values",
                          &PyGtkCellRenderer_Type, &pyrenderer))
        return NULL;

    if (!kwargs) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    view = GTK_CELL_VIEW(self->obj);
    renderer = GTK_CELL_RENDERER(pygobject_get(pyrenderer));
    while (PyDict_Next(kwargs, &i, &key, &item)) {
        property = PyString_AsString(key);
        pspec = g_object_class_find_property(G_OBJECT_GET_CLASS(renderer),
                                             property);
        if (!pspec) {
            PyErr_Format(PyExc_TypeError,
                         "property %s is not defined for the renderer",
                         property);
            return NULL;
        }
        g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));
        if (pyg_value_from_pyobject(&value, item)) {
            PyErr_Format(PyExc_TypeError,
                         "value is of the wrong type for property %s",
                         property);
            return NULL;
        }
        gtk_cell_view_set_value(view, renderer, property, &value);
        g_value_unset(&value);
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_cell_view_get_cell_renderers noargs
static PyObject *
_wrap_gtk_cell_view_get_cell_renderers(PyGObject *self)
{
    GList *cell_list;
    PyObject *py_cell_list, *py_cell;
    GtkCellRenderer *cell;
    guint len;
    int i;

    cell_list = gtk_cell_view_get_cell_renderers(GTK_CELL_VIEW(self->obj));
    len = g_list_length(cell_list);
    py_cell_list = PyList_New(len);
    for (i = 0; i < len; i++) {
        cell = GTK_CELL_RENDERER(g_list_nth_data(cell_list, i));
        if (!cell || !(py_cell = pygobject_new(G_OBJECT(cell)))) {
            g_list_free(cell_list);
            Py_DECREF(py_cell_list);
            return NULL;
        }
        PyList_SetItem(py_cell_list, i, py_cell);
    }
    g_list_free(cell_list);
    return py_cell_list;
}
%%
override gtk_cell_view_get_size_of_row kwargs
static PyObject *
_wrap_gtk_cell_view_get_size_of_row(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    PyObject *py_path;
    GtkTreePath *path;
    GtkRequisition requisition;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkCellView.get_size_of_row",
                                     kwlist, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError,
                        "could not convert path to a GtkTreePath");
        return NULL;
    }
    gtk_cell_view_get_size_of_row(GTK_CELL_VIEW(self->obj), path,
                                  &requisition);
    gtk_tree_path_free(path);
    return pyg_boxed_new(GTK_TYPE_REQUISITION, &requisition, TRUE, TRUE);
}
%%
override gtk_clipboard_set_can_store kwargs
static PyObject *
_wrap_gtk_clipboard_set_can_store(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    static char *kwlist[] = { "targets", NULL };
    GtkTargetEntry *targets;
    PyObject *py_targets;
    gint n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkClipboard.set_can_store",
                                     kwlist, &py_targets))
        return NULL;
    if (py_targets == Py_None) {
        targets = NULL;
        n_targets = 0;
    } else {
        if (!(py_targets = PySequence_Fast(py_targets,
                                       "targets must be a sequence")))
            return NULL;
        n_targets = PySequence_Fast_GET_SIZE(py_targets);
        targets = g_new(GtkTargetEntry, n_targets);
        for (i = 0; i < n_targets; i++) {
            PyObject *item = PySequence_Fast_GET_ITEM(py_targets, i);
            if (!PyArg_ParseTuple(item, "sii", &targets[i].target,
                                  &targets[i].flags, &targets[i].info)) {
                PyErr_Clear();
                PyErr_SetString(PyExc_TypeError,
                                "list items should be of form (string,int,int)");
                g_free(targets);
                Py_DECREF(py_targets);
                return NULL;
            }
        }
        Py_DECREF(py_targets);
    }
    gtk_clipboard_set_can_store(GTK_CLIPBOARD(self->obj), targets, n_targets);
    g_free(targets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_combo_box_set_row_separator_func args
static gboolean
pygtk_combo_box_row_separator_func_cb(GtkTreeModel *model,
				      GtkTreeIter *iter,
				      gpointer user_data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = user_data;
    PyObject *py_model, *py_iter;
    gboolean ret = FALSE;
    PyObject *retobj;
 
    g_assert(cunote->func);

    state = pyg_gil_state_ensure();
 
    py_model = pygobject_new((GObject *)model);
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, TRUE, TRUE);

    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(NNO)", py_model,
                                     py_iter, cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(NN)", py_model, py_iter);
    }

    if (retobj != NULL) {
	ret = PyObject_IsTrue(retobj);
        Py_DECREF(retobj);
    } else {
	PyErr_Print();
    }
 
    pyg_gil_state_release(state);
    return ret;
}
static PyObject *
_wrap_gtk_combo_box_set_row_separator_func(PyGObject *self, PyObject *args)
{
    PyObject *pyfunc = NULL, *pyarg = NULL;
    PyGtkCustomNotify *cunote;
 
    if (!PyArg_ParseTuple(args,
                          "|OO:GtkComboBox.set_row_separator_func",
                          &pyfunc, &pyarg))
        return NULL;

    if (pyfunc == NULL || pyfunc == Py_None) {
        gtk_combo_box_set_row_separator_func(GTK_COMBO_BOX(self->obj),
                                             NULL, NULL, NULL);
    } else if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object");
        return NULL;
    } else {
        cunote = g_new0(PyGtkCustomNotify, 1);
        cunote->func = pyfunc;
        cunote->data = pyarg;
        Py_INCREF(cunote->func);
        Py_XINCREF(cunote->data);

        gtk_combo_box_set_row_separator_func(
            GTK_COMBO_BOX(self->obj),
            pygtk_combo_box_row_separator_func_cb,
            cunote,
            pygtk_custom_destroy_notify);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_file_chooser_button_new kwargs
static int
_wrap_gtk_file_chooser_button_new(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist1[] = { "title", "backend", NULL };
    static char *kwlist2[] = { "dialog", NULL };
    gchar *title, *backend = NULL;
    PyGObject *dialog;
 
    if (PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s|z:GtkFileChooserButton.__init__",
				     kwlist1, &title, &backend))
        self->obj = g_object_new(pyg_type_from_object((PyObject*) self),
                                 "title", title,
                                 "file-system-backend", backend,
                                 NULL);
    else {
        PyErr_Clear();
	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "O!:GtkFileChooserButton.__init__",
                                         kwlist2, &PyGtkFileChooserDialog_Type,
					 &dialog)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "Usage: one of:\n"
			    "  gtk.FileChooserButton(title, backend=None)\n"
			    "  gtk.FileChooserButton(filechooserdialog)");
	    return -1;
	}
        self->obj = g_object_new(pyg_type_from_object((PyObject*) self),
                                 "dialog", GTK_WIDGET(dialog->obj), NULL);
    }
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkFileChooserBUtton object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_icon_theme_get_icon_sizes kwargs
static PyObject *
_wrap_gtk_icon_theme_get_icon_sizes(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "icon_name", NULL };
    const gchar *icon_name;
    gint *sizes;
    int i;
    PyObject *py_sizes;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s:GtkIconTheme.get_icon_sizes",
				     kwlist, &icon_name))
        return NULL;

    sizes = gtk_icon_theme_get_icon_sizes(GTK_ICON_THEME(self->obj),
                                          icon_name);

    for (i = 0; sizes[i] != 0; i++) ;

    if ((py_sizes = PyTuple_New(i)) == NULL) {
        g_free(sizes);
        return NULL;
    }
    for (i = 0; sizes[i] != 0; i++)
        PyTuple_SET_ITEM(py_sizes, i, PyInt_FromLong(sizes[i]));

    g_free(sizes);
    return py_sizes;
}
%%
override gtk_icon_view_new kwargs
static int
_wrap_gtk_icon_view_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "model", NULL };
    PyGObject *pymodel = NULL;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:GtkIconView.__init__",
				     kwlist, &pymodel))
        return -1;
    if (pymodel == NULL || (PyObject *)pymodel == Py_None)
	self->obj = g_object_new(pyg_type_from_object((PyObject*) self), NULL);
    else if (pygobject_check(pymodel, &PyGtkTreeModel_Type))
	self->obj = g_object_new(pyg_type_from_object((PyObject*) self),
                                 "model", GTK_TREE_MODEL(pymodel->obj), NULL);
    else {
	PyErr_SetString(PyExc_TypeError,
			"model must be a gtk.TreeModel or None");
	return -1;
    }
 
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkIconView object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_icon_view_get_selected_items noargs
static PyObject *
_wrap_gtk_icon_view_get_selected_items(PyGObject *self)
{
    GList *paths;
    PyObject *py_paths;
    int plen, i;

    paths = gtk_icon_view_get_selected_items(GTK_ICON_VIEW(self->obj));

    plen = g_list_length(paths);
    if ((py_paths = PyList_New(plen)) == NULL)
        return NULL;
    for (i = 0; i < plen; i++) {
        GtkTreePath *path = (GtkTreePath *)g_list_nth_data(paths, i);
        PyObject *pypath = pygtk_tree_path_to_pyobject(path);
        PyList_SET_ITEM(py_paths, i, pypath);
    }
    g_list_foreach(paths, (GFunc)gtk_tree_path_free, NULL);
    g_list_free(paths);
    return py_paths;
}
%%
override gtk_icon_view_selected_foreach kwargs
static void
pygtk_icon_view_selected_foreach_cb(GtkIconView *iconview,
                                    GtkTreePath *path,
                                    gpointer user_data)
{
    PyGILState_STATE state;
    PyObject *callback, *args, *ret;
 
    state = pyg_gil_state_ensure();
    callback = PyTuple_GetItem((PyObject *)user_data, 0);
    args = Py_BuildValue("(NNO)",
                         pygobject_new((GObject *)iconview),
                         pygtk_tree_path_to_pyobject(path),
                         PyTuple_GetItem((PyObject *)user_data, 1));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
        PyErr_Print();
    Py_XDECREF(ret);
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_icon_view_selected_foreach(PyGObject *self, PyObject *args,
                                     PyObject *kwargs)
{
    static char *kwlist[] = { "func", "data",  NULL };
    PyObject *func, *data, *py_data = Py_None;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:GtkIconView.foreach",
                                     kwlist, &func, &py_data)) {
        return NULL;
    }
    if (!PyCallable_Check(func)) {
        PyErr_SetString(PyExc_TypeError, "func must be callable");
        return NULL;
    }
 
    data = Py_BuildValue("(OO)", func, py_data);
     
    gtk_icon_view_selected_foreach(GTK_ICON_VIEW(self->obj),
                                   pygtk_icon_view_selected_foreach_cb,
                                   (gpointer)data);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_image_get_icon_name noargs
static PyObject *
_wrap_gtk_image_get_icon_name(PyGObject *self)
{
    gchar *icon_name = NULL;
    GtkIconSize size = GTK_ICON_SIZE_INVALID;

    gtk_image_get_icon_name(GTK_IMAGE(self->obj),
                            (G_CONST_RETURN gchar **)&icon_name, &size);

    return Py_BuildValue("(sN)", icon_name,
                         pyg_enum_from_gtype(GTK_TYPE_ICON_SIZE, size));
}
%%
override gtk_menu_tool_button_new kwargs
static int
_wrap_gtk_menu_tool_button_new(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist1[] = { "stock_id", NULL };
    static char *kwlist2[] = { "icon_widget", "label", NULL };
    gchar *stock_id, *label;
    PyObject *py_icon_widget;
    GtkWidget *icon_widget = NULL;
 
    if (PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s:GtkMenuToolButton.__init__",
				     kwlist1, &stock_id))
        self->obj = g_object_new(pyg_type_from_object((PyObject*) self),
                                 "stock-id", stock_id,
                                 NULL);
    else {
        PyErr_Clear();
	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "Oz:GtkFileChooserButton.__init__",
                                         kwlist2, &py_icon_widget, &label)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "Usage: one of:\n"
			    "  gtk.MenuToolButton(stock_id)\n"
			    "  gtk.MenuToolButton(icon_widget, label)");
	    return -1;
	}
        if (py_icon_widget != Py_None) {
            if (pygobject_check(py_icon_widget, &PyGtkWidget_Type)) {
                icon_widget = GTK_WIDGET(pygobject_get(py_icon_widget));
            } else {
                PyErr_SetString(PyExc_TypeError,
                                "icon_widget must be a GtkWidget type or None");
                return -1;
            }
        }
        self->obj = g_object_new(pyg_type_from_object((PyObject*) self),
                                 "icon-widget", icon_widget,
                                 "label", label,
                                 NULL);
    }
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkMenuToolButton object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_message_dialog_format_secondary_text kwargs
static PyObject *
_wrap_gtk_message_dialog_format_secondary_text(PyGObject *self, PyObject *args,
                                               PyObject *kwargs)
{
    static char *kwlist[] = { "message_format", NULL };
    gchar *message_format = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|z:GtkMessageDialog.format_secondary_text",
                                     kwlist, &message_format))
        return NULL;

    if (message_format)
        gtk_message_dialog_format_secondary_text(GTK_MESSAGE_DIALOG(self->obj),
                                                 "%s", message_format);
    else
        gtk_message_dialog_format_secondary_text(GTK_MESSAGE_DIALOG(self->obj),
                                                 message_format);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_message_dialog_format_secondary_markup kwargs
static PyObject *
_wrap_gtk_message_dialog_format_secondary_markup(PyGObject *self, PyObject *args,
                                               PyObject *kwargs)
{
    static char *kwlist[] = { "message_format", NULL };
    gchar *message_format = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|z:GtkMessageDialog.format_secondary_markup",
                                     kwlist, &message_format))
        return NULL;

    if (message_format)
        gtk_message_dialog_format_secondary_markup(GTK_MESSAGE_DIALOG(self->obj),
                                                   "%s", message_format);
    else
        gtk_message_dialog_format_secondary_markup(GTK_MESSAGE_DIALOG(self->obj),
                                                   message_format);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_target_list_add_text_targets kwargs
static PyObject *
_wrap_gtk_target_list_add_text_targets(PyGObject *self, PyObject *args,
                                       PyObject *kwargs)
{
    static char *kwlist[] = { "list", "info", NULL };
    PyObject *list = NULL;
    guint info = 0;
    GtkTargetList *targets;
    GList *tmp;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|Oi:gtk.target_list_add_text_targets",
                                     kwlist, &list, &info)) {
        return NULL;
    }
    if (!list || list == Py_None) {
        list = NULL;
    } else if (!PySequence_Check(list)) {
        PyErr_SetString(PyExc_TypeError,
                        "list must be a sequence of target entries or None");
        return NULL;
    }
    if (list)
        list = PySequence_List(list);
    else
        list = PyList_New(0);
    targets = gtk_target_list_new(NULL, 0);
    gtk_target_list_add_text_targets(targets, info);
    for (tmp = targets->list; tmp != NULL; tmp = tmp->next) {
        GtkTargetPair *pair = tmp->data;
        PyObject *item;
 
        item = Py_BuildValue("(Nii)",
                             PyString_FromString(gdk_atom_name(pair->target)),
                             pair->flags, pair->info);
        PyList_Append(list, item);
        Py_DECREF(item);
    }
    gtk_target_list_unref(targets);
    return list;
}
%%
override gtk_target_list_add_image_targets kwargs
static PyObject *
_wrap_gtk_target_list_add_image_targets(PyGObject *self, PyObject *args,
                                       PyObject *kwargs)
{
    static char *kwlist[] = { "list", "info", "writable", NULL };
    PyObject *list = NULL;
    guint info = 0;
    gboolean writable = FALSE;
    GtkTargetList *targets;
    GList *tmp;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|Oii:gtk.target_list_add_text_targets",
                                     kwlist, &list, &info, &writable)) {
        return NULL;
    }
    if (!list || list == Py_None) {
        list = NULL;
    } else if (!PySequence_Check(list)) {
        PyErr_SetString(PyExc_TypeError,
                        "list must be a sequence of target entries or None");
        return NULL;
    }
    if (list)
        list = PySequence_List(list);
    else
        list = PyList_New(0);
    targets = gtk_target_list_new(NULL, 0);
    gtk_target_list_add_image_targets(targets, info, writable);
    for (tmp = targets->list; tmp != NULL; tmp = tmp->next) {
        GtkTargetPair *pair = tmp->data;
        PyObject *item;
 
        item = Py_BuildValue("(Nii)",
                             PyString_FromString(gdk_atom_name(pair->target)),
                             pair->flags, pair->info);
        PyList_Append(list, item);
        Py_DECREF(item);
    }
    gtk_target_list_unref(targets);
    return list;
}
%%
override gtk_target_list_add_uri_targets kwargs
static PyObject *
_wrap_gtk_target_list_add_uri_targets(PyGObject *self, PyObject *args,
                                      PyObject *kwargs)
{
    static char *kwlist[] = { "list", "info", NULL };
    PyObject *list = NULL;
    guint info = 0;
    GtkTargetList *targets;
    GList *tmp;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|Oi:gtk.target_list_add_text_targets",
                                     kwlist, &list, &info)) {
        return NULL;
    }
    if (!list || list == Py_None) {
        list = NULL;
    } else if (!PySequence_Check(list)) {
        PyErr_SetString(PyExc_TypeError,
                        "list must be a sequence of target entries or None");
        return NULL;
    }
    if (list)
        list = PySequence_List(list);
    else
        list = PyList_New(0);
    targets = gtk_target_list_new(NULL, 0);
    gtk_target_list_add_uri_targets(targets, info);
    for (tmp = targets->list; tmp != NULL; tmp = tmp->next) {
        GtkTargetPair *pair = tmp->data;
        PyObject *item;
 
        item = Py_BuildValue("(Nii)",
                             PyString_FromString(gdk_atom_name(pair->target)),
                             pair->flags, pair->info);
        PyList_Append(list, item);
        Py_DECREF(item);
    }
    gtk_target_list_unref(targets);
    return list;
}
%%
override gtk_about_dialog_set_email_hook kwargs
static void
pygtk_about_dialog_link_hook_marshal(GtkAboutDialog *about,
                                         const gchar *link,
                                         gpointer user_data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = user_data;
    PyObject *py_about, *retobj;
 
    g_assert(cunote->func);

    state = pyg_gil_state_ensure();
 
    py_about = pygobject_new((GObject *)about);

    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(NsO)", py_about,
                                     link, cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(Ns)", py_about, link);
    }

    if (!retobj)
	PyErr_Print();
 
    Py_XDECREF(retobj);
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_about_dialog_set_email_hook(PyGObject *self, PyObject *args,
                                      PyObject *kwargs)
{
    static char *kwlist[] = { "func", "data", NULL };
    PyObject *pyfunc = NULL, *pyarg = NULL;
    PyGtkCustomNotify *cunote;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|OO:GtkAboutDialog.set_email_hook",
                                     kwlist, &pyfunc, &pyarg))
        return NULL;

    if (pyfunc == NULL || pyfunc == Py_None) {
        gtk_about_dialog_set_email_hook(NULL, NULL, NULL);
    } else if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object");
        return NULL;
    } else {
        cunote = g_new0(PyGtkCustomNotify, 1);
        cunote->func = pyfunc;
        cunote->data = pyarg;
        Py_INCREF(cunote->func);
        Py_XINCREF(cunote->data);

        gtk_about_dialog_set_email_hook(
            pygtk_about_dialog_link_hook_marshal,
            cunote,
            pygtk_custom_destroy_notify);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_about_dialog_set_url_hook kwargs
static PyObject *
_wrap_gtk_about_dialog_set_url_hook(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "func", "data", NULL};
    PyObject *pyfunc = NULL, *pyarg = NULL;
    PyGtkCustomNotify *cunote;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|OO:GtkAboutDialog.set_url_hook",
                                     kwlist, &pyfunc, &pyarg))
        return NULL;

    if (pyfunc == NULL || pyfunc == Py_None) {
        gtk_about_dialog_set_url_hook(NULL, NULL, NULL);
    } else if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object");
        return NULL;
    } else {
        cunote = g_new0(PyGtkCustomNotify, 1);
        cunote->func = pyfunc;
        cunote->data = pyarg;
        Py_INCREF(cunote->func);
        Py_XINCREF(cunote->data);

        gtk_about_dialog_set_url_hook(
            pygtk_about_dialog_link_hook_marshal,
            cunote,
            pygtk_custom_destroy_notify);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override GtkCellRenderer__proxy_do_get_size
static void
_wrap_GtkCellRenderer__proxy_do_get_size (GtkCellRenderer *cell,
                                          GtkWidget       *widget,
                                          GdkRectangle    *cell_area,
                                          gint            *x_offset,
                                          gint            *y_offset,
                                          gint            *width,
                                          gint            *height)
{
    PyGILState_STATE state;
    PyObject *self, *py_ret, *py_widget, *py_cell_area;
    gint my_x, my_y, my_width, my_height;

    state = pyg_gil_state_ensure();
    self = pygobject_new((GObject *)cell);
    py_widget = pygobject_new((GObject *)widget);
    py_cell_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, cell_area, TRUE, TRUE);

    py_ret = PyObject_CallMethod(self, "do_get_size", "OO",
				 py_widget, py_cell_area);
    if (!py_ret) {
	PyErr_Print();
	Py_DECREF(py_widget);
	Py_DECREF(py_cell_area);
	pyg_gil_state_release(state);
	return;
    }
    Py_DECREF(py_widget);
    Py_DECREF(py_cell_area);

    if (!PyArg_ParseTuple(py_ret, "iiii",
			  &my_x, &my_y, &my_width, &my_height)) {
	PyErr_Print();
	Py_DECREF(py_ret);
	pyg_gil_state_release(state);
	return;
    }

    pyg_gil_state_release(state);

    /* success */
    if (x_offset)
	*x_offset = my_x;
    if (y_offset)
	*y_offset = my_y;
    if (width)
	*width = my_width;
    if (height)
	*height = my_height;
}

%%
override GtkCellLayout__proxy_do_set_cell_data_func

typedef struct {
    GtkCellLayoutDataFunc  func;
    gpointer               func_data;
    GDestroyNotify         destroy;
} PyGtkCellLayoutDataFuncData;

static void
_wrap_GtkCellLayoutDataFunc_destroy(void *arg)
{
    PyGtkCellLayoutDataFuncData *data = arg;
    data->destroy(data->func_data);
    g_free(data);
}

static PyObject *
_wrap_GtkCellLayoutDataFunc(PyObject *self, PyObject *args)
{
    PyObject *py_cell_layout;
    PyObject *py_cell;
    PyObject *py_tree_model;
    PyObject *py_iter;
    PyObject *py_data;
    PyGtkCellLayoutDataFuncData *data;

    if (!PyArg_ParseTuple(args, "O!O!O!OO!",
                          &PyGtkCellLayout_Type, &py_cell_layout,
                          &PyGtkCellRenderer_Type, &py_cell,
                          &PyGtkTreeModel_Type, &py_tree_model,
                          &py_iter,
                          &PyCObject_Type, &py_data))
        return NULL;
    if (!pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER)) {
        PyErr_SetString(PyExc_TypeError, "4th argument must be a gtk.TreeIter");
        return NULL;
    }

    data = PyCObject_AsVoidPtr(py_data);
    data->func(GTK_CELL_LAYOUT(pygobject_get(py_cell_layout)),
               GTK_CELL_RENDERER(pygobject_get(py_cell)),
               GTK_TREE_MODEL(pygobject_get(py_tree_model)),
               pyg_boxed_get(py_iter, GtkTreeIter),
               data->func_data);
    Py_INCREF(Py_None);
    return Py_None;
}

static void
_wrap_GtkCellLayout__proxy_do_set_cell_data_func (
    GtkCellLayout         *cell_layout,
    GtkCellRenderer       *cell,
    GtkCellLayoutDataFunc  func,
    gpointer               func_data,
    GDestroyNotify         destroy)
{
    PyGILState_STATE state;
    PyObject *self, *py_ret, *py_cell, *py_func, *py_func_data;
    PyMethodDef pyfunc_def = { NULL, (PyCFunction)_wrap_GtkCellLayoutDataFunc,
                               METH_VARARGS|METH_KEYWORDS };
    PyGtkCellLayoutDataFuncData *data;

    state = pyg_gil_state_ensure();
    self = pygobject_new((GObject *)cell);
    py_cell = pygobject_new((GObject *)cell);
    py_func = PyCFunction_NewEx(&pyfunc_def, NULL, NULL);
    data = g_new(PyGtkCellLayoutDataFuncData, 1);
    data->func = func;
    data->func_data = func_data;
    data->destroy = destroy;
    py_func_data = PyCObject_FromVoidPtr(data, _wrap_GtkCellLayoutDataFunc_destroy);

    py_ret = PyObject_CallMethod(self, "do_set_cell_data_func", "NNNN",
                                 self, py_cell, py_func, py_func_data);
    if (!py_ret)
	PyErr_Print();
    pyg_gil_state_release(state);
}

