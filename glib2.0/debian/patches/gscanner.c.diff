--- glib-2.6.2/glib/gscanner.c	2004-09-16 09:05:53.000000000 +0300
+++ glib-2.6.2/glib/gscanner.c	2005-08-05 11:57:37.000000000 +0300
@@ -233,6 +233,12 @@
   scanner->scope_id = 0;
   
   scanner->msg_handler = g_scanner_msg_handler;
+
+  scanner->cache_fd = -1;
+  scanner->cache_size = 0;
+  scanner->cache_base = NULL;
+  scanner->cache_p = NULL;
+  scanner->cache_flags = 0;
   
   return scanner;
 }
@@ -269,6 +275,11 @@
   g_free (key);
 }
 
+#include <sys/mman.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
 void
 g_scanner_destroy (GScanner	*scanner)
 {
@@ -278,8 +289,17 @@
   g_hash_table_foreach (scanner->symbol_table, 
 			g_scanner_destroy_symbol_table_entry, NULL);
   g_hash_table_destroy (scanner->symbol_table);
-  g_scanner_free_value (&scanner->token, &scanner->value);
-  g_scanner_free_value (&scanner->next_token, &scanner->next_value);
+  if (scanner->cache_base != NULL)
+    {
+      munmap (scanner->cache_base, scanner->cache_size);
+    }
+  else
+    {
+      g_scanner_free_value (&scanner->token, &scanner->value);
+      g_scanner_free_value (&scanner->next_token, &scanner->next_value);
+    }
+  if (scanner->cache_fd != -1)
+    close (scanner->cache_fd);
   g_free (scanner->config);
   g_free (scanner->buffer);
   g_free (scanner);
@@ -554,6 +574,91 @@
   g_hash_table_foreach (scanner->symbol_table, g_scanner_foreach_internal, d);
 }
 
+static gboolean
+g_scanner_get_token_cache (GScanner     *scanner,
+			   GTokenType	*token_p,
+			   GTokenValue	*value_p,
+			   guint	*line_p,
+			   guint	*position_p)
+{
+  int len;
+
+  if (scanner->cache_p == NULL)
+    return FALSE;
+
+  if (scanner->cache_p == scanner->cache_end)
+    {
+      *token_p = G_TOKEN_EOF;
+      return TRUE;
+    }
+
+#define ENSURE_AVAILABLE(scanner, bytes)			\
+  if (scanner->cache_p + (bytes) > scanner->cache_end)	\
+    goto eof
+
+  ENSURE_AVAILABLE(scanner, sizeof(GTokenType));
+
+  *token_p = *(GTokenType *)scanner->cache_p;
+  scanner->cache_p += sizeof(GTokenType);
+
+  switch (*token_p)
+    {
+    case G_TOKEN_STRING:
+    case G_TOKEN_IDENTIFIER:
+    case G_TOKEN_IDENTIFIER_NULL:
+    case G_TOKEN_COMMENT_SINGLE:
+    case G_TOKEN_COMMENT_MULTI:
+      ENSURE_AVAILABLE(scanner, sizeof(int));
+
+      len = *(int *)scanner->cache_p;
+      scanner->cache_p += sizeof(int);
+
+      ENSURE_AVAILABLE(scanner, len);
+
+      value_p->v_string = (char*)scanner->cache_p;
+      scanner->cache_p += len;
+      break;
+
+    case G_TOKEN_ERROR:
+    case G_TOKEN_EOF:
+      break;
+
+    case G_TOKEN_LEFT_PAREN:
+    case G_TOKEN_RIGHT_PAREN:
+    case G_TOKEN_LEFT_CURLY:
+    case G_TOKEN_RIGHT_CURLY:
+    case G_TOKEN_LEFT_BRACE:
+    case G_TOKEN_RIGHT_BRACE:
+    case G_TOKEN_EQUAL_SIGN:
+    case G_TOKEN_COMMA:
+      value_p->v_int64 = *token_p;
+      break;
+
+    default:
+      if (*token_p < G_TOKEN_LAST)
+	{
+	  ENSURE_AVAILABLE(scanner, sizeof(GTokenValue));
+
+/*	  *value_p = *(GTokenValue *)scanner->cache_p;*/
+          memcpy(value_p, scanner->cache_p, sizeof(GTokenValue));
+	  scanner->cache_p += sizeof(GTokenValue);
+	}
+      else
+	value_p->v_int64 = 0;
+
+      break;
+    }
+
+  return TRUE;
+
+eof:
+  *token_p = G_TOKEN_ERROR;
+  value_p->v_error = G_ERR_UNEXP_EOF;
+  return TRUE;
+
+#undef ENSURE_AVAILABLE
+}
+
 GTokenType
 g_scanner_peek_next_token (GScanner	*scanner)
 {
@@ -563,16 +668,79 @@
     {
       scanner->next_line = scanner->line;
       scanner->next_position = scanner->position;
-      g_scanner_get_token_i (scanner,
-			     &scanner->next_token,
-			     &scanner->next_value,
-			     &scanner->next_line,
-			     &scanner->next_position);
+      if (!g_scanner_get_token_cache (scanner,
+				      &scanner->next_token,
+				      &scanner->next_value,
+				      &scanner->next_line,
+				      &scanner->next_position))
+	g_scanner_get_token_i (scanner,
+			       &scanner->next_token,
+			       &scanner->next_value,
+			       &scanner->next_line,
+			       &scanner->next_position);
     }
   
   return scanner->next_token;
 }
 
+static void
+g_scanner_cache_token (GScanner *scanner)
+{
+  int len;
+  int lena;
+
+  if (scanner->cache_fd == -1 || scanner->cache_p != NULL)
+    return;
+
+  g_assert (scanner->token != G_TOKEN_ERROR);
+
+  /* FIXME: error handling */
+
+  write (scanner->cache_fd, &scanner->token, sizeof(scanner->token));
+
+  switch (scanner->token)
+    {
+    case G_TOKEN_STRING:
+    case G_TOKEN_IDENTIFIER:
+    case G_TOKEN_IDENTIFIER_NULL:
+    case G_TOKEN_COMMENT_SINGLE:
+    case G_TOKEN_COMMENT_MULTI:
+      /* pad strings to multiple of G_MEM_ALIGN */
+      lena = len = strlen (scanner->value.v_string) + 1;
+      if (lena % G_MEM_ALIGN)
+	lena += G_MEM_ALIGN - (lena % G_MEM_ALIGN);
+
+      write (scanner->cache_fd, &lena, sizeof(lena));
+      write (scanner->cache_fd, scanner->value.v_string, len);
+      if (lena > len)
+	write (scanner->cache_fd, "\0\0\0\0\0\0\0\0", lena-len);
+      break;
+
+    case G_TOKEN_EOF:
+      close (scanner->cache_fd);
+      scanner->cache_fd = -1;
+      break;
+
+    case G_TOKEN_LEFT_PAREN:
+    case G_TOKEN_RIGHT_PAREN:
+    case G_TOKEN_LEFT_CURLY:
+    case G_TOKEN_RIGHT_CURLY:
+    case G_TOKEN_LEFT_BRACE:
+    case G_TOKEN_RIGHT_BRACE:
+    case G_TOKEN_EQUAL_SIGN:
+    case G_TOKEN_COMMA:
+      break;
+
+    default:
+      /* FIXME: check alignment requirements (double probably needs 8 bytes) */
+      if (scanner->token < G_TOKEN_LAST)
+	write (scanner->cache_fd, &scanner->value, sizeof(scanner->value));
+      else
+	g_assert (scanner->token == scanner->value.v_int);
+      break;
+    }
+}
+
 GTokenType
 g_scanner_get_next_token (GScanner	*scanner)
 {
@@ -580,7 +748,8 @@
   
   if (scanner->next_token != G_TOKEN_NONE)
     {
-      g_scanner_free_value (&scanner->token, &scanner->value);
+      if (scanner->cache_p == NULL)
+	g_scanner_free_value (&scanner->token, &scanner->value);
       
       scanner->token = scanner->next_token;
       scanner->value = scanner->next_value;
@@ -588,12 +757,23 @@
       scanner->position = scanner->next_position;
       scanner->next_token = G_TOKEN_NONE;
     }
+  else if (g_scanner_get_token_cache (scanner,
+				      &scanner->token,
+				      &scanner->value,
+				      &scanner->line,
+				      &scanner->position))
+    {
+      return scanner->token;
+    }
   else
     g_scanner_get_token_i (scanner,
 			   &scanner->token,
 			   &scanner->value,
 			   &scanner->line,
 			   &scanner->position);
+
+  if(scanner->cache_flags & CACHE_FLAGS_WRITE)
+    g_scanner_cache_token (scanner);
   
   return scanner->token;
 }
@@ -647,6 +827,61 @@
 }
 
 void
+osso_g_scanner_cache_open (GScanner *scanner, gchar *filename)
+{
+  char        basename[128];
+  struct stat st;
+  int         fd;
+  gsize       cache_size = 0;
+  void       *cache_p = NULL;
+
+  if (fstat (scanner->input_fd, &st) == -1)
+    return;
+
+  /* FIXME: create cache only if explicitly asked for (to be used by a
+   * standalone application, for example.)  The cache filename should also be
+   * derived from the gtkrc path, but it's not available without modifications
+   * to gtk+ */
+
+  if(getenv("GSCANNERCACHE_CREATE"))
+    {
+      /* we don't care if this file exists or not, just delete it */
+      remove (filename);
+
+      fd = open (filename, O_CREAT|O_EXCL|O_WRONLY, 0666);
+      scanner->cache_flags |= CACHE_FLAGS_WRITE;
+    }
+  else
+    {
+      fd = open (filename, O_RDONLY);
+      if (fd != -1)
+	{
+	  if (fstat (fd, &st) == 0)
+	    {
+	      void *ptr;
+
+	      ptr = mmap (NULL, st.st_size, PROT_READ, MAP_SHARED, fd, 0);
+	      if (ptr != MAP_FAILED)
+		{
+		  cache_p = ptr;
+		  cache_size = st.st_size;
+		}
+	    }
+
+	  /* after mmap the file descriptor is no longer needer */
+	  close (fd);
+	  fd = -1;
+	}
+    }
+
+  scanner->cache_fd = fd;
+  scanner->cache_size = cache_size;
+  scanner->cache_base = cache_p;
+  scanner->cache_p = cache_p;
+  scanner->cache_end = cache_p + cache_size;
+}
+
+void
 g_scanner_input_file (GScanner *scanner,
 		      gint	input_fd)
 {
