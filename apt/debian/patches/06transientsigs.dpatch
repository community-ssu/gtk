#! /bin/sh -e
## 05statusparse.dpatch by  <mvo@>
##
## All lines beginning with `## DP:' are a description of the patch.
##
## DP: Keep old Release.gpg and Release files when acquiring them
## DP: fails for a transient reason.

if [ $# -lt 1 ]; then
    echo "`basename $0`: script expects -patch|-unpatch as argument" >&2
    exit 1
fi

[ -f debian/patches/00patch-opts ] && . debian/patches/00patch-opts
patch_opts="${patch_opts:--f --no-backup-if-mismatch} ${2:+-d $2}"

case "$1" in
    -patch) patch -p0 ${patch_opts} < $0;;
    -unpatch) patch -R -p0 ${patch_opts} < $0;;
    *)
        echo "`basename $0`: script expects -patch|-unpatch as argument" >&2
        exit 1;;
esac

exit 0

@DPATCH@

Index: apt-pkg/acquire-item.cc
===================================================================
--- apt-pkg/acquire-item.cc	(revision 5175)
+++ apt-pkg/acquire-item.cc	(working copy)
@@ -332,23 +332,6 @@
    Desc.ShortDesc = ShortDesc;
    Desc.URI = URI;
    
-      
-   string Final = _config->FindDir("Dir::State::lists");
-   Final += URItoFileName(RealURI);
-   struct stat Buf;
-   if (stat(Final.c_str(),&Buf) == 0)
-   {
-      // File was already in place.  It needs to be re-verified
-      // because Release might have changed, so Move it into partial
-      Rename(Final,DestFile);
-      // unlink the file and do not try to use I-M-S and Last-Modified
-      // if the users proxy is broken
-      if(_config->FindB("Acquire::BrokenProxy", false) == true) {
-	 std::cerr << "forcing re-get of the signature file as requested" << std::endl;
-	 unlink(DestFile.c_str());
-      }
-   }
-
    QueueURI(Desc);
 }
 									/*}}}*/
@@ -357,8 +340,10 @@
 /* The only header we use is the last-modified header. */
 string pkgAcqMetaSig::Custom600Headers()
 {
-   struct stat Buf;
-   if (stat(DestFile.c_str(),&Buf) != 0)
+  string Final = _config->FindDir("Dir::State::lists");
+  Final += URItoFileName(RealURI);
+  struct stat Buf;
+   if (stat(Final.c_str(),&Buf) != 0)
       return "\nIndex-File: true";
 
    return "\nIndex-File: true\nLast-Modified: " + TimeRFC1123(Buf.st_mtime);
@@ -388,6 +373,21 @@
 
    Complete = true;
 
+   string Final = _config->FindDir("Dir::State::lists");
+   Final += URItoFileName(RealURI);
+   if (StringToBool(LookupTag(Message,"IMS-Hit"),false))
+     {
+       // Move it into position
+       Rename (Final, DestFile);
+     }
+   else
+     {
+       // Delete the old version in lists/.  The new version will be moved
+       // there from partial/ when the signature verification succeeds
+       //
+       unlink (Final.c_str ());
+     }
+
    // queue a pkgAcqMetaIndex to be verified against the sig we just retrieved
    new pkgAcqMetaIndex(Owner, MetaIndexURI, MetaIndexURIDesc, MetaIndexShortDesc,
 		       DestFile, IndexTargets, MetaIndexParser);
@@ -396,31 +396,61 @@
 									/*}}}*/
 void pkgAcqMetaSig::Failed(string Message,pkgAcquire::MethodConfig *Cnf)
 {
-   // Delete any existing sigfile, so that this source isn't
-   // mistakenly trusted
-   string Final = _config->FindDir("Dir::State::lists") + URItoFileName(RealURI);
-   unlink(Final.c_str());
+   string Final =
+     _config->FindDir("Dir::State::lists") + URItoFileName(RealURI);
 
-   // if we get a timeout if fail
-   if(LookupTag(Message,"FailReason") == "Timeout" || 
-      LookupTag(Message,"FailReason") == "TmpResolveFailure") {
-      Item::Failed(Message,Cnf);
-      return;
-   }
+   // If this is a transient failure, we use the old version, if we
+   // have one.  "Using it" means moving it into the partial/
+   // directory for further consumption by gpgv.
+   //
+   if (StringToBool(LookupTag(Message,"Transient-Failure"),false))
+     {
+       cerr << "transient " << Final << "\n";
+       struct stat Buf;
+       if (stat(Final.c_str(),&Buf) == 0)
+	 {
+	   cerr << "have old version\n";
+	   Rename (Final, DestFile); 
+	   new pkgAcqMetaIndex(Owner, MetaIndexURI, MetaIndexURIDesc,
+			       MetaIndexShortDesc,
+			       DestFile, IndexTargets, MetaIndexParser);
+	 }
+       else
+	 {
+	   // queue a pkgAcqMetaIndex with no sigfile
+	   new pkgAcqMetaIndex(Owner, MetaIndexURI, MetaIndexURIDesc,
+			       MetaIndexShortDesc,
+			       "", IndexTargets, MetaIndexParser);
+	 }
+     }
+   else
+     {
+       // Delete any existing sigfile, so that this source isn't
+       // mistakenly trusted
+       unlink(Final.c_str());
 
-   // queue a pkgAcqMetaIndex with no sigfile
-   new pkgAcqMetaIndex(Owner, MetaIndexURI, MetaIndexURIDesc, MetaIndexShortDesc,
-		       "", IndexTargets, MetaIndexParser);
+       // if we get a timeout if fail
+       if(LookupTag(Message,"FailReason") == "Timeout" || 
+	  LookupTag(Message,"FailReason") == "TmpResolveFailure") {
+	 Item::Failed(Message,Cnf);
+	 return;
+       }
 
+       // queue a pkgAcqMetaIndex with no sigfile
+       new pkgAcqMetaIndex(Owner, MetaIndexURI, MetaIndexURIDesc,
+			   MetaIndexShortDesc,
+			   "", IndexTargets, MetaIndexParser);
+     }
+
    if (Cnf->LocalOnly == true || 
        StringToBool(LookupTag(Message,"Transient-Failure"),false) == false)
-   {      
-      // Ignore this
+     {      
+       // Ignore this
       Status = StatDone;
       Complete = false;
       Dequeue();
       return;
-   }
+     }
    
    Item::Failed(Message,Cnf);
 }
@@ -690,13 +720,44 @@
 void pkgAcqMetaIndex::Failed(string Message,pkgAcquire::MethodConfig *Cnf)
 {
    if (AuthPass == true)
-   {
-      // gpgv method failed
-      _error->Warning("GPG error: %s: %s",
-                      Desc.Description.c_str(),
-                      LookupTag(Message,"Message").c_str());
-   }
+     {
+       // gpgv method failed
+       _error->Warning("GPG error: %s: %s",
+		       Desc.Description.c_str(),
+		       LookupTag(Message,"Message").c_str());
+     }
+   else
+     {
+       // If this is a transient failure, we use the old version, if we
+       // have one.
+       //
+       if (StringToBool(LookupTag(Message,"Transient-Failure"),false))
+	 {
+	   string Final = _config->FindDir("Dir::State::lists");
+	   Final += URItoFileName(RealURI);
+	   struct stat Buf;
+	   if (stat(Final.c_str(),&Buf) == 0)
+	     {
+	       DestFile = Final;
 
+	       if (SigFile != "")
+		 {
+		   // There was a signature file, so pass it to gpgv
+		   // for verification
+
+		   if (_config->FindB("Debug::pkgAcquire::Auth", false))
+		     std::cerr << "Metaindex acquired, queueing gpg verification ("
+			       << SigFile << "," << DestFile << ")\n";
+		   AuthPass = true;
+		   Desc.URI = "gpgv:" + SigFile;
+		   QueueURI(Desc);
+		   Mode = "gpgv";
+		   return;
+		 }
+	     }
+	 }
+     }
+       
    // No Release file was present, or verification failed, so fall
    // back to queueing Packages files without verification
    QueueIndexes(false);
