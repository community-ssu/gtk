Index: apt-pkg/acquire-item.cc
===================================================================
--- apt-pkg/acquire-item.cc	(revision 11194)
+++ apt-pkg/acquire-item.cc	(working copy)
@@ -1251,7 +1251,26 @@
 }
 
 									/*}}}*/
+static int
+default_index_trust_level_for_package (pkgIndexFile *Index,
+				       const pkgCache::VerIterator &Ver)
+{
+  return Index->IsTrusted ()? 1 : 0;
+}
 
+static int (*index_trust_level_for_package) (pkgIndexFile *Index,
+					      const pkgCache::VerIterator &Ver)
+  = default_index_trust_level_for_package;
+
+void
+apt_set_index_trust_level_for_package_hook (int (*hook)
+					    (pkgIndexFile *Index,
+					     const pkgCache::VerIterator &Ver))
+{
+  index_trust_level_for_package = hook;
+}
+
+
 // AcqArchive::AcqArchive - Constructor					/*{{{*/
 // ---------------------------------------------------------------------
 /* This just sets up the initial fetch environment and queues the first
@@ -1260,8 +1279,8 @@
 			     pkgRecords *Recs,pkgCache::VerIterator const &Version,
 			     string &StoreFilename) :
                Item(Owner), Version(Version), Sources(Sources), Recs(Recs), 
-               StoreFilename(StoreFilename), Vf(Version.FileList()), 
-	       Trusted(false)
+               StoreFilename(StoreFilename),
+	       TrustLevel(0)
 {
    Retries = _config->FindI("Acquire::Retries",0);
 
@@ -1277,6 +1296,9 @@
    /* We need to find a filename to determine the extension. We make the
       assumption here that all the available sources for this version share
       the same extension.. */
+
+   pkgCache::VerFileIterator Vf = Version.FileList();
+
    // Skip not source sources, they do not have file fields.
    for (; Vf.end() == false; Vf++)
    {
@@ -1300,31 +1322,55 @@
 	              "." + flExtension(Parse.FileName());
    }
 
-   // check if we have one trusted source for the package. if so, switch
-   // to "TrustedOnly" mode
-   for (pkgCache::VerFileIterator i = Version.FileList(); i.end() == false; i++)
-   {
-      pkgIndexFile *Index;
-      if (Sources->FindIndex(i.File(),Index) == false)
-         continue;
-      if (_config->FindB("Debug::pkgAcquire::Auth", false))
-      {
-         std::cerr << "Checking index: " << Index->Describe()
-                   << "(Trusted=" << Index->IsTrusted() << ")\n";
-      }
-      if (Index->IsTrusted()) {
-         Trusted = true;
-	 break;
-      }
-   }
+   VerFileCandidates.clear();
+   TrustLevel = 0;
 
-   // "allow-unauthenticated" restores apts old fetching behaviour
-   // that means that e.g. unauthenticated file:// uris are higher
-   // priority than authenticated http:// uris
    if (_config->FindB("APT::Get::AllowUnauthenticated",false) == true)
-      Trusted = false;
+     {
+       // "allow-unauthenticated" restores apts old fetching behaviour
+       // that means that e.g. unauthenticated file:// uris are higher
+       // priority than authenticated http:// uris
+       
+       while (!Vf.end())
+	 {
+	   if ((Vf.File()->Flags & pkgCache::Flag::NotSource) != 0)
+	     continue;
+	   VerFileCandidates.push_back (Vf);
+	   Vf++;
+	 }
+     }
+   else
+     {
+       // Find the sources with the highest trust level.
 
+       while (!Vf.end())
+	 {
+	   pkgIndexFile *Index;
+	   if (Sources->FindIndex(Vf.File(),Index) == false)
+	     continue;
+       
+	   int l = index_trust_level_for_package (Index, Version);
+	   
+	   if (_config->FindB("Debug::pkgAcquire::Auth", false))
+	     {
+	       std::cerr << "Checking index: " << Index->Describe()
+			 << "(Trust level =" << l << ")\n";
+	     }
+	   
+	   if (l >= TrustLevel) 
+	     {
+	       if (l > TrustLevel)
+		 VerFileCandidates.clear ();
+	       VerFileCandidates.push_back (Vf);
+	       TrustLevel = l;
+	     }
+	   
+	   Vf++;
+	 }
+     }
+
    // Select a source
+   CurVerFile = VerFileCandidates.begin ();
    if (QueueNext() == false && _error->PendingError() == false)
       _error->Error(_("I wasn't able to locate file for the %s package. "
 		    "This might mean you need to manually fix this package."),
@@ -1338,22 +1384,15 @@
    checking later. */
 bool pkgAcqArchive::QueueNext()
 {   
-   for (; Vf.end() == false; Vf++)
+  while (CurVerFile != VerFileCandidates.end())
    {
-      // Ignore not source sources
-      if ((Vf.File()->Flags & pkgCache::Flag::NotSource) != 0)
-	 continue;
+      pkgCache::VerFileIterator Vf = *CurVerFile++;
 
       // Try to cross match against the source list
       pkgIndexFile *Index;
       if (Sources->FindIndex(Vf.File(),Index) == false)
 	    continue;
       
-      // only try to get a trusted package from another source if that source
-      // is also trusted
-      if(Trusted && !Index->IsTrusted()) 
-	 continue;
-
       // Grab the text package record
       pkgRecords::Parser &Parse = Recs->Lookup(Vf);
       if (_error->PendingError() == true)
@@ -1431,7 +1470,6 @@
       Desc.ShortDesc = Version.ParentPkg().Name();
       QueueURI(Desc);
 
-      Vf++;
       return true;
    }
    return false;
@@ -1508,7 +1546,7 @@
        StringToBool(LookupTag(Message,"Transient-Failure"),false) == true)
    {
       // Vf = Version.FileList();
-      while (Vf.end() == false) Vf++;
+      CurVerFile = VerFileCandidates.end ();
       StoreFilename = string();
       Item::Failed(Message,Cnf);
       return;
@@ -1522,7 +1560,7 @@
 	  StringToBool(LookupTag(Message,"Transient-Failure"),false) == true)
       {
 	 Retries--;
-	 Vf = Version.FileList();
+	 CurVerFile = VerFileCandidates.begin ();
 	 if (QueueNext() == true)
 	    return;
       }
@@ -1537,7 +1575,7 @@
 // ---------------------------------------------------------------------
 bool pkgAcqArchive::IsTrusted()
 {
-   return Trusted;
+   return TrustLevel > 0;
 }
 
 // AcqArchive::Finished - Fetching has finished, tidy up		/*{{{*/
Index: apt-pkg/acquire-item.h
===================================================================
--- apt-pkg/acquire-item.h	(revision 11192)
+++ apt-pkg/acquire-item.h	(working copy)
@@ -27,6 +27,8 @@
 #include <apt-pkg/pkgrecords.h>
 #include <apt-pkg/indexrecords.h>
 
+#include <list>
+
 #ifdef __GNUG__
 #pragma interface "apt-pkg/acquire-item.h"
 #endif 
@@ -254,9 +256,10 @@
    pkgRecords *Recs;
    string MD5;
    string &StoreFilename;
-   pkgCache::VerFileIterator Vf;
+   std::list<pkgCache::VerFileIterator> VerFileCandidates;
+   std::list<pkgCache::VerFileIterator>::const_iterator CurVerFile;
    unsigned int Retries;
-   bool Trusted; 
+   int TrustLevel; 
 
    // Queue the next available file for download.
    bool QueueNext();
@@ -303,4 +306,28 @@
 	      const string &DestDir="", const string &DestFilename="");
 };
 
+/* For influencing the IsTrusted decision when acquiring a new version
+   of a package and for influencing which source is selected if the
+   highest version of a package is available from multiple sources.
+
+   The hook should return a integer indicating the 'trust level' that
+   a given index should be afforded for a given package.  Indices with
+   higher trust levels will be preferred.
+
+   The default behavior is to use a trust level of zero for unsigned
+   repositories and a level of one for repositories with valid
+   signatures.
+
+   The IsTrusted predicate on a pkgAcqArchive object will return true
+   when the highest trust level is non-zero, false otherwise.
+
+   A trust level can be negative.  In that case, the index will never
+   be considered as a source for the package.
+*/
+
+void
+apt_set_index_trust_level_for_package_hook (int (*hook)
+					    (pkgIndexFile *Index,
+					     const pkgCache::VerIterator &V));
+
 #endif
