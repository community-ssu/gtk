diff -ur dbus/dbus/dbus-string.c dbus.new/dbus/dbus-string.c
--- dbus/dbus/dbus-string.c	2006-01-04 17:22:50.443705344 +0200
+++ dbus.new/dbus/dbus-string.c	2006-01-04 17:30:08.972038904 +0200
@@ -426,7 +426,52 @@
   /* exceeding max length is the same as failure to allocate memory */
   if (_DBUS_UNLIKELY (new_length > real->max_length))
     return FALSE;
-  else if (new_length > (real->allocated - ALLOCATION_PADDING) &&
+
+  if (new_length == 0)
+    {
+       /* try to reduce heap fragmentation */
+       char* new_str;
+       dbus_free (real->str - real->align_offset);
+       new_str = dbus_malloc(ALLOCATION_PADDING);
+
+       if (_DBUS_UNLIKELY (new_str == NULL))
+         return FALSE;
+       
+       real->str = new_str + real->align_offset;
+       /* reallocate_for_length() would allocate the same size */
+       real->allocated = ALLOCATION_PADDING;
+       fixup_alignment (real);
+       real->len = 0;
+       real->str[0] = '\0';
+       return TRUE;
+    }
+
+  if (real->allocated > new_length * 2 + ALLOCATION_PADDING)
+    {
+       /* free some space */
+       int new_size = new_length * 2 + ALLOCATION_PADDING;
+       char* new_str;
+       if (new_length == 0)
+         {
+            /* free & reallocate to give the heap a chance to contract */
+            dbus_free (real->str - real->align_offset);
+            new_str = dbus_malloc (new_size); 
+         }
+       else
+         new_str = dbus_realloc (real->str - real->align_offset, new_size);
+
+       if (_DBUS_UNLIKELY (new_str == NULL))
+         return FALSE;
+
+       real->str = new_str + real->align_offset;
+       real->allocated = new_size;
+       fixup_alignment (real);
+       real->len = new_length;
+       real->str[new_length] = '\0';
+       return TRUE;
+    }
+
+  if (new_length > (real->allocated - ALLOCATION_PADDING) &&
            _DBUS_UNLIKELY (!reallocate_for_length (real, new_length)))
     return FALSE;
   else
