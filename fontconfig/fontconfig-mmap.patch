diff -Naur fontconfig-2.3.2/Makefile.am fontconfig-2.3.2-mmap/Makefile.am
--- fontconfig-2.3.2/Makefile.am	2005-03-03 08:20:57.000000000 +0200
+++ fontconfig-2.3.2-mmap/Makefile.am	2005-07-04 15:50:44.608714472 +0300
@@ -23,7 +23,7 @@
 
 DOCSRC=@DOCSRC@
 SUBDIRS=fontconfig fc-case fc-lang fc-glyphname src \
-	fc-cache fc-list fc-match conf.d $(DOCSRC) test
+	fc-cache fc-list fc-match fc-mmap conf.d $(DOCSRC) test
 
 DEBIAN = \
 	debian/changelog \
diff -Naur fontconfig-2.3.2/configure.in fontconfig-2.3.2-mmap/configure.in
--- fontconfig-2.3.2/configure.in	2005-04-27 21:54:24.000000000 +0300
+++ fontconfig-2.3.2-mmap/configure.in	2005-07-04 15:50:44.609714320 +0300
@@ -471,6 +471,7 @@
 fc-cache/Makefile
 fc-list/Makefile
 fc-match/Makefile
+fc-mmap/Makefile
 doc/Makefile
 doc/version.sgml
 test/Makefile
diff -Naur fontconfig-2.3.2/fc-mmap/.cvsignore fontconfig-2.3.2-mmap/fc-mmap/.cvsignore
--- fontconfig-2.3.2/fc-mmap/.cvsignore	1970-01-01 02:00:00.000000000 +0200
+++ fontconfig-2.3.2-mmap/fc-mmap/.cvsignore	2005-07-04 15:50:47.320302248 +0300
@@ -0,0 +1,6 @@
+.deps
+.libs
+Makefile
+Makefile.in
+fc-mmap
+fc-mmap.1
diff -Naur fontconfig-2.3.2/fc-mmap/Makefile.am fontconfig-2.3.2-mmap/fc-mmap/Makefile.am
--- fontconfig-2.3.2/fc-mmap/Makefile.am	1970-01-01 02:00:00.000000000 +0200
+++ fontconfig-2.3.2-mmap/fc-mmap/Makefile.am	2005-07-04 15:50:47.320302248 +0300
@@ -0,0 +1,56 @@
+# 
+#  $Id: Makefile.am,v 1.10 2004/12/07 01:14:46 keithp Exp $
+# 
+#  Copyright © 2003 Keith Packard
+# 
+#  Permission to use, copy, modify, distribute, and sell this software and its
+#  documentation for any purpose is hereby granted without fee, provided that
+#  the above copyright notice appear in all copies and that both that
+#  copyright notice and this permission notice appear in supporting
+#  documentation, and that the name of Keith Packard not be used in
+#  advertising or publicity pertaining to distribution of the software without
+#  specific, written prior permission.  Keith Packard makes no
+#  representations about the suitability of this software for any purpose.  It
+#  is provided "as is" without express or implied warranty.
+# 
+#  KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+#  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+#  EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+#  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+#  DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+#  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+#  PERFORMANCE OF THIS SOFTWARE.
+
+DOC2MAN = docbook2man
+
+FC_MMAP_SRC=${top_srcdir}/fc-mmap
+
+SGML = ${FC_MMAP_SRC}/fc-mmap.sgml
+
+bin_PROGRAMS=fc-mmap
+
+INCLUDES=-I${top_srcdir} $(FREETYPE_CFLAGS) $(WARN_CFLAGS)
+
+EXTRA_DIST=$(SGML)
+
+fc_mmap_LDADD = ${top_builddir}/src/libfontconfig.la
+
+
+if USEDOCBOOK
+
+man_MANS=fc-mmap.1
+
+${man_MANS}: ${SGML}
+	$(RM) $@
+	$(DOC2MAN) ${SGML}
+	$(RM) manpage.refs manpage.links
+
+all-local: $(man_MANS)
+
+clean-local:
+	$(RM) $(man_MANS)
+
+else
+all-local:
+clean-local:
+endif
diff -Naur fontconfig-2.3.2/fc-mmap/fc-mmap.c fontconfig-2.3.2-mmap/fc-mmap/fc-mmap.c
--- fontconfig-2.3.2/fc-mmap/fc-mmap.c	1970-01-01 02:00:00.000000000 +0200
+++ fontconfig-2.3.2-mmap/fc-mmap/fc-mmap.c	2005-07-04 15:50:47.321302096 +0300
@@ -0,0 +1,142 @@
+/*
+ * $RCSId: xc/lib/fontconfig/fc-mmap/fc-mmap.c,v 1.1 2005/06/06 10:22:40 plam Exp $
+ *
+ * Copyright © 2005 Patrick Lam
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <fontconfig/fontconfig.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#else
+#ifdef linux
+#define HAVE_GETOPT_LONG 1
+#endif
+#define HAVE_GETOPT 1
+#endif
+
+#ifndef HAVE_GETOPT
+#define HAVE_GETOPT 0
+#endif
+#ifndef HAVE_GETOPT_LONG
+#define HAVE_GETOPT_LONG 0
+#endif
+
+#if HAVE_GETOPT_LONG
+#undef  _GNU_SOURCE
+#define _GNU_SOURCE
+#include <getopt.h>
+const struct option longopts[] = {
+    {"system-only", 0, 0, 's'},
+    {"version", 0, 0, 'V'},
+    {"verbose", 0, 0, 'v'},
+    {"help", 0, 0, '?'},
+    {NULL,0,0,0},
+};
+#else
+#if HAVE_GETOPT
+extern char *optarg;
+extern int optind, opterr, optopt;
+#endif
+#endif
+
+static void
+usage (char *program)
+{
+#if HAVE_GETOPT_LONG
+    fprintf (stderr, "usage: %s [-svV?] [--system-only] [--verbose] [--version] [--help]\n",
+	     program);
+#else
+    fprintf (stderr, "usage: %s [-svV?]\n",
+	     program);
+#endif
+    fprintf (stderr, "Build font information caches.\n");
+    fprintf (stderr, "\n");
+#if HAVE_GETOPT_LONG
+    fprintf (stderr, "  -s, --system-only    scan system-wide directories only\n");
+    fprintf (stderr, "  -v, --verbose        display status information while busy\n");
+    fprintf (stderr, "  -V, --version        display font config version and exit\n");
+    fprintf (stderr, "  -?, --help           display this help and exit\n");
+#else
+    fprintf (stderr, "  -s         (system)  scan system-wide directories only\n");
+    fprintf (stderr, "  -v         (verbose) display status information while busy\n");
+    fprintf (stderr, "  -V         (version) display font config version and exit\n");
+    fprintf (stderr, "  -?         (help)    display this help and exit\n");
+#endif
+    exit (1);
+}
+
+int
+main (int argc, char **argv)
+{
+    int		verbose = 0;
+    int		i, r = 0;
+    FcBool	systemOnly = FcFalse;
+#if HAVE_GETOPT_LONG || HAVE_GETOPT
+    int		c;
+
+#if HAVE_GETOPT_LONG
+    while ((c = getopt_long (argc, argv, "sVv?", longopts, NULL)) != -1)
+#else
+    while ((c = getopt (argc, argv, "sVv?")) != -1)
+#endif
+    {
+	switch (c) {
+	case 's':
+	    systemOnly = FcTrue;
+	    break;
+	case 'V':
+	    fprintf (stderr, "fontconfig version %d.%d.%d\n", 
+		     FC_MAJOR, FC_MINOR, FC_REVISION);
+	    exit (0);
+	case 'v':
+	    verbose = 1;
+	    break;
+	default:
+	    usage (argv[0]);
+	}
+    }
+    i = optind;
+#else
+    i = 1;
+#endif
+
+    if (systemOnly)
+	FcConfigEnableHome (FcFalse);
+    FcMmapForce(FcTrue);
+
+    if (!FcInit ())
+    {
+	fprintf (stderr, "Can't init font config library\n");
+	return 1;
+    }
+    if (!FcMmapSave(FcConfigGetCurrent()))
+	r = 1;
+
+    FcFini ();
+
+    if (verbose)
+	printf ("%s: %s\n", argv[0], r ? "failed" : "succeeded");
+
+    return r;
+}
diff -Naur fontconfig-2.3.2/fc-mmap/fc-mmap.sgml fontconfig-2.3.2-mmap/fc-mmap/fc-mmap.sgml
--- fontconfig-2.3.2/fc-mmap/fc-mmap.sgml	1970-01-01 02:00:00.000000000 +0200
+++ fontconfig-2.3.2-mmap/fc-mmap/fc-mmap.sgml	2005-07-04 15:50:47.322301944 +0300
@@ -0,0 +1,168 @@
+<!doctype refentry PUBLIC "-//OASIS//DTD DocBook V4.1//EN" [
+
+<!-- Process this file with docbook-to-man to generate an nroff manual
+     page: `docbook-to-man manpage.sgml > manpage.1'.  You may view
+     the manual page with: `docbook-to-man manpage.sgml | nroff -man |
+     less'.  A typical entry in a Makefile or Makefile.am is:
+
+manpage.1: manpage.sgml
+	docbook-to-man $< > $@
+
+    
+	The docbook-to-man binary is found in the docbook-to-man package.
+	Please remember that if you create the nroff version in one of the
+	debian/rules file targets (such as build), you will need to include
+	docbook-to-man in your Build-Depends control field.
+
+  -->
+
+  <!-- Fill in your name for FIRSTNAME and SURNAME. -->
+  <!ENTITY dhfirstname "<firstname>Patrick</firstname>">
+  <!ENTITY dhsurname   "<surname>Lam</surname>">
+  <!-- Please adjust the date whenever revising the manpage. -->
+  <!ENTITY dhdate      "<date>June 9, 2005</date>">
+  <!-- SECTION should be 1-8, maybe w/ subsection other parameters are
+       allowed: see man(7), man(1). -->
+  <!ENTITY dhsection   "<manvolnum>1</manvolnum>">
+  <!ENTITY dhemail     "<email>plam@mit.edu</email>">
+  <!ENTITY dhusername  "Patrick Lam">
+  <!ENTITY dhucpackage "<refentrytitle>fc-mmap</refentrytitle>">
+  <!ENTITY dhpackage   "fc-mmap">
+
+  <!ENTITY debian      "<productname>Debian</productname>">
+  <!ENTITY gnu         "<acronym>GNU</acronym>">
+  <!ENTITY gpl         "&gnu; <acronym>GPL</acronym>">
+]>
+
+<refentry>
+  <refentryinfo>
+    <address>
+      &dhemail;
+    </address>
+    <author>
+      &dhfirstname;
+      &dhsurname;
+    </author>
+    <copyright>
+      <year>2005</year>
+      <holder>&dhusername;</holder>
+    </copyright>
+    &dhdate;
+  </refentryinfo>
+  <refmeta>
+    &dhucpackage;
+
+    &dhsection;
+  </refmeta>
+  <refnamediv>
+    <refname>&dhpackage;</refname>
+
+    <refpurpose>create fontconfig mmap file</refpurpose>
+  </refnamediv>
+  <refsynopsisdiv>
+    <cmdsynopsis>
+      <command>&dhpackage;</command>
+
+      <arg><option>-vV?</option></arg>
+      <arg><option>--system-only</option></arg>
+      <arg><option>--verbose</option></arg>
+      <arg><option>--version</option></arg>
+      <arg><option>--help</option></arg>
+      <arg><option><replaceable>pattern</replaceable></option></arg>
+      <arg><option><replaceable>element</replaceable></option></arg>
+      
+     </cmdsynopsis>
+  </refsynopsisdiv>
+  <refsect1>
+    <title>DESCRIPTION</title>
+
+    <para><command>&dhpackage;</command> creates memory-saving mmap file
+    caching loaded font information.</para>
+
+  </refsect1>
+  <refsect1>
+    <title>OPTIONS</title>
+
+    <para>This program follows the usual &gnu; command line syntax,
+      with long options starting with two dashes (`-').  A summary of
+      options is included below.</para>
+
+    <variablelist>
+      <varlistentry>
+        <term><option>-v</option>
+          <option>--verbose</option>
+        </term>
+        <listitem>
+          <para>Display status information while busy.</para>
+        </listitem>
+      </varlistentry>
+      <varlistentry>
+        <term><option>-?</option>
+          <option>--help</option>
+        </term>
+        <listitem>
+          <para>Show summary of options.</para>
+        </listitem>
+      </varlistentry>
+      <varlistentry>
+        <term><option>-V</option>
+          <option>--version</option>
+        </term>
+        <listitem>
+          <para>Show version of the program and exit.</para>
+        </listitem>
+      </varlistentry>
+      <varlistentry>
+        <term><option>-s</option>
+          <option>--system-only</option>
+        </term>
+        <listitem>
+          <para>Only caches system fonts.</para>
+        </listitem>
+      </varlistentry>
+    </variablelist>
+  </refsect1>
+
+  <refsect1>
+    <title>EXAMPLES</title>
+
+    <variablelist>
+      <varlistentry>
+        <term>fc-mmap</term>
+        <listitem><para>Creates font information cache.</para></listitem>
+      </varlistentry>
+    </variablelist>
+
+  </refsect1>
+
+  <refsect1>
+    <title>SEE ALSO</title>
+
+    <para>The fontconfig user's guide, in HTML format:
+      <filename>/usr/share/doc/fontconfig/fontconfig-user.html</filename>.</para>
+
+ </refsect1>
+  <refsect1>
+    <title>AUTHOR</title>
+
+    <para>This manual page was written by &dhusername; &dhemail;.</para>
+
+  </refsect1>
+</refentry>
+
+<!-- Keep this comment at the end of the file
+Local variables:
+mode: sgml
+sgml-omittag:t
+sgml-shorttag:t
+sgml-minimize-attributes:nil
+sgml-always-quote-attributes:t
+sgml-indent-step:2
+sgml-indent-data:t
+sgml-parent-document:nil
+sgml-default-dtd-file:nil
+sgml-exposed-tags:nil
+sgml-local-catalogs:nil
+sgml-local-ecat-files:nil
+End:
+-->
diff -Naur fontconfig-2.3.2/fontconfig/fontconfig.h fontconfig-2.3.2-mmap/fontconfig/fontconfig.h
--- fontconfig-2.3.2/fontconfig/fontconfig.h	2005-04-23 07:26:12.000000000 +0300
+++ fontconfig-2.3.2-mmap/fontconfig/fontconfig.h	2005-07-04 15:50:47.323301792 +0300
@@ -210,7 +210,7 @@
 	const FcMatrix	*m;
 	const FcCharSet	*c;
 	void		*f;
-	const FcPattern	*p;
+	const FcPattern	*p; /* apparently unused... */
 	const FcLangSet	*l;
     } u;
 } FcValue;
@@ -618,6 +618,17 @@
 void
 FcMatrixShear (FcMatrix *m, double sh, double sv);
 
+/* fcmmap.c */
+
+void
+FcMmapForce(FcBool f);
+
+FcBool
+FcMmapSave(FcConfig *config);
+
+FcBool
+FcMmapLoadFonts(FcConfig *config);
+
 /* fcname.c */
 
 FcBool
diff -Naur fontconfig-2.3.2/src/Makefile.am fontconfig-2.3.2-mmap/src/Makefile.am
--- fontconfig-2.3.2/src/Makefile.am	2004-12-05 07:49:20.000000000 +0200
+++ fontconfig-2.3.2-mmap/src/Makefile.am	2005-07-04 15:50:47.323301792 +0300
@@ -92,6 +92,7 @@
 	fclist.c \
 	fcmatch.c \
 	fcmatrix.c \
+	fcmmap.c \
 	fcname.c \
 	fcpat.c \
 	fcstr.c \
diff -Naur fontconfig-2.3.2/src/fccfg.c fontconfig-2.3.2-mmap/src/fccfg.c
--- fontconfig-2.3.2/src/fccfg.c	2005-03-09 06:56:35.000000000 +0200
+++ fontconfig-2.3.2-mmap/src/fccfg.c	2005-07-04 15:50:47.335299968 +0300
@@ -252,6 +252,13 @@
     FcStrList	    *list;
     FcChar8	    *dir;
 
+    if (FcMmapLoadFonts(config))
+    {
+        if (FcDebug () & FC_DBG_FONTSET)
+            FcFontSetPrint (config->fonts[FcSetSystem]);
+        return FcTrue;
+    }
+
     fonts = FcFontSetCreate ();
     if (!fonts)
 	goto bail0;
@@ -629,9 +636,11 @@
 		ret = FcStrStrIgnoreCase (left.u.s, right.u.s) != 0;
 		break;
 	    case FcOpNotEqual:
-	    case FcOpNotContains:
 		ret = FcStrCmpIgnoreCase (left.u.s, right.u.s) != 0;
 		break;
+	    case FcOpNotContains:
+		ret = FcStrStrIgnoreCase (left.u.s, right.u.s) != 0;
+		break;
 	    default:
 		break;
 	    }
diff -Naur fontconfig-2.3.2/src/fcinit.c fontconfig-2.3.2-mmap/src/fcinit.c
--- fontconfig-2.3.2/src/fcinit.c	2004-12-06 23:06:40.000000000 +0200
+++ fontconfig-2.3.2-mmap/src/fcinit.c	2005-07-04 15:50:47.335299968 +0300
@@ -61,6 +61,9 @@
     if (!config)
 	return FcFalse;
     
+    if (!FcMmapLoadObjects(config))
+        FcMmapForce(FcTrue);
+    
     if (!FcConfigParseAndLoad (config, 0, FcTrue))
     {
 	FcConfigDestroy (config);
diff -Naur fontconfig-2.3.2/src/fcint.h fontconfig-2.3.2-mmap/src/fcint.h
--- fontconfig-2.3.2/src/fcint.h	2005-01-29 01:49:49.000000000 +0200
+++ fontconfig-2.3.2-mmap/src/fcint.h	2005-07-04 15:50:47.337299664 +0300
@@ -221,6 +221,33 @@
     int	    size;
 } FcStrBuf;
 
+typedef struct _FcMmap {
+    int	magic;
+    off_t fontsets_offset;
+    off_t pattern_offset;     int pattern_length;
+    FcPattern * patterns_addr;
+    off_t patternelt_offset;  int patternelt_length;
+    FcPatternElt * patternelts_addr;
+    off_t valuelist_offset;   int valuelist_length;
+    FcValueList * valuelist_addr;
+    off_t objects_offset;     int objects_length;
+    const char * objects_addr; 
+    off_t matrices_offset;    int matrices_length;
+    FcMatrix * matrices_addr;
+    off_t charsets_offset;    int charsets_length;
+    FcCharSet * charsets_addr;
+    off_t charset_leaf_offset; int charset_num_sum;
+    FcCharLeaf * charset_leaf_addr;
+    off_t charset_leafidx_offset; 
+    FcCharLeaf ** charset_leafidx_addr;
+    off_t charset_numbers_offset; 
+    FcChar16 * charset_numbers_addr;
+    off_t langsets_offset;    int langsets_length;
+    FcLangSet * langsets_addr;
+    off_t strsets_offset;     int strsets_count;
+    off_t char8s_offset;      int char8s_length;
+} FcMmap;
+
 /*
  * To map adobe glyph names to unicode values, a precomputed hash
  * table is used
@@ -676,6 +703,21 @@
 FcBool
 FcNameUnparseLangSet (FcStrBuf *buf, const FcLangSet *ls);
 
+FcBool
+FcValueLangSetRead(int fd, FcMmap metadata);
+
+FcBool
+FcValueLangSetWrite(int fd, FcMmap *metadata);
+
+FcBool
+FcValueLangSetFixup(int fd, FcMmap *metadata);
+
+const FcLangSet *
+FcValueLangSetUnserialize(int fd, FcMmap metadata, int li);
+
+int
+FcValueLangSetSerialize(const FcLangSet *c);
+
 /* fclist.c */
 
 FcBool
@@ -684,6 +726,23 @@
 
 /* fcmatch.c */
 
+/* fcmmap.c */
+
+FcBool
+FcMmapLoadObjects(FcConfig *config);
+
+FcBool
+FcMmapLoad(FcConfig * config);
+
+int
+FcMmapNextOffset(int fd);
+
+int
+FcValueSerializeStrSet(FcStrSet *s);
+
+FcStrSet *
+FcValueMmappedStrSet(int fd, FcMmap metadata, int ssi);
+
 /* fcname.c */
 
 FcBool
@@ -718,6 +777,36 @@
 const char *
 FcObjectStaticName (const char *name);
 
+FcBool
+FcPatternConvertAllToStatic (FcConfig * config);
+
+FcBool
+FcPatternWrite (int fd, FcMmap *metadata);
+
+FcBool
+FcPatternEltWrite (int fd, FcMmap *metadata);
+
+FcBool
+FcObjectsWrite (int fd, FcMmap *metadata);
+
+FcBool
+FcPatternRead (int fd, FcMmap metadata);
+
+FcBool
+FcObjectsFixup (int fd, FcMmap * metadata);
+
+FcBool
+FcPatternEltRead (int fd, FcMmap metadata);
+
+FcBool
+FcPatternEltFixup (int fd, FcMmap *metadata);
+
+FcBool
+FcPatternFixup (int fd, FcMmap *metadata);
+
+FcBool
+FcObjectsRead (int fd, FcMmap metadata);
+
 /* fcrender.c */
 
 /* fcmatrix.c */
diff -Naur fontconfig-2.3.2/src/fclang.c fontconfig-2.3.2-mmap/src/fclang.c
--- fontconfig-2.3.2/src/fclang.c	2004-12-06 21:25:20.000000000 +0200
+++ fontconfig-2.3.2-mmap/src/fclang.c	2005-07-04 15:50:47.340299208 +0300
@@ -22,6 +22,8 @@
  * PERFORMANCE OF THIS SOFTWARE.
  */
 
+#include <fcntl.h>
+#include <sys/mman.h>
 #include "fcint.h"
 
 typedef struct {
@@ -684,3 +686,90 @@
     }
     return FcTrue;
 }
+
+/* relevant to mmap but uses _FcLangSet internals, so goes here. */
+static FcLangSet * langsets = 0;
+static int langset_ptr = 1, langset_alloc = 0;
+
+FcBool
+FcValueLangSetRead(int fd, FcMmap metadata)
+{
+    int c = metadata.langsets_length;
+    off_t w = metadata.langsets_offset;
+    int i;
+
+    langset_ptr = langset_alloc = c;
+
+    langsets = mmap(metadata.langsets_addr, c * sizeof(FcLangSet), 
+		    PROT_READ | PROT_WRITE, 
+		    MAP_FIXED | MAP_PRIVATE, fd, w);
+    if (langsets != metadata.langsets_addr) return FcFalse;
+
+    for (i = 0; i < c; i++)
+	if (langsets[i].extra)
+	    langsets[i].extra = FcValueMmappedStrSet(fd, metadata, 
+						     (int)langsets[i].extra);
+    return FcTrue;
+}
+
+FcBool
+FcValueLangSetWrite(int fd, FcMmap *metadata)
+{
+    metadata->langsets_length = langset_ptr;
+    metadata->langsets_offset = FcMmapNextOffset(fd);
+
+    lseek (fd, metadata->langsets_offset, SEEK_SET);
+    return write(fd, langsets, metadata->langsets_length * sizeof(FcLangSet));
+}
+
+FcBool
+FcValueLangSetFixup(int fd, FcMmap *metadata)
+{
+    int c = metadata->langsets_length;
+    off_t w = metadata->langsets_offset;
+
+    if (langsets)
+	free(langsets);
+
+    langsets = mmap(NULL, c * sizeof(FcLangSet), PROT_READ | PROT_WRITE, 
+		    MAP_FIXED | MAP_PRIVATE, fd, w);
+    if (langsets == MAP_FAILED)
+	return FcFalse;
+    metadata->langsets_addr = langsets;
+    munmap (langsets, c * sizeof(FcLangSet));
+
+    return FcTrue;
+}
+
+const FcLangSet *
+FcValueLangSetUnserialize(int fd, FcMmap metadata, int li)
+{
+    return &langsets[li];
+}
+
+int
+FcValueLangSetSerialize(const FcLangSet *l)
+{
+    int p = langset_ptr;
+
+    if (!l) return 0;
+
+    if (langset_ptr >= langset_alloc)
+    {
+	FcLangSet* t;
+	int newsize = langset_alloc + 2;
+	t = (FcLangSet *)realloc(langsets, newsize * sizeof(FcLangSet));
+	if (!t)
+	    return FcFalse;
+	if (langset_alloc == 0) // valgrind doesn't like writing uninit [0].
+	    memset(t, 0, newsize*sizeof(FcValueList));
+	langsets = t;
+	langset_alloc = newsize;
+    }
+
+    langsets[langset_ptr] = *l;
+    langsets[langset_ptr].extra = 
+	(FcStrSet*)FcValueSerializeStrSet(l->extra);
+    langset_ptr++;
+    return p;
+}
diff -Naur fontconfig-2.3.2/src/fcmmap.c fontconfig-2.3.2-mmap/src/fcmmap.c
--- fontconfig-2.3.2/src/fcmmap.c	1970-01-01 02:00:00.000000000 +0200
+++ fontconfig-2.3.2-mmap/src/fcmmap.c	2005-07-04 15:50:47.350297688 +0300
@@ -0,0 +1,1254 @@
+/*
+ * $RCSId: xc/lib/fontconfig/src/fcmmap.c,v 1.1 2005/06/06 10:30:00 plam Exp $
+ *
+ * Copyright © 2005 Patrick Lam
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <sys/utsname.h>
+#include "fcint.h"
+
+#define MAGIC 0x12345678
+
+static FcBool force;
+
+static FcBool
+FcFontSetWrite(int fd, FcConfig * config, FcMmap * metadata);
+static FcBool
+FcValueMatrixWrite(int fd, FcMmap * metadata);
+static void
+FcValueStrSetWrite(int fd, FcMmap *metadata);
+static FcBool
+FcValueListWrite(int fd, FcMmap * metadata);
+static FcBool
+FcValueCharSetWrite(int fd, FcMmap * metadata);
+
+static FcBool
+FcFontSetRead(int fd, FcConfig * config, FcMmap metadata);
+static FcBool
+FcValueMatrixRead(int fd, FcMmap metadata);
+static FcBool
+FcValueCharSetRead(int fd, FcMmap metadata);
+static FcBool
+FcValueListRead(int fd, FcMmap metadata);
+
+static FcBool
+FcFontSetFixup(int fd, FcConfig * config, FcMmap * metadata);
+static FcBool
+FcValueMatrixFixup(int fd, FcMmap *metadata);
+static FcBool
+FcValueListFixup(int fd, FcMmap * metadata);
+static FcBool
+FcValueCharSetFixup(int fd, FcMmap *metadata);
+static FcBool
+FcFontSetFixup(int fd, FcConfig * config, FcMmap * metadata);
+
+static const FcCharSet *
+FcValueCharSetUnserialize(int fd, FcMmap metadata, int ci);
+static const FcMatrix *
+FcValueMatrixUnserialize(int fd, FcMmap metadata, int mi);
+static int
+FcValueCharSetSerialize(FcCharSet *c);
+
+static int
+FcValueMatrixSerialize(const FcMatrix *m);
+static FcBool
+FcFontSetSerialize (FcConfig * config);
+static int
+FcValueListSerialize (FcValueList *pi);
+static FcBool
+FcPatternSerialize (FcPattern * p);
+
+static FcBool
+FcMmapFixup(FcConfig *config);
+
+static FcPattern * fcpatterns = NULL;
+static int fcpattern_alloc = 0;
+static int fcpattern_ptr = 0;
+
+static FcPatternElt * fcpatternelts = NULL;
+static int fcpatternelt_alloc = 0;
+static int fcpatternelt_ptr = 0;
+
+static FcValueList * fcvaluelists = NULL;
+static int fcvaluelist_alloc = 0;
+static int fcvaluelist_ptr = 0;
+
+void
+FcMmapForce(FcBool f)
+{
+    force = f;
+}
+
+#define MMAP_DEFAULT_TMPDIR "/tmp"
+#define MMAP_DEFAULT_NAME "/fontconfig-mmap"
+static char *
+FcMmapFilename(void)
+{
+    struct utsname b;
+    static char * name = 0;
+
+    if (name)
+        return name;
+
+    if (uname(&b) == -1)
+        name = MMAP_DEFAULT_NAME;
+    else
+    {
+	char * tmpname = getenv("TMPDIR");
+	char * logname = getenv("LOGNAME");
+	char * display = getenv("DISPLAY");
+	if (!tmpname)
+	    tmpname = MMAP_DEFAULT_TMPDIR;
+
+        name = malloc(strlen(MMAP_DEFAULT_NAME) + 
+                      strlen(b.sysname) +
+                      strlen(b.machine) + 
+		      strlen(tmpname) +
+		      (logname ? strlen(logname) : 0) +
+		      (display ? strlen(display) : 0) + 5);
+	strcpy(name, tmpname);
+        strcat(name, MMAP_DEFAULT_NAME);
+        strcat(name, "-");
+        strcat(name, b.sysname);
+        strcat(name, "-");
+        strcat(name, b.machine);
+	strcat(name, "-");
+	strcat(name, logname ? logname : "");
+	strcat(name, "-");
+	strcat(name, display ? display : "");
+    }
+    return name;
+}
+
+#define PAGESIZE 8192
+
+int
+FcMmapNextOffset(int fd)
+{
+    off_t initial, end, w;
+    initial = lseek(fd, 0, SEEK_CUR);
+    end = lseek(fd, 0, SEEK_END);
+    lseek(fd, initial, SEEK_SET);
+
+    w = ((end / PAGESIZE)+1)*PAGESIZE;
+    while (w < sizeof(FcMmap)) w += PAGESIZE;
+
+    return w;
+}
+
+/* Must be called immediately after allocating config */
+FcBool
+FcMmapLoadObjects(FcConfig *config)
+{
+    int fd;
+    FcMmap metadata;
+
+    if (force)
+        return FcFalse;
+
+    fd = open(FcMmapFilename(), O_RDONLY);
+    if (fd == -1)
+        return FcFalse;
+
+    // sanity check for endianness issues
+    read(fd, &metadata, sizeof(FcMmap));
+    if (metadata.magic != MAGIC) 
+        return FcFalse;
+
+    if (!FcObjectsRead(fd, metadata)) 
+	return FcFalse;
+    close(fd);
+    return FcTrue;
+}
+
+/* relies on LoadObjects having run previously */
+FcBool
+FcMmapLoadFonts(FcConfig *config)
+{
+    int fd, i;
+    FcMmap metadata;
+
+    if (force)
+        return FcFalse;
+
+    fd = open(FcMmapFilename(), O_RDONLY);
+    if (fd == -1)
+        return FcFalse;
+
+    // sanity check for endianness issues
+    read(fd, &metadata, sizeof(FcMmap));
+    if (metadata.magic != MAGIC) 
+        return FcFalse;
+
+    if (!FcValueCharSetRead(fd, metadata)) goto bail;
+    if (!FcValueMatrixRead(fd, metadata)) goto bail;
+    if (!FcValueLangSetRead(fd, metadata)) goto bail;
+    if (!FcValueListRead(fd, metadata)) goto bail;
+    if (!FcPatternEltRead(fd, metadata)) goto bail;
+    if (!FcPatternRead(fd, metadata)) goto bail;
+    if (!FcFontSetRead(fd, config, metadata)) goto bail;
+    close(fd);
+    return FcTrue;
+
+ bail: 
+    for (i = FcSetSystem; i <= FcSetApplication; i++)
+        config->fonts[i] = 0;
+    close(fd);
+    return FcFalse;
+}
+
+static FcBool
+FcMmapFixup(FcConfig *config)
+{
+    int fd;
+    FcMmap metadata;
+
+    fd = open(FcMmapFilename(), O_RDWR);
+    if (fd == -1)
+        return FcFalse;
+
+    // sanity check for endianness issues
+    lseek(fd, 0, SEEK_SET);
+    read(fd, &metadata, sizeof(FcMmap));
+    if (metadata.magic != MAGIC) 
+        return FcFalse;
+
+    // If we don't do the reads, cleanup (FcFini) will blowup.
+
+    if (!FcObjectsFixup(fd, &metadata)) goto bail;
+    if (!FcObjectsRead(fd, metadata)) goto bail;
+
+    // this must occur before valuelist fixup
+    if (!FcValueCharSetFixup(fd, &metadata)) goto bail;
+    if (!FcValueMatrixFixup(fd, &metadata)) goto bail;
+    if (!FcValueLangSetFixup(fd, &metadata)) goto bail;
+
+    if (!FcValueCharSetRead(fd, metadata)) goto bail;
+    if (!FcValueMatrixRead(fd, metadata)) goto bail;
+    if (!FcValueLangSetRead(fd, metadata)) goto bail;
+
+    // these depend on objects being fixed up and read
+    if (!FcValueListFixup(fd, &metadata)) goto bail;
+    if (!FcValueListRead(fd, metadata)) goto bail;
+
+    if (!FcPatternEltFixup(fd, &metadata)) goto bail;
+    if (!FcPatternEltRead(fd, metadata)) goto bail;
+
+    // this depends on pattern elts being fixed up.
+    if (!FcPatternFixup(fd, &metadata)) goto bail;
+    if (!FcPatternRead(fd, metadata)) goto bail;
+
+    if (!FcFontSetFixup(fd, config, &metadata)) goto bail;
+    if (!FcFontSetRead(fd, config, metadata)) goto bail;
+
+    lseek(fd, 0, SEEK_SET);
+    write(fd, &metadata, sizeof(FcMmap));
+    close(fd);
+    return FcTrue;
+
+ bail: 
+    unlink(FcMmapFilename());
+    close(fd);
+    return FcFalse;
+}
+
+FcBool
+FcMmapSave(FcConfig *config)
+{
+    int fd;
+    FcMmap metadata;
+    memset (&metadata, 0, sizeof(FcMmap));
+    /* sanity check for endianness issues */
+    metadata.magic = MAGIC;
+
+    if (!FcFontSetSerialize(config))
+	return FcFalse;
+
+    fd = open(FcMmapFilename(), O_WRONLY | O_CREAT | O_TRUNC, 0666);
+    if (fd == -1)
+        return FcFalse;
+
+    /* reserve space for metadata */
+    lseek(fd, 0, SEEK_SET);
+    write(fd, &metadata, sizeof(FcMmap));
+
+    FcFontSetWrite(fd, config, &metadata);
+    FcPatternWrite(fd, &metadata);
+    FcPatternEltWrite(fd, &metadata);
+    FcValueListWrite(fd, &metadata);
+    FcValueLangSetWrite(fd, &metadata);
+    FcValueCharSetWrite(fd, &metadata);
+    FcValueMatrixWrite(fd, &metadata);
+    FcValueStrSetWrite(fd, &metadata);
+    FcObjectsWrite(fd, &metadata);
+
+    /* now rewrite metadata */
+    lseek(fd, 0, SEEK_SET);
+    write(fd, &metadata, sizeof(FcMmap));
+
+    close(fd);
+
+    /* ok, now relocate everything as needed */
+    FcMmapFixup(config);
+    return FcTrue;
+}
+
+static FcBool
+FcFontSetWrite(int fd, FcConfig * config, FcMmap * metadata)
+{
+    int c, t, i;
+    int m = MAGIC, z = 0;
+
+    metadata->fontsets_offset = FcMmapNextOffset(fd);
+    lseek(fd, metadata->fontsets_offset, SEEK_SET);
+    for (i = FcSetSystem; i <= FcSetApplication; i++)
+    {
+        if (!config->fonts[i])
+        {
+            write(fd, &z, sizeof(int));
+            continue;
+        }
+        else
+            write(fd, &m, sizeof(int));
+
+        if ((c = write(fd, config->fonts[i], sizeof(FcFontSet))) == -1)
+            return FcFalse;
+        t = c;
+        if (config->fonts[i]->nfont > 0)
+        {
+            if ((c = write(fd, config->fonts[i]->fonts, 
+                           config->fonts[i]->nfont * sizeof(FcPattern *))) == -1)
+                return FcFalse;
+        }
+    }
+    return FcTrue;
+}
+
+static FcBool
+FcFontSetRead(int fd, FcConfig * config, FcMmap metadata)
+{
+    int i, mz;
+
+    lseek(fd, metadata.fontsets_offset, SEEK_SET);
+    for (i = FcSetSystem; i <= FcSetApplication; i++)
+    {
+	if (config->fonts[i])
+	{
+	    if (config->fonts[i]->nfont > 0 && config->fonts[i]->fonts)
+		free (config->fonts[i]->fonts);
+	    free (config->fonts[i]);
+	}
+    }
+
+    for (i = FcSetSystem; i <= FcSetApplication; i++)
+    {
+        read(fd, &mz, sizeof(int));
+        if (mz != MAGIC)
+            continue;
+
+        config->fonts[i] = malloc(sizeof(FcFontSet));
+        if (!config->fonts[i])
+            return FcFalse;
+        FcMemAlloc(FC_MEM_FONTSET, sizeof(FcFontSet));
+
+        if (read(fd, config->fonts[i], sizeof(FcFontSet)) == -1)
+            goto bail;
+        if (config->fonts[i]->nfont > 0)
+        {
+            config->fonts[i]->fonts = malloc
+                (config->fonts[i]->sfont*sizeof(FcPattern *));
+            if (read(fd, config->fonts[i]->fonts, 
+                     config->fonts[i]->nfont*sizeof(FcPattern *)) == -1)
+                goto bail;
+        }
+    }
+
+    return FcTrue;
+
+ bail:
+    for (i = FcSetSystem; i <= FcSetApplication; i++)
+    {
+        if (config->fonts[i])
+        {
+            if (config->fonts[i]->fonts)
+                free (config->fonts[i]->fonts);
+            free(config->fonts[i]);
+        }
+        config->fonts[i] = 0;
+    }
+    return FcFalse;
+}
+
+static FcBool
+FcFontSetFixup(int fd, FcConfig * config, FcMmap * metadata)
+{
+    int i, j;
+    int font_ptr = 0;
+
+    if (!FcFontSetRead(fd, config, *metadata)) return FcFalse;
+    for (i = FcSetSystem; i <= FcSetApplication; i++)
+        for (j = 0; j < config->fonts[i]->nfont; j++)
+            config->fonts[i]->fonts[j] = &fcpatterns[font_ptr++];
+    if (!FcFontSetWrite(fd, config, metadata)) return FcFalse;
+
+    return FcTrue;
+}
+
+/* FcFontSet */
+static FcBool
+FcFontSetSerialize (FcConfig * config)
+{
+    int i, j, k, pattern_count = 0, elt_count = 0, vallist_count = 0;
+    FcPattern * p;
+    FcPatternElt * t; FcValueList * tl;
+
+    for (i = FcSetSystem, pattern_count = 0; i <= FcSetApplication; i++)
+    {
+        if (config->fonts[i])
+        {
+            pattern_count += config->fonts[i]->nfont;
+            for (j = 0; j < config->fonts[i]->nfont; j++)
+            {
+                FcPattern *p = config->fonts[i]->fonts[j];
+                FcValueList *v;
+
+                if (p->num > 0)
+                    elt_count += p->num;
+                for (k = 0; k < p->num; k++)
+                    for (v = p->elts[k].values; v; v = v->next)
+                        vallist_count++;
+            }
+        }
+    }
+
+    p = malloc(sizeof(FcPattern) * pattern_count);
+    if (!p)
+        return FcFalse;
+    FcMemAlloc (FC_MEM_PATTERN,
+                sizeof(FcPattern) * pattern_count);
+    fcpatterns = p;
+
+    t = malloc(elt_count * sizeof(FcPatternElt));
+    if (!t)
+	return FcFalse;
+    FcMemAlloc (FC_MEM_PATELT, 
+		sizeof (FcPatternElt)*elt_count);
+    fcpatternelt_alloc = elt_count;
+    fcpatternelts = t;
+
+    tl = malloc(vallist_count * sizeof(FcValueList));
+    if (!tl)
+	return FcFalse;
+    FcMemAlloc (FC_MEM_VALLIST, 
+		sizeof (FcValueList)*vallist_count);
+    fcvaluelist_alloc = vallist_count; 
+    fcvaluelists = tl;
+
+    for (i = FcSetSystem; i <= FcSetApplication; i++)
+    {
+        if (config->fonts[i])
+            for (j = 0; j < config->fonts[i]->nfont; j++)
+                FcPatternSerialize(config->fonts[i]->fonts[j]);
+    }
+
+    return FcTrue;
+}
+
+/* FcPattern */
+FcBool
+FcPatternRead (int fd, FcMmap metadata)
+{
+    int c = metadata.pattern_length;
+    off_t w = metadata.pattern_offset;
+
+    fcpatterns = mmap(metadata.patterns_addr, 
+                      c * sizeof(FcPattern), PROT_READ, 
+                      MAP_SHARED | MAP_FIXED, fd, w);
+    fcpattern_alloc = c;
+    return (fcpatterns != MAP_FAILED);
+}
+
+FcBool
+FcPatternFixup (int fd, FcMmap *metadata)
+{
+    int c = metadata->pattern_length, i, ptr;
+    off_t w = metadata->pattern_offset;
+
+    if (fcpatterns)
+	free(fcpatterns);
+
+    fcpatterns = mmap(NULL, c * sizeof(FcPattern), 
+                      PROT_READ | PROT_WRITE, MAP_SHARED, fd, w);
+    if (fcpatterns == MAP_FAILED)
+	return FcFalse;
+    metadata->patterns_addr = fcpatterns;
+
+    for (i = 0, ptr = 0; i < c; i++)
+    {
+	if (fcpatterns[i].num > 0)
+	{
+	    fcpatterns[i].elts = &fcpatternelts[ptr];
+	    ptr += fcpatterns[i].num;
+	}
+	else
+	    fcpatterns[i].elts = 0;
+    }
+
+    munmap (fcpatterns, c * sizeof(FcPattern));
+    return FcTrue;
+}
+
+FcBool
+FcPatternWrite (int fd, FcMmap *metadata)
+{
+    int c = fcpattern_ptr;
+    off_t w = FcMmapNextOffset(fd);
+
+    metadata->pattern_offset = w;
+    metadata->pattern_length = c;
+
+    lseek(fd, w, SEEK_SET);
+    return write(fd, fcpatterns, c*sizeof(FcPattern));
+}
+
+static FcBool
+FcPatternSerialize (FcPattern * p)
+{
+    FcPatternElt *e, *nep;
+    FcValueList *nv;
+    FcValueList *v;
+    int nv_head;
+    int i;
+
+    nep = &fcpatternelts[fcpatternelt_ptr];
+    fcpatternelt_ptr += p->num;
+    if (!nep)
+	return FcFalse;
+
+    for (e = p->elts, i=0; i < p->num; i++, e++) 
+    {
+        v = e->values;
+        nv_head = FcValueListSerialize(v);
+        nv = &fcvaluelists[nv_head];
+        if (nv_head < 0)
+            goto bail;
+
+        for (; v; v = v->next)
+        {
+	    if (v->next)
+	    {
+                int nvv = FcValueListSerialize(v->next);
+                nv->next = fcvaluelists + nvv;
+                nv = nv->next;
+	    }
+        }
+
+	nep[i].values = &fcvaluelists[nv_head];
+	nep[i].object = FcObjectStaticName(e->object);
+    }
+
+    free (p->elts);
+    FcMemFree (FC_MEM_PATELT, sizeof(FcPatternElt)*p->size);
+    p->elts = nep;
+    p->size = p->num;
+
+    fcpatterns[fcpattern_ptr++] = *p;
+    return FcTrue;
+
+ bail:
+    return FcFalse;
+}
+
+/* FcPatternElt */
+FcBool
+FcPatternEltRead (int fd, FcMmap metadata)
+{
+    int c = metadata.patternelt_length;
+    off_t w = metadata.patternelt_offset;
+
+    fcpatternelts = mmap(metadata.patternelts_addr, 
+			 c * sizeof(FcPatternElt), 
+			 PROT_READ, MAP_SHARED | MAP_FIXED, fd, w);
+    if (fcpatternelts != metadata.patternelts_addr)
+        return FcFalse;
+
+    fcpatternelt_alloc = c;
+    return FcTrue;
+}
+
+FcBool
+FcPatternEltFixup (int fd, FcMmap *metadata)
+{
+    int c = metadata->patternelt_length, i, counter = 0;
+    off_t w = metadata->patternelt_offset;
+
+    if (fcpatternelts)
+	free(fcpatternelts);
+
+    fcpatternelts = mmap(NULL, c * sizeof(FcPatternElt), 
+			 PROT_READ | PROT_WRITE, MAP_SHARED, fd, w);
+    if (fcpatternelts == MAP_FAILED)
+	return FcFalse;
+    metadata->patternelts_addr = fcpatternelts;
+
+    for (i = 0; i < c; i++)
+    {
+        FcValueList * v = &fcvaluelists[counter];
+
+	fcpatternelts[i].object = 
+	    FcObjectStaticName(fcpatternelts[i].object);
+        fcpatternelts[i].values = v;
+        while (v)
+        {
+            v = v->next;
+            counter++;
+        }
+    }
+
+    munmap (fcpatternelts, c * sizeof(FcPatternElt));
+    return FcTrue;
+}
+
+FcBool
+FcPatternEltWrite (int fd, FcMmap *metadata)
+{
+    int c = fcpatternelt_ptr;
+    off_t w = FcMmapNextOffset(fd);
+
+    metadata->patternelt_offset = w;
+    metadata->patternelt_length = c;
+
+    lseek(fd, w, SEEK_SET);
+    return write(fd, fcpatternelts, c*sizeof(FcPatternElt));
+}
+
+/* FcValueList */
+
+static int
+FcValueListSerialize(FcValueList *vl)
+{
+    FcValue * v;
+    int i, new;
+
+    if (!vl)
+        return -1;
+
+    new = fcvaluelist_ptr++;
+    fcvaluelists[new].value = vl->value;
+    fcvaluelists[new].binding = vl->binding;
+    fcvaluelists[new].next = 0;
+    v = &fcvaluelists[new].value;
+    switch (v->type)
+    {
+    case FcTypeString:
+        v->u.s = FcObjectStaticName(v->u.s);
+        break;
+    case FcTypeMatrix:
+        i = FcValueMatrixSerialize(v->u.m);
+        if (i < 0)
+            return -1;
+        v->u.i = i;
+        break;
+    case FcTypeCharSet:
+        i = FcValueCharSetSerialize((FcCharSet *)v->u.c);
+        if (i < 0)
+            return -1;
+        v->u.i = i;
+        break;
+    case FcTypeLangSet:
+        i = FcValueLangSetSerialize(v->u.l);
+        if (i < 0)
+            return -1;
+        v->u.i = i;
+        break;
+    default:
+        break;
+    }
+    return new;
+}
+
+static FcBool
+FcValueListWrite(int fd, FcMmap * metadata)
+{
+    int c = fcvaluelist_ptr;
+    off_t w = FcMmapNextOffset(fd);
+
+    metadata->valuelist_offset = w;
+    metadata->valuelist_length = c;
+
+    lseek(fd, w, SEEK_SET);
+    return write(fd, fcvaluelists, c * sizeof(FcValueList));
+}
+
+static FcBool
+FcValueListFixup(int fd, FcMmap * metadata)
+{
+    int c = metadata->valuelist_length, i;
+    off_t w = metadata->valuelist_offset;
+
+    if (fcvaluelists)
+	free (fcvaluelists);
+
+    fcvaluelists = mmap(NULL, c * sizeof(FcValueList), 
+			PROT_READ | PROT_WRITE, MAP_SHARED, fd, w);
+    if (fcvaluelists == MAP_FAILED)
+	return FcFalse;
+
+    metadata->valuelist_addr = fcvaluelists;
+    fcvaluelist_ptr = 0;
+
+    for (i = 0; i < c; i++)
+    {
+	FcValue *v = &fcvaluelists[i].value;
+
+        if (fcvaluelists[i].next)
+            fcvaluelists[i].next = &fcvaluelists[i+1];
+
+	switch (v->type)
+	{
+	case FcTypeMatrix:
+	    v->u.m = FcValueMatrixUnserialize(fd, *metadata, v->u.i);
+	    break;
+	case FcTypeCharSet:
+	    v->u.c = FcValueCharSetUnserialize(fd, *metadata, v->u.i);
+	    break;
+	case FcTypeLangSet:
+	    v->u.l = FcValueLangSetUnserialize(fd, *metadata, v->u.i);
+	    break;
+        case FcTypeString:
+            v->u.s = FcObjectStaticName((const char *)v->u.s);
+            break;
+	default:
+	    break;
+	}
+    }
+
+    munmap (fcvaluelists, c * sizeof(FcValueList));
+    return FcTrue;
+}
+
+static FcBool
+FcValueListRead(int fd, FcMmap metadata)
+{
+    int c = metadata.valuelist_length;
+    off_t w = metadata.valuelist_offset;
+
+    fcvaluelists = mmap(metadata.valuelist_addr, c * sizeof(FcValueList), 
+			PROT_READ, MAP_FIXED | MAP_SHARED, fd, w);
+    fcvaluelist_ptr = c;
+
+    if (fcvaluelists != metadata.valuelist_addr)
+	return FcFalse;
+    return FcTrue;
+}
+
+/* FcStrSet */
+
+static FcStrSet * strsets = 0;
+static int ** strss = 0;
+static int strset_ptr = 1, strset_alloc = 0;
+static FcChar8 * char8s = 0;
+static int char8_ptr = 1, char8_alloc = 0;
+
+static int
+FcChar8PtrSerialize(FcChar8 *s)
+{
+    int len, old;
+
+    if (!s) return 0;
+
+    len = strlen((char*)s)+1; old = char8_ptr;
+
+    if (char8_ptr+len >= char8_alloc)
+    {
+	FcChar8* t;
+	int newsize = char8_alloc * 2;
+	if (newsize < char8_ptr + len)
+	    newsize = char8_ptr + len+1;
+
+	t = realloc(char8s, newsize * sizeof(FcChar8));
+	if (!t)
+	    return -1;
+
+	t[0] = 0;
+	char8s = t;
+	char8_alloc = newsize;
+    }
+
+    if (!*s)
+	return 0;
+
+    strcpy((char *)char8s+char8_ptr, (char *)s);
+    char8_ptr += len;
+    return old;
+}
+
+int
+FcValueSerializeStrSet(FcStrSet *s)
+{
+    int * strs;
+    int i;
+
+    if (!s) return 0;
+
+    if (strset_ptr >= strset_alloc)
+    {
+	FcStrSet* t; int ** ts;
+	int newsize = strset_alloc * 2;
+	if (newsize < strset_ptr + 1)
+	    newsize = strset_ptr + 1;
+
+	t = realloc(strsets, newsize * sizeof(FcStrSet));
+	if (!t)
+	    return FcFalse;
+	ts = realloc(strss, newsize * sizeof (int**));
+	if (!ts)
+	    return FcFalse;
+	memset (t+strset_alloc, 0, 
+		sizeof(FcStrSet)*(newsize-strset_alloc));
+	memset (ts+strset_alloc, 0, sizeof(int**)*(newsize-strset_alloc));
+
+	strsets = t;
+	strss = ts;
+	strset_alloc = newsize;
+    }
+
+    strsets[strset_ptr] = *s;
+    strsets[strset_ptr].strs = 0;
+
+    strs = malloc (s->num*sizeof(int));
+    if (!strs)
+	return FcFalse;
+
+    for (i = 0; i < s->num; i++)
+    {
+	int j = FcChar8PtrSerialize(s->strs[i]);
+	if (j < 0) goto bail;
+	strs[i] = j;
+    }
+
+    strss[strset_ptr] = strs;
+
+    strset_ptr++;
+    return FcTrue;
+
+ bail:
+    free(strs);
+    return FcFalse;
+}
+
+static FcChar8*
+FcValueReadChar8(int i)
+{
+    return &char8s[i];
+}
+
+static void
+FcValueStrSetWrite(int fd, FcMmap *metadata)
+{
+    int i;
+
+    metadata->strsets_count = strset_ptr;
+    metadata->strsets_offset = FcMmapNextOffset(fd);
+    lseek (fd, metadata->strsets_offset, SEEK_SET);
+    write (fd, strsets, strset_ptr * sizeof(FcStrSet));
+    for (i = 0; i < strset_ptr; i++)
+	write(fd, strss[i], strsets[i].num * sizeof(int));
+
+    metadata->char8s_offset = FcMmapNextOffset(fd);
+    metadata->char8s_length = char8_ptr;
+    lseek (fd, metadata->char8s_offset, SEEK_SET);
+    write (fd, char8s, metadata->char8s_length * sizeof (char));
+}
+
+static FcBool
+FcValueStrSetRead(int fd, FcMmap metadata)
+{
+    int c = metadata.strsets_count, i, j;
+    off_t w = metadata.strsets_offset;
+
+    strset_ptr = c;
+    strsets = malloc(c * sizeof(FcStrSet));
+    if (!strsets)
+	goto bail;
+    strss = malloc(c * sizeof(int **));
+    if (!strss)
+	goto bail1;
+
+    lseek (fd, w, SEEK_SET);
+    read(fd, strsets, c * sizeof(FcStrSet));
+    for (i = 0; i < c; i++)
+    {
+	strss[i] = malloc (strsets[i].num * sizeof(int));
+	if (!strss[i]) goto bail1;
+	read(fd, strss[i], strsets[i].num * sizeof(int));
+    }
+
+    lseek (fd, metadata.char8s_offset, SEEK_SET);
+    char8s = malloc(metadata.char8s_length * sizeof(char));
+    if (!char8s)
+	goto bail2;
+    read (fd, char8s, metadata.char8s_length * sizeof(char));
+
+    for (i = 0; i < c; i++)
+    {
+	strsets[i].strs = malloc (strsets[i].num * sizeof(char *));
+
+	for (j = 0; j < strsets[i].num; j++)
+	    strsets[i].strs[j] = FcValueReadChar8(strss[i][j]);
+    }
+
+    /* While we need strsets and char8s, we don't need strss. */
+    for (i = 0; i < c; i++)
+    {
+        free(strss[i]);
+    }
+    free (strss);
+    strss = 0;
+
+    return FcTrue;
+
+ bail2:
+    free(strss);
+ bail1:
+    free(strsets);
+ bail:
+    return FcFalse;
+}
+
+FcStrSet *
+FcValueMmappedStrSet(int fd, FcMmap metadata, int ssi)
+{
+    if (!strsets) FcValueStrSetRead(fd, metadata);
+    if (ssi > strset_ptr) abort();
+    return &strsets[ssi];
+}
+
+/* FcCharSet */
+static int charset_ptr = 1, charset_alloc = 0;
+static FcCharSet * charsets = 0;
+
+static int charset_leaf_ptr, charset_leaf_alloc;
+static FcChar16 * charset_numbers;
+static FcCharLeaf * charset_leaves;
+static FcCharLeaf ** charset_indices;
+
+static int
+FcValueCharSetSerialize(FcCharSet *c)
+{
+    int v = charset_ptr, vl = charset_leaf_ptr;
+    int i;
+
+    if (charset_ptr >= charset_alloc)
+    {
+	FcCharSet* st;
+	int newsize = charset_alloc * 2;
+	if (newsize < charset_ptr + 1)
+	    newsize = charset_ptr + 1;
+
+	st = realloc (charsets, newsize * sizeof(FcCharSet));
+	if (!st)
+	    return 0;
+	memset (st+charset_alloc, 0,
+		sizeof(FcCharSet)*(newsize-charset_alloc));
+
+	charsets = st;
+	charset_alloc = newsize;
+    }
+
+    if (vl+c->num >= charset_leaf_alloc)
+    {
+	FcChar16* t; FcCharLeaf * lt; FcCharLeaf ** it;
+	int newsize = charset_leaf_alloc * 2;
+	if (newsize < vl + c->num)
+	    newsize = vl + c->num;
+
+	t = realloc (charset_numbers, newsize * sizeof(FcChar16));
+	if (!t)
+	    return 0;
+	lt = realloc (charset_leaves, newsize * sizeof(FcCharLeaf));
+	if (!lt)
+	    return 0;
+	it = realloc (charset_indices, newsize * sizeof(FcCharLeaf*));
+	if (!it)
+	    return 0;
+
+	memset (t+charset_leaf_alloc, 0,
+		sizeof(FcChar16)*(newsize-charset_leaf_alloc));
+	memset (lt+charset_leaf_alloc, 0,
+		sizeof(FcCharLeaf)*(newsize-charset_leaf_alloc));
+	memset (it+charset_leaf_alloc, 0,
+		sizeof(FcCharLeaf*)*(newsize-charset_leaf_alloc));
+
+	charset_numbers = t;
+	charset_leaves = lt;
+	charset_indices = it;
+	charset_leaf_alloc = newsize;
+    }
+
+    memcpy(charset_numbers+vl, c->numbers, sizeof(FcChar16) * c->num);
+    for (i = 0; i < c->num; i++)
+    {
+	charset_indices[vl+i] = charset_leaves+vl+i;
+	memcpy(charset_leaves+vl+i, c->leaves[i], sizeof(FcCharLeaf));
+    }
+    charsets[v] = *c;
+    charsets[v].numbers = charset_numbers+vl;
+    charsets[v].leaves = charset_indices+vl;
+    charset_ptr++; charset_leaf_ptr += c->num;
+    FcCharSetDestroy(c);
+    return v;
+}
+
+static const FcCharSet *
+FcValueCharSetUnserialize(int fd, FcMmap metadata, int ci)
+{
+    if (!charsets) FcValueCharSetRead(fd, metadata);
+    return &charsets[ci];
+}
+
+static FcBool
+FcValueCharSetFixup(int fd, FcMmap *metadata)
+{
+    int i, j, count;
+    FcChar16 * numbers_ptr; FcCharLeaf ** leafidx_ptr;
+
+    if (charsets)
+	free (charsets);
+
+    charset_alloc = charset_ptr = metadata->charsets_length;
+    charsets = mmap(0, 
+                    metadata->charsets_length * sizeof (FcCharSet), 
+                    PROT_READ | PROT_WRITE, MAP_SHARED, fd, 
+                    metadata->charsets_offset);
+    if (charsets == MAP_FAILED)
+        return FcFalse;
+    metadata->charsets_addr = charsets;
+
+    if (charset_leaves)
+	free (charset_leaves);
+
+    charset_leaf_alloc = charset_leaf_ptr = metadata->charset_num_sum;
+    charset_leaves = mmap(0,
+                          metadata->charset_num_sum * sizeof (FcCharLeaf), 
+                          PROT_READ, MAP_SHARED, fd, 
+                          metadata->charset_leaf_offset);
+    if (charset_leaves == MAP_FAILED)
+        return FcFalse;
+    metadata->charset_leaf_addr = charset_leaves;
+
+    if (charset_indices)
+	free (charset_indices);
+
+    charset_leaf_ptr = charset_leaf_alloc = 
+	metadata->charset_num_sum;
+    charset_indices = mmap(0, 
+                           metadata->charset_num_sum * sizeof (FcCharLeaf *),
+                           PROT_READ | PROT_WRITE, MAP_SHARED, fd, 
+                           metadata->charset_leafidx_offset);
+    if (charset_indices == MAP_FAILED)
+        return FcFalse;
+    metadata->charset_leafidx_addr = charset_indices;
+
+    if (charset_numbers)
+	free (charset_numbers);
+
+    charset_numbers = mmap(0, 
+                           metadata->charset_num_sum * sizeof (FcChar16),
+                           PROT_READ, MAP_SHARED, fd, 
+                           metadata->charset_numbers_offset);
+    if (charset_numbers == MAP_FAILED)
+        return FcFalse;
+    metadata->charset_numbers_addr = charset_numbers;
+
+    /* now fix up charsets (-> numbers) and charset_indices' pointers */
+    for (i = count = 0, numbers_ptr = charset_numbers, 
+	     leafidx_ptr = charset_indices;
+	 i < charset_ptr; i++)
+    {
+	charsets[i].numbers = numbers_ptr;
+	charsets[i].leaves = leafidx_ptr;
+
+	for (j = 0; j < charsets[i].num; j++)
+	{
+	    leafidx_ptr[j] = &charset_leaves[count++];
+	}
+
+	numbers_ptr += charsets[i].num;
+	leafidx_ptr += charsets[i].num;
+    }
+
+    return FcTrue;
+}
+
+extern int charset_alloc;
+static FcBool
+FcValueCharSetWrite(int fd, FcMmap *metadata)
+{
+    metadata->charsets_length = charset_ptr;
+    metadata->charsets_offset = FcMmapNextOffset(fd);
+    lseek (fd, metadata->charsets_offset, SEEK_SET);
+    write (fd, charsets, charset_ptr * sizeof(FcCharSet));
+
+    metadata->charset_num_sum = charset_leaf_ptr;
+    metadata->charset_leaf_offset = FcMmapNextOffset(fd);
+    lseek (fd, metadata->charset_leaf_offset, SEEK_SET);
+    write (fd, charset_leaves, charset_leaf_ptr * sizeof(FcCharLeaf));
+
+    metadata->charset_leafidx_offset = FcMmapNextOffset(fd);
+    lseek (fd, metadata->charset_leafidx_offset, SEEK_SET);
+    write (fd, charset_indices, charset_leaf_ptr * sizeof(FcCharLeaf*));
+
+    metadata->charset_numbers_offset = FcMmapNextOffset(fd);
+    lseek (fd, metadata->charset_numbers_offset, SEEK_SET);
+    write (fd, charset_numbers, charset_leaf_ptr * sizeof(FcChar16));
+
+    return FcTrue;
+}
+
+static FcBool
+FcValueCharSetRead(int fd, FcMmap metadata)
+{
+    charset_alloc = charset_ptr = metadata.charsets_length;
+    charsets = mmap(metadata.charsets_addr, 
+                    metadata.charsets_length * sizeof (FcCharSet), 
+                    PROT_READ, MAP_FIXED | MAP_SHARED, fd, 
+                    metadata.charsets_offset);
+    if (charsets != metadata.charsets_addr)
+        return FcFalse;
+
+    charset_leaf_alloc = charset_leaf_ptr = metadata.charset_num_sum;
+
+    charset_indices = mmap(metadata.charset_leafidx_addr, 
+                           metadata.charset_num_sum * sizeof (FcCharLeaf *),
+                           PROT_READ, MAP_FIXED | MAP_SHARED, fd, 
+                           metadata.charset_leafidx_offset);
+    if (charset_indices != metadata.charset_leafidx_addr)
+        return FcFalse;
+
+    charset_leaves = mmap(metadata.charset_leaf_addr, 
+                          metadata.charset_num_sum * sizeof (FcCharLeaf), 
+                          PROT_READ, MAP_FIXED | MAP_SHARED, fd, 
+                          metadata.charset_leaf_offset);
+    if (charset_leaves != metadata.charset_leaf_addr)
+        return FcFalse;
+
+    charset_numbers = mmap(metadata.charset_numbers_addr, 
+                           metadata.charset_num_sum * sizeof (FcChar16),
+                           PROT_READ, MAP_FIXED | MAP_SHARED, fd, 
+                           metadata.charset_numbers_offset);
+    if (charset_numbers != metadata.charset_numbers_addr)
+        return FcFalse;
+
+    return FcTrue;
+}
+
+/* FcMatrix */
+
+static FcMatrix * matrices = 0;
+static int matrix_ptr = 0, matrix_alloc = 0;
+
+static int
+FcValueMatrixSerialize(const FcMatrix *m)
+{
+    if (matrix_ptr > matrix_alloc)
+    {
+	FcMatrix* t;
+	int newsize = matrix_alloc + 2;
+	t = (FcMatrix *)realloc(matrices, newsize * sizeof(FcMatrix));
+	if (!t)
+	    return -1;
+	if (matrix_alloc == 0) // valgrind doesn't like writing uninit [0].
+	    memset(t, 0, newsize*sizeof(FcMatrix));
+	matrices = t;
+	matrix_alloc = newsize;
+    }
+
+    matrices[matrix_ptr] = *m;
+    return matrix_ptr++;
+}
+
+static const FcMatrix *
+FcValueMatrixUnserialize(int fd, FcMmap metadata, int mi)
+{
+    FcMatrix * m = malloc(sizeof(FcMatrix));
+    if (!m) return 0;
+    FcMemAlloc (FC_MEM_MATRIX, sizeof(FcMatrix));
+
+    lseek(fd, metadata.matrices_offset + mi * sizeof(FcMatrix), SEEK_SET);
+    read(fd, m, sizeof(FcMatrix));
+    return m;
+}
+
+static FcBool
+FcValueMatrixWrite(int fd, FcMmap *metadata)
+{
+    int c = matrix_ptr;
+    off_t w = FcMmapNextOffset(fd);
+
+    metadata->matrices_offset = w; metadata->matrices_length = c;
+
+    lseek(fd, w, SEEK_SET);
+    return write(fd, matrices, c * sizeof(FcMatrix));
+}
+
+static FcBool
+FcValueMatrixFixup(int fd, FcMmap *metadata)
+{
+    int c = metadata->matrices_length;
+    off_t w = metadata->matrices_offset;
+
+    if (matrices)
+    {
+        free(matrices);
+        matrices = 0;
+    }
+
+    if (c)
+    {
+        matrices = mmap(NULL, c * sizeof(FcMatrix), 
+                        PROT_READ, MAP_SHARED, fd, w);
+        if (matrices == MAP_FAILED)
+            return FcFalse;
+    }
+
+    metadata->matrices_addr = matrices;
+    return FcTrue;
+}
+
+static FcBool
+FcValueMatrixRead(int fd, FcMmap metadata)
+{
+    int c = metadata.matrices_length;
+    off_t w = metadata.matrices_offset;
+
+    if (c)
+    {
+        matrices = mmap(metadata.matrices_addr, c * sizeof(FcMatrix), 
+                        PROT_READ, MAP_FIXED | MAP_SHARED, fd, w);
+        if (matrices != metadata.matrices_addr)
+            return FcFalse;
+    }
+
+    return FcTrue;
+}
diff -Naur fontconfig-2.3.2/src/fcpat.c fontconfig-2.3.2-mmap/src/fcpat.c
--- fontconfig-2.3.2/src/fcpat.c	2005-04-21 15:38:47.000000000 +0300
+++ fontconfig-2.3.2-mmap/src/fcpat.c	2005-07-04 15:51:34.192176640 +0300
@@ -25,6 +25,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <assert.h>
+#include <sys/mman.h>
 #include "fcint.h"
 
 FcPattern *
@@ -329,13 +330,16 @@
     size = sizeof (FcValueListAlign) + n * sizeof (FcValueList);
     FcValueListFrozenCount[h->value.type]++;
     FcValueListFrozenBytes[h->value.type] += size;
-    ea = malloc (size);
+    ea = malloc (sizeof (FcValueListAlign));
     if (!ea)
 	return 0;
+    new = malloc (n * sizeof (FcValueList));
+    if (!new)
+        return 0;
+    memset(new, 0, n * sizeof (FcValueList));
     FcMemAlloc (FC_MEM_VALLIST, size);
     e = &ea->ent;
-    e->list = (FcValueList *) (ea + 1);
-    new = e->list;
+    e->list = new;
     for (l = h; l; l = l->next, new++)
     {
 	if (l->value.type == FcTypeString)
@@ -464,7 +468,6 @@
     FcPatternEnt	**bucket = &FcPatternHashTable[hash % FC_VALUE_LIST_HASH_SIZE];
     FcPatternEnt	*ent;
     int			i;
-    int			size;
 
     FcPatternTotal++;
     for (ent = *bucket; ent; ent = ent->next)
@@ -486,15 +489,18 @@
     /*
      * Compute size of pattern + elts
      */
-    size = sizeof (FcPatternEnt) + b->num*sizeof (FcPatternElt);
-    ent = malloc (size);
+    ent = malloc (sizeof (FcPatternEnt));
     if (!ent)
 	return 0;
 
-    FcMemAlloc (FC_MEM_PATTERN, size);
+    FcMemAlloc (FC_MEM_PATTERN, sizeof (FcPatternEnt));
     FcPatternUsed++;
 
-    ent->pattern.elts = (FcPatternElt *) (ent + 1);
+    ent->pattern.elts = malloc(b->num * sizeof (FcPatternElt));
+    if (!ent->pattern.elts)
+        goto bail;
+    FcMemAlloc (FC_MEM_PATELT, sizeof (FcPatternElt)*(b->num));
+
     ent->pattern.num = b->num;
     ent->pattern.size = b->num;
     ent->pattern.ref = FC_REF_CONSTANT;
@@ -509,6 +515,10 @@
     ent->next = *bucket;
     *bucket = ent;
     return &ent->pattern;
+ bail:
+    free(ent);
+    FcMemFree (FC_MEM_PATTERN, sizeof (FcPatternEnt));
+    return 0;
 }
 
 static void
@@ -535,21 +545,24 @@
 FcPatternFreeze (FcPattern *p)
 {
     FcPattern	*b, *n = 0;
-    int		size;
     int		i;
     
     if (p->ref == FC_REF_CONSTANT)
        return p;
 
-    size = sizeof (FcPattern) + p->num * sizeof (FcPatternElt);
-    b = (FcPattern *) malloc (size);
+    b = FcPatternCreate();
     if (!b)
-	return 0;
-    FcMemAlloc (FC_MEM_PATTERN, size);
+        return 0;
+
     b->num = p->num;
     b->size = b->num;
     b->ref = 1;
-    b->elts = (FcPatternElt *) (b + 1);
+
+    b->elts = malloc(b->num * sizeof (FcPatternElt));
+    if (!b->elts)
+        goto bail;
+    FcMemAlloc (FC_MEM_PATELT, sizeof (FcPatternElt)*(b->num));
+
     /*
      * Freeze object lists
      */
@@ -558,7 +571,7 @@
 	b->elts[i].object = p->elts[i].object;
 	b->elts[i].values = FcValueListFreeze (p->elts[i].values);
 	if (!b->elts[i].values)
-	    goto bail;
+	    goto bail1;
     }
     /*
      * Freeze base
@@ -571,7 +584,10 @@
 	printf ("Patterns:   total %9d used %9d\n", FcPatternTotal, FcPatternUsed);
     }
 #endif
-bail:
+ bail1:
+    free (b->elts);
+    FcMemFree (FC_MEM_PATELT, sizeof (FcPatternElt)*(b->num));
+ bail:
     free (b);
 #ifdef DEBUG
     assert (FcPatternEqual (n, p));
@@ -632,12 +648,20 @@
     {
 	i = -i - 1;
     
-	/* grow array */
+	/* reallocate array */
 	if (p->num + 1 >= p->size)
 	{
 	    int s = p->size + 16;
 	    if (p->elts)
+	    {
 		e = (FcPatternElt *) realloc (p->elts, s * sizeof (FcPatternElt));
+		if (!e) /* maybe it was mmapped */
+		{
+		    e = malloc(s * sizeof (FcPatternElt));
+		    if (e)
+			memcpy(e, p->elts, p->num * sizeof (FcPatternElt));
+		}
+	    }
 	    else
 		e = (FcPatternElt *) malloc (s * sizeof (FcPatternElt));
 	    if (!e)
@@ -815,14 +839,11 @@
 FcPatternDel (FcPattern *p, const char *object)
 {
     FcPatternElt   *e;
-    int		    i;
 
     e = FcPatternFindElt (p, object);
     if (!e)
 	return FcFalse;
 
-    i = e - p->elts;
-    
     /* destroy value */
     FcValueListDestroy (e->values);
     
@@ -1173,30 +1194,310 @@
     return FcTrue;
 }
 
+#define OBJECT_HASH_SIZE    31
+struct objectBucket {
+    struct objectBucket	*next;
+    FcChar32		hash;
+};
+static struct objectBucket **buckets = 0;
+
 const char *
 FcObjectStaticName (const char *name)
 {
-#define OBJECT_HASH_SIZE    31
-    static struct objectBucket {
-	struct objectBucket	*next;
-	FcChar32		hash;
-    } *buckets[OBJECT_HASH_SIZE];
+    FcChar32		hash = FcStringHash ((const FcChar8 *) name);
+    struct objectBucket	**p;
+    struct objectBucket	*b;
+    const char *        nn;
+    int			size;
+
+    if (!buckets)
+    {
+        buckets = malloc(sizeof (struct objectBucket *)*OBJECT_HASH_SIZE);
+        memset (buckets, 0, sizeof (struct objectBucket *)*OBJECT_HASH_SIZE);
+    }
+
+    for (p = &buckets[hash % OBJECT_HASH_SIZE]; (b = *p); p = &(b->next))
+	if (b->hash == hash && !strcmp (name, *(char **) (b + 1)))
+	    return *((char **) (b + 1));
+    size = sizeof (struct objectBucket) + sizeof (char *) + 1;
+    b = malloc (size);
+    FcMemAlloc (FC_MEM_STATICSTR, size);
+    if (!b)
+	return NULL;
+    b->next = 0;
+    b->hash = hash;
+    nn = malloc(strlen(name)+1);
+    if (!nn)
+        goto bail;
+    *((const char **)(b+1)) = nn;
+    strcpy ((char *)nn, name);
+    *p = b;
+    return (char *) nn;
+
+ bail:
+    free(b);
+    return NULL;
+}
+
+struct objectTree {
+  struct objectTree * left, * right;
+  char * s;
+};
+
+static char * object_content;
+static char * object_content_ptr;
+int object_content_count = 0;
+
+static const char *
+FcObjectsDupString (const char * s)
+{
+     const char * r = object_content_ptr;
+     if (!s) return 0;
+
+     strcpy(object_content_ptr, s);
+     object_content_ptr += strlen(object_content_ptr)+1;
+     return r;
+}
+
+static struct objectTree *
+FcObjectTreeCreate(char * s)
+{
+    struct objectTree * new = malloc(sizeof (struct objectTree));
+    if (!new) return 0;
+    new->left = 0; new->right = 0;
+    new->s = s;
+    return new;
+}
+
+static FcBool
+FcObjectTreeInsert(struct objectTree * t, char * s)
+{
+    if (s < t->s)
+    {
+        if (t->left)
+            return FcObjectTreeInsert(t->left, s);
+        else
+        {
+            t->left = FcObjectTreeCreate(s);
+            return t->left != 0;
+        }
+    }
+    if (s > t->s)
+    {
+        if (t->right)
+            return FcObjectTreeInsert(t->right, s);
+        else
+        {
+            t->right = FcObjectTreeCreate(s);
+            return t->right != 0;
+        }
+    }
+    // already there (?)
+    return FcTrue;
+}
+
+static void
+FcObjectTreeTraverse(struct objectTree * t)
+{
+    if (t->left)
+        FcObjectTreeTraverse(t->left);
+    FcObjectsDupString(t->s);
+    if (t->right)
+        FcObjectTreeTraverse(t->right);
+}
+
+static void
+FcObjectTreeDestroy(struct objectTree * t)
+{
+    if (t->left)
+        FcObjectTreeDestroy(t->left);
+    if (t->right)
+        FcObjectTreeDestroy(t->right);
+    free(t);
+}
+
+/* does not create a fresh copy of name; assumes name in objects */
+static const char *
+FcObjectRebuildStaticName (const char *name)
+{
     FcChar32		hash = FcStringHash ((const FcChar8 *) name);
     struct objectBucket	**p;
     struct objectBucket	*b;
     int			size;
 
+    if (!buckets)
+    {
+        buckets = malloc(sizeof (struct objectBucket *)*OBJECT_HASH_SIZE);
+        memset (buckets, 0, sizeof (struct objectBucket *)*OBJECT_HASH_SIZE);
+    }
+
     for (p = &buckets[hash % OBJECT_HASH_SIZE]; (b = *p); p = &(b->next))
-	if (b->hash == hash && !strcmp (name, (char *) (b + 1)))
-	    return (char *) (b + 1);
-    size = sizeof (struct objectBucket) + strlen (name) + 1;
+	if (b->hash == hash && !strcmp (name, *(char **) (b + 1)))
+	    return name;
+    size = sizeof (struct objectBucket) + sizeof (char *) + 1;
     b = malloc (size);
     FcMemAlloc (FC_MEM_STATICSTR, size);
     if (!b)
 	return NULL;
     b->next = 0;
     b->hash = hash;
-    strcpy ((char *) (b + 1), name);
+    *((const char **)(b+1)) = name;
     *p = b;
-    return (char *) (b + 1);
+    return name;
+}
+
+static FcBool
+FcObjectsRebuildTableFromArray(void)
+{
+    char * p = object_content;
+
+    if (buckets)
+    {
+	int i;
+	for (i = 0; i < OBJECT_HASH_SIZE; i++)
+	{
+	    struct objectBucket *b, *bp;
+	    if (buckets[i] != NULL && buckets[i]->hash) 
+	    {
+		for (b = buckets[i]; b; )
+		{
+		    bp = b;
+		    b = b->next;
+		    free (bp);
+		}
+	    }
+	}
+
+	free(buckets);
+	buckets = 0;
+    }
+
+    while (p < object_content_ptr)
+    {
+        if (!FcObjectRebuildStaticName(p))
+            return FcFalse;
+        p += strlen(p)+1;
+    }
+    return FcTrue;
+}
+
+/* initialize the object_content array, preserving order */
+static FcBool
+FcObjectsPrepareSerialize (void)
+{
+    int i;
+    struct objectBucket *b;
+
+    struct objectTree *root = 0;
+    object_content_count = 0;
+
+    /* first, count the amount of memory required. */
+    /* also, create a tree of strings in memory order */
+    for (i = 0; i < OBJECT_HASH_SIZE; i++)
+    {
+        for (b = buckets[i]; b; b = b->next)
+        {
+            if (b->hash)
+            {
+                char * s = *((char**)(b+1)), *p;
+                object_content_count += strlen(s)+1;
+		p = s + strlen(s) + 1;
+
+                if (!root)
+                {
+                    root = FcObjectTreeCreate (s);
+                    if (!root)
+                        goto bail;
+                }
+                else
+                {
+                    if (!FcObjectTreeInsert (root, s))
+                        goto bail;
+                }
+            }
+        }
+    }
+
+    if (object_content)
+	free (object_content);
+
+    object_content = malloc(object_content_count);
+    object_content_ptr = object_content;
+    if (!object_content)
+        goto bail;
+
+    FcObjectTreeTraverse(root);
+
+    FcObjectsRebuildTableFromArray();
+
+    FcObjectTreeDestroy(root);
+
+    return FcTrue;
+
+ bail:
+    if (root)
+        FcObjectTreeDestroy(root);
+    return FcFalse;
+}
+
+FcBool
+FcObjectsWrite (int fd, FcMmap *metadata)
+{
+    if (!FcObjectsPrepareSerialize())
+        return FcFalse;
+
+    metadata->objects_length = object_content_count;
+    metadata->objects_offset = FcMmapNextOffset(fd); 
+    metadata->objects_addr = object_content;
+    lseek(fd, metadata->objects_offset, SEEK_SET);
+    write (fd, object_content, metadata->objects_length);
+
+    return FcTrue;
+}
+
+FcBool
+FcObjectsRead (int fd, FcMmap metadata)
+{
+    object_content = mmap((void *)metadata.objects_addr, 
+                          metadata.objects_length, 
+                          PROT_READ, 
+                          MAP_FIXED | MAP_SHARED, fd, metadata.objects_offset);
+    if (object_content == MAP_FAILED)
+        goto bail;
+    object_content_count = metadata.objects_length;
+    object_content_ptr = object_content + object_content_count;
+
+    if (!FcObjectsRebuildTableFromArray())
+        goto bail1;
+
+    return FcTrue;
+
+ bail1:
+    munmap(object_content, metadata.objects_length);
+ bail:
+    return FcFalse;
+}
+
+/* change all of the object addresses */
+FcBool
+FcObjectsFixup (int fd, FcMmap * metadata)
+{
+    object_content_count = metadata->objects_length;
+    off_t w = metadata->objects_offset;
+
+    if (object_content)
+	free (object_content);
+
+    object_content = mmap(NULL, object_content_count, PROT_READ, 
+                          MAP_SHARED, fd, w);
+    if (object_content == MAP_FAILED)
+	return FcFalse;
+    object_content_ptr = object_content + object_content_count;
+
+    metadata->objects_addr = object_content;
+
+    if (!FcObjectsRebuildTableFromArray())
+        return FcFalse;
+    
+    return FcTrue;
 }
