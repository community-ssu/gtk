/* -*- Mode: C; c-basic-offset: 4 -*- */
 * vi:si:et:sw=4:sts=4:ts=4
 *
 * gst-python
 * Copyright (C) 2004 Johan Dahlin
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 * 
 * Author: Johan Dahlin <johan@gnome.org
 */
%%
headers

/* we need to do this until PyClosures get exception handlers */
#ifndef pyg_closure_set_exception_handler
#  define pyg_closure_set_exception_handler(ig, nore)
#  define EXCEPTION_HANDLER G_GNUC_UNUSED
#else
#  define EXCEPTION_HANDLER
#endif
#define SET_PAD_CLOSURE(self, args, kwargs, name) \
    static char *kwlist[] = { G_STRINGIFY (name), NULL }; \
    PyObject *function; \
    GstPad *pad; \
    GClosure *closure; \
    PyGstPadPrivate *priv; \
\
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, \
                     "O:GstPad.set_" G_STRINGIFY (name), \
                     kwlist, \
                     &function)) { \
        return NULL; \
    } \
\
    if (!PyCallable_Check(function)) { \
        PyErr_SetString(PyExc_TypeError, G_STRINGIFY (name) " not callable"); \
        return NULL; \
    } \
\
    closure = pyg_closure_new (function, NULL, NULL); \
    pyg_closure_set_exception_handler (closure, handle_ ## name ## _exception); \
    pygobject_watch_closure((PyObject *)self, closure); \
    priv = py_pad_private(self);\
    if (priv->name) { \
      g_closure_invalidate (priv->name); \
      g_closure_unref (priv->name); \
    } \
    priv->name = closure; \
    pad = (GstPad*)pygobject_get(self); \
    gst_pad_set_ ## name (pad, call_ ## name); \
\
    Py_INCREF(Py_None); \
    return Py_None;
    
static void
free_pad_private (gpointer data)
{
  PyGstPadPrivate *private = data;
#define INVALIDATE_CLOSURE(closure) \
  if (closure) { \
    g_closure_invalidate (closure); \
    g_closure_unref (closure); \
    closure = NULL; \
  } 
  INVALIDATE_CLOSURE (private->link_function)
  INVALIDATE_CLOSURE (private->event_function)
  INVALIDATE_CLOSURE (private->chain_function)
  INVALIDATE_CLOSURE (private->get_function)
  INVALIDATE_CLOSURE (private->getcaps_function)
#undef INVALIDATE_CLOSURE
}

static PyGstPadPrivate*
pad_private(GstPad *pad)
{
    PyGstPadPrivate *private;
    static GQuark padprivate = 0;

    if (!padprivate)
        padprivate = g_quark_from_static_string ("PyGst::PadPrivate");
    private = g_object_get_qdata (G_OBJECT (pad), padprivate);
    if (private == NULL) {
        private = g_new0(PyGstPadPrivate, 1);
        private->pad = (PyGObject *) pygobject_new (G_OBJECT (pad));
        Py_DECREF (private->pad);
        g_object_set_qdata_full (G_OBJECT (pad), padprivate, private, free_pad_private);
    }
    return private;
}
    
static PyGstPadPrivate*
py_pad_private(PyGObject *pad)
{
    return pad_private ((GstPad *)pygobject_get(pad));
}

static gboolean
probe_handler_marshal(GstPad *pad, GstMiniObject *data, gpointer user_data)
{
    PyGILState_STATE state;
    PyObject *callback, *args;
    PyObject *ret;
    PyObject *py_data;
    PyObject *py_user_data;
    PyObject *repr;
    gboolean res;
    gint len, i;

    g_return_val_if_fail(user_data != NULL, FALSE);

    GST_LOG_OBJECT (pad, "marshalling probe handler for object %"
        GST_PTR_FORMAT, data);
    state = pyg_gil_state_ensure();

    py_user_data = (PyObject *) user_data;

    py_data = pygstminiobject_new(data);

    callback = PyTuple_GetItem(py_user_data, 0);
    args = Py_BuildValue("(NN)",
             pygobject_new(G_OBJECT(pad)),
             py_data);

    len = PyTuple_Size(py_user_data);
    for (i = 1; i < len; ++i) {
        PyObject *tuple = args;
        args = PySequence_Concat(tuple, PyTuple_GetItem(py_user_data, i));
        Py_DECREF(tuple);
    }
    repr = PyObject_Repr (callback);
    GST_LOG_OBJECT (pad, "calling callback %s", PyString_AsString (repr));
    Py_DECREF (repr);

    ret = PyObject_CallObject(callback, args);

    if (!ret) {
        PyErr_Print();
        res = TRUE;
    } else {
        res = PyObject_IsTrue(ret);
        Py_DECREF(ret);
    }
    Py_DECREF(args);
    pyg_gil_state_release(state);

    return res;
}
%%
ignore
  gst_pad_select
  gst_pad_selectv
  gst_pad_new_from_template
  gst_pad_load_and_link
%%
override gst_pad_set_getcaps_function kwargs

static void EXCEPTION_HANDLER
handle_getcaps_function_exception (GValue *ret, guint n, const GValue *params)
{
  g_value_set_boxed (ret, gst_pad_get_pad_template_caps (
      GST_PAD (g_value_get_object (&params[0]))));
  PyErr_Clear ();
}

static GstCaps *
call_getcaps_function (GstPad *pad)
{
    GClosure *closure;
    GValue ret = { 0, };
    GValue args = { 0, };
    GstCaps *caps;
    
    g_value_init (&ret, GST_TYPE_CAPS);
    g_value_init (&args, GST_TYPE_PAD);
    g_value_set_object (&args, pad);
    
    closure = pad_private(pad)->getcaps_function;
    
    g_closure_invoke (closure, &ret, 1, &args, NULL);

    caps = g_value_dup_boxed (&ret);
    g_value_unset (&ret);
    g_value_unset (&args);
    return caps;
}

static PyObject*
_wrap_gst_pad_set_getcaps_function (PyGObject *self,
        PyObject  *args,
        PyObject  *kwargs)
{
    SET_PAD_CLOSURE (self, args, kwargs, getcaps_function)
}

%%
override gst_pad_set_link_function kwargs

static void EXCEPTION_HANDLER
handle_link_function_exception (GValue *ret, guint n, const GValue *params)
{
  g_value_set_enum (ret, GST_PAD_LINK_REFUSED);
  PyErr_Clear ();
}

static GstPadLinkReturn
call_link_function (GstPad *pad, GstPad *peer)
{
    GClosure *closure;
    GValue ret = { 0, };
    GValue args[2] = { { 0, }, {0, } };
    GstPadLinkReturn i;
    
    g_value_init (&ret, GST_TYPE_PAD_LINK_RETURN);
    g_value_init (&args[0], GST_TYPE_PAD);
    g_value_init (&args[1], GST_TYPE_PAD);
    g_value_set_object (&args[0], pad);
    g_value_set_object (&args[1], peer);
    
    closure = pad_private(pad)->link_function;
    
    g_closure_invoke (closure, &ret, 2, args, NULL);

    i = g_value_get_enum (&ret);
    g_value_unset (&ret);
    g_value_unset (&args[0]);
    g_value_unset (&args[1]);
    return i;
}

static PyObject*
_wrap_gst_pad_set_link_function (PyGObject *self,
        PyObject  *args,
        PyObject  *kwargs)
{
    SET_PAD_CLOSURE (self, args, kwargs, link_function)
}

%%
override gst_pad_set_chain_function kwargs

static void EXCEPTION_HANDLER
handle_chain_function_exception (GValue *ret, guint n, const GValue *params)
{
  GstElement *element = GST_ELEMENT (gst_object_get_parent (g_value_get_object (&params[0])));
  
  if (!_pygst_element_check_error (element)) {
    g_assert_not_reached (); /* only returns FALSE when there's no error */
  }
}

static GstFlowReturn
call_chain_function(GstPad *pad, GstBuffer *buffer)
{
    GClosure *closure;
    GValue ret = { 0, };
    GValue args[2] = { { 0, }, { 0, } };
    GstFlowReturn    flow;
    
    g_value_init (&ret, GST_TYPE_FLOW_RETURN);
    g_value_set_enum (&ret, GST_FLOW_ERROR);
    g_value_init (&args[0], GST_TYPE_PAD);
    g_value_init (&args[1], GST_TYPE_BUFFER);

    g_value_set_object (&args[0], pad);
    gst_value_set_mini_object (&args[1], GST_MINI_OBJECT (buffer));
    closure = pad_private(pad)->chain_function;
    
    g_closure_invoke (closure, &ret, 2, args, NULL);
    flow = g_value_get_enum (&ret);

    g_value_unset (&ret);
    g_value_unset (&args[0]);
    g_value_unset (&args[1]);

    /* a chain function takes over the ref of the buffer handed to it;
     * so we should unref after calling the pythonic chain func */
    gst_buffer_unref (buffer);
    return flow;
}

static PyObject*
_wrap_gst_pad_set_chain_function(PyGObject *self,
                PyObject  *args,
                PyObject  *kwargs)
{
    SET_PAD_CLOSURE (self, args, kwargs, chain_function)
}

%%
override gst_pad_set_event_function kwargs

static void EXCEPTION_HANDLER
handle_event_function_exception (GValue *ret, guint n, const GValue *params)
{
  GstElement *element = GST_ELEMENT (gst_pad_get_parent (g_value_get_object (&params[0])));
  
  if (!_pygst_element_check_error (element)) {
    g_assert_not_reached (); /* only returns FALSE when there's no error */
  }
}

static gboolean
call_event_function (GstPad *pad, GstEvent *event)
{
    GClosure *closure;
    GValue ret = { 0, };
    GValue args[2] = { { 0, }, { 0, } };
    gboolean bool;
    
    g_value_init (&ret, G_TYPE_BOOLEAN);
    g_value_set_boolean (&ret, FALSE);
    g_value_init (&args[0], GST_TYPE_PAD);
    g_value_init (&args[1], GST_TYPE_EVENT);
    g_value_set_object (&args[0], pad);
    gst_value_set_mini_object (&args[1], GST_MINI_OBJECT (event));
    closure = pad_private(pad)->event_function;
    
    g_closure_invoke (closure, &ret, 2, args, NULL);

    bool = g_value_get_boolean (&ret);

    g_value_unset (&ret);
    g_value_unset (&args[0]);
    g_value_unset (&args[1]);
    return bool;
}

static PyObject*
_wrap_gst_pad_set_event_function (PyGObject *self,
                  PyObject  *args,
                  PyObject  *kwargs)
{
    SET_PAD_CLOSURE (self, args, 
		     kwargs, event_function)
}

%%
override-slot GstPad.tp_repr
static PyObject *
_wrap_gst_pad_tp_repr (PyGObject *self)
{
    char *buf;
    PyObject *retval;
    GstPad *pad;
    GstElement *parent;
    gchar *padname = NULL;
    gchar *elementname = NULL;

    pad = GST_PAD(self->obj);
    parent = GST_ELEMENT (gst_pad_get_parent (pad));
        
    padname = gst_pad_get_name (pad);
    if (parent)
	elementname = gst_element_get_name (parent);

    buf = g_strdup_printf ("<GstPad (%s:%s) at %lx>",
        parent ? elementname : "---",
        padname, (long) self->obj);

    if (parent) {
        gst_object_unref (parent);
	g_free(elementname);
    }
    g_free(padname);

    retval = PyString_FromString(buf);
    g_free(buf);
    return retval;
}

%%
override gst_pad_query kwargs
static PyObject *
_wrap_gst_pad_query(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "query", NULL };
    int ret;
    PyGstMiniObject *query;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GstPad.query", kwlist, &PyGstQuery_Type, &query))
        return NULL;

    ret = gst_pad_query(GST_PAD(self->obj), GST_QUERY (query->obj));

    return PyBool_FromLong(ret);   
}
%%
override gst_pad_convert kwargs
static PyObject *
_wrap_gst_pad_convert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "src_format", "src_value",
                  "dest_format", NULL };
    GstFormat src_format, dest_format;
    PyObject *src_value_obj;
    gint64 src_value, dest_value = 0;
    gboolean ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                     "iOi:GstPad.convert", kwlist,
                     &src_format, &src_value_obj,
                     &dest_format))
        return NULL;
    
    src_value = PyLong_AsLongLong(src_value_obj);
    
    ret = gst_pad_convert(GST_PAD(self->obj), src_format, src_value,
                  &dest_format, &dest_value);
    return PyLong_FromLongLong(dest_value);
}
%%
override gst_pad_link kwargs
static PyObject *
_wrap_gst_pad_link(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "sinkpad", NULL };
    PyGObject *sinkpad;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GstPad.link", kwlist,
                                     &PyGstPad_Type, &sinkpad))
        return NULL;
    ret = gst_pad_link(GST_PAD(self->obj), GST_PAD(sinkpad->obj));
    if (ret) {
        PyObject *exc_val = pyg_enum_from_gtype(GST_TYPE_PAD_LINK_RETURN, ret);
        PyErr_SetObject(PyGstExc_LinkError, exc_val);
        Py_DECREF(exc_val);
        return NULL;
    }
    return PyBool_FromLong(ret);
}

%%
override gst_pad_link_filtered kwargs
static PyObject *
_wrap_gst_pad_link_filtered(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "sinkpad", "filtercaps", NULL };
    PyGObject *sinkpad;
    PyObject *py_filtercaps;
    int ret;
    GstCaps *filtercaps = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!O:GstPad.link_filtered",
                                     kwlist, &PyGstPad_Type, &sinkpad,
                                     &py_filtercaps))
        return NULL;
    if (pyg_boxed_check(py_filtercaps, GST_TYPE_CAPS))
        filtercaps = pyg_boxed_get(py_filtercaps, GstCaps);
    else {
        PyErr_SetString(PyExc_TypeError, "filtercaps should be a GstCaps");
        return NULL;
    }
    ret = gst_pad_link_filtered(GST_PAD(self->obj),
                                GST_PAD(sinkpad->obj),
                                filtercaps);
    if (ret) {
        PyObject *exc_val = pyg_enum_from_gtype(GST_TYPE_PAD_LINK_RETURN, ret);
        PyErr_SetObject(PyGstExc_LinkError, exc_val);
        Py_DECREF(exc_val);
        return NULL;
    }
    return PyBool_FromLong(ret);
}
%%
override gst_pad_get_pad_template_caps noargs
static PyObject *
_wrap_gst_pad_get_pad_template_caps(PyGObject *self)
{
    GstCaps *ret = (GstCaps*)gst_pad_get_pad_template_caps(GST_PAD(self->obj));
    return pyg_boxed_new(GST_TYPE_CAPS, ret, TRUE, TRUE);
}
%%
override gst_pad_template_get_caps noargs
static PyObject *
_wrap_gst_pad_template_get_caps(PyGObject *self)
{
    GstCaps *ret = (GstCaps*)gst_pad_template_get_caps(GST_PAD_TEMPLATE(self->obj));
    return pyg_boxed_new(GST_TYPE_CAPS, ret, TRUE, TRUE);
}
%%
override gst_pad_template_get_caps_by_name kwargs
static PyObject *
_wrap_gst_pad_template_get_caps_by_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", NULL };
    char *name;
    GstCaps *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s:GstPadTemplate.get_caps_by_name", kwlist, &name))
        return NULL;
    ret = (GstCaps*)gst_pad_template_get_caps_by_name(GST_PAD_TEMPLATE(self->obj), name);
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GST_TYPE_CAPS, ret, TRUE, TRUE);
}
%%
new-constructor GST_TYPE_PAD
%%
override gst_pad_new kwargs
static int
_wrap_gst_pad_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", "direction", NULL };
    static char *kwlist2[] = { "template", "name", NULL };
    PyGObject *templ;
    char *name = NULL;
    PyObject *py_direction = NULL;
    GstPadDirection direction;

    if (PyArg_ParseTupleAndKeywords (args, kwargs, "zO:GstPad.__init__",
                                     kwlist, &name, &py_direction)) {

        GST_LOG ("gst.Pad.__init__: using gst_pad_new");
        if (pyg_enum_get_value (GST_TYPE_PAD_DIRECTION, py_direction,
                                (gint *) &direction)) {
            GST_LOG ("gst.Pad.__init__: direction is not valid");
            return -1;
        }

        self->obj = (GObject *) gst_pad_new (name, direction);
    } else {
        PyErr_Clear ();

        GST_LOG ("gst.Pad.__init__: using gst_pad_new_from_template");
        if (PyArg_ParseTupleAndKeywords (args, kwargs, "O!|s:GstPad.__init__",
                                         kwlist2, &PyGstPadTemplate_Type,
                                         &templ, &name)) {
            if (name == NULL) 
                name = GST_PAD_TEMPLATE_NAME_TEMPLATE (GST_PAD_TEMPLATE (
                    templ->obj));
            self->obj = (GObject *) gst_pad_new_from_template (
                GST_PAD_TEMPLATE (templ->obj), name);
        }
    }
    if (!self->obj) {
      PyErr_SetString (PyExc_RuntimeError, "could not create GstPad object");
      return -1;
    }
    pygobject_register_wrapper ((PyObject *)self);
    return 0;
}
%%
override gst_pad_add_data_probe args
static PyObject *
_wrap_gst_pad_add_data_probe(PyGObject *self, PyObject *args)
{
    PyObject *callback, *cbargs = NULL, *data;
    gulong sigid;
    gint len;

    len = PyTuple_Size(args);

    if (len < 1) {
        PyErr_SetString(PyExc_TypeError, "Probe requires at least 1 arg");
        return NULL;
    }
    callback = PySequence_GetItem(args, 0);
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "callback is not callable");
        return NULL;
    }
    cbargs = PySequence_GetSlice(args, 1, len);
    if (cbargs == NULL)
        return NULL;
    data = Py_BuildValue("(ON)", callback, cbargs);
    if (data == NULL)
        return NULL;
    sigid = gst_pad_add_data_probe (GST_PAD (self->obj), (GCallback) probe_handler_marshal, data);

    return PyLong_FromUnsignedLong(sigid);
}
%%
override gst_pad_add_event_probe args
static PyObject *
_wrap_gst_pad_add_event_probe(PyGObject *self, PyObject *args)
{
    PyObject *callback, *cbargs = NULL, *data;
    gulong sigid;
    gint len;

    len = PyTuple_Size(args);

    if (len < 1) {
        PyErr_SetString(PyExc_TypeError, "Probe requires at least 1 arg");
        return NULL;
    }
    callback = PySequence_GetItem(args, 0);
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "callback is not callable");
        return NULL;
    }
    cbargs = PySequence_GetSlice(args, 1, len);
    if (cbargs == NULL)
        return NULL;
    data = Py_BuildValue("(ON)", callback, cbargs);
    if (data == NULL)
        return NULL;
    sigid = gst_pad_add_event_probe (GST_PAD (self->obj), (GCallback) probe_handler_marshal, data);

    return PyLong_FromUnsignedLong(sigid);
}
%%
override gst_pad_add_buffer_probe args
static PyObject *
_wrap_gst_pad_add_buffer_probe(PyGObject *self, PyObject *args)
{
    PyObject *callback, *cbargs = NULL, *data;
    gulong sigid;
    gint len;

    len = PyTuple_Size(args);

    if (len < 1) {
        PyErr_SetString(PyExc_TypeError, "Probe requires at least 1 arg");
        return NULL;
    }
    callback = PySequence_GetItem(args, 0);
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "callback is not callable");
        return NULL;
    }
    cbargs = PySequence_GetSlice(args, 1, len);
    if (cbargs == NULL)
        return NULL;
    data = Py_BuildValue("(ON)", callback, cbargs);
    if (data == NULL)
        return NULL;
    sigid = gst_pad_add_buffer_probe (GST_PAD (self->obj), (GCallback) probe_handler_marshal, data);

    return PyLong_FromUnsignedLong(sigid);
}
%%
override-slot GstPadTemplate.tp_getattr
#define IS_ATTR(name) (strcmp (name, attr) == 0)
PyObject *
_wrap_gst_pad_template_tp_getattr(PyObject *self, char *attr)
{
  GstPadTemplate *templ = GST_PAD_TEMPLATE (pygobject_get (self));
  
  if (IS_ATTR ("__members__")) {
    return Py_BuildValue("[ssss]", "name_template", "direction", "presence", "caps" );
  } else if (IS_ATTR ("name_template")) {
    return PyString_FromString (GST_PAD_TEMPLATE_NAME_TEMPLATE(templ));
  } else if (IS_ATTR ("direction")) {
    return pyg_enum_from_gtype(GST_TYPE_PAD_DIRECTION, GST_PAD_TEMPLATE_DIRECTION(templ));
  } else if (IS_ATTR ("presence")) {
    return pyg_enum_from_gtype(GST_TYPE_PAD_PRESENCE, GST_PAD_TEMPLATE_PRESENCE(templ));
  } else if (IS_ATTR ("caps")) {
    return pyg_boxed_new (GST_TYPE_CAPS, GST_PAD_TEMPLATE_CAPS(templ), TRUE, TRUE);
  }
  return Py_FindMethod((PyMethodDef*) _PyGstPadTemplate_methods, self, attr);
}
%%
override gst_pad_query_position args
static PyObject *
_wrap_gst_pad_query_position (PyGObject *self, PyObject *args)
{
    gint64    cur;
    gint    format;
    PyObject    *pformat;
    PyObject    *ret;

    pformat = (PyObject*)PyTuple_GetItem(args, 0);
    if (pyg_enum_get_value (GST_TYPE_FORMAT, pformat, &format)) {
        PyErr_SetString(PyExc_TypeError, "argument should be a GstFormat");
        return NULL;
    }

    if ((gst_pad_query_position(GST_PAD (self->obj), (GstFormat*) &format, &cur))) {
	ret = Py_BuildValue("(LO)", cur,
			    pyg_enum_from_gtype (GST_TYPE_FORMAT, format));
    } else {
        Py_INCREF(Py_None);
        ret = Py_None;
    }

    return ret;
}
%%
override gst_pad_query_duration args
static PyObject *
_wrap_gst_pad_query_duration (PyGObject *self, PyObject *args)
{
    gint64    cur;
    gint    format;
    PyObject    *pformat;
    PyObject    *ret;

    pformat = (PyObject*)PyTuple_GetItem(args, 0);
    if (pyg_enum_get_value (GST_TYPE_FORMAT, pformat, &format)) {
        PyErr_SetString(PyExc_TypeError, "argument should be a GstFormat");
        return NULL;
    }

    if ((gst_pad_query_duration(GST_PAD (self->obj), (GstFormat*) &format, &cur))) {
	ret = Py_BuildValue("(LO)", cur,
			    pyg_enum_from_gtype (GST_TYPE_FORMAT, format));
    } else {
        Py_INCREF(Py_None);
        ret = Py_None;
    }

    return ret;
}
%%
override gst_pad_query_convert kwargs
static PyObject *
_wrap_gst_pad_query_convert (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "fromformat", "fromvalue", "destformat", NULL };
    PyObject    *pfromformat, *pdestformat;
    GstFormat    srcformat, destformat;
    gint64    fromval, dstval;

    /* Input : src_format, src_val, dst_format */
    /* Returns : dst_format, dst_val OR None */

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                     "0L0:GstPad.query_convert",
                     kwlist, &pfromformat, &fromval, &pdestformat))
    return NULL;
    if (pyg_enum_get_value(GST_TYPE_FORMAT, pfromformat, (gint *) &srcformat)) {
    PyErr_SetString(PyExc_TypeError, "argument should be a GstFormat");
    return NULL;
    }
    if (pyg_enum_get_value(GST_TYPE_FORMAT, pdestformat, (gint *) &destformat)) {
    PyErr_SetString(PyExc_TypeError, "argument should be a GstFormat");
    return NULL;
    }

    if (!(gst_pad_query_convert (GST_PAD(self->obj),
                 srcformat, fromval,
                 &destformat, &dstval))) {
    Py_INCREF(Py_None);
    return Py_None;
    }
    
    return Py_BuildValue("(OL)",
			 pyg_enum_from_gtype (GST_TYPE_FORMAT, destformat),
			 dstval);
}
%%
override gst_pad_alloc_buffer kwargs
static PyObject *
_wrap_gst_pad_alloc_buffer (PyGObject *self, PyObject * args, PyObject *kwargs)
{
    static char *kwlist[] = {"offset", "size", "caps", NULL};
    guint64    offset;
    gint    size;
    PyObject    *pcaps;
    GstCaps    *caps;
    PyObject    *ret;
    GstBuffer    *buf;
    GstFlowReturn    res;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                     "KiO:GstPad.alloc_buffer",
                     kwlist, &offset, &size, &pcaps))
    return NULL;
    caps = pyg_boxed_get(pcaps, GstCaps);
    res = gst_pad_alloc_buffer (GST_PAD(pygobject_get(self)),
                offset, size, caps, &buf);
    ret = PyList_New(2);
    PyList_SetItem(ret, 0, pyg_enum_from_gtype(GST_TYPE_FLOW_RETURN, res));
    if (res != GST_FLOW_OK) {
        PyList_SetItem(ret, 1, Py_None);
    } else {
        PyList_SetItem(ret, 1, pygstminiobject_new(GST_MINI_OBJECT(buf)));
    }
    return ret;
}
%%
override gst_pad_alloc_buffer_and_set_caps kwargs
static PyObject *
_wrap_gst_pad_alloc_buffer_and_set_caps (PyGObject *self, PyObject * args, PyObject *kwargs)
{
    static char *kwlist[] = {"offset", "size", "caps", NULL};
    guint64    offset;
    gint    size;
    PyObject    *pcaps;
    GstCaps    *caps;
    PyObject    *ret;
    GstBuffer    *buf;
    GstFlowReturn    res;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                     "KiO:GstPad.alloc_buffer_and_set_caps",
                     kwlist, &offset, &size, &pcaps))
    return NULL;
    caps = pyg_boxed_get(pcaps, GstCaps);
    res = gst_pad_alloc_buffer_and_set_caps (GST_PAD(pygobject_get(self)),
                offset, size, caps, &buf);
    ret = PyList_New(2);
    PyList_SetItem(ret, 0, pyg_enum_from_gtype(GST_TYPE_FLOW_RETURN, res));
    if (res != GST_FLOW_OK) {
        PyList_SetItem(ret, 1, Py_None);
    } else {
        PyList_SetItem(ret, 1, pygstminiobject_new(GST_MINI_OBJECT(buf)));
    }
    return ret;
}
%%
override gst_pad_pull_range kwargs
static PyObject *
_wrap_gst_pad_pull_range (PyGObject *self, PyObject * args, PyObject *kwargs)
{
    static char *kwlist[] = {"offset", "size", NULL};
    guint64    offset;
    gint    size;
    PyObject    *ret;
    GstBuffer    *buf;
    GstFlowReturn    res;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                     "Ki:GstPad.pull_range",
                     kwlist, &offset, &size))
    return NULL;
    res = gst_pad_pull_range (GST_PAD(pygobject_get(self)),
                  offset, size, &buf);
    ret = PyList_New(2);
    PyList_SetItem(ret, 0, pyg_enum_from_gtype(GST_TYPE_FLOW_RETURN, res));
    if (res != GST_FLOW_OK) {
        PyList_SetItem(ret, 1, Py_None);
    } else {
        PyList_SetItem(ret, 1, pygstminiobject_new(GST_MINI_OBJECT(buf)));
    }
    return ret;
}
%%
override gst_pad_get_range kwargs
static PyObject *
_wrap_gst_pad_get_range (PyGObject *self, PyObject * args, PyObject *kwargs)
{
    static char *kwlist[] = {"offset", "size", NULL};
    guint64    offset;
    gint    size;
    PyObject    *ret;
    GstBuffer    *buf;
    GstFlowReturn    res;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                     "Ki:GstPad.get_range",
                     kwlist, &offset, &size))
    return NULL;
    res = gst_pad_get_range (GST_PAD(pygobject_get(self)),
                 offset, size, &buf);
    ret = PyList_New(2);
    PyList_SetItem(ret, 0, pyg_enum_from_gtype(GST_TYPE_FLOW_RETURN, res));
    if (res != GST_FLOW_OK) {
        PyList_SetItem(ret, 1, Py_None);
    } else {
        PyList_SetItem(ret, 1, pygstminiobject_new(GST_MINI_OBJECT(buf)));
    }
    return ret;
}
%%
override gst_pad_get_internal_links noargs
static PyObject *
_wrap_gst_pad_get_internal_links (PyGObject * self)
{
    PyObject    *ret;
    GList    *lst, *tmp;
    gint i;

    lst = gst_pad_get_internal_links (GST_PAD (pygobject_get(self)));

    ret = PyList_New(g_list_length(lst));
    for (tmp = lst, i = 0 ; tmp; tmp = g_list_next(tmp), ++i) {
        PyList_SetItem(ret, i, pygobject_new(G_OBJECT(tmp->data)));
    }
    g_list_free(lst);
    return ret;
}
%%
override gst_pad_get_internal_links_default noargs
static PyObject *
_wrap_gst_pad_get_internal_links_default (PyGObject * self)
{
    PyObject    *ret;
    GList    *lst, *tmp;
    gint i;

    lst = gst_pad_get_internal_links_default (GST_PAD (pygobject_get(self)));

    ret = PyList_New(g_list_length(lst));
    for (tmp = lst, i = 0 ; tmp; tmp = g_list_next(tmp), ++i) {
        PyList_SetItem(ret, i, pygobject_new(G_OBJECT(tmp->data)));
    }
    g_list_free(lst);
    return ret;
}
%%
override gst_pad_get_query_types noargs
static PyObject *
_wrap_gst_pad_get_query_types (PyGObject *self)
{
    PyObject    *ret;
    PyObject    *item;
    int        i;
    GstQueryType    *tab;

    tab = (GstQueryType*) gst_pad_get_query_types(GST_PAD(self->obj));
    if (tab == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
    }

    ret = PyList_New(0);
    for (i = 0; tab[i] != 0; i++) {
        item = pyg_enum_from_gtype (GST_TYPE_QUERY_TYPE, tab[i]);
        PyList_Append(ret, item);
        Py_XDECREF(item);
    }
    
    return ret;
}
%%
override gst_pad_get_query_types_default noargs
static PyObject *
_wrap_gst_pad_get_query_types_default (PyGObject *self)
{
    PyObject    *ret;
    PyObject    *item;
    int        i;
    GstQueryType    *tab;

    tab = (GstQueryType*) gst_pad_get_query_types_default(GST_PAD(self->obj));
    if (tab == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
    }

    ret = PyList_New(0);
    for (i = 0; tab[i] != 0; i++) {
        item = pyg_enum_from_gtype (GST_TYPE_QUERY_TYPE, tab[i]);
        PyList_Append(ret, item);
        Py_XDECREF(item);
    }
    
    return ret;
}
%%
override gst_pad_set_blocked_async args

static void
pad_block_callback_marshal(GstPad *pad, gboolean blocked, gpointer user_data)
{
    PyGILState_STATE state;
    PyObject *callback, *args;
    PyObject *ret;
    PyObject *py_user_data;

    g_return_if_fail(user_data != NULL);

    state = pyg_gil_state_ensure();

    py_user_data = (PyObject *) user_data;

    callback = PyTuple_GetItem(py_user_data, 0);
    args = Py_BuildValue("(NO)",
             pygobject_new(G_OBJECT(pad)),
             blocked ? Py_True : Py_False);
    
    {
        PyObject *tmp = args;
        args = PySequence_Concat(tmp, PyTuple_GetItem(py_user_data, 1));
        Py_DECREF (tmp);
    }

    ret = PyObject_CallObject(callback, args);
    Py_DECREF(args);

    if (!ret)
        PyErr_Print();
    else
        Py_DECREF(ret);
    
    pyg_gil_state_release(state);
}

static PyObject *
_wrap_gst_pad_set_blocked_async (PyGObject *self, PyObject *args)
{
    PyObject *callback, *cbargs = NULL, *data;
    PyObject    *pblocked, *pret;
    gboolean    blocked;
    gboolean    ret;
    gint    len;

    len = PyTuple_Size(args);

    if (len < 2) {
        PyErr_SetString(PyExc_TypeError, "Requires at least 2 arg");
        return NULL;
    }
    pblocked = PyTuple_GetItem(args, 0);
    blocked = PyObject_IsTrue(pblocked);

    callback = PyTuple_GetItem(args, 1);
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "callback is not callable");
        return NULL;
    }
    cbargs = PySequence_GetSlice(args, 2, len);
    if (cbargs == NULL)
        return NULL;
    data = Py_BuildValue("(ON)", callback, cbargs);
    if (data == NULL)
        return NULL;
    ret = gst_pad_set_blocked_async (GST_PAD (self->obj), blocked,
        (GstPadBlockCallback) pad_block_callback_marshal, data);
    if (ret)
        pret = Py_True;
    else
        pret = Py_False;
    Py_INCREF(pret);

    return pret;
}
%%
override gst_pad_set_caps kwargs
static PyObject *
_wrap_gst_pad_set_caps(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "caps", NULL };
    PyObject *py_caps;
    int ret;
    GstCaps *caps;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GstPad.set_caps", kwlist, &py_caps))
        return NULL;
    caps = pygst_caps_from_pyobject (py_caps, NULL);
    if (PyErr_Occurred())
      return NULL;
    pyg_begin_allow_threads;
    ret = gst_pad_set_caps(GST_PAD(self->obj), caps);
    if (ret)
	gst_caps_unref (caps);
    pyg_end_allow_threads;
    return PyBool_FromLong(ret);

}
%%
override gst_pad_query_peer_position args
static PyObject *
_wrap_gst_pad_query_peer_position (PyGObject *self, PyObject *args)
{
    gint64    cur;
    gint    format;
    PyObject    *pformat;
    PyObject    *ret;

    pformat = (PyObject*)PyTuple_GetItem(args, 0);
    if (pyg_enum_get_value (GST_TYPE_FORMAT, pformat, &format)) {
        PyErr_SetString(PyExc_TypeError, "argument should be a GstFormat");
        return NULL;
    }

    if ((gst_pad_query_peer_position(GST_PAD (self->obj), (GstFormat*) &format, &cur))) {
        ret = PyList_New(2);
        PyList_SetItem(ret, 0, PyLong_FromLongLong(cur));
        PyList_SetItem(ret, 1, pyg_enum_from_gtype (GST_TYPE_FORMAT, format ));
    } else {
        Py_INCREF(Py_None);
        ret = Py_None;
    }

    return ret;
}
%%
override gst_pad_query_peer_duration args
static PyObject *
_wrap_gst_pad_query_peer_duration (PyGObject *self, PyObject *args)
{
    gint64    cur;
    gint    format;
    PyObject    *pformat;
    PyObject    *ret;

    pformat = (PyObject*)PyTuple_GetItem(args, 0);
    if (pyg_enum_get_value (GST_TYPE_FORMAT, pformat, &format)) {
        PyErr_SetString(PyExc_TypeError, "argument should be a GstFormat");
        return NULL;
    }

    if ((gst_pad_query_peer_duration(GST_PAD (self->obj), (GstFormat*) &format, &cur))) {
        ret = PyList_New(2);
        PyList_SetItem(ret, 0, PyLong_FromLongLong(cur));
        PyList_SetItem(ret, 1, pyg_enum_from_gtype (GST_TYPE_FORMAT, format ));
    } else {
        Py_INCREF(Py_None);
        ret = Py_None;
    }

    return ret;
}
%%
override gst_pad_query_peer_convert kwargs
static PyObject *
_wrap_gst_pad_query_peer_convert (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "fromformat", "fromvalue", "destformat", NULL };
    PyObject    *pfromformat, *pdestformat;
    GstFormat    srcformat, destformat;
    gint64    fromval, dstval;
    PyObject    *ret;

    /* Input : src_format, src_val, dst_format */
    /* Returns : dst_format, dst_val OR None */

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                     "0L0:GstPad.query_peer_convert",
                     kwlist, &pfromformat, &fromval, &pdestformat))
    return NULL;
    if (pyg_enum_get_value(GST_TYPE_FORMAT, pfromformat, (gint *) &srcformat)) {
    PyErr_SetString(PyExc_TypeError, "argument should be a GstFormat");
    return NULL;
    }
    if (pyg_enum_get_value(GST_TYPE_FORMAT, pdestformat, (gint *) &destformat)) {
    PyErr_SetString(PyExc_TypeError, "argument should be a GstFormat");
    return NULL;
    }

    if (!(gst_pad_query_peer_convert (GST_PAD(self->obj),
                 srcformat, fromval,
                 &destformat, &dstval))) {
    Py_INCREF(Py_None);
    return Py_None;
    }
    
    ret = PyList_New(2);
    PyList_SetItem(ret, 0, pyg_enum_from_gtype (GST_TYPE_FORMAT, destformat));
    PyList_SetItem(ret, 1, PyLong_FromLongLong(dstval));

    return ret;
}
%%
override-attr GstStaticPadTemplate.static_caps
static PyObject *
_wrap_gst_static_pad_template__get_static_caps(PyObject *self, void *closure)
{
    GstStaticPadTemplate *templ;


    templ = pyg_pointer_get(self, GstStaticPadTemplate);
    return pyg_pointer_new(GST_TYPE_STATIC_CAPS, &(templ->static_caps));
}

