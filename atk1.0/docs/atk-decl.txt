<MACRO>
<NAME>ATK_TYPE_GOBJECT_ACCESSIBLE</NAME>
#define ATK_TYPE_GOBJECT_ACCESSIBLE            (atk_gobject_accessible_get_type ())
</MACRO>
<MACRO>
<NAME>ATK_GOBJECT_ACCESSIBLE</NAME>
#define ATK_GOBJECT_ACCESSIBLE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_GOBJECT_ACCESSIBLE, AtkGObjectAccessible))
</MACRO>
<MACRO>
<NAME>ATK_GOBJECT_ACCESSIBLE_CLASS</NAME>
#define ATK_GOBJECT_ACCESSIBLE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), ATK_TYPE_GOBJECT_ACCESSIBLE, AtkGObjectAccessibleClass))
</MACRO>
<MACRO>
<NAME>ATK_IS_GOBJECT_ACCESSIBLE</NAME>
#define ATK_IS_GOBJECT_ACCESSIBLE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ATK_TYPE_GOBJECT_ACCESSIBLE))
</MACRO>
<MACRO>
<NAME>ATK_IS_GOBJECT_ACCESSIBLE_CLASS</NAME>
#define ATK_IS_GOBJECT_ACCESSIBLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ATK_TYPE_GOBJECT_ACCESSIBLE))
</MACRO>
<MACRO>
<NAME>ATK_GOBJECT_ACCESSIBLE_GET_CLASS</NAME>
#define ATK_GOBJECT_ACCESSIBLE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), ATK_TYPE_GOBJECT_ACCESSIBLE, AtkGObjectAccessibleClass))
</MACRO>
<STRUCT>
<NAME>AtkGObjectAccessible</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkGObjectAccessibleClass</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkGObjectAccessible</NAME>
struct _AtkGObjectAccessible
{
  AtkObject parent;
};
</STRUCT>
<FUNCTION>
<NAME>atk_gobject_accessible_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>AtkGObjectAccessibleClass</NAME>
struct _AtkGObjectAccessibleClass
{
  AtkObjectClass parent_class;

  AtkFunction pad1;
  AtkFunction pad2;
};
</STRUCT>
<FUNCTION>
<NAME>atk_gobject_accessible_for_object</NAME>
<RETURNS>AtkObject *</RETURNS>
GObject           *obj
</FUNCTION>
<FUNCTION>
<NAME>atk_gobject_accessible_get_object</NAME>
<RETURNS>GObject   *</RETURNS>
AtkGObjectAccessible *obj
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_RELATION_SET</NAME>
#define ATK_TYPE_RELATION_SET                     (atk_relation_set_get_type ())
</MACRO>
<MACRO>
<NAME>ATK_RELATION_SET</NAME>
#define ATK_RELATION_SET(obj)                     (G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_RELATION_SET, AtkRelationSet))
</MACRO>
<MACRO>
<NAME>ATK_RELATION_SET_CLASS</NAME>
#define ATK_RELATION_SET_CLASS(klass)             (G_TYPE_CHECK_CLASS_CAST ((klass), ATK_TYPE_RELATION_SET, AtkRelationSetClass))
</MACRO>
<MACRO>
<NAME>ATK_IS_RELATION_SET</NAME>
#define ATK_IS_RELATION_SET(obj)                  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ATK_TYPE_RELATION_SET))
</MACRO>
<MACRO>
<NAME>ATK_IS_RELATION_SET_CLASS</NAME>
#define ATK_IS_RELATION_SET_CLASS(klass)          (G_TYPE_CHECK_CLASS_TYPE ((klass), ATK_TYPE_RELATION_SET))
</MACRO>
<MACRO>
<NAME>ATK_RELATION_SET_GET_CLASS</NAME>
#define ATK_RELATION_SET_GET_CLASS(obj)           (G_TYPE_INSTANCE_GET_CLASS ((obj), ATK_TYPE_RELATION_SET, AtkRelationSetClass))
</MACRO>
<STRUCT>
<NAME>AtkRelationSetClass</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkRelationSet</NAME>
struct _AtkRelationSet
{
  GObject parent;

  GPtrArray *relations;
};
</STRUCT>
<STRUCT>
<NAME>AtkRelationSetClass</NAME>
struct _AtkRelationSetClass
{
  GObjectClass parent;

  AtkFunction pad1;
  AtkFunction pad2;
};
</STRUCT>
<FUNCTION>
<NAME>atk_relation_set_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atk_relation_set_new</NAME>
<RETURNS>AtkRelationSet*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atk_relation_set_contains</NAME>
<RETURNS>gboolean        </RETURNS>
AtkRelationSet  *set,AtkRelationType relationship
</FUNCTION>
<FUNCTION>
<NAME>atk_relation_set_remove</NAME>
<RETURNS>void            </RETURNS>
AtkRelationSet  *set,AtkRelation     *relation
</FUNCTION>
<FUNCTION>
<NAME>atk_relation_set_add</NAME>
<RETURNS>void            </RETURNS>
AtkRelationSet  *set,AtkRelation     *relation
</FUNCTION>
<FUNCTION>
<NAME>atk_relation_set_get_n_relations</NAME>
<RETURNS>gint            </RETURNS>
AtkRelationSet  *set
</FUNCTION>
<FUNCTION>
<NAME>atk_relation_set_get_relation</NAME>
<RETURNS>AtkRelation*</RETURNS>
AtkRelationSet  *set,gint            i
</FUNCTION>
<FUNCTION>
<NAME>atk_relation_set_get_relation_by_type</NAME>
<RETURNS>AtkRelation*</RETURNS>
AtkRelationSet  *set,AtkRelationType relationship
</FUNCTION>
<FUNCTION>
<NAME>atk_relation_set_add_relation_by_type</NAME>
<RETURNS>void            </RETURNS>
AtkRelationSet  *set,AtkRelationType relationship,AtkObject       *target
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_OBJECT_FACTORY</NAME>
#define ATK_TYPE_OBJECT_FACTORY                     (atk_object_factory_get_type ())
</MACRO>
<MACRO>
<NAME>ATK_OBJECT_FACTORY</NAME>
#define ATK_OBJECT_FACTORY(obj)                     (G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_OBJECT_FACTORY, AtkObjectFactory))
</MACRO>
<MACRO>
<NAME>ATK_OBJECT_FACTORY_CLASS</NAME>
#define ATK_OBJECT_FACTORY_CLASS(klass)             (G_TYPE_CHECK_CLASS_CAST ((klass), ATK_TYPE_OBJECT_FACTORY, AtkObjectFactoryClass))
</MACRO>
<MACRO>
<NAME>ATK_IS_OBJECT_FACTORY</NAME>
#define ATK_IS_OBJECT_FACTORY(obj)                  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ATK_TYPE_OBJECT_FACTORY))
</MACRO>
<MACRO>
<NAME>ATK_IS_OBJECT_FACTORY_CLASS</NAME>
#define ATK_IS_OBJECT_FACTORY_CLASS(klass)          (G_TYPE_CHECK_CLASS_TYPE ((klass), ATK_TYPE_OBJECT_FACTORY))
</MACRO>
<MACRO>
<NAME>ATK_OBJECT_FACTORY_GET_CLASS</NAME>
#define ATK_OBJECT_FACTORY_GET_CLASS(obj)           (G_TYPE_INSTANCE_GET_CLASS ((obj), ATK_TYPE_OBJECT_FACTORY, AtkObjectFactoryClass))
</MACRO>
<STRUCT>
<NAME>AtkObjectFactory</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkObjectFactoryClass</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkObjectFactory</NAME>
struct _AtkObjectFactory
{
  GObject parent;
};
</STRUCT>
<STRUCT>
<NAME>AtkObjectFactoryClass</NAME>
struct _AtkObjectFactoryClass
{
  GObjectClass parent_class;

  AtkObject* (* create_accessible) (GObject          *obj);
  void       (* invalidate)        (AtkObjectFactory *factory);
  GType      (* get_accessible_type)    (void);

  AtkFunction pad1;
  AtkFunction pad2;
};
</STRUCT>
<FUNCTION>
<NAME>atk_object_factory_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atk_object_factory_create_accessible</NAME>
<RETURNS>AtkObject*</RETURNS>
AtkObjectFactory *factory, GObject *obj
</FUNCTION>
<FUNCTION>
<NAME>atk_object_factory_invalidate</NAME>
<RETURNS>void       </RETURNS>
AtkObjectFactory *factory
</FUNCTION>
<FUNCTION>
<NAME>atk_object_factory_get_accessible_type</NAME>
<RETURNS>GType      </RETURNS>
AtkObjectFactory *factory
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_HYPERTEXT</NAME>
#define ATK_TYPE_HYPERTEXT                    (atk_hypertext_get_type ())
</MACRO>
<MACRO>
<NAME>ATK_IS_HYPERTEXT</NAME>
#define ATK_IS_HYPERTEXT(obj)                 G_TYPE_CHECK_INSTANCE_TYPE ((obj), ATK_TYPE_HYPERTEXT)
</MACRO>
<MACRO>
<NAME>ATK_HYPERTEXT</NAME>
#define ATK_HYPERTEXT(obj)                    G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_HYPERTEXT, AtkHypertext)
</MACRO>
<MACRO>
<NAME>ATK_HYPERTEXT_GET_IFACE</NAME>
#define ATK_HYPERTEXT_GET_IFACE(obj)          (G_TYPE_INSTANCE_GET_INTERFACE ((obj), ATK_TYPE_HYPERTEXT, AtkHypertextIface))
</MACRO>
<STRUCT>
<NAME>AtkHypertext</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkHypertextIface</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkHypertextIface</NAME>
struct _AtkHypertextIface
{
  GTypeInterface parent;

  AtkHyperlink*(* get_link)                 (AtkHypertext       *hypertext,
                                             gint               link_index);
  gint         (* get_n_links)              (AtkHypertext       *hypertext);
  gint         (* get_link_index)           (AtkHypertext       *hypertext,
                                             gint               char_index);

  /*
   * signal handlers
   */
  void         (* link_selected)            (AtkHypertext       *hypertext,
                                             gint               link_index);

  AtkFunction pad1;
  AtkFunction pad2;
  AtkFunction pad3;
};
</STRUCT>
<FUNCTION>
<NAME>atk_hypertext_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atk_hypertext_get_link</NAME>
<RETURNS>AtkHyperlink*</RETURNS>
AtkHypertext *hypertext,gint          link_index
</FUNCTION>
<FUNCTION>
<NAME>atk_hypertext_get_n_links</NAME>
<RETURNS>gint          </RETURNS>
AtkHypertext *hypertext
</FUNCTION>
<FUNCTION>
<NAME>atk_hypertext_get_link_index</NAME>
<RETURNS>gint          </RETURNS>
AtkHypertext *hypertext,gint          char_index
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_STATE_SET</NAME>
#define ATK_TYPE_STATE_SET                        (atk_state_set_get_type ())
</MACRO>
<MACRO>
<NAME>ATK_STATE_SET</NAME>
#define ATK_STATE_SET(obj)                        (G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_STATE_SET, AtkStateSet))
</MACRO>
<MACRO>
<NAME>ATK_STATE_SET_CLASS</NAME>
#define ATK_STATE_SET_CLASS(klass)                (G_TYPE_CHECK_CLASS_CAST ((klass), ATK_TYPE_STATE_SET, AtkStateSetClass))
</MACRO>
<MACRO>
<NAME>ATK_IS_STATE_SET</NAME>
#define ATK_IS_STATE_SET(obj)                     (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ATK_TYPE_STATE_SET))
</MACRO>
<MACRO>
<NAME>ATK_IS_STATE_SET_CLASS</NAME>
#define ATK_IS_STATE_SET_CLASS(klass)             (G_TYPE_CHECK_CLASS_TYPE ((klass), ATK_TYPE_STATE_SET))
</MACRO>
<MACRO>
<NAME>ATK_STATE_SET_GET_CLASS</NAME>
#define ATK_STATE_SET_GET_CLASS(obj)              (G_TYPE_INSTANCE_GET_CLASS ((obj), ATK_TYPE_STATE_SET, AtkStateSetClass))
</MACRO>
<STRUCT>
<NAME>AtkStateSetClass</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkStateSet</NAME>
struct _AtkStateSet
{
  GObject parent;

};
</STRUCT>
<STRUCT>
<NAME>AtkStateSetClass</NAME>
struct _AtkStateSetClass
{
  GObjectClass parent;
};
</STRUCT>
<FUNCTION>
<NAME>atk_state_set_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atk_state_set_new</NAME>
<RETURNS>AtkStateSet*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atk_state_set_is_empty</NAME>
<RETURNS>gboolean        </RETURNS>
AtkStateSet  *set
</FUNCTION>
<FUNCTION>
<NAME>atk_state_set_add_state</NAME>
<RETURNS>gboolean        </RETURNS>
AtkStateSet  *set,AtkStateType type
</FUNCTION>
<FUNCTION>
<NAME>atk_state_set_add_states</NAME>
<RETURNS>void            </RETURNS>
AtkStateSet  *set,AtkStateType *types,gint         n_types
</FUNCTION>
<FUNCTION>
<NAME>atk_state_set_clear_states</NAME>
<RETURNS>void            </RETURNS>
AtkStateSet  *set
</FUNCTION>
<FUNCTION>
<NAME>atk_state_set_contains_state</NAME>
<RETURNS>gboolean        </RETURNS>
AtkStateSet  *set,AtkStateType type
</FUNCTION>
<FUNCTION>
<NAME>atk_state_set_contains_states</NAME>
<RETURNS>gboolean        </RETURNS>
AtkStateSet  *set,AtkStateType *types,gint         n_types
</FUNCTION>
<FUNCTION>
<NAME>atk_state_set_remove_state</NAME>
<RETURNS>gboolean        </RETURNS>
AtkStateSet  *set,AtkStateType type
</FUNCTION>
<FUNCTION>
<NAME>atk_state_set_and_sets</NAME>
<RETURNS>AtkStateSet*</RETURNS>
AtkStateSet  *set,AtkStateSet  *compare_set
</FUNCTION>
<FUNCTION>
<NAME>atk_state_set_or_sets</NAME>
<RETURNS>AtkStateSet*</RETURNS>
AtkStateSet  *set,AtkStateSet  *compare_set
</FUNCTION>
<FUNCTION>
<NAME>atk_state_set_xor_sets</NAME>
<RETURNS>AtkStateSet*</RETURNS>
AtkStateSet  *set,AtkStateSet  *compare_set
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_COMPONENT</NAME>
#define ATK_TYPE_COMPONENT                    (atk_component_get_type ())
</MACRO>
<MACRO>
<NAME>ATK_IS_COMPONENT</NAME>
#define ATK_IS_COMPONENT(obj)                 G_TYPE_CHECK_INSTANCE_TYPE ((obj), ATK_TYPE_COMPONENT)
</MACRO>
<MACRO>
<NAME>ATK_COMPONENT</NAME>
#define ATK_COMPONENT(obj)                    G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_COMPONENT, AtkComponent)
</MACRO>
<MACRO>
<NAME>ATK_COMPONENT_GET_IFACE</NAME>
#define ATK_COMPONENT_GET_IFACE(obj)          (G_TYPE_INSTANCE_GET_INTERFACE ((obj), ATK_TYPE_COMPONENT, AtkComponentIface))
</MACRO>
<STRUCT>
<NAME>AtkComponent</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkComponentIface</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>AtkFocusHandler</NAME>
<RETURNS>void </RETURNS>
AtkObject*, gboolean
</USER_FUNCTION>
<STRUCT>
<NAME>AtkRectangle</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkRectangle</NAME>
struct _AtkRectangle
{
  gint x;
  gint y;
  gint width;
  gint height;
};
</STRUCT>
<FUNCTION>
<NAME>atk_rectangle_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_RECTANGLE</NAME>
#define ATK_TYPE_RECTANGLE (atk_rectangle_get_type ())
</MACRO>
<STRUCT>
<NAME>AtkComponentIface</NAME>
struct _AtkComponentIface
{
  GTypeInterface parent;

  guint          (* add_focus_handler)  (AtkComponent          *component,
                                         AtkFocusHandler        handler);

  gboolean       (* contains)           (AtkComponent          *component,
                                         gint                   x,
                                         gint                   y,
                                         AtkCoordType           coord_type);

  AtkObject*    (* ref_accessible_at_point)  (AtkComponent     *component,
                                         gint                   x,
                                         gint                   y,
                                         AtkCoordType           coord_type);
  void          (* get_extents)         (AtkComponent          *component,
                                         gint                  *x,
                                         gint                  *y,
                                         gint                  *width,
                                         gint                  *height,
                                         AtkCoordType          coord_type);
  void                     (* get_position)     (AtkComponent   *component,
                                                 gint           *x,
                                                 gint           *y,
                                                 AtkCoordType   coord_type);
  void                     (* get_size)                 (AtkComponent   *component,
                                                         gint           *width,
                                                         gint           *height);
  gboolean                 (* grab_focus)               (AtkComponent   *component);
  void                     (* remove_focus_handler)      (AtkComponent  *component,
                                                          guint         handler_id);
  gboolean                 (* set_extents)      (AtkComponent   *component,
                                                 gint           x,
                                                 gint           y,
                                                 gint           width,
                                                 gint           height,
                                                 AtkCoordType   coord_type);
  gboolean                 (* set_position)     (AtkComponent   *component,
                                                 gint           x,
                                                 gint           y,
                                                 AtkCoordType   coord_type);
  gboolean                 (* set_size)         (AtkComponent   *component,
                                                 gint           width,
                                                 gint           height);
  	
  AtkLayer                 (* get_layer)        (AtkComponent   *component);
  gint                     (* get_mdi_zorder)   (AtkComponent   *component);

  /*
   * signal handlers
   */
  void                     (* bounds_changed)   (AtkComponent   *component,
                                                 AtkRectangle   *bounds);
  gdouble                  (* get_alpha)        (AtkComponent   *component);
};
</STRUCT>
<FUNCTION>
<NAME>atk_component_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atk_component_add_focus_handler</NAME>
<RETURNS>guint                </RETURNS>
AtkComponent    *component,AtkFocusHandler handler
</FUNCTION>
<FUNCTION>
<NAME>atk_component_contains</NAME>
<RETURNS>gboolean              </RETURNS>
AtkComponent    *component,gint            x,gint            y,AtkCoordType    coord_type
</FUNCTION>
<FUNCTION>
<NAME>atk_component_ref_accessible_at_point</NAME>
<RETURNS>AtkObject*</RETURNS>
AtkComponent    *component,gint            x,gint            y,AtkCoordType    coord_type
</FUNCTION>
<FUNCTION>
<NAME>atk_component_get_extents</NAME>
<RETURNS>void                  </RETURNS>
AtkComponent    *component,gint            *x,gint            *y,gint            *width,gint            *height,AtkCoordType    coord_type
</FUNCTION>
<FUNCTION>
<NAME>atk_component_get_position</NAME>
<RETURNS>void                  </RETURNS>
AtkComponent    *component,gint            *x,gint            *y,AtkCoordType    coord_type
</FUNCTION>
<FUNCTION>
<NAME>atk_component_get_size</NAME>
<RETURNS>void                  </RETURNS>
AtkComponent    *component,gint            *width,gint            *height
</FUNCTION>
<FUNCTION>
<NAME>atk_component_get_layer</NAME>
<RETURNS>AtkLayer              </RETURNS>
AtkComponent    *component
</FUNCTION>
<FUNCTION>
<NAME>atk_component_get_mdi_zorder</NAME>
<RETURNS>gint                  </RETURNS>
AtkComponent    *component
</FUNCTION>
<FUNCTION>
<NAME>atk_component_grab_focus</NAME>
<RETURNS>gboolean              </RETURNS>
AtkComponent    *component
</FUNCTION>
<FUNCTION>
<NAME>atk_component_remove_focus_handler</NAME>
<RETURNS>void                  </RETURNS>
AtkComponent    *component,guint           handler_id
</FUNCTION>
<FUNCTION>
<NAME>atk_component_set_extents</NAME>
<RETURNS>gboolean              </RETURNS>
AtkComponent    *component,gint            x,gint            y,gint            width,gint            height,AtkCoordType    coord_type
</FUNCTION>
<FUNCTION>
<NAME>atk_component_set_position</NAME>
<RETURNS>gboolean              </RETURNS>
AtkComponent    *component,gint            x,gint            y,AtkCoordType    coord_type
</FUNCTION>
<FUNCTION>
<NAME>atk_component_set_size</NAME>
<RETURNS>gboolean              </RETURNS>
AtkComponent    *component,gint            width,gint            height
</FUNCTION>
<FUNCTION>
<NAME>atk_component_get_alpha</NAME>
<RETURNS>gdouble               </RETURNS>
AtkComponent    *component
</FUNCTION>
<ENUM>
<NAME>AtkRelationType</NAME>
typedef enum
{
  ATK_RELATION_NULL = 0,
  ATK_RELATION_CONTROLLED_BY,
  ATK_RELATION_CONTROLLER_FOR,
  ATK_RELATION_LABEL_FOR,
  ATK_RELATION_LABELLED_BY,
  ATK_RELATION_MEMBER_OF,
  ATK_RELATION_NODE_CHILD_OF,
  ATK_RELATION_FLOWS_TO,
  ATK_RELATION_FLOWS_FROM,
  ATK_RELATION_SUBWINDOW_OF, 
  ATK_RELATION_EMBEDS, 
  ATK_RELATION_EMBEDDED_BY, 
  ATK_RELATION_POPUP_FOR, 
  ATK_RELATION_PARENT_WINDOW_OF, 
  ATK_RELATION_DESCRIBED_BY,
  ATK_RELATION_DESCRIPTION_FOR,
  ATK_RELATION_LAST_DEFINED
} AtkRelationType;
</ENUM>
<ENUM>
<NAME>AtkRole</NAME>
typedef enum
{
  ATK_ROLE_INVALID = 0, 
  ATK_ROLE_ACCEL_LABEL,
  ATK_ROLE_ALERT,
  ATK_ROLE_ANIMATION,
  ATK_ROLE_ARROW,
  ATK_ROLE_CALENDAR,
  ATK_ROLE_CANVAS,
  ATK_ROLE_CHECK_BOX,
  ATK_ROLE_CHECK_MENU_ITEM,
  ATK_ROLE_COLOR_CHOOSER,
  ATK_ROLE_COLUMN_HEADER,
  ATK_ROLE_COMBO_BOX,
  ATK_ROLE_DATE_EDITOR,
  ATK_ROLE_DESKTOP_ICON,
  ATK_ROLE_DESKTOP_FRAME,
  ATK_ROLE_DIAL,
  ATK_ROLE_DIALOG,
  ATK_ROLE_DIRECTORY_PANE,
  ATK_ROLE_DRAWING_AREA,
  ATK_ROLE_FILE_CHOOSER,
  ATK_ROLE_FILLER,
  ATK_ROLE_FONT_CHOOSER,
  ATK_ROLE_FRAME,
  ATK_ROLE_GLASS_PANE,
  ATK_ROLE_HTML_CONTAINER,
  ATK_ROLE_ICON,
  ATK_ROLE_IMAGE,
  ATK_ROLE_INTERNAL_FRAME,
  ATK_ROLE_LABEL,
  ATK_ROLE_LAYERED_PANE,
  ATK_ROLE_LIST,
  ATK_ROLE_LIST_ITEM,
  ATK_ROLE_MENU,
  ATK_ROLE_MENU_BAR,
  ATK_ROLE_MENU_ITEM,
  ATK_ROLE_OPTION_PANE,
  ATK_ROLE_PAGE_TAB,
  ATK_ROLE_PAGE_TAB_LIST,
  ATK_ROLE_PANEL,
  ATK_ROLE_PASSWORD_TEXT,
  ATK_ROLE_POPUP_MENU,
  ATK_ROLE_PROGRESS_BAR,
  ATK_ROLE_PUSH_BUTTON,
  ATK_ROLE_RADIO_BUTTON,
  ATK_ROLE_RADIO_MENU_ITEM,
  ATK_ROLE_ROOT_PANE,
  ATK_ROLE_ROW_HEADER,
  ATK_ROLE_SCROLL_BAR,
  ATK_ROLE_SCROLL_PANE,
  ATK_ROLE_SEPARATOR,
  ATK_ROLE_SLIDER,
  ATK_ROLE_SPLIT_PANE,
  ATK_ROLE_SPIN_BUTTON,
  ATK_ROLE_STATUSBAR,
  ATK_ROLE_TABLE,
  ATK_ROLE_TABLE_CELL,
  ATK_ROLE_TABLE_COLUMN_HEADER,
  ATK_ROLE_TABLE_ROW_HEADER,
  ATK_ROLE_TEAR_OFF_MENU_ITEM,
  ATK_ROLE_TERMINAL,
  ATK_ROLE_TEXT,
  ATK_ROLE_TOGGLE_BUTTON,
  ATK_ROLE_TOOL_BAR,
  ATK_ROLE_TOOL_TIP,
  ATK_ROLE_TREE,
  ATK_ROLE_TREE_TABLE,
  ATK_ROLE_UNKNOWN,
  ATK_ROLE_VIEWPORT,
  ATK_ROLE_WINDOW,
  ATK_ROLE_HEADER,
  ATK_ROLE_FOOTER,
  ATK_ROLE_PARAGRAPH,
  ATK_ROLE_RULER,
  ATK_ROLE_APPLICATION,
  ATK_ROLE_AUTOCOMPLETE,
  ATK_ROLE_EDITBAR,
  ATK_ROLE_EMBEDDED,
  ATK_ROLE_ENTRY,
  ATK_ROLE_CHART,
  ATK_ROLE_CAPTION,
  ATK_ROLE_DOCUMENT_FRAME,
  ATK_ROLE_HEADING,
  ATK_ROLE_PAGE,
  ATK_ROLE_SECTION,
  ATK_ROLE_REDUNDANT_OBJECT,
  ATK_ROLE_FORM,
  ATK_ROLE_LINK,
  ATK_ROLE_INPUT_METHOD_WINDOW,
  ATK_ROLE_LAST_DEFINED
} AtkRole;
</ENUM>
<FUNCTION>
<NAME>atk_role_register</NAME>
<RETURNS>AtkRole                  </RETURNS>
const gchar *name
</FUNCTION>
<ENUM>
<NAME>AtkLayer</NAME>
typedef enum
{
  ATK_LAYER_INVALID,
  ATK_LAYER_BACKGROUND,
  ATK_LAYER_CANVAS,
  ATK_LAYER_WIDGET,
  ATK_LAYER_MDI,
  ATK_LAYER_POPUP,
  ATK_LAYER_OVERLAY,
  ATK_LAYER_WINDOW
} AtkLayer;
</ENUM>
<TYPEDEF>
<NAME>AtkAttributeSet</NAME>
typedef GSList AtkAttributeSet;
</TYPEDEF>
<STRUCT>
<NAME>AtkAttribute</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkAttribute</NAME>
struct _AtkAttribute {
  gchar* name;
  gchar* value;
};
</STRUCT>
<MACRO>
<NAME>ATK_TYPE_OBJECT</NAME>
#define ATK_TYPE_OBJECT                           (atk_object_get_type ())
</MACRO>
<MACRO>
<NAME>ATK_OBJECT</NAME>
#define ATK_OBJECT(obj)                           (G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_OBJECT, AtkObject))
</MACRO>
<MACRO>
<NAME>ATK_OBJECT_CLASS</NAME>
#define ATK_OBJECT_CLASS(klass)                   (G_TYPE_CHECK_CLASS_CAST ((klass), ATK_TYPE_OBJECT, AtkObjectClass))
</MACRO>
<MACRO>
<NAME>ATK_IS_OBJECT</NAME>
#define ATK_IS_OBJECT(obj)                        (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ATK_TYPE_OBJECT))
</MACRO>
<MACRO>
<NAME>ATK_IS_OBJECT_CLASS</NAME>
#define ATK_IS_OBJECT_CLASS(klass)                (G_TYPE_CHECK_CLASS_TYPE ((klass), ATK_TYPE_OBJECT))
</MACRO>
<MACRO>
<NAME>ATK_OBJECT_GET_CLASS</NAME>
#define ATK_OBJECT_GET_CLASS(obj)                 (G_TYPE_INSTANCE_GET_CLASS ((obj), ATK_TYPE_OBJECT, AtkObjectClass))
</MACRO>
<MACRO>
<NAME>ATK_TYPE_IMPLEMENTOR</NAME>
#define ATK_TYPE_IMPLEMENTOR                      (atk_implementor_get_type ())
</MACRO>
<MACRO>
<NAME>ATK_IS_IMPLEMENTOR</NAME>
#define ATK_IS_IMPLEMENTOR(obj)                   G_TYPE_CHECK_INSTANCE_TYPE ((obj), ATK_TYPE_IMPLEMENTOR)
</MACRO>
<MACRO>
<NAME>ATK_IMPLEMENTOR</NAME>
#define ATK_IMPLEMENTOR(obj)                      G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_IMPLEMENTOR, AtkImplementor)
</MACRO>
<MACRO>
<NAME>ATK_IMPLEMENTOR_GET_IFACE</NAME>
#define ATK_IMPLEMENTOR_GET_IFACE(obj)            (G_TYPE_INSTANCE_GET_INTERFACE ((obj), ATK_TYPE_IMPLEMENTOR, AtkImplementorIface))
</MACRO>
<STRUCT>
<NAME>AtkImplementor</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkImplementorIface</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkObject</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkObjectClass</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkRelationSet</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkStateSet</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkPropertyValues</NAME>
struct _AtkPropertyValues
{
  const gchar  *property_name;
  GValue old_value;
  GValue new_value;
};
</STRUCT>
<STRUCT>
<NAME>AtkPropertyValues</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>AtkFunction</NAME>
<RETURNS>gboolean </RETURNS>
gpointer data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>AtkPropertyChangeHandler</NAME>
<RETURNS>void </RETURNS>
AtkObject*, AtkPropertyValues*
</USER_FUNCTION>
<STRUCT>
<NAME>AtkObject</NAME>
struct _AtkObject
{
  GObject parent;

  gchar *description;
  gchar *name;
  AtkObject *accessible_parent;
  AtkRole role;
  AtkRelationSet *relation_set;
  AtkLayer layer;
};
</STRUCT>
<STRUCT>
<NAME>AtkObjectClass</NAME>
struct _AtkObjectClass
{
  GObjectClass parent;

  /*
   * Gets the accessible name of the object
   */
  G_CONST_RETURN gchar*    (* get_name)            (AtkObject                *accessible);
  /*
   * Gets the accessible description of the object
   */
  G_CONST_RETURN gchar*    (* get_description)     (AtkObject                *accessible);
  /*
   * Gets the accessible parent of the object
   */
  AtkObject*               (*get_parent)           (AtkObject                *accessible);

  /*
   * Gets the number of accessible children of the object
   */
  gint                    (* get_n_children)       (AtkObject                *accessible);
  /*
   * Returns a reference to the specified accessible child of the object.
   * The accessible children are 0-based so the first accessible child is
   * at index 0, the second at index 1 and so on.
   */
  AtkObject*              (* ref_child)            (AtkObject                *accessible,
                                                    gint                      i);
  /*
   * Gets the 0-based index of this object in its parent; returns -1 if the
   * object does not have an accessible parent.
   */
  gint                    (* get_index_in_parent) (AtkObject                 *accessible);
  /*
   * Gets the RelationSet associated with the object
   */
  AtkRelationSet*         (* ref_relation_set)    (AtkObject                 *accessible);
  /*
   * Gets the role of the object
   */
  AtkRole                 (* get_role)            (AtkObject                 *accessible);
  AtkLayer                (* get_layer)           (AtkObject                 *accessible);
  gint                    (* get_mdi_zorder)      (AtkObject                 *accessible);
  /*
   * Gets the state set of the object
   */
  AtkStateSet*            (* ref_state_set)       (AtkObject                 *accessible);
  /*
   * Sets the accessible name of the object
   */
  void                    (* set_name)            (AtkObject                 *accessible,
                                                   const gchar               *name);
  /*
   * Sets the accessible description of the object
   */
  void                    (* set_description)     (AtkObject                 *accessible,
                                                   const gchar               *description);
  /*
   * Sets the accessible parent of the object
   */
  void                    (* set_parent)          (AtkObject                 *accessible,
                                                   AtkObject                 *parent);
  /*
   * Sets the accessible role of the object
   */
  void                    (* set_role)            (AtkObject                 *accessible,
                                                   AtkRole                   role);
  /*
   * Specifies a function to be called when a property changes value
   */
guint                     (* connect_property_change_handler)    (AtkObject
                 *accessible,
                                                                  AtkPropertyChangeHandler       *handler);
  /*
   * Removes a property change handler which was specified using
   * connect_property_change_handler
   */
void                      (* remove_property_change_handler)     (AtkObject
                *accessible,
                                                                  guint
                handler_id);
void                      (* initialize)                         (AtkObject                     *accessible,
                                                                  gpointer                      data);
  /*
   * The signal handler which is executed when there is a change in the
   * children of the object
   */
  void                    (* children_changed)    (AtkObject                  *accessible,
                                                   guint                      change_index,
                                                   gpointer                   changed_child);
  /*
   * The signal handler which is executed  when there is a focus event
   * for an object.
   */
  void                    (* focus_event)         (AtkObject                  *accessible,
                                                   gboolean                   focus_in);
  /*
   * The signal handler which is executed  when there is a property_change 
   * signal for an object.
   */
  void                    (* property_change)     (AtkObject                  *accessible,
                                                   AtkPropertyValues          *values);
  /*
   * The signal handler which is executed  when there is a state_change 
   * signal for an object.
   */
  void                    (* state_change)        (AtkObject                  *accessible,
                                                   const gchar                *name,
                                                   gboolean                   state_set);
  /*
   * The signal handler which is executed when there is a change in the
   * visible data for an object
   */
  void                    (*visible_data_changed) (AtkObject                  *accessible);

  /*
   * The signal handler which is executed when there is a change in the
   * 'active' child or children of the object, for instance when 
   * interior focus changes in a table or list.  This signal should be emitted
   * by objects whose state includes ATK_STATE_MANAGES_DESCENDANTS.
   */
  void                    (*active_descendant_changed) (AtkObject                  *accessible,
                                                        gpointer                   *child);

  /*    	
   * Gets a list of properties applied to this object as a whole, as an #AtkAttributeSet consisting of name-value pairs. 
   * Since ATK 1.12
   */
  AtkAttributeSet* 	  (*get_attributes)            (AtkObject                  *accessible);
  AtkFunction             pad1;
  AtkFunction             pad2;
};
</STRUCT>
<FUNCTION>
<NAME>atk_object_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>AtkImplementorIface</NAME>
struct _AtkImplementorIface
{
  GTypeInterface parent;

  AtkObject*   (*ref_accessible) (AtkImplementor *implementor);
};
</STRUCT>
<FUNCTION>
<NAME>atk_implementor_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atk_implementor_ref_accessible</NAME>
<RETURNS>AtkObject*</RETURNS>
AtkImplementor *implementor
</FUNCTION>
<FUNCTION>
<NAME>atk_object_get_name</NAME>
<RETURNS>G_CONST_RETURN gchar*</RETURNS>
AtkObject *accessible
</FUNCTION>
<FUNCTION>
<NAME>atk_object_get_description</NAME>
<RETURNS>G_CONST_RETURN gchar*</RETURNS>
AtkObject *accessible
</FUNCTION>
<FUNCTION>
<NAME>atk_object_get_parent</NAME>
<RETURNS>AtkObject*</RETURNS>
AtkObject *accessible
</FUNCTION>
<FUNCTION>
<NAME>atk_object_get_n_accessible_children</NAME>
<RETURNS>gint                    </RETURNS>
AtkObject *accessible
</FUNCTION>
<FUNCTION>
<NAME>atk_object_ref_accessible_child</NAME>
<RETURNS>AtkObject*</RETURNS>
AtkObject *accessible,gint        i
</FUNCTION>
<FUNCTION>
<NAME>atk_object_ref_relation_set</NAME>
<RETURNS>AtkRelationSet*</RETURNS>
AtkObject *accessible
</FUNCTION>
<FUNCTION>
<NAME>atk_object_get_role</NAME>
<RETURNS>AtkRole                 </RETURNS>
AtkObject *accessible
</FUNCTION>
<FUNCTION>
<NAME>atk_object_get_layer</NAME>
<RETURNS>AtkLayer                </RETURNS>
AtkObject *accessible
</FUNCTION>
<FUNCTION>
<NAME>atk_object_get_mdi_zorder</NAME>
<RETURNS>gint                    </RETURNS>
AtkObject *accessible
</FUNCTION>
<FUNCTION>
<NAME>atk_object_get_attributes</NAME>
<RETURNS>AtkAttributeSet*</RETURNS>
AtkObject *accessible
</FUNCTION>
<FUNCTION>
<NAME>atk_object_ref_state_set</NAME>
<RETURNS>AtkStateSet*</RETURNS>
AtkObject *accessible
</FUNCTION>
<FUNCTION>
<NAME>atk_object_get_index_in_parent</NAME>
<RETURNS>gint                    </RETURNS>
AtkObject *accessible
</FUNCTION>
<FUNCTION>
<NAME>atk_object_set_name</NAME>
<RETURNS>void                    </RETURNS>
AtkObject *accessible,const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>atk_object_set_description</NAME>
<RETURNS>void                    </RETURNS>
AtkObject *accessible,const gchar *description
</FUNCTION>
<FUNCTION>
<NAME>atk_object_set_parent</NAME>
<RETURNS>void                    </RETURNS>
AtkObject *accessible,AtkObject *parent
</FUNCTION>
<FUNCTION>
<NAME>atk_object_set_role</NAME>
<RETURNS>void                    </RETURNS>
AtkObject *accessible,AtkRole   role
</FUNCTION>
<FUNCTION>
<NAME>atk_object_connect_property_change_handler</NAME>
<RETURNS>guint                </RETURNS>
AtkObject                      *accessible,AtkPropertyChangeHandler       *handler
</FUNCTION>
<FUNCTION>
<NAME>atk_object_remove_property_change_handler</NAME>
<RETURNS>void                 </RETURNS>
AtkObject                      *accessible,guint                          handler_id
</FUNCTION>
<FUNCTION>
<NAME>atk_object_notify_state_change</NAME>
<RETURNS>void                 </RETURNS>
AtkObject                      *accessible,AtkState                       state,gboolean                       value
</FUNCTION>
<FUNCTION>
<NAME>atk_object_initialize</NAME>
<RETURNS>void                 </RETURNS>
AtkObject                     *accessible,gpointer                      data
</FUNCTION>
<FUNCTION>
<NAME>atk_role_get_name</NAME>
<RETURNS>G_CONST_RETURN gchar*</RETURNS>
AtkRole         role
</FUNCTION>
<FUNCTION>
<NAME>atk_role_for_name</NAME>
<RETURNS>AtkRole               </RETURNS>
const gchar     *name
</FUNCTION>
<FUNCTION>
<NAME>atk_object_add_relationship</NAME>
<RETURNS>gboolean              </RETURNS>
AtkObject      *object,AtkRelationType relationship,AtkObject      *target
</FUNCTION>
<FUNCTION>
<NAME>atk_object_remove_relationship</NAME>
<RETURNS>gboolean              </RETURNS>
AtkObject      *object,AtkRelationType relationship,AtkObject      *target
</FUNCTION>
<FUNCTION>
<NAME>atk_role_get_localized_name</NAME>
<RETURNS>G_CONST_RETURN gchar*</RETURNS>
AtkRole     role
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_REGISTRY</NAME>
#define ATK_TYPE_REGISTRY                (atk_registry_get_type ())
</MACRO>
<MACRO>
<NAME>ATK_REGISTRY</NAME>
#define ATK_REGISTRY(obj)                (G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_REGISTRY, AtkRegistry))
</MACRO>
<MACRO>
<NAME>ATK_REGISTRY_CLASS</NAME>
#define ATK_REGISTRY_CLASS(klass)       (G_TYPE_CHECK_CLASS_CAST ((klass), ATK_TYPE_REGISTRY, AtkRegistryClass))
</MACRO>
<MACRO>
<NAME>ATK_IS_REGISTRY</NAME>
#define ATK_IS_REGISTRY(obj)            (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ATK_TYPE_REGISTRY))
</MACRO>
<MACRO>
<NAME>ATK_IS_REGISTRY_CLASS</NAME>
#define ATK_IS_REGISTRY_CLASS(klass)     (G_TYPE_CHECK_CLASS_TYPE ((klass), ATK_TYPE_REGISTRY))
</MACRO>
<MACRO>
<NAME>ATK_REGISTRY_GET_CLASS</NAME>
#define ATK_REGISTRY_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), ATK_TYPE_REGISTRY, AtkRegistryClass))
</MACRO>
<STRUCT>
<NAME>AtkRegistry</NAME>
struct _AtkRegistry
{
  GObject    parent;
  GHashTable *factory_type_registry;
  GHashTable *factory_singleton_cache;
};
</STRUCT>
<STRUCT>
<NAME>AtkRegistryClass</NAME>
struct _AtkRegistryClass
{
  GObjectClass    parent_class;
};
</STRUCT>
<STRUCT>
<NAME>AtkRegistry</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkRegistryClass</NAME>
</STRUCT>
<FUNCTION>
<NAME>atk_registry_get_type</NAME>
<RETURNS>GType             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atk_registry_set_factory_type</NAME>
<RETURNS>void              </RETURNS>
AtkRegistry *registry,GType type,GType factory_type
</FUNCTION>
<FUNCTION>
<NAME>atk_registry_get_factory_type</NAME>
<RETURNS>GType             </RETURNS>
AtkRegistry *registry,GType type
</FUNCTION>
<FUNCTION>
<NAME>atk_registry_get_factory</NAME>
<RETURNS>AtkObjectFactory*</RETURNS>
AtkRegistry *registry,GType type
</FUNCTION>
<FUNCTION>
<NAME>atk_get_default_registry</NAME>
<RETURNS>AtkRegistry*</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_ACTION</NAME>
#define ATK_TYPE_ACTION                    (atk_action_get_type ())
</MACRO>
<MACRO>
<NAME>ATK_IS_ACTION</NAME>
#define ATK_IS_ACTION(obj)                 G_TYPE_CHECK_INSTANCE_TYPE ((obj), ATK_TYPE_ACTION)
</MACRO>
<MACRO>
<NAME>ATK_ACTION</NAME>
#define ATK_ACTION(obj)                    G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_ACTION, AtkAction)
</MACRO>
<MACRO>
<NAME>ATK_ACTION_GET_IFACE</NAME>
#define ATK_ACTION_GET_IFACE(obj)          (G_TYPE_INSTANCE_GET_INTERFACE ((obj), ATK_TYPE_ACTION, AtkActionIface))
</MACRO>
<STRUCT>
<NAME>AtkAction</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkActionIface</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkActionIface</NAME>
struct _AtkActionIface
{
  GTypeInterface parent;

  gboolean                (*do_action)         (AtkAction         *action,
                                                gint              i);
  gint                    (*get_n_actions)     (AtkAction         *action);
  G_CONST_RETURN gchar*   (*get_description)   (AtkAction         *action,
                                                gint              i);
  G_CONST_RETURN gchar*   (*get_name)          (AtkAction         *action,
                                                gint              i);
  G_CONST_RETURN gchar*   (*get_keybinding)    (AtkAction         *action,
                                                gint              i);
  gboolean                (*set_description)   (AtkAction         *action,
                                                gint              i,
                                                const gchar       *desc);
  G_CONST_RETURN gchar*   (*get_localized_name)(AtkAction         *action,
						gint              i);
  AtkFunction             pad2;
};
</STRUCT>
<FUNCTION>
<NAME>atk_action_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atk_action_do_action</NAME>
<RETURNS>gboolean   </RETURNS>
AtkAction         *action,gint              i
</FUNCTION>
<FUNCTION>
<NAME>atk_action_get_n_actions</NAME>
<RETURNS>gint   </RETURNS>
AtkAction *action
</FUNCTION>
<FUNCTION>
<NAME>atk_action_get_description</NAME>
<RETURNS>G_CONST_RETURN gchar*</RETURNS>
AtkAction         *action,gint              i
</FUNCTION>
<FUNCTION>
<NAME>atk_action_get_name</NAME>
<RETURNS>G_CONST_RETURN gchar*</RETURNS>
AtkAction         *action,gint              i
</FUNCTION>
<FUNCTION>
<NAME>atk_action_get_keybinding</NAME>
<RETURNS>G_CONST_RETURN gchar*</RETURNS>
AtkAction         *action,gint              i
</FUNCTION>
<FUNCTION>
<NAME>atk_action_set_description</NAME>
<RETURNS>gboolean              </RETURNS>
AtkAction         *action,gint              i,const gchar       *desc
</FUNCTION>
<FUNCTION>
<NAME>atk_action_get_localized_name</NAME>
<RETURNS>G_CONST_RETURN gchar*</RETURNS>
AtkAction       *action,gint            i
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_RELATION</NAME>
#define ATK_TYPE_RELATION                         (atk_relation_get_type ())
</MACRO>
<MACRO>
<NAME>ATK_RELATION</NAME>
#define ATK_RELATION(obj)                         (G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_RELATION, AtkRelation))
</MACRO>
<MACRO>
<NAME>ATK_RELATION_CLASS</NAME>
#define ATK_RELATION_CLASS(klass)                 (G_TYPE_CHECK_CLASS_CAST ((klass), ATK_TYPE_RELATION, AtkRelationClass))
</MACRO>
<MACRO>
<NAME>ATK_IS_RELATION</NAME>
#define ATK_IS_RELATION(obj)                      (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ATK_TYPE_RELATION))
</MACRO>
<MACRO>
<NAME>ATK_IS_RELATION_CLASS</NAME>
#define ATK_IS_RELATION_CLASS(klass)              (G_TYPE_CHECK_CLASS_TYPE ((klass), ATK_TYPE_RELATION))
</MACRO>
<MACRO>
<NAME>ATK_RELATION_GET_CLASS</NAME>
#define ATK_RELATION_GET_CLASS(obj)               (G_TYPE_INSTANCE_GET_CLASS ((obj), ATK_TYPE_RELATION, AtkRelationClass))
</MACRO>
<STRUCT>
<NAME>AtkRelation</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkRelationClass</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkRelation</NAME>
struct _AtkRelation
{
  GObject parent;

  GPtrArray       *target;
  AtkRelationType relationship;
};
</STRUCT>
<STRUCT>
<NAME>AtkRelationClass</NAME>
struct _AtkRelationClass
{
  GObjectClass parent;
};
</STRUCT>
<FUNCTION>
<NAME>atk_relation_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atk_relation_type_register</NAME>
<RETURNS>AtkRelationType       </RETURNS>
const gchar     *name
</FUNCTION>
<FUNCTION>
<NAME>atk_relation_type_get_name</NAME>
<RETURNS>G_CONST_RETURN gchar*</RETURNS>
AtkRelationType type
</FUNCTION>
<FUNCTION>
<NAME>atk_relation_type_for_name</NAME>
<RETURNS>AtkRelationType       </RETURNS>
const gchar     *name
</FUNCTION>
<FUNCTION>
<NAME>atk_relation_new</NAME>
<RETURNS>AtkRelation*</RETURNS>
AtkObject       **targets,gint            n_targets,AtkRelationType relationship
</FUNCTION>
<FUNCTION>
<NAME>atk_relation_get_relation_type</NAME>
<RETURNS>AtkRelationType       </RETURNS>
AtkRelation     *relation
</FUNCTION>
<FUNCTION>
<NAME>atk_relation_get_target</NAME>
<RETURNS>GPtrArray*</RETURNS>
AtkRelation     *relation
</FUNCTION>
<FUNCTION>
<NAME>atk_relation_add_target</NAME>
<RETURNS>void                  </RETURNS>
AtkRelation     *relation,AtkObject       *target
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_UTIL</NAME>
#define ATK_TYPE_UTIL                   (atk_util_get_type ())
</MACRO>
<MACRO>
<NAME>ATK_IS_UTIL</NAME>
#define ATK_IS_UTIL(obj)                G_TYPE_CHECK_INSTANCE_TYPE ((obj), ATK_TYPE_UTIL)
</MACRO>
<MACRO>
<NAME>ATK_UTIL</NAME>
#define ATK_UTIL(obj)                   G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_UTIL, AtkUtil)
</MACRO>
<MACRO>
<NAME>ATK_UTIL_CLASS</NAME>
#define ATK_UTIL_CLASS(klass)                   (G_TYPE_CHECK_CLASS_CAST ((klass), ATK_TYPE_UTIL, AtkUtilClass))
</MACRO>
<MACRO>
<NAME>ATK_IS_UTIL_CLASS</NAME>
#define ATK_IS_UTIL_CLASS(klass)                (G_TYPE_CHECK_CLASS_TYPE ((klass), ATK_TYPE_UTIL))
</MACRO>
<MACRO>
<NAME>ATK_UTIL_GET_CLASS</NAME>
#define ATK_UTIL_GET_CLASS(obj)                 (G_TYPE_INSTANCE_GET_CLASS ((obj), ATK_TYPE_UTIL, AtkUtilClass))
</MACRO>
<STRUCT>
<NAME>AtkUtil</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkUtilClass</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkKeyEventStruct</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>AtkEventListener</NAME>
<RETURNS>void </RETURNS>
AtkObject* obj
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>AtkEventListenerInit</NAME>
<RETURNS>void </RETURNS>
void
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>AtkKeySnoopFunc</NAME>
<RETURNS>gint </RETURNS>
AtkKeyEventStruct *event,
				   gpointer func_data
</USER_FUNCTION>
<STRUCT>
<NAME>AtkKeyEventStruct</NAME>
struct _AtkKeyEventStruct {
  gint type;
  guint state;
  guint keyval;
  gint length;
  gchar *string;
  guint16 keycode;
  guint32 timestamp;	
};
</STRUCT>
<ENUM>
<NAME>AtkKeyEventType</NAME>
typedef enum
{
  ATK_KEY_EVENT_PRESS,
  ATK_KEY_EVENT_RELEASE,
  ATK_KEY_EVENT_LAST_DEFINED
} AtkKeyEventType;
</ENUM>
<STRUCT>
<NAME>AtkUtil</NAME>
struct _AtkUtil
{
  GObject parent;
};
</STRUCT>
<STRUCT>
<NAME>AtkUtilClass</NAME>
struct _AtkUtilClass
{
   GObjectClass parent;
   guint        (* add_global_event_listener)    (GSignalEmissionHook listener,
						  const gchar        *event_type);
   void         (* remove_global_event_listener) (guint               listener_id);
   guint	(* add_key_event_listener) 	 (AtkKeySnoopFunc     listener,
						  gpointer data);
   void         (* remove_key_event_listener)    (guint               listener_id);
   AtkObject*   (* get_root)                     (void);
   G_CONST_RETURN gchar* (* get_toolkit_name)    (void);
   G_CONST_RETURN gchar* (* get_toolkit_version) (void);
};
</STRUCT>
<FUNCTION>
<NAME>atk_util_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>AtkCoordType</NAME>
typedef enum {
  ATK_XY_SCREEN,
  ATK_XY_WINDOW
}AtkCoordType;
</ENUM>
<FUNCTION>
<NAME>atk_add_focus_tracker</NAME>
<RETURNS>guint    </RETURNS>
AtkEventListener      focus_tracker
</FUNCTION>
<FUNCTION>
<NAME>atk_remove_focus_tracker</NAME>
<RETURNS>void     </RETURNS>
guint                tracker_id
</FUNCTION>
<FUNCTION>
<NAME>atk_focus_tracker_init</NAME>
<RETURNS>void     </RETURNS>
AtkEventListenerInit  init
</FUNCTION>
<FUNCTION>
<NAME>atk_focus_tracker_notify</NAME>
<RETURNS>void     </RETURNS>
AtkObject            *object
</FUNCTION>
<FUNCTION>
<NAME>atk_add_global_event_listener</NAME>
<RETURNS>guint	</RETURNS>
GSignalEmissionHook listener,const gchar        *event_type
</FUNCTION>
<FUNCTION>
<NAME>atk_remove_global_event_listener</NAME>
<RETURNS>void	</RETURNS>
guint listener_id
</FUNCTION>
<FUNCTION>
<NAME>atk_add_key_event_listener</NAME>
<RETURNS>guint	</RETURNS>
AtkKeySnoopFunc listener, gpointer data
</FUNCTION>
<FUNCTION>
<NAME>atk_remove_key_event_listener</NAME>
<RETURNS>void	</RETURNS>
guint listener_id
</FUNCTION>
<FUNCTION>
<NAME>atk_get_root</NAME>
<RETURNS>AtkObject*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atk_get_focus_object</NAME>
<RETURNS>AtkObject*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atk_get_toolkit_name</NAME>
<RETURNS>G_CONST_RETURN gchar *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atk_get_toolkit_version</NAME>
<RETURNS>G_CONST_RETURN gchar *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_IMAGE</NAME>
#define ATK_TYPE_IMAGE                   (atk_image_get_type ())
</MACRO>
<MACRO>
<NAME>ATK_IS_IMAGE</NAME>
#define ATK_IS_IMAGE(obj)                G_TYPE_CHECK_INSTANCE_TYPE ((obj), ATK_TYPE_IMAGE)
</MACRO>
<MACRO>
<NAME>ATK_IMAGE</NAME>
#define ATK_IMAGE(obj)                   G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_IMAGE, AtkImage)
</MACRO>
<MACRO>
<NAME>ATK_IMAGE_GET_IFACE</NAME>
#define ATK_IMAGE_GET_IFACE(obj)         (G_TYPE_INSTANCE_GET_INTERFACE ((obj), ATK_TYPE_IMAGE, AtkImageIface))
</MACRO>
<STRUCT>
<NAME>AtkImage</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkImageIface</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkImageIface</NAME>
struct _AtkImageIface
{
  GTypeInterface parent;
  void          	( *get_image_position)    (AtkImage		 *image,
                                                   gint                  *x,
				                   gint	                 *y,
    			                           AtkCoordType	         coord_type);
  G_CONST_RETURN gchar* ( *get_image_description) (AtkImage              *image);
  void                  ( *get_image_size)        (AtkImage              *image,
                                                   gint                  *width,
                                                   gint                  *height);
  gboolean              ( *set_image_description) (AtkImage              *image,
                                                   const gchar           *description);
  G_CONST_RETURN gchar* ( *get_image_locale)      (AtkImage              *image);

  AtkFunction           pad1;
	
};
</STRUCT>
<FUNCTION>
<NAME>atk_image_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atk_image_get_image_description</NAME>
<RETURNS>G_CONST_RETURN gchar*</RETURNS>
AtkImage   *image
</FUNCTION>
<FUNCTION>
<NAME>atk_image_get_image_size</NAME>
<RETURNS>void     </RETURNS>
AtkImage           *image,gint               *width,gint               *height
</FUNCTION>
<FUNCTION>
<NAME>atk_image_set_image_description</NAME>
<RETURNS>gboolean </RETURNS>
AtkImage           *image,const gchar       *description
</FUNCTION>
<FUNCTION>
<NAME>atk_image_get_image_position</NAME>
<RETURNS>void     </RETURNS>
AtkImage	     *image,gint               *x,gint	             *y,AtkCoordType	     coord_type
</FUNCTION>
<FUNCTION>
<NAME>atk_image_get_image_locale</NAME>
<RETURNS>G_CONST_RETURN gchar*</RETURNS>
AtkImage   *image
</FUNCTION>
<ENUM>
<NAME>AtkTextAttribute</NAME>
typedef enum
{
  ATK_TEXT_ATTR_INVALID = 0,
  ATK_TEXT_ATTR_LEFT_MARGIN,
  ATK_TEXT_ATTR_RIGHT_MARGIN,
  ATK_TEXT_ATTR_INDENT,
  ATK_TEXT_ATTR_INVISIBLE,
  ATK_TEXT_ATTR_EDITABLE,
  ATK_TEXT_ATTR_PIXELS_ABOVE_LINES,
  ATK_TEXT_ATTR_PIXELS_BELOW_LINES,
  ATK_TEXT_ATTR_PIXELS_INSIDE_WRAP,
  ATK_TEXT_ATTR_BG_FULL_HEIGHT,
  ATK_TEXT_ATTR_RISE,
  ATK_TEXT_ATTR_UNDERLINE,
  ATK_TEXT_ATTR_STRIKETHROUGH,
  ATK_TEXT_ATTR_SIZE,
  ATK_TEXT_ATTR_SCALE,
  ATK_TEXT_ATTR_WEIGHT,
  ATK_TEXT_ATTR_LANGUAGE,
  ATK_TEXT_ATTR_FAMILY_NAME,
  ATK_TEXT_ATTR_BG_COLOR,
  ATK_TEXT_ATTR_FG_COLOR,
  ATK_TEXT_ATTR_BG_STIPPLE,
  ATK_TEXT_ATTR_FG_STIPPLE,
  ATK_TEXT_ATTR_WRAP_MODE,
  ATK_TEXT_ATTR_DIRECTION,
  ATK_TEXT_ATTR_JUSTIFICATION,
  ATK_TEXT_ATTR_STRETCH,
  ATK_TEXT_ATTR_VARIANT,
  ATK_TEXT_ATTR_STYLE,
  ATK_TEXT_ATTR_LAST_DEFINED
} AtkTextAttribute;
</ENUM>
<FUNCTION>
<NAME>atk_text_attribute_register</NAME>
<RETURNS>AtkTextAttribute         </RETURNS>
const gchar *name
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_TEXT</NAME>
#define ATK_TYPE_TEXT                    (atk_text_get_type ())
</MACRO>
<MACRO>
<NAME>ATK_IS_TEXT</NAME>
#define ATK_IS_TEXT(obj)                 G_TYPE_CHECK_INSTANCE_TYPE ((obj), ATK_TYPE_TEXT)
</MACRO>
<MACRO>
<NAME>ATK_TEXT</NAME>
#define ATK_TEXT(obj)                    G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_TEXT, AtkText)
</MACRO>
<MACRO>
<NAME>ATK_TEXT_GET_IFACE</NAME>
#define ATK_TEXT_GET_IFACE(obj)          (G_TYPE_INSTANCE_GET_INTERFACE ((obj), ATK_TYPE_TEXT, AtkTextIface))
</MACRO>
<STRUCT>
<NAME>AtkText</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkTextIface</NAME>
</STRUCT>
<ENUM>
<NAME>AtkTextBoundary</NAME>
typedef enum {
  ATK_TEXT_BOUNDARY_CHAR,
  ATK_TEXT_BOUNDARY_WORD_START,
  ATK_TEXT_BOUNDARY_WORD_END,
  ATK_TEXT_BOUNDARY_SENTENCE_START,
  ATK_TEXT_BOUNDARY_SENTENCE_END,
  ATK_TEXT_BOUNDARY_LINE_START,
  ATK_TEXT_BOUNDARY_LINE_END
} AtkTextBoundary;
</ENUM>
<STRUCT>
<NAME>AtkTextRectangle</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkTextRectangle</NAME>
struct _AtkTextRectangle {
  gint x;
  gint y;
  gint width;
  gint height;
};
</STRUCT>
<STRUCT>
<NAME>AtkTextRange</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkTextRange</NAME>
struct _AtkTextRange {
  AtkTextRectangle bounds;
  gint start_offset;
  gint end_offset;
  gchar* content;
};
</STRUCT>
<ENUM>
<NAME>AtkTextClipType</NAME>
typedef enum {
    ATK_TEXT_CLIP_NONE,
    ATK_TEXT_CLIP_MIN,
    ATK_TEXT_CLIP_MAX,
    ATK_TEXT_CLIP_BOTH
} AtkTextClipType;
</ENUM>
<STRUCT>
<NAME>AtkTextIface</NAME>
struct _AtkTextIface
{
  GTypeInterface parent;

  gchar*         (* get_text)                     (AtkText          *text,
                                                   gint             start_offset,
                                                   gint             end_offset);
  gchar*         (* get_text_after_offset)        (AtkText          *text,
                                                   gint             offset,
                                                   AtkTextBoundary  boundary_type,
						   gint             *start_offset,
						   gint             *end_offset);
  gchar*         (* get_text_at_offset)           (AtkText          *text,
                                                   gint             offset,
                                                   AtkTextBoundary  boundary_type,
						   gint             *start_offset,
						   gint             *end_offset);
  gunichar       (* get_character_at_offset)      (AtkText          *text,
                                                   gint             offset);
  gchar*         (* get_text_before_offset)       (AtkText          *text,
                                                   gint             offset,
                                                   AtkTextBoundary  boundary_type,
 						   gint             *start_offset,
						   gint             *end_offset);
  gint           (* get_caret_offset)             (AtkText          *text);
  AtkAttributeSet* (* get_run_attributes)         (AtkText	    *text,
						   gint	  	    offset,
						   gint             *start_offset,
						   gint	 	    *end_offset);
  AtkAttributeSet* (* get_default_attributes)     (AtkText	    *text);
  void           (* get_character_extents)        (AtkText          *text,
                                                   gint             offset,
                                                   gint             *x,
                                                   gint             *y,
                                                   gint             *width,
                                                   gint             *height,
                                                   AtkCoordType	    coords);
  gint           (* get_character_count)          (AtkText          *text);
  gint           (* get_offset_at_point)          (AtkText          *text,
                                                   gint             x,
                                                   gint             y,
                                                   AtkCoordType	    coords);
  gint		 (* get_n_selections)		  (AtkText          *text);
  gchar*         (* get_selection)	          (AtkText          *text,
						   gint		    selection_num,
						   gint		    *start_offset,
						   gint		    *end_offset);
  gboolean       (* add_selection)		  (AtkText          *text,
						   gint		    start_offset,
						   gint		    end_offset);
  gboolean       (* remove_selection)		  (AtkText          *text,
						   gint             selection_num);
  gboolean       (* set_selection)		  (AtkText          *text,
						   gint		    selection_num,
						   gint		    start_offset,
						   gint		    end_offset);
  gboolean       (* set_caret_offset)             (AtkText          *text,
                                                   gint             offset);

  /*
   * signal handlers
   */
  void		 (* text_changed)                 (AtkText          *text,
                                                   gint             position,
                                                   gint             length);
  void           (* text_caret_moved)             (AtkText          *text,
                                                   gint             location);
  void           (* text_selection_changed)       (AtkText          *text);

  void           (* text_attributes_changed)      (AtkText          *text);


  void           (* get_range_extents)            (AtkText          *text,
                                                   gint             start_offset,
                                                   gint             end_offset,
                                                   AtkCoordType     coord_type,
                                                   AtkTextRectangle *rect);

  AtkTextRange** (* get_bounded_ranges)           (AtkText          *text,
                                                   AtkTextRectangle *rect,
                                                   AtkCoordType     coord_type,
                                                   AtkTextClipType  x_clip_type,
                                                   AtkTextClipType  y_clip_type);
 

  AtkFunction    pad4;
};
</STRUCT>
<FUNCTION>
<NAME>atk_text_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atk_text_get_text</NAME>
<RETURNS>gchar*</RETURNS>
AtkText          *text,gint             start_offset,gint             end_offset
</FUNCTION>
<FUNCTION>
<NAME>atk_text_get_character_at_offset</NAME>
<RETURNS>gunichar      </RETURNS>
AtkText          *text,gint             offset
</FUNCTION>
<FUNCTION>
<NAME>atk_text_get_text_after_offset</NAME>
<RETURNS>gchar*</RETURNS>
AtkText          *text,gint             offset,AtkTextBoundary  boundary_type,gint             *start_offset,gint	            *end_offset
</FUNCTION>
<FUNCTION>
<NAME>atk_text_get_text_at_offset</NAME>
<RETURNS>gchar*</RETURNS>
AtkText          *text,gint             offset,AtkTextBoundary  boundary_type,gint             *start_offset,gint             *end_offset
</FUNCTION>
<FUNCTION>
<NAME>atk_text_get_text_before_offset</NAME>
<RETURNS>gchar*</RETURNS>
AtkText          *text,gint             offset,AtkTextBoundary  boundary_type,gint             *start_offset,gint	            *end_offset
</FUNCTION>
<FUNCTION>
<NAME>atk_text_get_caret_offset</NAME>
<RETURNS>gint          </RETURNS>
AtkText          *text
</FUNCTION>
<FUNCTION>
<NAME>atk_text_get_character_extents</NAME>
<RETURNS>void          </RETURNS>
AtkText          *text,gint             offset,gint             *x,gint             *y,gint             *width,gint             *height,AtkCoordType	    coords
</FUNCTION>
<FUNCTION>
<NAME>atk_text_get_run_attributes</NAME>
<RETURNS>AtkAttributeSet*</RETURNS>
AtkText	    *text,gint	  	    offset,gint             *start_offset,gint	 	    *end_offset
</FUNCTION>
<FUNCTION>
<NAME>atk_text_get_default_attributes</NAME>
<RETURNS>AtkAttributeSet*</RETURNS>
AtkText	    *text
</FUNCTION>
<FUNCTION>
<NAME>atk_text_get_character_count</NAME>
<RETURNS>gint          </RETURNS>
AtkText          *text
</FUNCTION>
<FUNCTION>
<NAME>atk_text_get_offset_at_point</NAME>
<RETURNS>gint          </RETURNS>
AtkText          *text,gint             x,gint             y,AtkCoordType	    coords
</FUNCTION>
<FUNCTION>
<NAME>atk_text_get_n_selections</NAME>
<RETURNS>gint          </RETURNS>
AtkText          *text
</FUNCTION>
<FUNCTION>
<NAME>atk_text_get_selection</NAME>
<RETURNS>gchar*</RETURNS>
AtkText          *text,gint		    selection_num,gint             *start_offset,gint             *end_offset
</FUNCTION>
<FUNCTION>
<NAME>atk_text_add_selection</NAME>
<RETURNS>gboolean      </RETURNS>
AtkText          *text,gint             start_offset,gint             end_offset
</FUNCTION>
<FUNCTION>
<NAME>atk_text_remove_selection</NAME>
<RETURNS>gboolean      </RETURNS>
AtkText          *text,gint		    selection_num
</FUNCTION>
<FUNCTION>
<NAME>atk_text_set_selection</NAME>
<RETURNS>gboolean      </RETURNS>
AtkText          *text,gint		    selection_num,gint             start_offset,gint             end_offset
</FUNCTION>
<FUNCTION>
<NAME>atk_text_set_caret_offset</NAME>
<RETURNS>gboolean      </RETURNS>
AtkText          *text,gint             offset
</FUNCTION>
<FUNCTION>
<NAME>atk_text_get_range_extents</NAME>
<RETURNS>void          </RETURNS>
AtkText          *text,gint             start_offset,gint             end_offset,AtkCoordType     coord_type,AtkTextRectangle *rect
</FUNCTION>
<FUNCTION>
<NAME>atk_text_get_bounded_ranges</NAME>
<RETURNS>AtkTextRange**</RETURNS>
AtkText          *text,AtkTextRectangle *rect,AtkCoordType     coord_type,AtkTextClipType  x_clip_type,AtkTextClipType  y_clip_type
</FUNCTION>
<FUNCTION>
<NAME>atk_text_free_ranges</NAME>
<RETURNS>void          </RETURNS>
AtkTextRange     **ranges
</FUNCTION>
<FUNCTION>
<NAME>atk_attribute_set_free</NAME>
<RETURNS>void 	      </RETURNS>
AtkAttributeSet  *attrib_set
</FUNCTION>
<FUNCTION>
<NAME>atk_text_attribute_get_name</NAME>
<RETURNS>G_CONST_RETURN gchar*</RETURNS>
AtkTextAttribute attr
</FUNCTION>
<FUNCTION>
<NAME>atk_text_attribute_for_name</NAME>
<RETURNS>AtkTextAttribute       </RETURNS>
const gchar      *name
</FUNCTION>
<FUNCTION>
<NAME>atk_text_attribute_get_value</NAME>
<RETURNS>G_CONST_RETURN gchar*</RETURNS>
AtkTextAttribute attr,gint             index_
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_TABLE</NAME>
#define ATK_TYPE_TABLE                    (atk_table_get_type ())
</MACRO>
<MACRO>
<NAME>ATK_IS_TABLE</NAME>
#define ATK_IS_TABLE(obj)                 G_TYPE_CHECK_INSTANCE_TYPE ((obj), ATK_TYPE_TABLE)
</MACRO>
<MACRO>
<NAME>ATK_TABLE</NAME>
#define ATK_TABLE(obj)                    G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_TABLE, AtkTable)
</MACRO>
<MACRO>
<NAME>ATK_TABLE_GET_IFACE</NAME>
#define ATK_TABLE_GET_IFACE(obj)          (G_TYPE_INSTANCE_GET_INTERFACE ((obj), ATK_TYPE_TABLE, AtkTableIface))
</MACRO>
<STRUCT>
<NAME>AtkTable</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkTableIface</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkTableIface</NAME>
struct _AtkTableIface
{
  GTypeInterface parent;

  AtkObject*        (* ref_at)                   (AtkTable      *table,
                                                  gint          row,
                                                  gint          column);
  gint              (* get_index_at)             (AtkTable      *table,
                                                  gint          row,
                                                  gint          column);
  gint              (* get_column_at_index)      (AtkTable      *table,
                                                  gint          index_);
  gint              (* get_row_at_index)         (AtkTable      *table,
                                                  gint          index_);
  gint              (* get_n_columns)           (AtkTable      *table);
  gint              (* get_n_rows)               (AtkTable      *table);
  gint              (* get_column_extent_at)     (AtkTable      *table,
                                                  gint          row,
                                                  gint          column);
  gint              (* get_row_extent_at)        (AtkTable      *table,
                                                  gint          row,
                                                  gint          column);
  AtkObject*
                    (* get_caption)              (AtkTable      *table);
  G_CONST_RETURN gchar*
                    (* get_column_description)   (AtkTable      *table,
                                                  gint          column);
  AtkObject*        (* get_column_header)        (AtkTable      *table,
						  gint		column);
  G_CONST_RETURN gchar*
                    (* get_row_description)      (AtkTable      *table,
                                                  gint          row);
  AtkObject*        (* get_row_header)           (AtkTable      *table,
						  gint		row);
  AtkObject*        (* get_summary)              (AtkTable      *table);
  void              (* set_caption)              (AtkTable      *table,
                                                  AtkObject     *caption);
  void              (* set_column_description)   (AtkTable      *table,
                                                  gint          column,
                                                  const gchar   *description);
  void              (* set_column_header)        (AtkTable      *table,
                                                  gint          column,
                                                  AtkObject     *header);
  void              (* set_row_description)      (AtkTable      *table,
                                                  gint          row,
                                                  const gchar   *description);
  void              (* set_row_header)           (AtkTable      *table,
                                                  gint          row,
                                                  AtkObject     *header);
  void              (* set_summary)              (AtkTable      *table,
                                                  AtkObject     *accessible);
  gint              (* get_selected_columns)     (AtkTable      *table,
                                                  gint          **selected);
  gint              (* get_selected_rows)        (AtkTable      *table,
                                                  gint          **selected);
  gboolean          (* is_column_selected)       (AtkTable      *table,
                                                  gint          column);
  gboolean          (* is_row_selected)          (AtkTable      *table,
                                                  gint          row);
  gboolean          (* is_selected)              (AtkTable      *table,
                                                  gint          row,
                                                  gint          column);
  gboolean          (* add_row_selection)        (AtkTable      *table,
                                                  gint          row);
  gboolean          (* remove_row_selection)     (AtkTable      *table,
                                                  gint          row);
  gboolean          (* add_column_selection)     (AtkTable      *table,
                                                  gint          column);
  gboolean          (* remove_column_selection)  (AtkTable      *table,
                                                  gint          column);

  /*
   * signal handlers
   */
  void              (* row_inserted)             (AtkTable      *table,
                                                  gint          row,
                                                  gint          num_inserted);
  void              (* column_inserted)          (AtkTable      *table,
                                                  gint          column,
                                                  gint          num_inserted);
  void              (* row_deleted)              (AtkTable      *table,
                                                  gint          row,
                                                  gint          num_deleted);
  void              (* column_deleted)           (AtkTable      *table,
                                                  gint          column,
                                                  gint          num_deleted);
  void              (* row_reordered)            (AtkTable      *table);
  void              (* column_reordered)         (AtkTable      *table);
  void              (* model_changed)            (AtkTable      *table);

  AtkFunction       pad1;
  AtkFunction       pad2;
  AtkFunction       pad3;
  AtkFunction       pad4;
};
</STRUCT>
<FUNCTION>
<NAME>atk_table_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atk_table_ref_at</NAME>
<RETURNS>AtkObject*</RETURNS>
AtkTable         *table,gint             row,gint             column
</FUNCTION>
<FUNCTION>
<NAME>atk_table_get_index_at</NAME>
<RETURNS>gint              </RETURNS>
AtkTable         *table,gint             row,gint             column
</FUNCTION>
<FUNCTION>
<NAME>atk_table_get_column_at_index</NAME>
<RETURNS>gint              </RETURNS>
AtkTable         *table,gint             index_
</FUNCTION>
<FUNCTION>
<NAME>atk_table_get_row_at_index</NAME>
<RETURNS>gint              </RETURNS>
AtkTable         *table,gint             index_
</FUNCTION>
<FUNCTION>
<NAME>atk_table_get_n_columns</NAME>
<RETURNS>gint              </RETURNS>
AtkTable         *table
</FUNCTION>
<FUNCTION>
<NAME>atk_table_get_n_rows</NAME>
<RETURNS>gint              </RETURNS>
AtkTable         *table
</FUNCTION>
<FUNCTION>
<NAME>atk_table_get_column_extent_at</NAME>
<RETURNS>gint              </RETURNS>
AtkTable         *table,gint             row,gint             column
</FUNCTION>
<FUNCTION>
<NAME>atk_table_get_row_extent_at</NAME>
<RETURNS>gint              </RETURNS>
AtkTable         *table,gint             row,gint             column
</FUNCTION>
<FUNCTION>
<NAME>atk_table_get_caption</NAME>
<RETURNS>AtkObject *</RETURNS>
AtkTable         *table
</FUNCTION>
<FUNCTION>
<NAME>atk_table_get_column_description</NAME>
<RETURNS>G_CONST_RETURN gchar *</RETURNS>
AtkTable         *table,gint             column
</FUNCTION>
<FUNCTION>
<NAME>atk_table_get_column_header</NAME>
<RETURNS>AtkObject*</RETURNS>
AtkTable         *table,gint		   column
</FUNCTION>
<FUNCTION>
<NAME>atk_table_get_row_description</NAME>
<RETURNS>G_CONST_RETURN gchar *</RETURNS>
AtkTable         *table,gint             row
</FUNCTION>
<FUNCTION>
<NAME>atk_table_get_row_header</NAME>
<RETURNS>AtkObject*</RETURNS>
AtkTable         *table,gint		   row
</FUNCTION>
<FUNCTION>
<NAME>atk_table_get_summary</NAME>
<RETURNS>AtkObject*</RETURNS>
AtkTable         *table
</FUNCTION>
<FUNCTION>
<NAME>atk_table_set_caption</NAME>
<RETURNS>void              </RETURNS>
AtkTable         *table,AtkObject        *caption
</FUNCTION>
<FUNCTION>
<NAME>atk_table_set_column_description</NAME>
<RETURNS>void  </RETURNS>
AtkTable         *table,gint             column,const gchar      *description
</FUNCTION>
<FUNCTION>
<NAME>atk_table_set_column_header</NAME>
<RETURNS>void              </RETURNS>
AtkTable         *table,gint             column,AtkObject        *header
</FUNCTION>
<FUNCTION>
<NAME>atk_table_set_row_description</NAME>
<RETURNS>void              </RETURNS>
AtkTable         *table,gint             row,const gchar      *description
</FUNCTION>
<FUNCTION>
<NAME>atk_table_set_row_header</NAME>
<RETURNS>void              </RETURNS>
AtkTable         *table,gint             row,AtkObject        *header
</FUNCTION>
<FUNCTION>
<NAME>atk_table_set_summary</NAME>
<RETURNS>void              </RETURNS>
AtkTable         *table,AtkObject        *accessible
</FUNCTION>
<FUNCTION>
<NAME>atk_table_get_selected_columns</NAME>
<RETURNS>gint              </RETURNS>
AtkTable         *table,gint             **selected
</FUNCTION>
<FUNCTION>
<NAME>atk_table_get_selected_rows</NAME>
<RETURNS>gint              </RETURNS>
AtkTable         *table,gint             **selected
</FUNCTION>
<FUNCTION>
<NAME>atk_table_is_column_selected</NAME>
<RETURNS>gboolean          </RETURNS>
AtkTable         *table,gint             column
</FUNCTION>
<FUNCTION>
<NAME>atk_table_is_row_selected</NAME>
<RETURNS>gboolean          </RETURNS>
AtkTable         *table,gint             row
</FUNCTION>
<FUNCTION>
<NAME>atk_table_is_selected</NAME>
<RETURNS>gboolean          </RETURNS>
AtkTable         *table,gint             row,gint             column
</FUNCTION>
<FUNCTION>
<NAME>atk_table_add_row_selection</NAME>
<RETURNS>gboolean          </RETURNS>
AtkTable         *table,gint             row
</FUNCTION>
<FUNCTION>
<NAME>atk_table_remove_row_selection</NAME>
<RETURNS>gboolean          </RETURNS>
AtkTable         *table,gint             row
</FUNCTION>
<FUNCTION>
<NAME>atk_table_add_column_selection</NAME>
<RETURNS>gboolean          </RETURNS>
AtkTable         *table,gint             column
</FUNCTION>
<FUNCTION>
<NAME>atk_table_remove_column_selection</NAME>
<RETURNS>gboolean  </RETURNS>
AtkTable         *table,gint             column
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_NO_OP_OBJECT_FACTORY</NAME>
#define ATK_TYPE_NO_OP_OBJECT_FACTORY                (atk_no_op_object_factory_get_type ())
</MACRO>
<MACRO>
<NAME>ATK_NO_OP_OBJECT_FACTORY</NAME>
#define ATK_NO_OP_OBJECT_FACTORY(obj)               (G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_NO_OP_OBJECT_FACTORY, AtkNoOpObjectFactory))
</MACRO>
<MACRO>
<NAME>ATK_NO_OP_OBJECT_FACTORY_CLASS</NAME>
#define ATK_NO_OP_OBJECT_FACTORY_CLASS(klass)       (G_TYPE_CHECK_CLASS_CAST ((klass), ATK_TYPE_NO_OP_OBJECT_FACTORY, AtkNoOpObjectFactoryClass))
</MACRO>
<MACRO>
<NAME>ATK_IS_NO_OP_OBJECT_FACTORY</NAME>
#define ATK_IS_NO_OP_OBJECT_FACTORY(obj)            (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ATK_TYPE_NO_OP_OBJECT_FACTORY))
</MACRO>
<MACRO>
<NAME>ATK_IS_NO_OP_OBJECT_FACTORY_CLASS</NAME>
#define ATK_IS_NO_OP_OBJECT_FACTORY_CLASS(klass)    (G_TYPE_CHECK_CLASS_TYPE ((klass), ATK_TYPE_NO_OP_OBJECT_FACTORY))
</MACRO>
<MACRO>
<NAME>ATK_NO_OP_OBJECT_FACTORY_GET_CLASS</NAME>
#define ATK_NO_OP_OBJECT_FACTORY_GET_CLASS(obj)     (G_TYPE_INSTANCE_GET_CLASS ( (obj), ATK_TYPE_NO_OP_OBJECT_FACTORY, AtkNoOpObjectFactoryClass))
</MACRO>
<STRUCT>
<NAME>AtkNoOpObjectFactory</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkNoOpObjectFactoryClass</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkNoOpObjectFactory</NAME>
struct _AtkNoOpObjectFactory
{
  AtkObjectFactory parent;
};
</STRUCT>
<STRUCT>
<NAME>AtkNoOpObjectFactoryClass</NAME>
struct _AtkNoOpObjectFactoryClass
{
  AtkObjectFactoryClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>atk_no_op_object_factory_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atk_no_op_object_factory_new</NAME>
<RETURNS>AtkObjectFactory *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_NO_OP_OBJECT</NAME>
#define ATK_TYPE_NO_OP_OBJECT                (atk_no_op_object_get_type ())
</MACRO>
<MACRO>
<NAME>ATK_NO_OP_OBJECT</NAME>
#define ATK_NO_OP_OBJECT(obj)                (G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_NO_OP_OBJECT, AtkNoOpObject))
</MACRO>
<MACRO>
<NAME>ATK_NO_OP_OBJECT_CLASS</NAME>
#define ATK_NO_OP_OBJECT_CLASS(klass)        (G_TYPE_CHECK_CLASS_CAST ((klass), ATK_TYPE_NO_OP_OBJECT, AtkNoOpObjectClass))
</MACRO>
<MACRO>
<NAME>ATK_IS_NO_OP_OBJECT</NAME>
#define ATK_IS_NO_OP_OBJECT(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ATK_TYPE_NO_OP_OBJECT))
</MACRO>
<MACRO>
<NAME>ATK_IS_NO_OP_OBJECT_CLASS</NAME>
#define ATK_IS_NO_OP_OBJECT_CLASS(klass)     (G_TYPE_CHECK_CLASS_TYPE ((klass), ATK_TYPE_NO_OP_OBJECT))
</MACRO>
<MACRO>
<NAME>ATK_NO_OP_OBJECT_GET_CLASS</NAME>
#define ATK_NO_OP_OBJECT_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), ATK_TYPE_NO_OP_OBJECT, AtkNoOpObjectClass))
</MACRO>
<STRUCT>
<NAME>AtkNoOpObject</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkNoOpObjectClass</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkNoOpObject</NAME>
struct _AtkNoOpObject
{
  AtkObject     parent;
};
</STRUCT>
<FUNCTION>
<NAME>atk_no_op_object_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>AtkNoOpObjectClass</NAME>
struct _AtkNoOpObjectClass
{
  AtkObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>atk_no_op_object_new</NAME>
<RETURNS>AtkObject *</RETURNS>
GObject  *obj
</FUNCTION>
<ENUM>
<NAME>AtkHyperlinkStateFlags</NAME>
typedef enum 
{
  ATK_HYPERLINK_IS_INLINE = 1 << 0
} AtkHyperlinkStateFlags;
</ENUM>
<MACRO>
<NAME>ATK_TYPE_HYPERLINK</NAME>
#define ATK_TYPE_HYPERLINK                        (atk_hyperlink_get_type ())
</MACRO>
<MACRO>
<NAME>ATK_HYPERLINK</NAME>
#define ATK_HYPERLINK(obj)                        (G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_HYPERLINK, AtkHyperlink))
</MACRO>
<MACRO>
<NAME>ATK_HYPERLINK_CLASS</NAME>
#define ATK_HYPERLINK_CLASS(klass)                (G_TYPE_CHECK_CLASS_CAST ((klass), ATK_TYPE_HYPERLINK, AtkHyperlinkClass))
</MACRO>
<MACRO>
<NAME>ATK_IS_HYPERLINK</NAME>
#define ATK_IS_HYPERLINK(obj)                     (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ATK_TYPE_HYPERLINK))
</MACRO>
<MACRO>
<NAME>ATK_IS_HYPERLINK_CLASS</NAME>
#define ATK_IS_HYPERLINK_CLASS(klass)             (G_TYPE_CHECK_CLASS_TYPE ((klass), ATK_TYPE_HYPERLINK))
</MACRO>
<MACRO>
<NAME>ATK_HYPERLINK_GET_CLASS</NAME>
#define ATK_HYPERLINK_GET_CLASS(obj)              (G_TYPE_INSTANCE_GET_CLASS ((obj), ATK_TYPE_HYPERLINK, AtkHyperlinkClass))
</MACRO>
<STRUCT>
<NAME>AtkHyperlink</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkHyperlinkClass</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkHyperlink</NAME>
struct _AtkHyperlink
{
  GObject parent;
};
</STRUCT>
<STRUCT>
<NAME>AtkHyperlinkClass</NAME>
struct _AtkHyperlinkClass
{
  GObjectClass parent;

  gchar*           (* get_uri)             (AtkHyperlink     *link_,
                                            gint             i);
  AtkObject*       (* get_object)          (AtkHyperlink     *link_,
                                            gint             i);
  gint             (* get_end_index)       (AtkHyperlink     *link_);
  gint             (* get_start_index)     (AtkHyperlink     *link_);
  gboolean         (* is_valid)            (AtkHyperlink     *link_);
  gint	           (* get_n_anchors)	   (AtkHyperlink     *link_);
  guint	           (* link_state)	   (AtkHyperlink     *link_);
  gboolean         (* is_selected_link)    (AtkHyperlink     *link_);

  /* Signals */
  void             ( *link_activated)      (AtkHyperlink     *link_);
  AtkFunction      pad1;
};
</STRUCT>
<FUNCTION>
<NAME>atk_hyperlink_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atk_hyperlink_get_uri</NAME>
<RETURNS>gchar*</RETURNS>
AtkHyperlink     *link_,gint             i
</FUNCTION>
<FUNCTION>
<NAME>atk_hyperlink_get_object</NAME>
<RETURNS>AtkObject*</RETURNS>
AtkHyperlink     *link_,gint             i
</FUNCTION>
<FUNCTION>
<NAME>atk_hyperlink_get_end_index</NAME>
<RETURNS>gint             </RETURNS>
AtkHyperlink     *link_
</FUNCTION>
<FUNCTION>
<NAME>atk_hyperlink_get_start_index</NAME>
<RETURNS>gint             </RETURNS>
AtkHyperlink     *link_
</FUNCTION>
<FUNCTION>
<NAME>atk_hyperlink_is_valid</NAME>
<RETURNS>gboolean         </RETURNS>
AtkHyperlink     *link_
</FUNCTION>
<FUNCTION>
<NAME>atk_hyperlink_is_inline</NAME>
<RETURNS>gboolean         </RETURNS>
AtkHyperlink     *link_
</FUNCTION>
<FUNCTION>
<NAME>atk_hyperlink_get_n_anchors</NAME>
<RETURNS>gint		 </RETURNS>
AtkHyperlink     *link_
</FUNCTION>
<FUNCTION>
<NAME>atk_hyperlink_is_selected_link</NAME>
<RETURNS>gboolean         </RETURNS>
AtkHyperlink     *link_
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_STREAMABLE_CONTENT</NAME>
#define ATK_TYPE_STREAMABLE_CONTENT           (atk_streamable_content_get_type ())
</MACRO>
<MACRO>
<NAME>ATK_IS_STREAMABLE_CONTENT</NAME>
#define ATK_IS_STREAMABLE_CONTENT(obj)        G_TYPE_CHECK_INSTANCE_TYPE ((obj), ATK_TYPE_STREAMABLE_CONTENT)
</MACRO>
<MACRO>
<NAME>ATK_STREAMABLE_CONTENT</NAME>
#define ATK_STREAMABLE_CONTENT(obj)           G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_STREAMABLE_CONTENT, AtkStreamableContent)
</MACRO>
<MACRO>
<NAME>ATK_STREAMABLE_CONTENT_GET_IFACE</NAME>
#define ATK_STREAMABLE_CONTENT_GET_IFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), ATK_TYPE_STREAMABLE_CONTENT, AtkStreamableContentIface))
</MACRO>
<STRUCT>
<NAME>AtkStreamableContent</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkStreamableContentIface</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkStreamableContentIface</NAME>
struct _AtkStreamableContentIface
{
  GTypeInterface parent;

  /*
   * Get the number of mime types supported by this object
   */
  gint                      (* get_n_mime_types)  (AtkStreamableContent     *streamable);
  /*
   * Gets the specified mime type supported by this object.
   * The mime types are 0-based so the first mime type is 
   * at index 0, the second at index 1 and so on.  The mime-type
   * at index 0 should be considered the "default" data type for the stream.
   *
   * This assumes that the strings for the mime types are stored in the
   * AtkStreamableContent. Alternatively the G_CONST_RETURN could be removed
   * and the caller would be responsible for calling g_free() on the
   * returned value.
   */
  G_CONST_RETURN gchar*     (* get_mime_type)     (AtkStreamableContent     *streamable,
                                                   gint                     i);
  /*
   * One possible implementation for this method is that it constructs the
   * content appropriate for the mime type and then creates a temporary
   * file containing the content, opens the file and then calls
   * g_io_channel_unix_new_fd().
   */
  GIOChannel*               (* get_stream)        (AtkStreamableContent     *streamable,
                                                   const gchar              *mime_type);

/*
 * Returns a string representing a URI in IETF standard format
 * (see http://www.ietf.org/rfc/rfc2396.txt) from which the object's content
 * may be streamed in the specified mime-type.
 * If mime_type is NULL, the URI for the default (and possibly only) mime-type is
 * returned.
 *
 * returns NULL if the mime-type is not supported, or if no URI can be 
 * constructed.  Note that it is possible for get_uri to return NULL but for
 * get_stream to work nonetheless, since not all GIOChannels connect to URIs.
 */
    G_CONST_RETURN  gchar*  (* get_uri)           (AtkStreamableContent     *streamable,
                                                   const gchar              *mime_type);


  AtkFunction               pad1;
  AtkFunction               pad2;
  AtkFunction               pad3;
};
</STRUCT>
<FUNCTION>
<NAME>atk_streamable_content_get_type</NAME>
<RETURNS>GType                  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atk_streamable_content_get_n_mime_types</NAME>
<RETURNS>gint                   </RETURNS>
AtkStreamableContent     *streamable
</FUNCTION>
<FUNCTION>
<NAME>atk_streamable_content_get_mime_type</NAME>
<RETURNS>G_CONST_RETURN gchar*</RETURNS>
AtkStreamableContent     *streamable,gint                     i
</FUNCTION>
<FUNCTION>
<NAME>atk_streamable_content_get_stream</NAME>
<RETURNS>GIOChannel*</RETURNS>
AtkStreamableContent     *streamable,const gchar              *mime_type
</FUNCTION>
<FUNCTION>
<NAME>atk_streamable_content_get_uri</NAME>
<RETURNS>gchar*</RETURNS>
AtkStreamableContent     *streamable,const gchar              *mime_type
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_VALUE</NAME>
#define ATK_TYPE_VALUE                    (atk_value_get_type ())
</MACRO>
<MACRO>
<NAME>ATK_IS_VALUE</NAME>
#define ATK_IS_VALUE(obj)                 G_TYPE_CHECK_INSTANCE_TYPE ((obj), ATK_TYPE_VALUE)
</MACRO>
<MACRO>
<NAME>ATK_VALUE</NAME>
#define ATK_VALUE(obj)                    G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_VALUE, AtkValue)
</MACRO>
<MACRO>
<NAME>ATK_VALUE_GET_IFACE</NAME>
#define ATK_VALUE_GET_IFACE(obj)          (G_TYPE_INSTANCE_GET_INTERFACE ((obj), ATK_TYPE_VALUE, AtkValueIface))
</MACRO>
<STRUCT>
<NAME>AtkValue</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkValueIface</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkValueIface</NAME>
struct _AtkValueIface
{
  GTypeInterface parent;

  void     (* get_current_value) (AtkValue     *obj,
                                  GValue       *value);
  void     (* get_maximum_value) (AtkValue     *obj,
                                  GValue       *value);
  void     (* get_minimum_value) (AtkValue     *obj,
                                  GValue       *value);
  gboolean (* set_current_value) (AtkValue     *obj,
                                  const GValue *value);
  void     (* get_minimum_increment) (AtkValue   *obj,
				      GValue     *value);
  AtkFunction pad1;
};
</STRUCT>
<FUNCTION>
<NAME>atk_value_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atk_value_get_current_value</NAME>
<RETURNS>void      </RETURNS>
AtkValue     *obj,GValue       *value
</FUNCTION>
<FUNCTION>
<NAME>atk_value_get_maximum_value</NAME>
<RETURNS>void     </RETURNS>
AtkValue     *obj,GValue       *value
</FUNCTION>
<FUNCTION>
<NAME>atk_value_get_minimum_value</NAME>
<RETURNS>void     </RETURNS>
AtkValue     *obj,GValue       *value
</FUNCTION>
<FUNCTION>
<NAME>atk_value_set_current_value</NAME>
<RETURNS>gboolean </RETURNS>
AtkValue     *obj,const GValue *value
</FUNCTION>
<FUNCTION>
<NAME>atk_value_get_minimum_increment</NAME>
<RETURNS>void     </RETURNS>
AtkValue     *obj,GValue       *value
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_DOCUMENT</NAME>
#define ATK_TYPE_DOCUMENT                   (atk_document_get_type ())
</MACRO>
<MACRO>
<NAME>ATK_IS_DOCUMENT</NAME>
#define ATK_IS_DOCUMENT(obj)                G_TYPE_CHECK_INSTANCE_TYPE ((obj), ATK_TYPE_DOCUMENT)
</MACRO>
<MACRO>
<NAME>ATK_DOCUMENT</NAME>
#define ATK_DOCUMENT(obj)                   G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_DOCUMENT, AtkDocument)
</MACRO>
<MACRO>
<NAME>ATK_DOCUMENT_GET_IFACE</NAME>
#define ATK_DOCUMENT_GET_IFACE(obj)         (G_TYPE_INSTANCE_GET_INTERFACE ((obj), ATK_TYPE_DOCUMENT, AtkDocumentIface))
</MACRO>
<STRUCT>
<NAME>AtkDocument</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkDocumentIface</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkDocumentIface</NAME>
struct _AtkDocumentIface
{
  GTypeInterface parent;
  G_CONST_RETURN gchar* ( *get_document_type) (AtkDocument              *document);
  gpointer              ( *get_document)      (AtkDocument              *document);

  G_CONST_RETURN gchar* ( *get_document_locale) (AtkDocument              *document);
  AtkAttributeSet *     ( *get_document_attributes) (AtkDocument        *document);
  G_CONST_RETURN gchar* ( *get_document_attribute_value) (AtkDocument   *document,
                                                          const gchar   *attribute_name);
  gboolean              ( *set_document_attribute) (AtkDocument         *document,
                                                    const gchar         *attribute_name,
                                                    const gchar         *attribute_value);
  
  AtkFunction pad1;
  AtkFunction pad2;
  AtkFunction pad3;
  AtkFunction pad4;
};
</STRUCT>
<FUNCTION>
<NAME>atk_document_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atk_document_get_document_type</NAME>
<RETURNS>G_CONST_RETURN gchar*</RETURNS>
AtkDocument   *document
</FUNCTION>
<FUNCTION>
<NAME>atk_document_get_document</NAME>
<RETURNS>gpointer </RETURNS>
AtkDocument   *document
</FUNCTION>
<FUNCTION>
<NAME>atk_document_get_locale</NAME>
<RETURNS>G_CONST_RETURN gchar*</RETURNS>
AtkDocument *document
</FUNCTION>
<FUNCTION>
<NAME>atk_document_get_attributes</NAME>
<RETURNS>AtkAttributeSet*</RETURNS>
AtkDocument *document
</FUNCTION>
<FUNCTION>
<NAME>atk_document_get_attribute_value</NAME>
<RETURNS>G_CONST_RETURN gchar*</RETURNS>
AtkDocument *document,const gchar *attribute_name
</FUNCTION>
<FUNCTION>
<NAME>atk_document_set_attribute_value</NAME>
<RETURNS>gboolean              </RETURNS>
AtkDocument *document,const gchar *attribute_name,const gchar *attribute_value
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_EDITABLE_TEXT</NAME>
#define ATK_TYPE_EDITABLE_TEXT                    (atk_editable_text_get_type ())
</MACRO>
<MACRO>
<NAME>ATK_IS_EDITABLE_TEXT</NAME>
#define ATK_IS_EDITABLE_TEXT(obj)                 G_TYPE_CHECK_INSTANCE_TYPE ((obj), ATK_TYPE_EDITABLE_TEXT)
</MACRO>
<MACRO>
<NAME>ATK_EDITABLE_TEXT</NAME>
#define ATK_EDITABLE_TEXT(obj)                    G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_EDITABLE_TEXT, AtkEditableText)
</MACRO>
<MACRO>
<NAME>ATK_EDITABLE_TEXT_GET_IFACE</NAME>
#define ATK_EDITABLE_TEXT_GET_IFACE(obj)          (G_TYPE_INSTANCE_GET_INTERFACE ((obj), ATK_TYPE_EDITABLE_TEXT, AtkEditableTextIface))
</MACRO>
<STRUCT>
<NAME>AtkEditableText</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkEditableTextIface</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkEditableTextIface</NAME>
struct _AtkEditableTextIface
{
  GTypeInterface parent_interface;

  gboolean (* set_run_attributes) (AtkEditableText  *text,
                                   AtkAttributeSet  *attrib_set,
                                   gint		    start_offset,
 				   gint		    end_offset);
  void   (* set_text_contents)    (AtkEditableText  *text,
                                   const gchar      *string);
  void   (* insert_text)          (AtkEditableText  *text,
                                   const gchar      *string,
                                   gint             length,
                                   gint             *position);
  void   (* copy_text)            (AtkEditableText  *text,
                                   gint             start_pos,
                                   gint             end_pos);
  void   (* cut_text)             (AtkEditableText  *text,
                                   gint             start_pos,
                                   gint             end_pos);
  void   (* delete_text)          (AtkEditableText  *text,
                                   gint             start_pos,
                                   gint             end_pos);
  void   (* paste_text)           (AtkEditableText  *text,
                                   gint             position);

  AtkFunction                     pad1;
  AtkFunction                     pad2;
};
</STRUCT>
<FUNCTION>
<NAME>atk_editable_text_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atk_editable_text_set_run_attributes</NAME>
<RETURNS>gboolean </RETURNS>
AtkEditableText          *text,AtkAttributeSet  *attrib_set,gint    	        start_offset,gint	        end_offset
</FUNCTION>
<FUNCTION>
<NAME>atk_editable_text_set_text_contents</NAME>
<RETURNS>void </RETURNS>
AtkEditableText  *text,const gchar      *string
</FUNCTION>
<FUNCTION>
<NAME>atk_editable_text_insert_text</NAME>
<RETURNS>void </RETURNS>
AtkEditableText  *text,const gchar      *string,gint             length,gint             *position
</FUNCTION>
<FUNCTION>
<NAME>atk_editable_text_copy_text</NAME>
<RETURNS>void </RETURNS>
AtkEditableText  *text,gint             start_pos,gint             end_pos
</FUNCTION>
<FUNCTION>
<NAME>atk_editable_text_cut_text</NAME>
<RETURNS>void </RETURNS>
AtkEditableText  *text,gint             start_pos,gint             end_pos
</FUNCTION>
<FUNCTION>
<NAME>atk_editable_text_delete_text</NAME>
<RETURNS>void </RETURNS>
AtkEditableText  *text,gint             start_pos,gint             end_pos
</FUNCTION>
<FUNCTION>
<NAME>atk_editable_text_paste_text</NAME>
<RETURNS>void </RETURNS>
AtkEditableText  *text,gint             position
</FUNCTION>
<ENUM>
<NAME>AtkStateType</NAME>
typedef enum
{
  ATK_STATE_INVALID,
  ATK_STATE_ACTIVE,
  ATK_STATE_ARMED,
  ATK_STATE_BUSY,
  ATK_STATE_CHECKED,
  ATK_STATE_DEFUNCT,
  ATK_STATE_EDITABLE,
  ATK_STATE_ENABLED,
  ATK_STATE_EXPANDABLE,
  ATK_STATE_EXPANDED,
  ATK_STATE_FOCUSABLE,
  ATK_STATE_FOCUSED,
  ATK_STATE_HORIZONTAL,
  ATK_STATE_ICONIFIED,
  ATK_STATE_MODAL,
  ATK_STATE_MULTI_LINE,
  ATK_STATE_MULTISELECTABLE,
  ATK_STATE_OPAQUE,
  ATK_STATE_PRESSED,
  ATK_STATE_RESIZABLE,
  ATK_STATE_SELECTABLE,
  ATK_STATE_SELECTED,
  ATK_STATE_SENSITIVE,
  ATK_STATE_SHOWING,
  ATK_STATE_SINGLE_LINE,
  ATK_STATE_STALE,
  ATK_STATE_TRANSIENT,
  ATK_STATE_VERTICAL,
  ATK_STATE_VISIBLE,
  ATK_STATE_MANAGES_DESCENDANTS,
  ATK_STATE_INDETERMINATE,
  ATK_STATE_TRUNCATED,
  ATK_STATE_REQUIRED,
  ATK_STATE_INVALID_ENTRY,
  ATK_STATE_SUPPORTS_AUTOCOMPLETION,
  ATK_STATE_SELECTABLE_TEXT,
  ATK_STATE_DEFAULT,
  ATK_STATE_ANIMATED,
  ATK_STATE_VISITED,
	
  ATK_STATE_LAST_DEFINED
} AtkStateType;
</ENUM>
<TYPEDEF>
<NAME>AtkState</NAME>
typedef guint64      AtkState;
</TYPEDEF>
<FUNCTION>
<NAME>atk_state_type_register</NAME>
<RETURNS>AtkStateType </RETURNS>
const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>atk_state_type_get_name</NAME>
<RETURNS>G_CONST_RETURN gchar*</RETURNS>
AtkStateType type
</FUNCTION>
<FUNCTION>
<NAME>atk_state_type_for_name</NAME>
<RETURNS>AtkStateType          </RETURNS>
const gchar  *name
</FUNCTION>
<FUNCTION>
<NAME>atk_hyperlink_state_flags_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_HYPERLINK_STATE_FLAGS</NAME>
#define ATK_TYPE_HYPERLINK_STATE_FLAGS (atk_hyperlink_state_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>atk_role_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_ROLE</NAME>
#define ATK_TYPE_ROLE (atk_role_get_type())
</MACRO>
<FUNCTION>
<NAME>atk_layer_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_LAYER</NAME>
#define ATK_TYPE_LAYER (atk_layer_get_type())
</MACRO>
<FUNCTION>
<NAME>atk_relation_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_RELATION_TYPE</NAME>
#define ATK_TYPE_RELATION_TYPE (atk_relation_type_get_type())
</MACRO>
<FUNCTION>
<NAME>atk_state_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_STATE_TYPE</NAME>
#define ATK_TYPE_STATE_TYPE (atk_state_type_get_type())
</MACRO>
<FUNCTION>
<NAME>atk_text_attribute_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_TEXT_ATTRIBUTE</NAME>
#define ATK_TYPE_TEXT_ATTRIBUTE (atk_text_attribute_get_type())
</MACRO>
<FUNCTION>
<NAME>atk_text_boundary_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_TEXT_BOUNDARY</NAME>
#define ATK_TYPE_TEXT_BOUNDARY (atk_text_boundary_get_type())
</MACRO>
<FUNCTION>
<NAME>atk_text_clip_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_TEXT_CLIP_TYPE</NAME>
#define ATK_TYPE_TEXT_CLIP_TYPE (atk_text_clip_type_get_type())
</MACRO>
<FUNCTION>
<NAME>atk_key_event_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_KEY_EVENT_TYPE</NAME>
#define ATK_TYPE_KEY_EVENT_TYPE (atk_key_event_type_get_type())
</MACRO>
<FUNCTION>
<NAME>atk_coord_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_COORD_TYPE</NAME>
#define ATK_TYPE_COORD_TYPE (atk_coord_type_get_type())
</MACRO>
<MACRO>
<NAME>ATK_TYPE_SELECTION</NAME>
#define ATK_TYPE_SELECTION                        (atk_selection_get_type ())
</MACRO>
<MACRO>
<NAME>ATK_IS_SELECTION</NAME>
#define ATK_IS_SELECTION(obj)                     G_TYPE_CHECK_INSTANCE_TYPE ((obj), ATK_TYPE_SELECTION)
</MACRO>
<MACRO>
<NAME>ATK_SELECTION</NAME>
#define ATK_SELECTION(obj)                        G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_SELECTION, AtkSelection)
</MACRO>
<MACRO>
<NAME>ATK_SELECTION_GET_IFACE</NAME>
#define ATK_SELECTION_GET_IFACE(obj)              (G_TYPE_INSTANCE_GET_INTERFACE ((obj), ATK_TYPE_SELECTION, AtkSelectionIface))
</MACRO>
<STRUCT>
<NAME>AtkSelection</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkSelectionIface</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkSelectionIface</NAME>
struct _AtkSelectionIface
{
  GTypeInterface parent;

  gboolean     (* add_selection)        (AtkSelection   *selection,
                                         gint           i);
  gboolean     (* clear_selection)      (AtkSelection   *selection);
  AtkObject*   (* ref_selection)        (AtkSelection   *selection,
                                         gint           i);
  gint         (* get_selection_count)  (AtkSelection   *selection);
  gboolean     (* is_child_selected)    (AtkSelection   *selection,
                                         gint           i);
  gboolean     (* remove_selection)     (AtkSelection   *selection,
                                         gint           i);
  gboolean     (* select_all_selection) (AtkSelection   *selection);

  /* signal handlers */
  
  void         (*selection_changed)     (AtkSelection   *selection);

  AtkFunction  pad1;
  AtkFunction  pad2;
};
</STRUCT>
<FUNCTION>
<NAME>atk_selection_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atk_selection_add_selection</NAME>
<RETURNS>gboolean     </RETURNS>
AtkSelection   *selection,gint           i
</FUNCTION>
<FUNCTION>
<NAME>atk_selection_clear_selection</NAME>
<RETURNS>gboolean     </RETURNS>
AtkSelection   *selection
</FUNCTION>
<FUNCTION>
<NAME>atk_selection_ref_selection</NAME>
<RETURNS>AtkObject*</RETURNS>
AtkSelection   *selection,gint           i
</FUNCTION>
<FUNCTION>
<NAME>atk_selection_get_selection_count</NAME>
<RETURNS>gint         </RETURNS>
AtkSelection   *selection
</FUNCTION>
<FUNCTION>
<NAME>atk_selection_is_child_selected</NAME>
<RETURNS>gboolean     </RETURNS>
AtkSelection   *selection,gint           i
</FUNCTION>
<FUNCTION>
<NAME>atk_selection_remove_selection</NAME>
<RETURNS>gboolean     </RETURNS>
AtkSelection   *selection,gint           i
</FUNCTION>
<FUNCTION>
<NAME>atk_selection_select_all_selection</NAME>
<RETURNS>gboolean     </RETURNS>
AtkSelection   *selection
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_HYPERLINK_IMPL</NAME>
#define ATK_TYPE_HYPERLINK_IMPL          (atk_hyperlink_impl_get_type ())
</MACRO>
<MACRO>
<NAME>ATK_IS_HYPERLINK_IMPL</NAME>
#define ATK_IS_HYPERLINK_IMPL(obj)       G_TYPE_CHECK_INSTANCE_TYPE ((obj), ATK_TYPE_HYPERLINK_IMPL)
</MACRO>
<MACRO>
<NAME>ATK_HYPERLINK_IMPL</NAME>
#define ATK_HYPERLINK_IMPL(obj)             G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_HYPERLINK_IMPL, AtkHyperlinkImpl)
</MACRO>
<MACRO>
<NAME>ATK_HYPERLINK_IMPL_GET_IFACE</NAME>
#define ATK_HYPERLINK_IMPL_GET_IFACE(obj)   G_TYPE_INSTANCE_GET_INTERFACE ((obj), ATK_TYPE_HYPERLINK_IMPL, AtkHyperlinkImplIface)
</MACRO>
<STRUCT>
<NAME>AtkHyperlinkImpl</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkHyperlinkImplIface</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkHyperlinkImplIface</NAME>
struct _AtkHyperlinkImplIface
{
  GTypeInterface parent;
    
  AtkHyperlink*  (* get_hyperlink) (AtkHyperlinkImpl *impl);

  AtkFunction pad1;
};
</STRUCT>
<FUNCTION>
<NAME>atk_hyperlink_impl_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atk_hyperlink_impl_get_hyperlink</NAME>
<RETURNS>AtkHyperlink    *</RETURNS>
AtkHyperlinkImpl *obj
</FUNCTION>
<MACRO>
<NAME>ATK_TYPE_MISC</NAME>
#define ATK_TYPE_MISC                   (atk_misc_get_type ())
</MACRO>
<MACRO>
<NAME>ATK_IS_MISC</NAME>
#define ATK_IS_MISC(obj)                G_TYPE_CHECK_INSTANCE_TYPE ((obj), ATK_TYPE_MISC)
</MACRO>
<MACRO>
<NAME>ATK_MISC</NAME>
#define ATK_MISC(obj)                   G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_MISC, AtkMisc)
</MACRO>
<MACRO>
<NAME>ATK_MISC_CLASS</NAME>
#define ATK_MISC_CLASS(klass)                   (G_TYPE_CHECK_CLASS_CAST ((klass), ATK_TYPE_MISC, AtkMiscClass))
</MACRO>
<MACRO>
<NAME>ATK_IS_MISC_CLASS</NAME>
#define ATK_IS_MISC_CLASS(klass)                (G_TYPE_CHECK_CLASS_TYPE ((klass), ATK_TYPE_MISC))
</MACRO>
<MACRO>
<NAME>ATK_MISC_GET_CLASS</NAME>
#define ATK_MISC_GET_CLASS(obj)                 (G_TYPE_INSTANCE_GET_CLASS ((obj), ATK_TYPE_MISC, AtkMiscClass))
</MACRO>
<STRUCT>
<NAME>AtkMisc</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkMiscClass</NAME>
</STRUCT>
<STRUCT>
<NAME>AtkMisc</NAME>
struct _AtkMisc
{
  GObject parent;
};
</STRUCT>
<VARIABLE>
<NAME>atk_misc_instance</NAME>
extern AtkMisc *atk_misc_instance;
</VARIABLE>
<STRUCT>
<NAME>AtkMiscClass</NAME>
struct _AtkMiscClass
{
   GObjectClass parent;
   void   (* threads_enter)                     (AtkMisc *misc);
   void   (* threads_leave)                     (AtkMisc *misc);
   gpointer vfuncs[32]; /* future bincompat */
};
</STRUCT>
<FUNCTION>
<NAME>atk_misc_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atk_misc_threads_enter</NAME>
<RETURNS>void     </RETURNS>
AtkMisc *misc
</FUNCTION>
<FUNCTION>
<NAME>atk_misc_threads_leave</NAME>
<RETURNS>void     </RETURNS>
AtkMisc *misc
</FUNCTION>
<FUNCTION>
<NAME>atk_misc_get_instance</NAME>
<RETURNS>const AtkMisc *</RETURNS>
void
</FUNCTION>
