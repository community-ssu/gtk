<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 6.0/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="numpy.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE> 19.	 Properties Reference</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">
<H1 CLASS="Chapter">
<A NAME="pgfId-305690"></A>19.	 <A NAME="10775"></A>Properties Reference</H1>
<P CLASS="ChapterDescription">
<A NAME="pgfId-305691"></A><A NAME="marker-306251"></A>The package Properties defines one module, PropertiedClasses. PropertiedClasses is a module that defines a mix-in class PropertiedClass. Classes that inherit it appear have what appear to be attributes that are actually read, written or deleted via functions. </P>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-305692"></A>Defining a property</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-305693"></A>A <A NAME="marker-306252"></A>property y in a class C is defined by associating the name y to functions that respond to one or more of the three possible operations on attributes:</P>
<OL>
<LI CLASS="Numbered1">
<A NAME="pgfId-305700"></A>&quot;get&quot;, returning the result of the Python syntax x.y, where x is an instance of C, by defining a method g(self, name);</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-305705"></A>&quot;set&quot;, performing an operation in response to the Python statement x.y = value, by defining a method s(self, name, value); and,</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-305706"></A><A NAME="marker-306259"></A>&quot;delete&quot;, performing an operation in response to the Python statement del x.y, by defining a method d(self, name).</LI>
</OL>
<P CLASS="Body">
<A NAME="pgfId-305712"></A>The association is performed by calls to PropertiedClasses.set_property as explained below. We refer to these functions as the &quot;handlers&quot; for the property. In defining a property, you can specify one, two, or three of the functions above. If you do not specify an attribute, the normal attribute fetch mechanism can be used (which means that self.__dict__[name] is returned, set, or deleted, respectively). </P>
<P CLASS="Body">
<A NAME="pgfId-305726"></A>Additionally, set_property allows you to use a short-hand method of arranging for the attribute to be unwriteable and/or undeleteable via the normal mechanisms.</P>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305730"></A>Evading the mechanism</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-305734"></A>There are two ways to avoid the property mechanism, which you may want to do, for example, to set a value to a &quot;unwriteable&quot; attribute.</P>
<P CLASS="Body">
<A NAME="pgfId-305729"></A>First, PropertiedClass defines a method is_internal_attribute (self, name) which may be redefined in a child. The default version is to true if the name begins with an underscore. Names for which <BR>
is_internal_attribute(self, name) is true are always treated as names to which the property mechanism does not apply, and no attempt is made to locate &quot;handlers&quot; for them.</P>
<P CLASS="Body">
<A NAME="pgfId-304172"></A>Secondly, methods <A NAME="marker-306260"></A>_basic_get (self, name), <A NAME="marker-306261"></A>_basic_set (self, name, value), and <A NAME="marker-306262"></A>_basic_del (self, name) are available to perform the &quot;normal&quot; get, set, and delete functions via the instance dictionary, self.__dict__.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305737"></A>Creating the class</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-305741"></A>In defining a class that will have properties, all you have to do is inherit from <A NAME="marker-306250"></A>PropertiedClass. You also need to exercise great caution in overriding any of the three special attributes related to attribute handling, __getattr__, __setattr__, and __delattr__, since PropertiedClass defines these in order to do its job. The property behavior can be lost if any child's versions do not call the parent versions of these routines.</P>
<P CLASS="Body">
<A NAME="pgfId-305747"></A>In writing the methods of your class, be aware that the properties you define will be active even in the initialization routine for the class. You may in particular need to use _basic_set to create the initial state.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305742"></A>Setting a property</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-305746"></A>The module function <A NAME="marker-306249"></A>set_property should be called immediately after the class definition to set properties:</P>
<P CLASS="PythonDefinition">
<A NAME="pgfId-305758"></A>set_property (C, name, actg=None, acts=None, actd=None, </P>
<P CLASS="Python">
<A NAME="pgfId-305775"></A>	nowrite=None, nodelete=None)</P>
<P CLASS="Python">
<A NAME="pgfId-305784"></A>&quot;&quot;&quot;Set attribute handlers for  name to methods actg, acts, actd</P>
<P CLASS="Python">
<A NAME="pgfId-305785"></A>       None means no change for that action.</P>
<P CLASS="Python">
<A NAME="pgfId-305786"></A>       nowrite = 1 prevents setting this attribute.</P>
<P CLASS="Python">
<A NAME="pgfId-305787"></A>           nowrite defaults to 0.</P>
<P CLASS="Python">
<A NAME="pgfId-305788"></A>       nodelete = 1 prevents deleting this attribute.</P>
<P CLASS="Python">
<A NAME="pgfId-305789"></A>           nodelete defaults to 1 unless actd given.</P>
<P CLASS="Python">
<A NAME="pgfId-305790"></A>       if nowrite and nodelete is None: nodelete = 1</P>
<P CLASS="Python">
<A NAME="pgfId-305791"></A>&quot;&quot;&quot;</P>
<P CLASS="Body">
<A NAME="pgfId-305759"></A>C is the class, name is the name of the property to define, and actg, acts, and actd are unbound methods of class C having signatures actg (self, name), acts (self, name, value), and actd (self, name). The specifying of nowrite = 1 causes acts to be the method PropertiedClass._write_disallowed, a function that will raise an AttributeError if invoked. If nodelete is 1, actd is set to PropertiedClass._delete_disallowed, a function that will raise an AttributeError if invoked. It is an error to specify nowrite or nodelete at the same time you specify acts or actd respectively. You can use the routine _basic_get for actg, _basic_set for acts, or _basic_del for actd, if you wish.</P>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-305804"></A>Example:</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-305811"></A><A NAME="marker-306277"></A>In this example, three properties are defined: a is a normal attribute but it cannot be deleted; b, an undeleteable property which gets and sets a hidden value _b; and c, an undeleteable attribute whose value is checked on assignment to make sure it is greater than zero. The attribute _d is unaffected by Properties since its name starts with an underscore.</P>
<P CLASS="Python">
<A NAME="pgfId-305814"></A>import PropertiedClasses</P>
<P CLASS="Python">
<A NAME="pgfId-305821"></A>class C (PropertiedClasses.PropertiedClass):</P>
<P CLASS="Python">
<A NAME="pgfId-306173"></A>	def __init__ (self):</P>
<P CLASS="Python">
<A NAME="pgfId-306174"></A>		self.a = 1</P>
<P CLASS="Python">
<A NAME="pgfId-306175"></A>		self._b = 2</P>
<P CLASS="Python">
<A NAME="pgfId-306176"></A>		self.c = 3</P>
<P CLASS="Python">
<A NAME="pgfId-306196"></A>		self._d = 4</P>
<P CLASS="Python">
<A NAME="pgfId-306216"></A>&nbsp;</P>
<P CLASS="Python">
<A NAME="pgfId-306177"></A>	def assign_with_validate (self, name, value):</P>
<P CLASS="Python">
<A NAME="pgfId-306178"></A>		&quot;Checks that name is positive before assignment.&quot;</P>
<P CLASS="Python">
<A NAME="pgfId-306180"></A>		if c &lt;= 0: raise ValueError, `cannot assign negative value'</P>
<P CLASS="Python">
<A NAME="pgfId-306183"></A>		self._basic_set (name, value)</P>
<P CLASS="Python">
<A NAME="pgfId-306217"></A>&nbsp;</P>
<P CLASS="Python">
<A NAME="pgfId-306186"></A>	def _bget (self, name):</P>
<P CLASS="Python">
<A NAME="pgfId-306190"></A>		return self._b</P>
<P CLASS="Python">
<A NAME="pgfId-306218"></A>&nbsp;</P>
<P CLASS="Python">
<A NAME="pgfId-306191"></A>	def _bset (self, name, value):</P>
<P CLASS="Python">
<A NAME="pgfId-306192"></A>		self._b = value</P>
<P CLASS="Python">
<A NAME="pgfId-306193"></A>&nbsp;</P>
<P CLASS="Python">
<A NAME="pgfId-306187"></A>PropertiedClasses.set_property (C, `a', nodelete=1)</P>
<P CLASS="Python">
<A NAME="pgfId-306188"></A>PropertiedClasses.set_property (C, `b', C._bget, C._bset)</P>
<P CLASS="Python">
<A NAME="pgfId-306189"></A>PropertiedClasses.set_property (C, `c', acts = C.assign_with_validate)</P>
<P CLASS="Python">
<A NAME="pgfId-306197"></A>&nbsp;</P>
<P CLASS="Python">
<A NAME="pgfId-306198"></A>Note that as written the method assign_with_validate will only be called internally with the name `c'. If we latter add another attribute c2 that we also wish to validate with this method, we can use the same method as acts for it.</P>
<P CLASS="Body">
<A NAME="pgfId-306212"></A>&nbsp;</P>
</DIV>
</DIV>
</DIV>
<P><A HREF="numpy.html">Go to Main</A>      <A HREF="numpy-20.html">Go to Previous</A>       <A HREF="numpy-22.html">Go to Next</A></P>
</BODY>
</HTML>
