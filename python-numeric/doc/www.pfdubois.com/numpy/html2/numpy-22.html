<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 6.0/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="numpy.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE> 20.	 Masked Arrays</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">
<H1 CLASS="Chapter">
<A NAME="pgfId-303698"></A>20.	 <A NAME="48250"></A>Masked Arrays<A NAME="marker-308206"></A></H1>
<P CLASS="ChapterDescription">
<A NAME="pgfId-303702"></A><A NAME="marker-308207"></A>Masked arrays are arrays that may have missing or invalid entries. Module MA provides a nearly work-alike replacement for Numeric that supports data arrays with masks.</P>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-296294"></A>Required Packages</H6>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-320813"></A>Properties</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-320814"></A>MA uses Numeric and the optional package Properties. See <A HREF="numpy-21.html#10775" CLASS="XRef">Properties Reference</A>.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-320810"></A>What is a <A NAME="masked array"></A>masked array?</H6>
<P CLASS="BodyAfterHead">
<A NAME="pgfId-305401"></A>Masked arrays are arrays that may have missing or invalid entries. Module MA provides a work-alike replacement for Numeric that supports data arrays with masks. A mask is either None or an array of ones and zeros, that determines for each element of the masked array whether or not it contains an invalid entry. The package assures that invalid entries are not used in calculations. </P>
<P CLASS="Body">
<A NAME="pgfId-296293"></A>A particular element is said to be masked (<A NAME="marker-305508"></A>invalid) if the mask is not None and the corresponding element of the mask is 1; otherwise it is unmasked (valid). </P>
<P CLASS="Body">
<A NAME="pgfId-304710"></A>This package was written by <A NAME="marker-305509"></A>Paul F. Dubois at Lawrence Livermore National Laboratory. Please see the legal notice in the software and on <A HREF="numpy-16.html#66303" CLASS="XRef">License and disclaimer for packages MA, RNG, Properties</A>.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-304772"></A><A NAME="marker-305507"></A>Installing and using MA</H6>
<P CLASS="BodyAfterHead">
<A NAME="pgfId-296302"></A>MA is one of the optional Packages and installing it requires a separate step as explained in the Numeric README. To install just the MA package using Distutils, in the MA top directory enter:</P>
<P CLASS="C-Code">
<A NAME="pgfId-305192"></A>python setup.py install</P>
<P CLASS="FirstBody">
<A NAME="pgfId-304662"></A>Use MA as a replacement for Numeric:</P>
<P CLASS="Python">
<A NAME="pgfId-304660"></A>from MA import *</P>
<P CLASS="Python">
<A NAME="pgfId-305467"></A>x = array([1, 2, 3])</P>
<P CLASS="Body">
<A NAME="pgfId-304661"></A>To create an array with the second element invalid, we would do:</P>
<P CLASS="Python">
<A NAME="pgfId-305471"></A>y = array([1, 2, 3], mask = [0, 1, 0])</P>
<P CLASS="Body">
<A NAME="pgfId-305491"></A>To create a masked array where all values &quot;near&quot; 1.e20 are invalid, we can do:</P>
<P CLASS="Python">
<A NAME="pgfId-305495"></A>z = <A NAME="marker-305506"></A>masked_values ([1.0, 1.e20, 3.0, 4.0], 1.e20)</P>
<P CLASS="Body">
<A NAME="pgfId-305502"></A>For a complete discussion of creation methods for masked arrays please see <A HREF="numpy-22.html#73354" CLASS="XRef">Constructing masked arrays</A>.</P>
<P CLASS="Body">
<A NAME="pgfId-305470"></A>The Numeric module is an attribute in MA, so to execute a method foo from Numeric, you can reference it as Numeric.foo(...).</P>
<P CLASS="Body">
<A NAME="pgfId-304673"></A>Usually people use both MA and Numeric this way, but of course you can always fully-qualify the names:</P>
<P CLASS="Python">
<A NAME="pgfId-304674"></A>import MA</P>
<P CLASS="Python">
<A NAME="pgfId-304685"></A>x = MA.array([1, 2, 3])</P>
<P CLASS="Body">
<A NAME="pgfId-305234"></A>The principal feature of module MA is class MaskedArray, the class whose instances are returned by the array constructors and most functions in module MA. We will discuss this class first, and later cover the attributes and functions in module MA. For now suffice it to say that among the attributes of the module are the constants from module Numeric including those for declaring typecodes, NewAxis, and the mathematical constants such as pi and e. An additional typecode, MaskType, is the typecode used for masks.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-296950"></A>Class MaskedArray</H6>
<P CLASS="Body">
<A NAME="pgfId-304137"></A>In Module MA, an array is an instance of class MaskedArray, which is defined in the module MA. An instance of class MaskedArray can be thought of as containing the following parts:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-304138"></A>An array of data, of any shape;</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-304139"></A>A mask of ones and zeros of the same shape as the data; and,</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-304140"></A>A &quot;fill value&quot; -- this is a value that may be used to replace the invalid entries in order to return a plain Numeric array. The chief method that does this is the method filled discussed below.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-304141"></A>We will use the terms &quot;invalid value&quot; and &quot;invalid entry&quot; to refer to the data value at a place corresponding to a mask value of 1. It should be emphasized that the invalid values are <EM CLASS="Emphasis">
never</EM>
 used in any computation, and that the fill value is not used for <EM CLASS="Emphasis">
any</EM>
 computational purpose. When an instance x of class MaskedArray is converted to its string representation, it is the result returned by filled (x) that is converted to a string.</P>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305213"></A>Attributes of masked arrays</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-305939"></A>flat: (deprecated) returns the masked array as one-dimensional. This is provided for compatibility with Numeric. ravel (x) is preferred. It can be assigned to: x.flat = value will change the values of x.</P>
<P CLASS="Body">
<A NAME="pgfId-305943"></A>real: returns the real part of the array if complex. It can be assigned to: x.real = value will change the real parts of x.</P>
<P CLASS="Body">
<A NAME="pgfId-305944"></A>imaginary: returns the imaginary part of the array if complex. It can be assigned to: x.imaginary = value will change the imaginary parts of x.</P>
<P CLASS="FirstBody">
<A NAME="pgfId-305250"></A>shape: The shape of a masked array can be accessed or changed by using the special attribute shape, as with Numerical arrays. It can be assigned to: x.shape = newshape will change the shape of x. The new shape describe the same total number of elements.</P>
<P CLASS="Body">
<A NAME="pgfId-305520"></A>shared_data: This read-only flag if true indicates that the masked array shared a reference with the original data used to construct it at the time of construction. Changes to the original array will affect the masked array. (This is not the default behavior; see <A HREF="numpy-22.html#72295" CLASS="XRef">Copying or not?</A>.) This flag is informational only.</P>
<P CLASS="Body">
<A NAME="pgfId-305536"></A><A NAME="MA"></A>shared_mask: This read-only flag if true indicates that the masked array currently shares a reference to the mask used to create it. Unlike shared_data, this flag may change as the result of modifying the array contents, as the mask uses copy on write semantics if it is shared.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305217"></A>Methods on masked arrays. </H6>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="TableTitle">
<A NAME="pgfId-298191"></A>Methods on masked arrays; attributes, constructors and operations discussed separately.<A NAME="36299"></A></H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId-298197"></A>Method</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId-298199"></A>Description</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId-298201"></A>Sample syntax</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320400"></A>__array__ </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320402"></A>A special method allows conversion to a Numeric array if no element is actually masked. If there is a masked element, an MAError exception is thrown. Many Numeric functions, such as Numeric.sqrt, will attempt this conversion on their arguments. See also module method filled.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320404"></A>yn = Numeric.array(x)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320394"></A>astype (typecode)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320396"></A>return self as array of given type.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320398"></A>y = x.astype (Float32)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320526"></A>byte_swapped()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320528"></A>returns the raw Numeric data byte-swapped; included for consistency with Numeric but probably meaningless.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320530"></A>yn = x.byte_swapped()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320388"></A>compressed ()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320390"></A>return an array of the valid elements. Result is one-dimensional.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320392"></A>y = x.compressed()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320381"></A>count(axis=None)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320383"></A>count the number of non-masked elements in the array, if axis is None. Otherwise return an array of such counts along the axis given.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320385"></A>n=x.count()</P>
<P CLASS="CellBody">
<A NAME="pgfId-320386"></A>y=x.count(0)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320410"></A>fill_value ()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320412"></A>Get the current fill value.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320414"></A>v = x.fill_value ()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320416"></A>filled (fill_value=None)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320418"></A>Returns a Numeric array with the masked values replaced by the fill value. See also the description of module method filled.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320420"></A>yn = x.filled()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320428"></A>ids ()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320430"></A>Return the ids of the data and mask areas</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320432"></A>id1, id2 = x.ids ()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320422"></A>iscontiguous ()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320424"></A>Is the data area contiguous? See Numeric manual.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320426"></A>if x.iscontiguous ()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320434"></A>itemsize()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320436"></A>size of individual data items in bytes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320438"></A>n = x.itemsize()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320502"></A>mask ()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320504"></A>Return the data mask, or None.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320506"></A>m = x.mask ()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320496"></A>put (values)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320498"></A>Set the value at each non-masked entry to the corresponding entry in values. The mask is unchanged. See also module method put.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320500"></A>x.put (values)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320489"></A>putmask (values)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320491"></A>Eliminate any masked values by setting the value at each masked entry to the corresponding entry in values. Set the mask to None.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320493"></A>x.putmask(values)</P>
<P CLASS="CellBody">
<A NAME="pgfId-320494"></A>assert getmask(x) is None</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320483"></A>raw_data ()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320485"></A>A reference to the non-filled data; portions may be meaningless. Expert use only.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320487"></A>d = x.raw_data ()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320477"></A>savespace (v)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320479"></A>Set the spacesaver attribute to v.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320481"></A>x.savespace (1)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320471"></A>set_fill_value ()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320473"></A>Set the fill value to v. Omit v to restore default.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320475"></A>x.set_fill_value (1.e21)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320465"></A>set_shape (args...)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320467"></A>shape (n, m, ...) sets the shape.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320469"></A>x.set_shape (3, 12)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320458"></A>size (axis)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320460"></A>Number of elements in array, or in a particular axis.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320462"></A>totalsize = x.size ()</P>
<P CLASS="CellBody">
<A NAME="pgfId-320463"></A>col_len = x.size (1)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320452"></A>spacesaver()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320454"></A>Query the spacesave flag.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320456"></A>flag = x.spacesaver()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320446"></A>tolist(fill_value=None)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320448"></A>Return the Python list self.filled(fill_value).tolist(); note that masked values are filled.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320450"></A>alist=x.tolist()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320440"></A>tostring(fill_value=None)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320442"></A>Return the string self.filled(fill_value).tostring()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320444"></A>s = x.tostring()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320508"></A>typecode ()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320510"></A>Return the type of the data. See module Precision.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320512"></A>z = x.typecode()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320520"></A>unmask()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320522"></A>Replaces the mask by None if possible. Subsequent operations may be faster if the array previously had an all-zero mask.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320524"></A>x.unmask()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320514"></A>unshare_mask()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320516"></A>If shared_mask is currently true, replaces the reference to it with a copy.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320518"></A>x.unshare_mask()</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-320251"></A><A NAME="73354"></A>Constructing masked arrays</H6>
<OL>
<LI CLASS="Numbered1">
<A NAME="pgfId-308231"></A><A NAME="marker-308230"></A>array (data, typecode = None, copy = 1, savespace = 0, mask = None, fill_value = None) <BR>
Creates a masked array with the given data and mask. The name array is simply an alias for the class name, MaskedArray, The fill value is set to fill_value, and the savespace flag is applied. If data is a MaskedArray, its mask, typecode, spacesaver flag, and fill value will be used unless specifically specified by one of the remaining arguments. In particular, if d is a masked array, array(d, copy=0) is d. </LI>
<LI CLASS="Numbered">
<A NAME="pgfId-308233"></A><A NAME="marker-308232"></A>masked_array (data, mask = None, fill_value = None)<BR>
This is an easier-to-use version of array, for the common case of typecode = None, copy = 0. When data is newly-created this function can be used to make it a masked array without copying the data if data is already a Numeric array.</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-303765"></A><A NAME="marker-304072"></A>masked_values (data, value, rtol=1.e-5, atol=1.e-8, typecode = None, copy = 1, savespace = 0) <BR>
Constructs a masked array whose mask is set at those places where <BR>
abs (data - value) &lt; atol + rtol * abs (data). <BR>
That is a careful way of saying that those elements of the data that have value = value (to within a tolerance) are to be treated as invalid. If data is not of a floating point type, calls masked_object instead.</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-305796"></A><A NAME="marker-305802"></A>masked_object (data, value, copy=1, savespace=0) <BR>
Creates a masked array with those entries marked invalid that are equal to value. Again, copy and savespace are passed on to the Numeric array constructor.</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-313038"></A>asarray(data, typecode=None)<BR>
This is the same as array(data, typecode, copy=0). This is a short way of ensuring that something is an instance of MaskedArray of a given type before proceeding, as in <BR>
data = asarray(data). <BR>
<BR>
If data already is a masked array and typecode is None then the return value is data; nothing is copied in that case.</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-307728"></A><A NAME="marker-307732"></A>masked_where (condition, data, copy=1) <BR>
Creates a masked array whose shape is that of condition, whose values are those of data, and which is masked where elements of condition are true.</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-320600"></A>masked is a module constant that represents a scalar masked value. For example, if x is a masked array and a particular location such as x[1] is masked, the quantity x[1] will be this special constant. This special element is discussed more fully in <A HREF="numpy-22.html#42703" CLASS="XRef">The constant masked</A>.</LI>
</OL>
<P CLASS="Body">
<A NAME="pgfId-313044"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-313063"></A>The following additional constructors are provided for convenience.</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-307764"></A><A NAME="marker-307789"></A>masked_greater (data, value, copy=1) is equivalent to masked_where (greater(data, value), data)). Similarly, <A NAME="marker-307793"></A>masked_greater_equal, <A NAME="marker-307797"></A>masked_equal, <A NAME="marker-307801"></A>masked_not_equal, <A NAME="marker-307805"></A>masked_less, <A NAME="marker-307809"></A>masked_less_equal are called in the same way with the obvious meanings. Note that for floating point data, <A NAME="marker-307810"></A>masked_values is preferable to masked_equal in most cases.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-313024"></A>masked_inside (data, v1, v2, copy=1) creates an array with values in the closed interval [v1, v2] masked. v1 and v2 may be in either order.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-313028"></A>masked_outside (data, v1, v2, copy=1) creates an array with values outside the closed interval [v1, v2] masked. v1 and v2 may be in either order.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-313074"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-305283"></A>On entry to any of these constructors, data must be any object which the Numeric package can accept to create an array (with the desired typecode, if specified). The mask if given must be None or any object that can be turned into a Numeric array of integer type (it will be converted to typecode MaskType, if necessary), have the same shape as data, and contain only values of 0 or 1.</P>
<P CLASS="Body">
<A NAME="pgfId-306531"></A>If the mask is not None but its shape does not match that of data, an exception will be thrown, unless one of the two is of length 1, in which case the scalar will be resized (using Numeric.resize) to match the other.</P>
<P CLASS="Body">
<A NAME="pgfId-306530"></A>See <A HREF="numpy-22.html#72295" CLASS="XRef">Copying or not?</A> for a discussion of whether or not the resulting array shares its data or its mask with the arguments given to these constructors.</P>
<DIV>
<H6 CLASS="NoteTip">
<A NAME="pgfId-313009"></A><DIV>
<IMG SRC="numpy-10.gif" width="469" height="12">
</DIV>
&nbsp;</H6>
<P CLASS="Note">
<A NAME="pgfId-305623"></A><A NAME="35793"></A>filled is very important. It converts its argument to a plain Numeric array.</P>
<DIV>
<H6 CLASS="NoteBottom">
<A NAME="pgfId-313013"></A><DIV>
<IMG SRC="numpy-10.gif" width="469" height="12">
</DIV>
&nbsp;</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-304255"></A>filled (x, value = None) returns x with any invalid locations replaced by a fill value. filled is guaranteed to return a plain Numeric array. The argument x does not have to be a masked array or even an array, just something that Numeric can turn into one.</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-305156"></A>If x is not a masked array, and not a Numeric array, Numeric.array (x) is returned.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-305647"></A>If x is a contiguous Numeric array then x is returned. (A Numeric array is contiguous if its data storage region is layed out in column-major order; Numeric allows non-contiguous arrays to exist but they are not allowed in certain operations). </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-305648"></A>If x is a masked array, but the mask is None, and x's data array is contiguous, then it is returned. If the data array is not contiguous, a (contiguous) copy of it is returned.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-305649"></A>If x is a masked array with an actual mask, then an array formed by replacing the invalid entries with value, or fill_value (x) if value is None, is returned. If the fill value used is of a different type or precision than x, the result may be of a different type or precision than x.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-308305"></A>Note that a new array is created only if necessary to create a correctly filled, contiguous, Numeric array.</P>
<P CLASS="FirstBody">
<A NAME="pgfId-305154"></A>The function filled plays a central role in our design. It is the &quot;exit&quot; back to Numeric, and is used whenever the invalid values must be replaced before an operation. For example, adding two masked arrays a and b is roughly:</P>
<P CLASS="Python">
<A NAME="pgfId-304389"></A>masked_array(filled(a, 0)+filled(b, 0), mask_or(getmask(a), getmask(b))</P>
<P CLASS="Body">
<A NAME="pgfId-304394"></A>That is, fill the invalid entries a and b with zeros, add them up, and declare any entry of the result invalid if either a or b was invalid at that spot. The functions getmask and mask_or are discussed later.</P>
<P CLASS="Body">
<A NAME="pgfId-305057"></A>filled also can be used to simply be certain that some expression is a contiguous Numerical array at little cost. If its argument is a Numeric array already, it is returned without copying. </P>
<P CLASS="Body">
<A NAME="pgfId-320544"></A>If you are certain that a masked array x contains a mask that is None or is all zeros, you can convert it to a Numeric array with the Numeric.array(x) constructor. If you turn out to be wrong, an MAError exception is raised.</P>
<P CLASS="Body">
<A NAME="pgfId-305142"></A><A NAME="marker-305346"></A>fill_value (x), and the method x.fill_value() of the same name on masked arrays, returns a value suitable for filling x based on its type. If x is a masked array, then x.fill_value () results. The returned value for a given type can be changed by assigning to these names in module MA: They should be set to scalars or one element arrays. </P>
<P CLASS="Python">
<A NAME="pgfId-305143"></A><A NAME="marker-305365"></A>default_real_fill_value = Numeric.array([1.0e20], Float32)</P>
<P CLASS="Python">
<A NAME="pgfId-305144"></A><A NAME="marker-305348"></A>default_complex_fill_value = Numeric.array([1.0e20 + 0.0j], Complex32)</P>
<P CLASS="Python">
<A NAME="pgfId-305145"></A><A NAME="marker-305349"></A>default_character_fill_value = masked</P>
<P CLASS="Python">
<A NAME="pgfId-306195"></A><A NAME="marker-305350"></A>default_integer_fill_value = Numeric.array([0]).astype(UnsignedInt8)</P>
<P CLASS="Python">
<A NAME="pgfId-305148"></A><A NAME="marker-305352"></A>default_object_fill_value = masked</P>
<P CLASS="Body">
<A NAME="pgfId-305671"></A>The variable <A NAME="marker-306591"></A>masked is a module variable of MA and is discussed in <A HREF="numpy-22.html#42703" CLASS="XRef">The constant masked</A>. Calling filled with a fill_value of masked sometimes produces a useful printed representation of a masked array. The function fill_value works on any kind of object.</P>
<P CLASS="Body">
<A NAME="pgfId-320344"></A><A NAME="marker-320343"></A>set_fill_value (a, fill_value) is the same as a.set_fill_value (fill_value) if a is a masked array; otherwise it does nothing. Please note that the fill value is mostly cosmetic; it is used when it is needed to convert the masked array to a plain Numeric array but not involved in most operations. In particular, setting the fill value to 1.e20 will <EM CLASS="Emphasis">
not, repeat not, </EM>
cause elements of the array whose values are currently 1.e20 to be masked. For that sort of behavior use the masked_value constructor.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-320302"></A>What are masks?<A NAME="marker-320328"></A></H6>
<P CLASS="FirstBody">
<A NAME="pgfId-320306"></A>Masks are either None or 1-byte Numerical arrays of 1's and 0's. To avoid excessive performance penalties, mask arrays are never checked to be sure that the values are 1's and 0's, and supplying a mask= argument to a constructor with an illegal mask will have undefined consequences later. </P>
<P CLASS="Body">
<A NAME="pgfId-320308"></A><EM CLASS="Emphasis">
Masks have the savespace attribute set</EM>
. This attribute, discussed in the Numeric Python manual, may have surprising consequences if you attempt to do any operations on them other than those supplied by this package. In particular, do not add or multiply a quantity involving a mask. For example, if m is a mask consisting of 1080 1 values, sum(m) is 56, not 1080. Oops.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-320312"></A>Working with masks</H6>
<P CLASS="Body">
<A NAME="pgfId-304996"></A><A NAME="marker-305354"></A>is_mask (m) is true if m is of a type and precision that would be allowed as the mask field of a masked array (that is, it is an array of integers with Numeric's typecode MaskType, or it is None). To be a legal mask, m should contain only zeros or ones, but this is not checked.</P>
<P CLASS="Body">
<A NAME="pgfId-305010"></A><A NAME="marker-305355"></A>make_mask (m, copy=0, flag=0) returns an object whose entries are equal to m and for which is_mask would return true. If m is already a mask or None, it returns m or a copy of it. Otherwise it will attempt to make a mask, so it will accept any sequence of integers of for m. If flag is true, make_mask returns None if its return value otherwise would contain no true elements. To make a legal mask, m should contain only zeros or ones, but this is not checked.</P>
<P CLASS="Body">
<A NAME="pgfId-320553"></A><A NAME="marker-320559"></A>make_mask_none (s) returns a mask of all zeros of shape s (deprecated form: <A NAME="marker-320562"></A>create_mask).</P>
<P CLASS="Body">
<A NAME="pgfId-305014"></A><A NAME="marker-305356"></A>getmask (x) returns x.<A NAME="marker-305366"></A>mask(), the mask of x, if x is a masked array, and None otherwise. Note that getmask may return None if x is a masked array but has a mask of None. (Please see caution above about operating on the result).</P>
<P CLASS="Body">
<A NAME="pgfId-304965"></A><A NAME="marker-305367"></A>getmaskarray (x) returns x.mask() if x is a masked array and has a mask that is not None; otherwise it returns a zero mask array of the same shape as x. Unlike getmask, getmaskarray always returns an Numeric array of typecode MaskType. (Please see caution above about operating on the result).</P>
<P CLASS="Body">
<A NAME="pgfId-304917"></A><A NAME="marker-305370"></A>mask_or (m1, m2) returns an object which when used as a mask behaves like the element-wise &quot;logical or&quot; of m1 and m2, where m1 and m2 are either masks or None (e.g., they are the results of calling getmask). A None is treated as everywhere false. If both m1 and m2 are None, it returns None. If just one of them is None, it returns the other. If m1 and m2 refer to the same object, a reference to that object is returned.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-320257"></A>Operations</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-320263"></A>Masked arrays support the operators +, *, /, -, **, and unary plus and minus. The other operand can be another masked array, a scalar, a Numeric array, or something Numeric.array() can convert to a Numeric array. The results are masked arrays.</P>
<P CLASS="Body">
<A NAME="pgfId-320287"></A>In addition masked arrays support the in-place operators +=, -=, *=, and /=. Implementation of in-place operators differs from Numeric semantics in being more generous about converting the right-hand side to the required type: any kind or lesser type accepted via an astype conversion. In-place operators truly operate in-place when the target is not masked. </P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305173"></A><A NAME="72295"></A>Copying or not?</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-305179"></A>Depending on the arguments results of constructors may or may not contain a separate copy of the data or mask arguments. The easiest way to think about this is as follows: the given field, be it data or a mask, is required to be a Numerical array, possibly with a given typecode, and a mask's shape must match that of the data. If the copy argument is zero, and the candidate array otherwise qualifies, a reference will be made instead of a copy. If for any reason the data is unsuitable as is, an attempt will be made to make a copy that is suitable. Should that fail, an exception will be thrown. Thus, a copy=0 argument is more of a hope than a command.</P>
<P CLASS="Body">
<A NAME="pgfId-308218"></A>If the basic array constructor is given a masked array as the first argument, its mask, typecode, spacesaver flag, and fill value will be used unless specifically specified by one of the remaining arguments. In particular, if d is a masked array, array(d, copy=0) is d.</P>
<P CLASS="Body">
<A NAME="pgfId-305700"></A>Since the default behavior for masks is to use a reference if possible, rather than a copy, which produces a sizeable time and space savings, it is especially important not to modify something you used as a mask argument to a masked array creation routine, if it was a Numeric array of typecode MaskType.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305435"></A>Behaviors</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-305439"></A>A masked array defines the conversion operators str (x), repr (x), float (x), and int (x) by applying the corresponding operator to the Numeric array filled (x)</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-304210"></A><A NAME="marker-304071"></A><A NAME="40659"></A>Indexing and Slicing</H6>
<P CLASS="Body">
<A NAME="pgfId-304211"></A>Indexing and slicing differ from Numeric: while generally the same, they return a copy, not a reference, when used in an expression that produces a non-scalar result. Consider this example:</P>
<P CLASS="Python">
<A NAME="pgfId-304212"></A>from Numeric import *</P>
<P CLASS="Python">
<A NAME="pgfId-304213"></A>x = array([1.,2.,3.])</P>
<P CLASS="Python">
<A NAME="pgfId-304214"></A>y = x[1:]</P>
<P CLASS="Python">
<A NAME="pgfId-304215"></A>y[0] = 9.</P>
<P CLASS="Python">
<A NAME="pgfId-304216"></A>print x</P>
<P CLASS="Body">
<A NAME="pgfId-304217"></A>This will print [1., 9., 3.] since x[1:] returns a reference to a portion of x. Doing the same operation using MA, </P>
<P CLASS="Python">
<A NAME="pgfId-304218"></A>from MA import *</P>
<P CLASS="Python">
<A NAME="pgfId-304219"></A>x = array([1.,2.,3.])</P>
<P CLASS="Python">
<A NAME="pgfId-304220"></A>y = x[1:]</P>
<P CLASS="Python">
<A NAME="pgfId-304221"></A>y[0] = 9.</P>
<P CLASS="Python">
<A NAME="pgfId-304222"></A>print x</P>
<P CLASS="Body">
<A NAME="pgfId-304223"></A>will print [1., 2., 3.], while y will be a separate array whose present value would be [9., 3.]. While sentiment on the correct semantics here is divided amongst the Numeric community as a whole, it is not divided amongst the author's community, on whose behalf this package is written.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-320846"></A>Indexing in assignments</H6>
<P CLASS="Body">
<A NAME="pgfId-320845"></A>Using multiple sets of square brackets on the left side of an assignment statement will not produce the desired result:</P>
<P CLASS="Python">
<A NAME="pgfId-320832"></A>x = array([[1,2],[3,4]])</P>
<P CLASS="Python">
<A NAME="pgfId-320836"></A>x[1][1] = 20. # Error, does not change x</P>
<P CLASS="Python">
<A NAME="pgfId-320837"></A>x[1,1] = 20. # Correct, changes x</P>
<P CLASS="Body">
<A NAME="pgfId-320838"></A>The reason is that x[1] is a copy, so changing it changes that copy, not x. Always use just one single square bracket for assignments.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-306592"></A>Operations that produce a scalar result</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-306598"></A>If indexing or another operation on a masked array produces a scalar result, then a scalar value is returned rather than a one-element masked array. This raises the issue of what to return if that result is masked. The answer is that the module constant masked is returned. This constant is discussed in <A HREF="numpy-22.html#42703" CLASS="XRef">The constant masked</A>. While this most frequently occurs from indexing, you can also get such a result from other functions. For example, averaging a 1-D array, all of whom's values are invalid, would result in masked.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-304229"></A>Assignment to elements and slices</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-304233"></A>Assignment of a normal value to a single element or slice of a masked array has the effect of clearing the mask in those locations. In this way previously invalid elements become valid. The value being assigned is filled first, so that you are guaranteed that all the elements on the left-hand side are now valid. </P>
<P CLASS="Body">
<A NAME="pgfId-305698"></A>Assignment of None to a single element or slice of a masked array has the effect of setting the mask in those locations, and the locations become invalid.</P>
<P CLASS="Body">
<A NAME="pgfId-305699"></A>Since these operations change the mask, the result afterwards will no longer share a mask, since masks have copy-on-write semantics.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-297249"></A>Module MA: Attributes</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-305713"></A>Constants e, pi, NewAxis from Numeric, and the constants from module Precision that define nice names for the typecodes. </P>
<P CLASS="Body">
<A NAME="pgfId-306942"></A>The special variables <A NAME="marker-306618"></A>masked and masked_print_option are discussed in <A HREF="numpy-22.html#42703" CLASS="XRef">The constant masked</A>. </P>
<P CLASS="Body">
<A NAME="pgfId-306941"></A>The module Numeric is an element of MA, so after from MA import *, you can refer to the functions in Numeric such as Numeric.ones.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-305706"></A>Module MA: Functions</H6>
<P CLASS="BodyAfterHead">
<A NAME="pgfId-298310"></A>Each of the operations discussed below returns an instance of <A NAME="marker-306622"></A>class MaskedArray, having performed the desired operation element-wise. In most cases the array arguments can be masked arrays or Numeric arrays or something that Numeric can turn into a Numeric array, such as a list of real numbers.</P>
<P CLASS="Body">
<A NAME="pgfId-305885"></A>In most cases, if Numeric has a function of the same name, the behavior of the one in MA is the same, except that it &quot;respects&quot; the mask.</P>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-298306"></A>Unary functions</H6>
<P CLASS="BodyAfterHead">
<A NAME="pgfId-298311"></A>The result of a unary operation will be masked wherever the original operand was masked. It may also be masked if the argument is not in the domain of the function. Functions available are: </P>
<P CLASS="Body">
<A NAME="pgfId-298322"></A><A NAME="marker-307861"></A>sqrt, <A NAME="marker-307862"></A>log, <A NAME="marker-307863"></A>log10, <A NAME="marker-307864"></A>exp, <A NAME="marker-307865"></A>conjugate, <A NAME="marker-307866"></A>sin, <A NAME="marker-307867"></A>cos, <A NAME="marker-307868"></A>tan, <A NAME="marker-307869"></A>arcsin, <A NAME="marker-307870"></A>arccos, <A NAME="marker-307871"></A>arctan, <A NAME="marker-307872"></A>sinh, <A NAME="marker-307873"></A>cosh, <A NAME="marker-307874"></A>tanh, <A NAME="marker-307875"></A>absolute, <A NAME="marker-307876"></A>fabs, <A NAME="marker-307877"></A>negative (also as operator -x), <A NAME="marker-307878"></A>nonzero, <A NAME="marker-307879"></A>around, <A NAME="marker-307880"></A>floor</P>
<P CLASS="Body">
<A NAME="pgfId-306090"></A><A NAME="marker-307881"></A>fabs (x) is the absolute value of x as a Float32 array. The other functions have their standard meaning.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-298312"></A>Binary functions</H6>
<P CLASS="BodyAfterHead">
<A NAME="pgfId-298333"></A>Binary functions return a result that is masked wherever either of the operands were masked; it may also be masked where the arguments are not in the domain of the function.</P>
<P CLASS="BodyAfterHead">
<A NAME="pgfId-297747"></A><A NAME="marker-307882"></A>add (also as operator +), <A NAME="marker-307883"></A>subtract (also as operator -), <A NAME="marker-307884"></A>multiply (also as operator *), <A NAME="marker-307885"></A>divide (also as operator /), <A NAME="marker-307886"></A>power (also as operator **), <A NAME="marker-307887"></A>remainder, <A NAME="marker-307888"></A>fmod, <A NAME="marker-307889"></A>hypot, <A NAME="marker-307890"></A>arctan2, <A NAME="marker-307891"></A>bitwise_and, <A NAME="marker-307892"></A>bitwise_or, <A NAME="marker-307893"></A>bitwise_xor.</P>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-298340"></A>Comparison operators</H6>
<P CLASS="Body">
<A NAME="pgfId-298345"></A>To compare arrays, use the following binary functions. Each of them returns a masked array of 1's and 0's.</P>
<P CLASS="Body">
<A NAME="pgfId-304047"></A><A NAME="marker-307894"></A>equal, <A NAME="marker-307895"></A>not_equal, <A NAME="marker-307896"></A>less_equal, <A NAME="marker-307897"></A>greater_equal, <A NAME="marker-307898"></A>less, <A NAME="marker-307899"></A>greater</P>
<P CLASS="Body">
<A NAME="pgfId-305376"></A>Note that as in Numeric, you can use a scalar for one argument and an array for the other. Note the special caution, <A HREF="numpy-7.html#91621" CLASS="XRef">The operators and the comparison functions are not exactly equivalent</A></P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-298353"></A>Logical operators</H6>
<P CLASS="BodyAfterHead">
<A NAME="pgfId-298357"></A>Arrays of logical values can be manipulated with:</P>
<P CLASS="Body">
<A NAME="pgfId-298358"></A><A NAME="marker-307900"></A>l<A NAME="marker-308197"></A>ogical_not (unary), <A NAME="marker-307901"></A>logical_or, <A NAME="marker-307902"></A>logical_and, <A NAME="marker-307903"></A>logical_xor.</P>
<P CLASS="Body">
<A NAME="pgfId-298359"></A><A NAME="marker-307904"></A>alltrue (x) returns 1 if all elements of x are true. Masked elements are treated as true.</P>
<P CLASS="Body">
<A NAME="pgfId-298360"></A><A NAME="marker-307905"></A>sometrue (x) returns 1 if any element of x is true. Masked elements are treated as false.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-298365"></A><A NAME="14948"></A>Special array operators</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-305827"></A><A NAME="marker-305831"></A>isarray (x), <A NAME="marker-305832"></A>isMA (x) return true if x is a masked array.</P>
<P CLASS="Body">
<A NAME="pgfId-298407"></A><A NAME="marker-307906"></A>rank (x) is the number of dimensions in x. </P>
<P CLASS="Body">
<A NAME="pgfId-305842"></A><A NAME="marker-307907"></A>shape (x) returns the shape of x, a tuple of array extents.</P>
<P CLASS="Body">
<A NAME="pgfId-305846"></A><A NAME="marker-307908"></A>resize (x, new_shape) returns a new array with specified shape.</P>
<P CLASS="Body">
<A NAME="pgfId-305865"></A><A NAME="marker-307909"></A>reshape (x, new_shape) returns a copy of x with the given new shape. </P>
<P CLASS="Body">
<A NAME="pgfId-305869"></A><A NAME="marker-307910"></A>ravel (x) returns x as one-dimensional.</P>
<P CLASS="Body">
<A NAME="pgfId-305877"></A><A NAME="marker-307911"></A>concatenate (arrays, axis=0) concatenates the arrays along the specified axis.</P>
<P CLASS="Body">
<A NAME="pgfId-319938"></A>repeat (array, repeats, axis = 0) repeat elements of a repeats times along axis. repeats is a sequence of length a.shape[axis] telling how many times to repeat each element.</P>
<P CLASS="Body">
<A NAME="pgfId-305850"></A><A NAME="marker-307912"></A>identity (n) returns the identity matrix of shape n by n.</P>
<P CLASS="Body">
<A NAME="pgfId-305854"></A><A NAME="marker-307913"></A>indices (dimensions, typecode = None) returns an array representing a grid of indices with row-only and column-only variation.</P>
<P CLASS="Body">
<A NAME="pgfId-298408"></A><A NAME="marker-307914"></A>len (x) is defined to be the length of the first dimension of x. This definition, peculiar from the array point of view, is required by the way Python implements slicing. Use size (x) for the total length of x.</P>
<P CLASS="Body">
<A NAME="pgfId-298465"></A><A NAME="marker-307915"></A>size (x, axis = None) is the total size of x, or the length of a particular dimension axis whose index is given. When axis is given the dimension of the result is one less than the dimension of x.</P>
<P CLASS="Body">
<A NAME="pgfId-298461"></A><A NAME="marker-307916"></A>count (x, axis = None) counts the number of (non-masked) elements in the array, or in the array along a certain axis.When axis is given the dimension of the result is one less than the dimension of x.</P>
<P CLASS="Body">
<A NAME="pgfId-305809"></A><A NAME="marker-305810"></A>arange, <A NAME="marker-305817"></A><A NAME="marker-305818"></A>arrayrange, <A NAME="marker-305822"></A>diagonal<A NAME="marker-320572"></A>, <A NAME="marker-320573"></A>fromfunction, <A NAME="marker-320574"></A>fromstring, ones, and <A NAME="marker-305826"></A>zeros are the same as in Numeric, but return masked arrays.</P>
<P CLASS="Body">
<A NAME="pgfId-298470"></A><A NAME="marker-307917"></A>sum, and <A NAME="marker-307918"></A>product are called the same way as count; the difference is that the result is the sum, product, or average respectively of the unmasked element.</P>
<P CLASS="Body">
<A NAME="pgfId-307970"></A><A NAME="marker-308029"></A>average (x, axis=0, weights=None, returned=0) computes the average value of the non-masked elements of x along the selected axis. If weights is given, it must match the size and shape of x, and the value returned is:</P>
<P CLASS="CBlockIndent">
<A NAME="pgfId-308000"></A><IMG SRC="numpy-11.gif" ALIGN="BASELINE" width="69" height="30">
&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-308008"></A>In computing these sums, elements that correspond to those that are masked in x or weights are ignored. If returned, a 2-tuple consisting of the average and the sum of the weights is returned.</P>
<P CLASS="Body">
<A NAME="pgfId-298369"></A><A NAME="marker-307920"></A>allclose (x, y, fill_value = 1, rtol = 1.e-5, atol = 1.e-8) tests whether or not arrays x and y are equal subject to the given relative and absolute tolerances. If fill_value is 1, masked values are considered equal, otherwise they are considered different. The formula used for elements where both x and y have a valid value is:</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Code">
<A NAME="pgfId-298386"></A>| x - y | &lt; atol + rtol * | y |</H6>
<P CLASS="Body">
<A NAME="pgfId-298393"></A>This means essentially that both elements are small compared to atol or their difference divided by their value is small compared to rtol.</P>
<P CLASS="Body">
<A NAME="pgfId-298403"></A><A NAME="marker-307921"></A>allequal (x, y, fill_value = 1) is similar to allclose, except that exact equality is demanded.</P>
<P CLASS="Body">
<A NAME="pgfId-305881"></A><A NAME="marker-307922"></A>take (a, indices, axis=0) returns a selection of items from a. See the documentation in the Numeric manual.</P>
<P CLASS="Body">
<A NAME="pgfId-307667"></A><A NAME="marker-307923"></A>transpose (a, axes=None) performs a reordering of the axes depending on the tuple of indices <EM CLASS="Code">
axes</EM>
; the default is to reverse the order of the axes.</P>
<P CLASS="Body">
<A NAME="pgfId-306637"></A><A NAME="marker-307924"></A>put (a, indices, values) is the opposite of <EM CLASS="Code">
take</EM>
. The values of the array <EM CLASS="Code">
a</EM>
 at the locations specified in <EM CLASS="Code">
indices</EM>
 are set to the corresponding value of <EM CLASS="Code">
values</EM>
. The array <EM CLASS="Code">
a </EM>
must be a contiguous array. The argument indices can be any integer sequence object with values suitable for indexing into the flat form of <EM CLASS="Code">
a</EM>
. The argument v must be any sequence of values that can be converted to the typecode of <EM CLASS="Code">
a</EM>
.</P>
<P CLASS="Python">
<A NAME="pgfId-306639"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x = arange(6)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-306640"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
put(x, [2,4], [20,40])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-306641"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-306642"></A>[ 0  1 20  3 40  5 ]</P>
<P CLASS="Body">
<A NAME="pgfId-306666"></A>Note that the target array <EM CLASS="Code">
a</EM>
 is not required to be one-dimensional. Since it is contiguous and stored in row-major order, the array <EM CLASS="Code">
indices</EM>
 can be treated as indexing <EM CLASS="Code">
a</EM>
's elements in storage order. </P>
<P CLASS="Body">
<A NAME="pgfId-306676"></A>The wrinkle on this for masked arrays is that if the locations being set by put are masked, the mask is cleared in those locations.</P>
<P CLASS="Body">
<A NAME="pgfId-307940"></A><A NAME="marker-307939"></A>choose (condition, t) has a result shaped like condition. t must be a tuple. Each element of the tuple can be an array, a scalar, or the constant element <EM CLASS="Callout">
masked (</EM>
See<EM CLASS="Callout">
 </EM>
<A HREF="numpy-22.html#42703" CLASS="XRef">The constant masked</A><EM CLASS="Callout">
)</EM>
. Each element of the result is the corresponding element of t[i] where condition has the value i. The result is masked where condition is masked or where the selected element is masked or the selected element of t is the constant <EM CLASS="Callout">
masked</EM>
. </P>
<P CLASS="Body">
<A NAME="pgfId-305858"></A><A NAME="marker-307860"></A>where (condition, x, y) returns an array that is filled (x) where condition is true, filled (y) where the condition is false. One of x or y can be the constant element <EM CLASS="Callout">
masked (</EM>
See<EM CLASS="Callout">
 </EM>
<A HREF="numpy-22.html#42703" CLASS="XRef">The constant masked</A><EM CLASS="Callout">
)</EM>
. The result is masked where condition is masked, where the element selected from x or y is masked, or where x or y itself is the constant <EM CLASS="Callout">
masked</EM>
 and it is selected.</P>
<P CLASS="Body">
<A NAME="pgfId-305886"></A><A NAME="marker-307925"></A>innerproduct (a, b) and dot (a, b) work as in Numeric, but missing values don't contribute. The result is always a masked array, possibly of length one, because of the possibility that one or more entries in it may be invalid since all the data contributing to that entry was invalid.</P>
<P CLASS="Body">
<A NAME="pgfId-307701"></A><A NAME="marker-307926"></A>outerproduct (a, b) produces a masked array such that result[i, j] = a[i] * b[j]. The result will be masked where a[i] or b[j] is masked.</P>
<P CLASS="Body">
<A NAME="pgfId-305887"></A><A NAME="marker-307928"></A>compress (condition, x, dimension=-1) compresses out only those valid values where condition is true. Masked values in condition are considered false.</P>
<P CLASS="Body">
<A NAME="pgfId-305907"></A><A NAME="marker-307929"></A>maximum (x, y = None) and <A NAME="marker-307930"></A>minimum (x, y = None) compute the minimum and maximum valid values of x if y is None; with two arguments, they return the element-wise larger or smaller of valid values, and mask the result where either x or y is masked. If both arguments are scalars a scalar is returned.</P>
<P CLASS="Body">
<A NAME="pgfId-305914"></A><A NAME="marker-307931"></A>sort (x, axis=-1, value = None) returns the array x sorted along the given axis, with masked values treated as if they have a sort value of value but locations containing value are masked in the result if x had a mask to start with. Thus if x contains value at a non-masked spot, but has other spots masked, the result may not be what you want.</P>
<P CLASS="Body">
<A NAME="pgfId-305918"></A><A NAME="marker-307932"></A>argsort (x, axis = -1, fill_value = None) is unusual in that it returns a Numeric array, equal to <BR>
Numeric.argsort (filled (x, fill_value), axis); this is an array of indices for sorting along a given axis.</P>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305726"></A>Controlling the size of the string representations</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-305730"></A>The functions <A NAME="marker-307933"></A>get_print_limit () and <A NAME="marker-307934"></A>set_print_limit (n=0) query and set the limit for converting arrays using str() or repr (). If an array is printed that is larger than this, the values are not printed; rather you are informed of the type and size of the array. If n is zero, the standard Numeric conversion functions are used.</P>
<P CLASS="Body">
<A NAME="pgfId-306167"></A>When imported, MA sets this limit to 300, and the limit is also made to apply to standard Numeric arrays as well.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-304172"></A>Helper classes</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-305725"></A>This section discusses other classes defined in module MA.</P>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-306892"></A>MAError</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-306893"></A>Class <A NAME="marker-307935"></A>MAError inherits from Exception, used to raise exceptions in the MA module. Other exceptions are possible, such as errors from the underlying Numeric module.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-306894"></A><A NAME="42703"></A>The constant <A NAME="marker-307936"></A>masked</H6>
<P CLASS="Body">
<A NAME="pgfId-306895"></A>A constant named masked, in Module MA, serves several purposes.</P>
<OL>
<LI CLASS="Numbered1">
<A NAME="pgfId-306896"></A>When a indexing operation on an MaskedArray instance returns a scalar result, but the location indexed was masked, then masked is returned. For example, given a one-dimensional array x such that x.mask()[3] is 1, then x[3] is masked.</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-306897"></A>When masked is assigned to elements of an array via indexing or slicing, those elements become masked. So after x[3] = masked, x[3] is masked. </LI>
<LI CLASS="Numbered">
<A NAME="pgfId-320640"></A>Some other operations that may return scalar values, such as average, may return masked if given only invalid data.</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-320651"></A>To test whether or not a variable is this element, use the &quot;is&quot; or &quot;is not&quot; operator, not &quot;==&quot; or &quot;!=&quot;.</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-320652"></A>Operations involving the constant masked may result in an exception. In operations, masked behaves as an integer array of shape () with one masked element. For example, using + for illustration,</LI>
<LI CLASS="StepLev2">
<A NAME="pgfId-320653"></A>masked + masked is masked</LI>
<LI CLASS="StepLev2">
<A NAME="pgfId-320662"></A>masked + numeric scalar or numeric scalar + masked is masked</LI>
<LI CLASS="StepLev2">
<A NAME="pgfId-320663"></A>masked + array or array + masked is a masked array with all masked elements if array is of a numeric type. The same is true if array is a Numeric array.</LI>
</OL>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-320644"></A>The constant masked_print_option</H6>
<P CLASS="Body">
<A NAME="pgfId-320622"></A>Another constant, <A NAME="marker-320629"></A>masked_print_option, controls what happens when masked arrays and the constant masked are printed:</P>
<OL>
<LI CLASS="Numbered1">
<A NAME="pgfId-306898"></A>masked_print_option.display() is a string that may be used to indicate those elements of an array that are masked when the array is converted to a string, as happens with the print statement. </LI>
<LI CLASS="Numbered">
<A NAME="pgfId-306899"></A><A NAME="marker-307957"></A>masked_print_option.set_display (string) can be used to change the value; the default is `--'.</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-306900"></A>masked_print_option.enable(flag) can be used to enable (flag = 1, default) the use of the display string. If disabled (flag=0), the conversion to string becomes equivalent to str(self.filled()).</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-306901"></A>masked_print_option.enabled() returns the state of the display-enabling flag.</LI>
</OL>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-306903"></A>Example of masked behavior</H6>
<P CLASS="Python">
<A NAME="pgfId-320698"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
from MA import *</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-320699"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x=arange(5)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-320700"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x[3] = masked</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-320701"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-320702"></A>[0 ,1 ,2 ,-- ,4 ,]</P>
<P CLASS="Python">
<A NAME="pgfId-320703"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print repr(x)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-320704"></A>array(data = </P>
<P CLASS="Python">
<A NAME="pgfId-320705"></A> [0,1,2,0,4,],</P>
<P CLASS="Python">
<A NAME="pgfId-320706"></A>      mask = </P>
<P CLASS="Python">
<A NAME="pgfId-320707"></A> [0,0,0,1,0,],</P>
<P CLASS="Python">
<A NAME="pgfId-320708"></A>      fill_value=[0,])</P>
<P CLASS="Python">
<A NAME="pgfId-320709"></A>&nbsp;</P>
<P CLASS="Python">
<A NAME="pgfId-320710"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x[3]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-320711"></A>--</P>
<P CLASS="Python">
<A NAME="pgfId-320712"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x[3] + 1.0</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-320713"></A>--</P>
<P CLASS="Python">
<A NAME="pgfId-320714"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print masked + x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-320696"></A>[-- ,-- ,-- ,-- ,-- ,]</P>
<P CLASS="Python">
<A NAME="pgfId-320750"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
masked_print_option.enable(0)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-320751"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-320752"></A>[0,1,2,0,4,]</P>
<P CLASS="Python">
<A NAME="pgfId-320753"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x + masked</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-320754"></A>[0,0,0,0,0,]</P>
<P CLASS="Python">
<A NAME="pgfId-320758"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print filled(x+masked, -99)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-320748"></A>[-99,-99,-99,-99,-99,]</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305737"></A>Class masked_unary_function</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-305741"></A>Given a unary array function f (x), <A NAME="marker-305745"></A>masked_unary_function (f, fill = 0, domain = None) is a function which when applied to an argument x returns f applied to the array filled (x, fill), with a mask equal to <BR>
mask_or (getmask (x), domain (x)). </P>
<P CLASS="Body">
<A NAME="pgfId-305744"></A>The argument domain therefore should be a callable object that returns true where x is not in the domain of f. The following domains are also supplied as members of module MA:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-305749"></A>domain_check_interval (a, b) (x) = true where x &lt; a or y &gt; b.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-305753"></A>domain_tan (eps) (x) is true where abs (cos (x)) &lt; eps, that is, a domain suitable for the tangent function.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-305754"></A>domain_greater (v) (x) is true where x &lt;= v.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-305755"></A>domain_greater_equal (v) (x) is true where x &lt; v.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305759"></A>Class masked_binary_function</H6>
<P CLASS="BodyAfterHead">
<A NAME="pgfId-305766"></A>Given a binary array function f (x, y), masked_binary_function (f, fillx=0, filly=0) defines a function whose value at x is f (filled (x, fillx), filled (y, filly)) with a resulting mask of mask_or (getmask (x), getmask (y)). The values fillx and filly must be chosen so that (fillx, filly) is in the domain of f. </P>
<P CLASS="Body">
<A NAME="pgfId-305771"></A>In addition, an instance of masked_binary_function has two methods defined upon it:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-305772"></A>reduce (target, axis = 0)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-305776"></A>accumulate (target, axis = 0)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-320784"></A>outer(a, b)</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-305780"></A>These methods perform reduction, accumulation, and applying the function in an outer-product-like manner, as discussed in the section <A HREF="numpy-7.html#87042" CLASS="XRef">Ufuncs have special methods</A>.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-320776"></A>Class <A NAME="marker-320783"></A>domained_binary_function</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-320782"></A>This class exists to implement division-related operations. It is the same as masked_binary_function, except that a new second argument is a domain which is used to mask operations that would otherwise cause failure, such as dividing by zero. The functions that are created from this class are <A NAME="marker-320792"></A>divide, remainder (mod), and fmod.</P>
<P CLASS="Body">
<A NAME="pgfId-305787"></A>The following domains are available for use as the domain argument:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-305788"></A><A NAME="marker-320791"></A>domain_safe_divide () (x, y) is true where absolute(x)*<A NAME="marker-320790"></A>divide_tolerance &gt; absolute (y). As the comments in the code say, &quot;better ideas welcome&quot;. The constant divide_tolerance is set to 1.e-35 in the source and can be changed by editing its value in MA.py and reinstalling. This domain is used for the divide operator.</LI>
</UL>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-306123"></A>Examples of Using MA</H6>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-306127"></A>Data with a given value representing missing data</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-306131"></A>Suppose we have read a one-dimensional list of elements named x. We also know that if any of the values are 1.e20, they represent missing data. We want to compute the average value of the data and the vector of deviations from average.</P>
<P CLASS="Python">
<A NAME="pgfId-306443"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
from MA import *</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-306505"></A>&gt;&gt;&gt; x = array([0.,1.,2.,3.,4.])</P>
<P CLASS="Python">
<A NAME="pgfId-306511"></A>&gt;&gt;&gt; x[2] = 1.e20</P>
<P CLASS="Python">
<A NAME="pgfId-306508"></A>&gt;&gt;&gt; y = masked_values (x, 1.e20)</P>
<P CLASS="Python">
<A NAME="pgfId-306477"></A>&gt;&gt;&gt; print average(y)</P>
<P CLASS="Python">
<A NAME="pgfId-306478"></A>2.0</P>
<P CLASS="Python">
<A NAME="pgfId-306479"></A>&gt;&gt;&gt; print y-average(y)</P>
<P CLASS="Python">
<A NAME="pgfId-306482"></A>[ -2.00000000e+00, -1.00000000e+00,  --,  1.00000000e+00,</P>
<P CLASS="Python">
<A NAME="pgfId-306483"></A>        2.00000000e+00,]</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-306145"></A><A NAME="16670"></A>Filling in the missing data</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-306155"></A>Suppose now that we wish to print that same data, but with the missing values replaced by the average value.</P>
<P CLASS="Python">
<A NAME="pgfId-306156"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print filled (y, average(y))</EM>
</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-306378"></A>Numerical operations</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-306382"></A>We can do numerical operations without worrying about missing values, dividing by zero, square roots of negative numbers, etc.</P>
<P CLASS="Python">
<A NAME="pgfId-306388"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
from MA import *</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-306389"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x=array([1., -1., 3., 4., 5., 6.], mask=[0,0,0,0,1,0])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-306390"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
y=array([1., 2., 0., 4., 5., 6.], mask=[0,0,0,0,0,1])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-306391"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print sqrt(x/y)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-306392"></A>[  1.00000000e+00,  --,  --,  1.00000000e+00, --,  --,]</P>
<P CLASS="Body">
<A NAME="pgfId-306383"></A>Note that four values in the result are invalid: one from a negative square root, one from a divide by zero, and two more where the two arrays x and y had invalid data. Since the result was of a real type, the print command printed str (filled (sqrt (x/y))).</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-306406"></A>Seeing the mask</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-306410"></A>There are various ways to see the mask. One is to print it directly, the other is to convert to the repr representation, and a third is get the mask itself. Use of getmask(x) is more robust than x.mask(), since it will work (returning None) if x is a Numeric array or list.</P>
<P CLASS="Python">
<A NAME="pgfId-307389"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x=arange(10)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-307390"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x[3:5] = masked</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-307391"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-307392"></A>[0 ,1 ,2 ,-- ,-- ,5 ,6 ,7 ,8 ,9 ,]</P>
<P CLASS="Python">
<A NAME="pgfId-307393"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print repr(x)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-307394"></A>*** Masked array, mask present ***</P>
<P CLASS="Python">
<A NAME="pgfId-307395"></A>Data:</P>
<P CLASS="Python">
<A NAME="pgfId-307396"></A>[0 ,1 ,2 ,-- ,-- ,5 ,6 ,7 ,8 ,9 ,]</P>
<P CLASS="Python">
<A NAME="pgfId-307397"></A>Mask (fill value [0,])</P>
<P CLASS="Python">
<A NAME="pgfId-307398"></A>[0,0,0,1,1,0,0,0,0,0,]</P>
<P CLASS="Python">
<A NAME="pgfId-307399"></A>&nbsp;</P>
<P CLASS="Python">
<A NAME="pgfId-307400"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print getmask(x)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-307401"></A>[0,0,0,1,1,0,0,0,0,0,]</P>
<P CLASS="Python">
<A NAME="pgfId-307387"></A>&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-306428"></A>Filling it your way</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-306441"></A>If we want to print the data with -1's where the elements are masked, we use filled.</P>
<P CLASS="Python">
<A NAME="pgfId-306433"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print filled(z, -1)</EM>
     </P>
<P CLASS="Python">
<A NAME="pgfId-306434"></A>[ 1.,-1.,-1., 1.,-1.,-1.,]</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-320020"></A>Ignoring extreme values</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-320028"></A>Suppose we have an array d and we wish to compute the average of the values in d but ignore any data outside the range -100. to 100. </P>
<P CLASS="Python">
<A NAME="pgfId-320029"></A>v = masked_outside(d, -100., 100.)</P>
<P CLASS="Python">
<A NAME="pgfId-320030"></A>print average(v)</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-320037"></A>Averaging an entire multidimensional array</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-320069"></A>The problem with averaging over an entire array is that the average function only reduces one dimension at a time. So to average the entire array, ravel it first.</P>
<P CLASS="Python">
<A NAME="pgfId-320046"></A><EM CLASS="CodeInput">
&gt;&gt;&gt; x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-320047"></A>*** Masked array, no mask ***</P>
<P CLASS="Python">
<A NAME="pgfId-320048"></A>Data:</P>
<P CLASS="Python">
<A NAME="pgfId-320049"></A>[[ 0, 1, 2,]</P>
<P CLASS="Python">
<A NAME="pgfId-320050"></A> [ 3, 4, 5,]</P>
<P CLASS="Python">
<A NAME="pgfId-320051"></A> [ 6, 7, 8,]</P>
<P CLASS="Python">
<A NAME="pgfId-320052"></A> [ 9,10,11,]]</P>
<P CLASS="Python">
<A NAME="pgfId-320053"></A>&nbsp;</P>
<P CLASS="Python">
<A NAME="pgfId-320054"></A><EM CLASS="CodeInput">
&gt;&gt;&gt; average(x)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-320055"></A>*** Masked array, no mask ***</P>
<P CLASS="Python">
<A NAME="pgfId-320056"></A>Data:</P>
<P CLASS="Python">
<A NAME="pgfId-320057"></A>[ 4.5, 5.5, 6.5,]</P>
<P CLASS="Python">
<A NAME="pgfId-320058"></A>&nbsp;</P>
<P CLASS="Python">
<A NAME="pgfId-320059"></A><EM CLASS="CodeInput">
&gt;&gt;&gt; average(ravel(x))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-320060"></A>5.5</P>
<P CLASS="Python">
<A NAME="pgfId-320041"></A>&nbsp;</P>
</DIV>
</DIV>
</DIV>
<H2 CLASS="IndexTitleTOC">
<A HREF="numpy-23.html#pgfId-862972" CLASS="Hypertext">Index</A></H2>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-900966"></A>Symbols<A NAME="Symbols"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-900968"></A><A HREF="numpy-22.html#marker-307929" CLASS="Index"> 107</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-900970"></A><A HREF="numpy-6.html#marker-59821" CLASS="Index">... 27</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-900972"></A><A HREF="numpy-6.html#marker-59830" CLASS="Index">: 26</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-900974"></A><A HREF="numpy-6.html#marker-59831" CLASS="Index"><A HREF="numpy-12.html#marker-59857" CLASS="Index">:: 27, 55</A></A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-900977"></A><A HREF="numpy-21.html#marker-306262" CLASS="Index">_basic_del 94</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-900979"></A><A HREF="numpy-21.html#marker-306260" CLASS="Index">_basic_get 94</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-900981"></A><A HREF="numpy-21.html#marker-306261" CLASS="Index">_basic_set 94</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-900983"></A><A HREF="numpy-14.html#marker-59753" CLASS="Index">_PyArray_multiply_list 70</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-900985"></A>A<A NAME="Numerics"></A><A NAME="A"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-900988"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">absolute 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-900990"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">add 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-900992"></A><A HREF="numpy-9.html#marker-86232" CLASS="Index">allclose 46</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-900994"></A><A HREF="numpy-9.html#marker-59698" CLASS="Index">alltrue() 46</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-900996"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">arccos 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-900998"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">arccosh 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901000"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">arcsin 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901002"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">arcsinh 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901004"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">arctan 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901006"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">arctanh 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901008"></A><A HREF="numpy-9.html#marker-66025" CLASS="Index">argmax() 41</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901010"></A><A HREF="numpy-9.html#marker-65840" CLASS="Index">argsort() 41</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901012"></A><A HREF="numpy-15.html#marker-59794" CLASS="Index">array 77</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901014"></A><A HREF="numpy-11.html#marker-59711" CLASS="Index">Array Attributes 49</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901016"></A><A HREF="numpy-9.html#marker-59632" CLASS="Index">Array Functions 36</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901018"></A><A HREF="numpy-10.html#marker-59710" CLASS="Index">Array Methods 47</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901020"></A><A HREF="numpy-6.html#marker-59546" CLASS="Index">array() 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901022"></A><A HREF="numpy-9.html#marker-59658" CLASS="Index">array_repr() 44</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901024"></A><A HREF="numpy-9.html#marker-59659" CLASS="Index">array_str() 44</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901026"></A><A HREF="numpy-12.html#marker-59729" CLASS="Index">array2string 57</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901028"></A><A HREF="numpy-13.html#marker-59737" CLASS="Index">arrayobject.h 61</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901030"></A><A HREF="numpy-6.html#marker-59594" CLASS="Index">arrayrange() 18</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901032"></A><A HREF="numpy-22.html#marker-308206" CLASS="Index">arrays with missing values 97</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901034"></A><A HREF="numpy-6.html#marker-59617" CLASS="Index">astype 23</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901036"></A><A HREF="numpy-21.html#marker-306277" CLASS="Index">attribute validation 95</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901038"></A><A HREF="numpy-6.html#marker-59609" CLASS="Index">Automatic Coercions 21</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901040"></A><A HREF="numpy-6.html#marker-59544" CLASS="Index">axes 13</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-901042"></A>B<A NAME="B"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-901044"></A><A HREF="numpy-12.html#marker-86122" CLASS="Index">bit operations 59</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901046"></A><A HREF="numpy-7.html#marker-86560" CLASS="Index">bitwise_and 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901048"></A><A HREF="numpy-7.html#marker-86560" CLASS="Index">bitwise_not 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901050"></A><A HREF="numpy-7.html#marker-86560" CLASS="Index">bitwise_or 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901052"></A><A HREF="numpy-7.html#marker-86560" CLASS="Index">bitwise_xor 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901054"></A><A HREF="numpy-12.html#marker-59727" CLASS="Index">Broadcasting 56</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901056"></A><A HREF="numpy-3.html#marker-68554" CLASS="Index">Bugs 6</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901058"></A><A HREF="numpy-2.html#marker-86249" CLASS="Index">bugs, reporting 3</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901060"></A><A HREF="numpy-10.html#marker-59707" CLASS="Index">byteswapped() 47</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-901062"></A>C<A NAME="C"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-901064"></A><A HREF="numpy-6.html#marker-59608" CLASS="Index">Casting 21</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901066"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">ceil 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901068"></A><A HREF="numpy-6.html#marker-59548" CLASS="Index">Character 14</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901070"></A><A HREF="numpy-18.html#marker-306345" CLASS="Index">Cholesky decomposition 85</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901072"></A><A HREF="numpy-18.html#marker-306334" CLASS="Index">cholesky_decomposition 85</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901074"></A><A HREF="numpy-9.html#marker-59484" CLASS="Index">choose 38</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901076"></A><A HREF="numpy-9.html#marker-59647" CLASS="Index">clip() 42</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901078"></A><A HREF="numpy-12.html#marker-67986" CLASS="Index">Code Organization 51</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901080"></A><A HREF="numpy-6.html#marker-59607" CLASS="Index">Coercion 21</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901082"></A><A HREF="numpy-12.html#marker-86123" CLASS="Index">comparison, of arrays 59</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901084"></A><A HREF="numpy-6.html#marker-59576" CLASS="Index">Complex 14</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901086"></A><A HREF="numpy-6.html#marker-84325" CLASS="Index">complex numbers 14</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901088"></A><A HREF="numpy-6.html#marker-59577" CLASS="Index">Complex0 14</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901090"></A><A HREF="numpy-6.html#marker-59582" CLASS="Index">Complex128 14</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901092"></A><A HREF="numpy-6.html#marker-59579" CLASS="Index">Complex16 14</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901094"></A><A HREF="numpy-6.html#marker-59580" CLASS="Index">Complex32 14</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901096"></A><A HREF="numpy-6.html#marker-59581" CLASS="Index">Complex64 14</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901098"></A><A HREF="numpy-6.html#marker-59578" CLASS="Index">Complex8 14</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901100"></A><A HREF="numpy-9.html#marker-59638" CLASS="Index">compress() 39</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901102"></A><A HREF="numpy-9.html#marker-59651" CLASS="Index">concatenate() 43</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901104"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">conjugate 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901106"></A><A HREF="numpy-13.html#marker-59740" CLASS="Index">Contiguous arrays 63</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901108"></A><A HREF="numpy-5.html#marker-60951" CLASS="Index">Convenience 11</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901110"></A><A HREF="numpy-9.html#marker-67940" CLASS="Index">convolve 45</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901112"></A><A HREF="numpy-9.html#marker-67939" CLASS="Index">correlation 45</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901114"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">cos 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901116"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">cosh 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901118"></A><A HREF="numpy-9.html#marker-67939" CLASS="Index">cross_correlate 45</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901120"></A><A HREF="numpy-9.html#marker-59697" CLASS="Index">cumproduct() 46</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901122"></A><A HREF="numpy-9.html#marker-59695" CLASS="Index">cumsum() 46</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901124"></A><A HREF="numpy-3.html#marker-68553" CLASS="Index">CVS 6</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-901126"></A>D<A NAME="D"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-901128"></A><A HREF="numpy-18.html#marker-303081" CLASS="Index">determinant() 85</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901130"></A><A HREF="numpy-9.html#marker-59639" CLASS="Index"><A HREF="numpy-9.html#marker-59662" CLASS="Index">diagonal() 39, 44</A></A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901133"></A><A HREF="numpy-6.html#marker-59543" CLASS="Index">dimensions 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901135"></A><A HREF="numpy-3.html#marker-68556" CLASS="Index">Discussion list 6</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901137"></A><A HREF="numpy-12.html#marker-86292" CLASS="Index">disk storage 59</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901139"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">divide 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901141"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">divide_safe 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901143"></A><A HREF="numpy-2.html#marker-86249" CLASS="Index">documentation, how to get 3</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901145"></A><A HREF="numpy-2.html#marker-86249" CLASS="Index">downloads 3</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901147"></A><A HREF="numpy-22.html#marker-305509" CLASS="Index">Dubois, Paul F. 97</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-901149"></A>E<A NAME="E"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-901151"></A><A HREF="numpy-18.html#marker-303046" CLASS="Index">eigenvalues() 84</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901153"></A><A HREF="numpy-18.html#marker-306345" CLASS="Index">eigenvalues, Hermitian 85</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901155"></A><A HREF="numpy-18.html#marker-303057" CLASS="Index">eigenvectors() 85</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901157"></A><A HREF="numpy-18.html#marker-306366" CLASS="Index">eigenvectors, Hermitian 86</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901159"></A><A HREF="numpy-6.html#marker-61094" CLASS="Index">element-wise 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901161"></A><A HREF="numpy-12.html#marker-59725" CLASS="Index">Ellipses 56</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901163"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">equal 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901165"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">exp 28</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-901167"></A>F<A NAME="F"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-901169"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">fabs 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901171"></A><A HREF="numpy-17.html#marker-302950" CLASS="Index">FFT 81</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901173"></A><A HREF="numpy-17.html#marker-302957" CLASS="Index">fft() 81</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901175"></A><A HREF="numpy-11.html#marker-59712" CLASS="Index">flat (attribute) 49</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901177"></A><A HREF="numpy-6.html#marker-59566" CLASS="Index">Float 14</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901179"></A><A HREF="numpy-6.html#marker-59570" CLASS="Index">Float0 14</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901181"></A><A HREF="numpy-6.html#marker-59575" CLASS="Index">Float128 14</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901183"></A><A HREF="numpy-6.html#marker-59572" CLASS="Index">Float16 14</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901185"></A><A HREF="numpy-6.html#marker-59573" CLASS="Index">Float32 14</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901187"></A><A HREF="numpy-6.html#marker-59574" CLASS="Index">Float64 14</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901189"></A><A HREF="numpy-6.html#marker-59571" CLASS="Index">Float8 14</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901191"></A><A HREF="numpy-12.html#marker-59732" CLASS="Index">floating point exceptions 59</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901193"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">floor 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901195"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">fmod 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901197"></A><A HREF="numpy-12.html#marker-59733" CLASS="Index">fpectl 59</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901199"></A><A HREF="numpy-6.html#marker-59598" CLASS="Index">fromfunction() 20</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901201"></A><A HREF="numpy-9.html#marker-59645" CLASS="Index"><A HREF="numpy-9.html#marker-67905" CLASS="Index">fromstring() 41, 45</A></A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901204"></A><A HREF="numpy-3.html#marker-68557" CLASS="Index">FTP Site 6</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-901206"></A>G<A NAME="G"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-901208"></A>gather</LI>
<UL>
<LI CLASS="Level2IX">
<A NAME="pgfId-901209"></A><A HREF="numpy-9.html#marker-78559" CLASS="Index">see put() 37</A></LI>
</UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-901211"></A><A HREF="numpy-18.html#marker-303078" CLASS="Index">generalized_inverse() 85</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901213"></A><A HREF="numpy-19.html#marker-303098" CLASS="Index">get_seed() 87</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901215"></A><A HREF="numpy-6.html#marker-59618" CLASS="Index">Getting array values 25</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901217"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">greater 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901219"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">greater_equal 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901221"></A><A HREF="numpy-4.html#marker-59531" CLASS="Index">greece 8</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-901223"></A>H<A NAME="H"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-901225"></A><A HREF="numpy-18.html#marker-306345" CLASS="Index">Heigenvalues 85</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901227"></A><A HREF="numpy-18.html#marker-306365" CLASS="Index">Heigenvectors 86</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901229"></A><A HREF="numpy-6.html#marker-59541" CLASS="Index">homogeneous 13</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-901231"></A>I<A NAME="I"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-901233"></A><A HREF="numpy-6.html#marker-59606" CLASS="Index"><A HREF="numpy-9.html#marker-59693" CLASS="Index">identity() 21, 45</A></A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901236"></A><A HREF="numpy-4.html#marker-59534" CLASS="Index">IDLE 9</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901238"></A><A HREF="numpy-11.html#marker-59714" CLASS="Index">imaginary (attribute) 49</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901240"></A><A HREF="numpy-6.html#marker-84325" CLASS="Index">imaginary numbers 14</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901242"></A><A HREF="numpy-12.html#marker-59724" CLASS="Index">Indexing 55</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901244"></A><A HREF="numpy-9.html#marker-66266" CLASS="Index">indices() 42</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901246"></A><A HREF="numpy-9.html#marker-59656" CLASS="Index">innerproduct() 44</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901248"></A><A HREF="numpy-3.html#marker-59513" CLASS="Index">Installing NumPy 5</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901250"></A><A HREF="numpy-6.html#marker-59558" CLASS="Index">Int 14</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901252"></A><A HREF="numpy-6.html#marker-59559" CLASS="Index">Int0 14</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901254"></A><A HREF="numpy-6.html#marker-59565" CLASS="Index">Int128 14</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901256"></A><A HREF="numpy-6.html#marker-59561" CLASS="Index">Int16 14</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901258"></A><A HREF="numpy-6.html#marker-59562" CLASS="Index">Int32 14</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901260"></A><A HREF="numpy-6.html#marker-59563" CLASS="Index">Int64 14</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901262"></A><A HREF="numpy-6.html#marker-59560" CLASS="Index">Int8 14</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901264"></A><A HREF="numpy-18.html#marker-303022" CLASS="Index">inverse() 84</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901266"></A><A HREF="numpy-17.html#marker-302969" CLASS="Index">inverse_fft() 81</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901268"></A><A HREF="numpy-17.html#marker-302985" CLASS="Index">inverse_real_fft() 82</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901270"></A><A HREF="numpy-10.html#marker-59705" CLASS="Index">iscontiguous() 47</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901272"></A><A HREF="numpy-10.html#marker-59704" CLASS="Index">itemsize() 47</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-901274"></A>L<A NAME="J"></A><A NAME="K"></A><A NAME="L"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-901278"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">less 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901280"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">less_equal 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901282"></A><A HREF="numpy-22.html#marker-307934" CLASS="Index">limiting printing of large arrays 107</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901284"></A><A HREF="numpy-18.html#marker-303084" CLASS="Index">linear_least_squares() 85</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901286"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">log 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901288"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">log10 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901290"></A><A HREF="numpy-7.html#marker-59626" CLASS="Index">Logical Ufuncs 31</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901292"></A><A HREF="numpy-7.html#marker-86560" CLASS="Index"><A HREF="numpy-12.html#marker-86121" CLASS="Index">logical_and 28, 59</A></A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901295"></A><A HREF="numpy-7.html#marker-86560" CLASS="Index"><A HREF="numpy-12.html#marker-86120" CLASS="Index">logical_or 28, 59</A></A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901298"></A><A HREF="numpy-7.html#marker-86560" CLASS="Index">logical_xor 28</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-901300"></A>M<A NAME="M"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-901302"></A>MA</LI>
<UL>
<LI CLASS="Level2IX">
<A NAME="pgfId-901303"></A><A HREF="numpy-22.html#marker-307875" CLASS="Index">absolute 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901305"></A><A HREF="numpy-22.html#marker-307882" CLASS="Index">add 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901307"></A><A HREF="numpy-22.html#marker-307920" CLASS="Index">allclose 106</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901309"></A><A HREF="numpy-22.html#marker-307921" CLASS="Index">allequal 106</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901311"></A><A HREF="numpy-22.html#marker-307904" CLASS="Index">alltrue 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901313"></A><A HREF="numpy-22.html#marker-305810" CLASS="Index">arange 106</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901315"></A><A HREF="numpy-22.html#marker-307870" CLASS="Index">arccos 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901317"></A><A HREF="numpy-22.html#marker-307869" CLASS="Index">arcsin 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901319"></A><A HREF="numpy-22.html#marker-307871" CLASS="Index">arctan 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901321"></A><A HREF="numpy-22.html#marker-307890" CLASS="Index">arctan2 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901323"></A><A HREF="numpy-22.html#marker-307932" CLASS="Index">argsort 107</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901325"></A><A HREF="numpy-22.html#marker-307882" CLASS="Index">arithmetic operators 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901327"></A><A HREF="numpy-22.html#marker-307879" CLASS="Index">around 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901329"></A><A HREF="numpy-22.html#marker-308230" CLASS="Index">array (constructor) 101</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901331"></A><A HREF="numpy-22.html#marker-305817" CLASS="Index">arrayrange 106</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901333"></A><A HREF="numpy-22.html#marker-308029" CLASS="Index">average 106</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901335"></A><A HREF="numpy-22.html#marker-307891" CLASS="Index">bitwise_and 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901337"></A><A HREF="numpy-22.html#marker-307892" CLASS="Index">bitwise_or 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901339"></A><A HREF="numpy-22.html#marker-307893" CLASS="Index">bitwise_xor 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901341"></A><A HREF="numpy-22.html#marker-307939" CLASS="Index">choose 107</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901343"></A><A HREF="numpy-22.html#marker-306622" CLASS="Index">class MA 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901345"></A><A HREF="numpy-22.html#marker-307897" CLASS="Index">comparisons 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901347"></A><A HREF="numpy-22.html#marker-307928" CLASS="Index">compress 107</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901349"></A><A HREF="numpy-22.html#marker-307911" CLASS="Index">concatenate 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901351"></A><A HREF="numpy-22.html#marker-307865" CLASS="Index">conjugate 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901353"></A><A HREF="numpy-22.html#marker-307867" CLASS="Index">cos 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901355"></A><A HREF="numpy-22.html#marker-307873" CLASS="Index">cosh 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901357"></A><A HREF="numpy-22.html#marker-307916" CLASS="Index">count 106</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901359"></A><A HREF="numpy-22.html#marker-320562" CLASS="Index">create_mask (deprecated) 103</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901361"></A><A HREF="numpy-22.html#marker-305349" CLASS="Index">default_character_fill_value 102</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901363"></A><A HREF="numpy-22.html#marker-305348" CLASS="Index">default_complex_fill_value 102</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901365"></A><A HREF="numpy-22.html#marker-305350" CLASS="Index">default_integer_fill_value 102</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901367"></A><A HREF="numpy-22.html#marker-305352" CLASS="Index">default_object_fill_value 102</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901369"></A><A HREF="numpy-22.html#marker-305365" CLASS="Index">default_real_fill_value 102</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901371"></A><A HREF="numpy-22.html#marker-320572" CLASS="Index">diagonal 106</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901373"></A><A HREF="numpy-22.html#marker-307885" CLASS="Index"><A HREF="numpy-22.html#marker-320792" CLASS="Index">divide 105, 109</A></A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901376"></A><A HREF="numpy-22.html#marker-320790" CLASS="Index">divide_tolerance 109</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901378"></A><A HREF="numpy-22.html#marker-320791" CLASS="Index">domain_safe_divide 109</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901380"></A><A HREF="numpy-22.html#marker-320783" CLASS="Index">domained_binary_function 109</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901382"></A><A HREF="numpy-22.html#marker-307894" CLASS="Index">equal 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901384"></A><A HREF="numpy-22.html#marker-307864" CLASS="Index">exp 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901386"></A><A HREF="numpy-22.html#marker-307876" CLASS="Index">fabs 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901388"></A><A HREF="numpy-22.html#marker-305346" CLASS="Index">fill_value 102</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901390"></A><A HREF="numpy-22.html#marker-307880" CLASS="Index">floor 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901392"></A><A HREF="numpy-22.html#marker-307888" CLASS="Index"><A HREF="numpy-22.html#marker-320792" CLASS="Index">fmod 105, 109</A></A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901395"></A><A HREF="numpy-22.html#marker-320573" CLASS="Index">fromfunction 106</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901397"></A><A HREF="numpy-22.html#marker-320574" CLASS="Index">fromstring 106</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901399"></A><A HREF="numpy-22.html#marker-304071" CLASS="Index">functions and operators 104</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901401"></A><A HREF="numpy-22.html#marker-307933" CLASS="Index">get_print_limit 107</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901403"></A><A HREF="numpy-22.html#marker-305356" CLASS="Index">getmask 103</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901405"></A><A HREF="numpy-22.html#marker-305367" CLASS="Index">getmaskarray 103</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901407"></A><A HREF="numpy-22.html#marker-307899" CLASS="Index">greater 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901409"></A><A HREF="numpy-22.html#marker-307897" CLASS="Index">greater_equal 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901411"></A><A HREF="numpy-22.html#marker-307889" CLASS="Index">hypot 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901413"></A><A HREF="numpy-22.html#marker-307912" CLASS="Index">identity 106</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901415"></A><A HREF="numpy-22.html#marker-307913" CLASS="Index">indices 106</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901417"></A><A HREF="numpy-22.html#marker-307925" CLASS="Index">innerproduct 107</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901419"></A><A HREF="numpy-22.html#marker-305507" CLASS="Index">installing 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901421"></A><A HREF="numpy-22.html#marker-305508" CLASS="Index">invalid, defined 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901423"></A><A HREF="numpy-22.html#marker-305354" CLASS="Index">is_mask 103</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901425"></A><A HREF="numpy-22.html#marker-305831" CLASS="Index">isarray 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901427"></A><A HREF="numpy-22.html#marker-305832" CLASS="Index">isMA 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901429"></A><A HREF="numpy-22.html#marker-307914" CLASS="Index">len 106</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901431"></A><A HREF="numpy-22.html#marker-307898" CLASS="Index">less 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901433"></A><A HREF="numpy-22.html#marker-307896" CLASS="Index">less_equal 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901435"></A><A HREF="numpy-22.html#marker-307862" CLASS="Index">log 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901437"></A><A HREF="numpy-22.html#marker-307863" CLASS="Index">log10 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901439"></A><A HREF="numpy-22.html#marker-307900" CLASS="Index">logical operators 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901441"></A><A HREF="numpy-22.html#marker-307902" CLASS="Index">logical_and 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901443"></A><A HREF="numpy-22.html#marker-308197" CLASS="Index">logical_not 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901445"></A><A HREF="numpy-22.html#marker-307901" CLASS="Index">logical_or 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901447"></A><A HREF="numpy-22.html#marker-307903" CLASS="Index">logical_xor 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901449"></A><A HREF="numpy-22.html#marker-307935" CLASS="Index">MAError 107</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901451"></A><A HREF="numpy-22.html#marker-305355" CLASS="Index">make_mask 103</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901453"></A><A HREF="numpy-22.html#marker-320559" CLASS="Index">make_mask_none 103</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901455"></A><A HREF="numpy-22.html#marker-305366" CLASS="Index">mask method 103</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901457"></A><A HREF="numpy-22.html#marker-305802" CLASS="Index">mask_object (constructor) 101</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901459"></A><A HREF="numpy-22.html#marker-305370" CLASS="Index">mask_or 103</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901461"></A><A HREF="numpy-22.html#marker-305506" CLASS="Index">mask_values 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901463"></A><A HREF="numpy-22.html#marker-307936" CLASS="Index">masked (constant) 107</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901465"></A><A HREF="numpy-22.html#marker-307957" CLASS="Index">masked (constant), role in printing 108</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901467"></A><A HREF="numpy-22.html#marker-306591" CLASS="Index">masked (module constant) 102</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901469"></A><A HREF="numpy-22.html#marker-306618" CLASS="Index">masked (special constant) 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901471"></A><A HREF="numpy-22.html#marker-305508" CLASS="Index">masked, defined 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901473"></A><A HREF="numpy-22.html#marker-304072" CLASS="Index">masked_array 101</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901475"></A><A HREF="numpy-22.html#marker-308232" CLASS="Index">masked_array (constructor) 101</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901477"></A><A HREF="numpy-22.html#marker-307797" CLASS="Index">masked_equal 101</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901479"></A><A HREF="numpy-22.html#marker-307789" CLASS="Index">masked_greater 101</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901481"></A><A HREF="numpy-22.html#marker-307793" CLASS="Index">masked_greater_equal 101</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901483"></A><A HREF="numpy-22.html#marker-307805" CLASS="Index">masked_less 101</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901485"></A><A HREF="numpy-22.html#marker-307809" CLASS="Index">masked_less_equal 101</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901487"></A><A HREF="numpy-22.html#marker-307801" CLASS="Index">masked_not_equal 101</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901489"></A><A HREF="numpy-22.html#marker-320629" CLASS="Index">masked_print_option 108</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901491"></A><A HREF="numpy-22.html#marker-305745" CLASS="Index">masked_unary_function 108</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901493"></A><A HREF="numpy-22.html#marker-307810" CLASS="Index">masked_values 101</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901495"></A><A HREF="numpy-22.html#marker-307732" CLASS="Index">masked_where 101</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901497"></A><A HREF="numpy-22.html#marker-320328" CLASS="Index">masks, and savespace attribute 102</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901499"></A><A HREF="numpy-22.html#marker-320328" CLASS="Index">masks, description of 102</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901501"></A><A HREF="numpy-22.html#marker-307929" CLASS="Index">maximum 107</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901503"></A><A HREF="numpy-22.html#marker-307929" CLASS="Index">maximum with two arguments 107</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901505"></A><A HREF="numpy-22.html#marker-307930" CLASS="Index">minimum 107</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901507"></A><A HREF="numpy-22.html#marker-320792" CLASS="Index">mod 109</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901509"></A><A HREF="numpy-22.html#marker-307884" CLASS="Index">multiply 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901511"></A><A HREF="numpy-22.html#marker-307877" CLASS="Index">negative 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901513"></A><A HREF="numpy-22.html#marker-307878" CLASS="Index">nonzero 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901515"></A><A HREF="numpy-22.html#marker-307895" CLASS="Index">not_equal 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901517"></A><A HREF="numpy-22.html#marker-305822" CLASS="Index">ones 106</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901519"></A><A HREF="numpy-22.html#marker-307926" CLASS="Index">outerproduct 107</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901521"></A><A HREF="numpy-22.html#marker-307886" CLASS="Index">power 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901523"></A><A HREF="numpy-22.html#marker-320629" CLASS="Index">printing masked values 108</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901525"></A><A HREF="numpy-22.html#marker-307918" CLASS="Index">product 106</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901527"></A><A HREF="numpy-22.html#marker-307924" CLASS="Index">put 106</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901529"></A><A HREF="numpy-22.html#marker-307906" CLASS="Index">rank 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901531"></A><A HREF="numpy-22.html#marker-307910" CLASS="Index">ravel 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901533"></A><A HREF="numpy-22.html#marker-307887" CLASS="Index"><A HREF="numpy-22.html#marker-320792" CLASS="Index">remainder 105, 109</A></A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901536"></A><A HREF="numpy-22.html#marker-307909" CLASS="Index">reshape 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901538"></A><A HREF="numpy-22.html#marker-307908" CLASS="Index">resize 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901540"></A><A HREF="numpy-22.html#marker-320343" CLASS="Index">set_fill_value 102</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901542"></A><A HREF="numpy-22.html#marker-307934" CLASS="Index">set_print_limit 107</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901544"></A><A HREF="numpy-22.html#marker-307907" CLASS="Index">shape 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901546"></A><A HREF="numpy-22.html#marker-307866" CLASS="Index">sin 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901548"></A><A HREF="numpy-22.html#marker-307872" CLASS="Index">sinh 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901550"></A><A HREF="numpy-22.html#marker-307915" CLASS="Index">size 106</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901552"></A><A HREF="numpy-22.html#marker-307905" CLASS="Index">sometrue 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901554"></A><A HREF="numpy-22.html#marker-307931" CLASS="Index">sort 107</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901556"></A><A HREF="numpy-22.html#marker-307861" CLASS="Index">sqrt 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901558"></A><A HREF="numpy-22.html#marker-307883" CLASS="Index">subtract 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901560"></A><A HREF="numpy-22.html#marker-307917" CLASS="Index">sum 106</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901562"></A><A HREF="numpy-22.html#marker-307922" CLASS="Index">take 106</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901564"></A><A HREF="numpy-22.html#marker-307868" CLASS="Index">tan 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901566"></A><A HREF="numpy-22.html#marker-307874" CLASS="Index">tanh 105</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901568"></A><A HREF="numpy-22.html#marker-307923" CLASS="Index">transpose 106</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901570"></A><A HREF="numpy-22.html#marker-307860" CLASS="Index">where 107</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-901572"></A><A HREF="numpy-22.html#marker-305826" CLASS="Index">zeros 106</A></LI>
</UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-901574"></A><A HREF="numpy-5.html#marker-68202" CLASS="Index">MA (masked arrays) 10</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901576"></A><A HREF="numpy-3.html#marker-68556" CLASS="Index">mailing list 6</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901578"></A><A HREF="numpy-2.html#marker-86249" CLASS="Index">mailing lists 3</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901580"></A><A HREF="numpy-22.html#marker-308206" CLASS="Index">masked arrays 97</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901582"></A><A HREF="numpy-15.html#marker-59797" CLASS="Index">Matrix 77</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901584"></A><A HREF="numpy-9.html#marker-59646" CLASS="Index">matrixmultiply() 42</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901586"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">maximum 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901588"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">minimum 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901590"></A><A HREF="numpy-5.html#marker-68202" CLASS="Index"><A HREF="numpy-22.html#marker-308206" CLASS="Index">missing values 10, 97</A></A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901593"></A><A HREF="numpy-5.html#marker-59537" CLASS="Index"><A HREF="numpy-6.html#marker-59540" CLASS="Index"><A HREF="numpy-12.html#marker-66810" CLASS="Index"><A HREF="numpy-15.html#marker-59795" CLASS="Index">multiarray 10, 13, 54, 77</A></A></A></A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901598"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">multiply 28</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-901600"></A>N<A NAME="N"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-901602"></A><A HREF="numpy-12.html#marker-59733" CLASS="Index">NaNs 59</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901604"></A><A HREF="numpy-12.html#marker-86292" CLASS="Index">netCDF 59</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901606"></A><A HREF="numpy-8.html#marker-59833" CLASS="Index"><A HREF="numpy-12.html#marker-59726" CLASS="Index">NewAxis 35, 56</A></A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901609"></A><A HREF="numpy-9.html#marker-59636" CLASS="Index">nonzero() 39</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901611"></A><A HREF="numpy-5.html#marker-59536" CLASS="Index">Numeric.py 10</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901613"></A><A HREF="numpy-4.html#marker-59530" CLASS="Index">NumTut 8</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-901615"></A>O<A NAME="O"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-901617"></A><A HREF="numpy-22.html#marker-308207" CLASS="Index">observations, dealing with missing 97</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901619"></A><A HREF="numpy-6.html#marker-60119" CLASS="Index">ones() 18</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901621"></A><A HREF="numpy-7.html#marker-86560" CLASS="Index">operators, connection to functions 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901623"></A><A HREF="numpy-9.html#marker-84312" CLASS="Index">outerproduct 44</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-901625"></A>P<A NAME="P"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-901627"></A><A HREF="numpy-3.html#marker-68555" CLASS="Index">Patches 6</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901629"></A><A HREF="numpy-2.html#marker-86249" CLASS="Index">patches, submitting 3</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901631"></A><A HREF="numpy-19.html#marker-303110" CLASS="Index">permutation() 87</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901633"></A><A HREF="numpy-12.html#marker-59731" CLASS="Index">pickle 59</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901635"></A><A HREF="numpy-12.html#marker-59730" CLASS="Index">Pickling 59</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901637"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">power 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901639"></A>printing</LI>
<UL>
<LI CLASS="Level2IX">
<A NAME="pgfId-901640"></A><A HREF="numpy-22.html#marker-307934" CLASS="Index">using MA to limit printing of large arrays 107</A></LI>
</UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-901642"></A><A HREF="numpy-9.html#marker-59696" CLASS="Index">product() 46</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901644"></A><A HREF="numpy-21.html#marker-306250" CLASS="Index">PropertiedClass 94</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901646"></A><A HREF="numpy-21.html#marker-306251" CLASS="Index">PropertiedClasses 94</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901648"></A><A HREF="numpy-21.html#marker-306252" CLASS="Index">property 94</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901650"></A><A HREF="numpy-8.html#marker-59631" CLASS="Index">Pseudo Indices 34</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901652"></A><A HREF="numpy-9.html#marker-78558" CLASS="Index">put() 37</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901654"></A><A HREF="numpy-13.html#marker-86192" CLASS="Index">PY_ARRAY_UNIQUE_SYMBOL 61</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901656"></A><A HREF="numpy-14.html#marker-59764" CLASS="Index">PyArray_As1D 71</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901658"></A><A HREF="numpy-14.html#marker-59765" CLASS="Index">PyArray_As2D 71</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901660"></A><A HREF="numpy-14.html#marker-59751" CLASS="Index">PyArray_CanCastSafely 70</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901662"></A><A HREF="numpy-14.html#marker-59750" CLASS="Index">PyArray_Cast 70</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901664"></A><A HREF="numpy-14.html#marker-59743" CLASS="Index">PyArray_Check 69</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901666"></A><A HREF="numpy-14.html#marker-59757" CLASS="Index">PyArray_ContiguousFromObject 71</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901668"></A><A HREF="numpy-14.html#marker-59762" CLASS="Index">PyArray_Copy 71</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901670"></A><A HREF="numpy-14.html#marker-59758" CLASS="Index">PyArray_CopyFromObject 71</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901672"></A><A HREF="numpy-14.html#marker-59749" CLASS="Index">PyArray_DescrFromType 70</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901674"></A><A HREF="numpy-14.html#marker-59766" CLASS="Index">PyArray_Free 71</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901676"></A><A HREF="numpy-14.html#marker-59755" CLASS="Index">PyArray_FromDims 70</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901678"></A><A HREF="numpy-14.html#marker-59756" CLASS="Index">PyArray_FromDimsAndData 70</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901680"></A><A HREF="numpy-14.html#marker-59759" CLASS="Index">PyArray_FromObject 71</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901682"></A><A HREF="numpy-14.html#marker-59745" CLASS="Index">PyArray_INCREF 69</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901684"></A><A HREF="numpy-14.html#marker-59752" CLASS="Index">PyArray_ObjectType 70</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901686"></A><A HREF="numpy-14.html#marker-59761" CLASS="Index">PyArray_Reshape 71</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901688"></A><A HREF="numpy-14.html#marker-59760" CLASS="Index">PyArray_Return 71</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901690"></A><A HREF="numpy-14.html#marker-59744" CLASS="Index">PyArray_SetNumericOps 69</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901692"></A><A HREF="numpy-14.html#marker-59748" CLASS="Index">PyArray_SetStringFunction 70</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901694"></A><A HREF="numpy-14.html#marker-59754" CLASS="Index">PyArray_Size 70</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901696"></A><A HREF="numpy-14.html#marker-59763" CLASS="Index">PyArray_Take 71</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901698"></A><A HREF="numpy-14.html#marker-59746" CLASS="Index">PyArray_XDECREF 70</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901700"></A><A HREF="numpy-14.html#marker-59747" CLASS="Index">PyArrayError 70</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901702"></A><A HREF="numpy-13.html#marker-59739" CLASS="Index"><A HREF="numpy-14.html#marker-59742" CLASS="Index">PyArrayObject 62, 68</A></A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901705"></A><A HREF="numpy-6.html#marker-59583" CLASS="Index">PyObject 15</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901707"></A><A HREF="numpy-14.html#marker-59768" CLASS="Index">PyUFunc_Check 74</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901709"></A><A HREF="numpy-14.html#marker-59769" CLASS="Index">PyUFunc_FromFuncAndData 74</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901711"></A><A HREF="numpy-14.html#marker-59770" CLASS="Index">PyUFunc_GenericFunction 75</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-901713"></A>R<A NAME="Q"></A><A NAME="R"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-901716"></A><A HREF="numpy-19.html#marker-303107" CLASS="Index">randint() 87</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901718"></A><A HREF="numpy-19.html#marker-303101" CLASS="Index">random() 87</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901720"></A><A HREF="numpy-19.html#marker-303092" CLASS="Index">RandomArray 87</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901722"></A><A HREF="numpy-6.html#marker-59542" CLASS="Index"><A HREF="numpy-15.html#marker-59798" CLASS="Index">rank 13, 77</A></A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901725"></A><A HREF="numpy-9.html#marker-59485" CLASS="Index">ravel 39</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901727"></A><A HREF="numpy-21.html#marker-306259" CLASS="Index">read-only attributes 94</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901729"></A><A HREF="numpy-11.html#marker-59713" CLASS="Index">real (attribute) 49</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901731"></A><A HREF="numpy-17.html#marker-302972" CLASS="Index">real_fft() 81</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901733"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">remainder 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901735"></A><A HREF="numpy-9.html#marker-59635" CLASS="Index"><A HREF="numpy-9.html#marker-59666" CLASS="Index">repeat() 38, 44</A></A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901738"></A><A HREF="numpy-6.html#marker-59584" CLASS="Index">reshape 16</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901740"></A><A HREF="numpy-6.html#marker-59585" CLASS="Index">resize 17</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901742"></A><A HREF="numpy-9.html#marker-59660" CLASS="Index">resize() 44</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-901744"></A>S<A NAME="S"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-901746"></A><A HREF="numpy-19.html#marker-303095" CLASS="Index">seed() 87</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901748"></A><A HREF="numpy-21.html#marker-306249" CLASS="Index">set_property 95</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901750"></A><A HREF="numpy-6.html#marker-59619" CLASS="Index">Setting array values 25</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901752"></A><A HREF="numpy-15.html#marker-59799" CLASS="Index">shape 77</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901754"></A><A HREF="numpy-18.html#marker-303075" CLASS="Index">singular_value_decomposition() 85</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901756"></A><A HREF="numpy-6.html#marker-59620" CLASS="Index">Slicing Arrays 26</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901758"></A><A HREF="numpy-18.html#marker-303018" CLASS="Index">solve_linear_equations() 84</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901760"></A><A HREF="numpy-9.html#marker-59699" CLASS="Index">sometrue() 46</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901762"></A><A HREF="numpy-9.html#marker-66635" CLASS="Index">sort() 40</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901764"></A><A HREF="numpy-2.html#marker-86249" CLASS="Index"><A HREF="numpy-3.html#marker-68558" CLASS="Index">SourceForge 3, 6</A></A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901767"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">sqrt 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901769"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">subtract 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901771"></A><A HREF="numpy-9.html#marker-59694" CLASS="Index">sum() 46</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901773"></A><A HREF="numpy-9.html#marker-59650" CLASS="Index">swapaxes() 43</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-901775"></A>T<A NAME="T"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-901777"></A><A HREF="numpy-9.html#marker-59633" CLASS="Index">take() 36</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901779"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">tan 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901781"></A><A HREF="numpy-7.html#marker-86559" CLASS="Index">tanh 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901783"></A><A HREF="numpy-12.html#marker-59728" CLASS="Index">Textual representations 57</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901785"></A><A HREF="numpy-4.html#marker-59533" CLASS="Index">thread 9</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901787"></A><A HREF="numpy-4.html#marker-59532" CLASS="Index">Tk 9</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901789"></A><A HREF="numpy-10.html#marker-59709" CLASS="Index">tolist() 48</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901791"></A><A HREF="numpy-10.html#marker-59708" CLASS="Index">tostring() 47</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901793"></A><A HREF="numpy-9.html#marker-59640" CLASS="Index">trace() 40</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901795"></A><A HREF="numpy-9.html#marker-59634" CLASS="Index">transpose() 38</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901797"></A><A HREF="numpy-6.html#marker-59547" CLASS="Index"><A HREF="numpy-6.html#marker-59613" CLASS="Index"><A HREF="numpy-15.html#marker-59791" CLASS="Index">typecode 13, 22, 77</A></A></A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901801"></A><A HREF="numpy-10.html#marker-59706" CLASS="Index">typecode() 47</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901803"></A><A HREF="numpy-12.html#marker-59717" CLASS="Index">Typecodes 54</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-901805"></A>U<A NAME="U"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-901807"></A><A HREF="numpy-5.html#marker-59538" CLASS="Index"><A HREF="numpy-15.html#marker-59792" CLASS="Index">ufunc 10, 77</A></A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901810"></A><A HREF="numpy-7.html#marker-59630" CLASS="Index">Ufunc shorthands 33</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901812"></A><A HREF="numpy-14.html#marker-59767" CLASS="Index">UfuncObject 72</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901814"></A><A HREF="numpy-13.html#marker-59738" CLASS="Index">ufuncobject.h 61</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901816"></A><A HREF="numpy-7.html#marker-59621" CLASS="Index">Ufuncs 28</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901818"></A><A HREF="numpy-7.html#marker-59625" CLASS="Index">Unary Mathematical Ufuncs 31</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901820"></A><A HREF="numpy-19.html#marker-303104" CLASS="Index">uniform() 87</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901822"></A><A HREF="numpy-15.html#marker-59793" CLASS="Index">universal function 77</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901824"></A><A HREF="numpy-5.html#marker-59539" CLASS="Index">universal functions 10</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901826"></A><A HREF="numpy-3.html#marker-59524" CLASS="Index">Unix 6</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901828"></A><A HREF="numpy-6.html#marker-59549" CLASS="Index">UnsignedInt8 14</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901830"></A><A HREF="numpy-15.html#marker-59796" CLASS="Index">UserArray 77</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-901832"></A>V<A NAME="V"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-901834"></A><A HREF="numpy-21.html#marker-306277" CLASS="Index">validating attributes 95</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901836"></A><A HREF="numpy-4.html#marker-59535" CLASS="Index">view 8</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-901838"></A>W<A NAME="W"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-901840"></A><A HREF="numpy-2.html#marker-86249" CLASS="Index">web site 3</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901842"></A><A HREF="numpy-9.html#marker-59637" CLASS="Index"><A HREF="numpy-9.html#marker-67906" CLASS="Index">where() 39, 45</A></A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-901845"></A>Z<A NAME="X"></A><A NAME="Y"></A><A NAME="Z"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-901849"></A><A HREF="numpy-13.html#marker-59741" CLASS="Index">Zero-dimensional arrays 63</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-901851"></A><A HREF="numpy-6.html#marker-60118" CLASS="Index">zeros() 18</A></LI>
</UL>
</DIV>
<P><A HREF="numpy.html">Go to Main</A>      <A HREF="numpy-21.html">Go to Previous</A>       <A HREF="numpy-23.html">Go to Next</A></P>
</BODY>
</HTML>
