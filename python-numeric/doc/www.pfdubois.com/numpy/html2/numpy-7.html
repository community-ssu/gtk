<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 6.0/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="numpy.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE> 6.	 Ufuncs </TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">
<H1 CLASS="Chapter">
<A NAME="pgfId-36126"></A>6.	 <A NAME="marker-59621"></A><A NAME="30906"></A>Ufuncs </H1>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36127"></A>What are Ufuncs?</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-36128"></A>The operations on arrays that were mentioned in the previous section (element-wise addition, multiplication, etc.) all share some features -- they all follow similar rules for broadcasting, coercion and &quot;element-wise operation&quot;.  Just like standard addition is available in Python through the add function in the operator module, array operations are available through callable objects as well.  Thus, the following objects are available in the Numeric module:</P>
<TABLE>
<CAPTION>
<H6 CLASS="TableTitle">
<A NAME="pgfId-36131"></A>Universal Functions, or <EM CLASS="Code">
ufunc</EM>
s. The operators which invoke them when applied to arrays are indicated in parentheses. The entries in slanted typeface refer to unary ufuncs, while the others refer to binary ufuncs.</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36139"></A><EM CLASS="Code">
add (+)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36141"></A><EM CLASS="Code">
subtract (-)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36143"></A><EM CLASS="Code">
multiply (*)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36145"></A><EM CLASS="Code">
divide (/), divide_safe</EM>
<A NAME="marker-86559"></A><A NAME="marker-86560"></A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36147"></A><EM CLASS="Code">
remainder (%)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36149"></A><EM CLASS="Code">
power (**)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36151"></A><EM CLASS="Emphasis">
arccos</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36153"></A><EM CLASS="Emphasis">
arccosh</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36155"></A><EM CLASS="Emphasis">
arcsin</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36157"></A><EM CLASS="Emphasis">
arcsinh</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36159"></A><EM CLASS="Emphasis">
arctan</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36161"></A><EM CLASS="Emphasis">
arctanh</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36163"></A><EM CLASS="Emphasis">
cos</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36165"></A><EM CLASS="Emphasis">
cosh</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36167"></A><EM CLASS="Emphasis">
tan</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36169"></A><EM CLASS="Emphasis">
tanh</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36171"></A><EM CLASS="Emphasis">
log10</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36173"></A><EM CLASS="Emphasis">
sin</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36175"></A><EM CLASS="Emphasis">
sinh</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36177"></A><EM CLASS="Emphasis">
sqrt</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-86467"></A>absolute</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-86469"></A>fabs</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-86471"></A>floor</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-86473"></A>ceil</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-86484"></A>fmod</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-86486"></A>exp</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-86488"></A>log</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-86490"></A>conjugate</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36179"></A><EM CLASS="Emphasis">
maximum</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36181"></A><EM CLASS="Emphasis">
minimum</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36183"></A><EM CLASS="Code">
</EM>
&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36185"></A><EM CLASS="Code">
</EM>
&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36187"></A><EM CLASS="Emphasis">
greater (&gt;)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36189"></A><EM CLASS="Code">
equal (==)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36191"></A><EM CLASS="Code">
not_equal  (!=)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36193"></A><EM CLASS="Code">
</EM>
&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36195"></A><EM CLASS="Code">
greater_equal (&gt;=)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36197"></A><EM CLASS="Code">
less (&lt;)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36199"></A><EM CLASS="Code">
less_equal (&lt;=)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36201"></A><EM CLASS="Code">
</EM>
&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36203"></A><EM CLASS="Code">
logical_or (or)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36205"></A><EM CLASS="Code">
logical_xor</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36207"></A><EM CLASS="Code">
logical_not (not)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-86543"></A><EM CLASS="Code">
logical_and (and)</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36211"></A><EM CLASS="Code">
bitwise_or (|)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36213"></A><EM CLASS="Code">
bitwise_xor (^)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36215"></A><EM CLASS="Code">
bitwise_not (&#126;)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36217"></A><EM CLASS="Code">
bitwise_and (&amp;)</EM>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-36218"></A>All of these ufuncs can be used as functions.  For example, to use <EM CLASS="Code">
add</EM>
, which is a binary ufunc (i.e. it takes two arguments), one can do either of:</P>
<P CLASS="Python">
<A NAME="pgfId-36219"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = arange(10)<BR>
</EM>
&gt;&gt;&gt; <EM CLASS="CodeInput">
print add(a,a)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36220"></A>[ 0  2  4  6  8 10 12 14 16 18]</P>
<P CLASS="Python">
<A NAME="pgfId-36221"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a + a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36222"></A>[ 0  2  4  6  8 10 12 14 16 18]</P>
<P CLASS="Body">
<A NAME="pgfId-36223"></A>In other words, the + operator on arrays performs exactly the same thing as the <EM CLASS="Code">
add</EM>
 ufunc when operated on arrays.  For a unary ufunc such as <EM CLASS="Code">
sin</EM>
, one can do, e.g.:</P>
<P CLASS="Python">
<A NAME="pgfId-36224"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = arange(10)<BR>
</EM>
&gt;&gt;&gt; <EM CLASS="CodeInput">
print sin(a)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36225"></A>[ 0.          0.84147098  0.90929743  0.14112001 -0.7568025  -0.95892427</P>
<P CLASS="Python">
<A NAME="pgfId-36226"></A>      -0.2794155   0.6569866   0.98935825  0.41211849]</P>
<P CLASS="Body">
<A NAME="pgfId-36227"></A>Unary ufuncs return arrays with the same shape as their arguments, but with the contents corresponding to the corresponding mathematical function applied to each element (sin(0)=0, sin(1)=0.84147098, etc.).  </P>
<P CLASS="Body">
<A NAME="pgfId-36228"></A>There are three additional features of ufuncs which make them different from standard Python functions.  They can operate on any Python sequence in addition to arrays; they can take an &quot;output&quot; argument; they have attributes which are themselves callable with arrays and sequences. Each of these will be described in turn.</P>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-36229"></A>Ufuncs can operate on any Python sequence</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-36230"></A>Ufuncs have so far been described as callable objects which take either one or two arrays as arguments (depending on whether they are unary or binary).  In fact, any Python sequence which can be the input to the array() constructor can be used.  The return value from ufuncs is always an array.  Thus:</P>
<P CLASS="Python">
<A NAME="pgfId-36231"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
add([1,2,3,4], (1,2,3,4))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36232"></A>array([2, 4, 6, 8])</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-36233"></A>Ufuncs can take output arguments</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-36234"></A>In many computations with large sets of numbers, arrays are often used only once.  For example, a computation on a large set of numbers could involve the following step</P>
<P CLASS="Python">
<A NAME="pgfId-36235"></A>    dataset = dataset * 1.20</P>
<P CLASS="Body">
<A NAME="pgfId-36236"></A>This operation as written needs to create a temporary array to store the results of the computation, and then eventually free the memory used by the original dataset array (provided there are no other references to the data it contains).  It is more efficient, both in terms of memory and computation time, to do an &quot;in-place&quot; operation.  This can be done by specifying an existing array as the place to store the result of the ufunc.  In this example, one can write:</P>
<P CLASS="Python">
<A NAME="pgfId-36237"></A>    multiply(dataset, 1.20, dataset)</P>
<P CLASS="Body">
<A NAME="pgfId-36238"></A>This is not a step to take lightly, however.  For example, the &quot;big and slow&quot; version (<EM CLASS="Code">
dataset = dataset * 1.20</EM>
) and the &quot;small and fast&quot; version above will yield different results in two cases:  </P>
<UL>
<LI CLASS="BulletLev2">
<A NAME="pgfId-36239"></A>If the typecode of the target array is not that which would normally be computed, the operation will fail and raise a TypeError exception.</LI>
<LI CLASS="BulletLev2">
<A NAME="pgfId-36240"></A>If the target array corresponds to a different &quot;view&quot; on the same data as either of the source arrays, inconsistencies will result.  For example, </LI>
</UL>
<P CLASS="Python">
<A NAME="pgfId-36241"></A>          &gt;&gt;&gt; <EM CLASS="CodeInput">
a = arange(5, typecode=Float64)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36242"></A>          &gt;&gt;&gt; <EM CLASS="CodeInput">
print a[::-1] * 1.2</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36243"></A>          [ 4.8  3.6  2.4  1.2  0. ]</P>
<P CLASS="Python">
<A NAME="pgfId-36244"></A>          &gt;&gt;&gt; <EM CLASS="CodeInput">
multiply(a[::-1], 1.2, a)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36245"></A>          array([ 4.8 ,  3.6 ,  2.4 ,  4.32,  5.76])</P>
<P CLASS="Python">
<A NAME="pgfId-36246"></A>          &gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36247"></A>          [ 4.8   3.6   2.4   4.32  5.76]</P>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-36248"></A>This is because the ufunc does not know which arrays share which data, and in this case the overwriting of the data contents follows a different path through the shared data space of the two arrays, thus resulting in strangely distorted data.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-36249"></A><A NAME="87042"></A>Ufuncs have special methods</H6>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-36250"></A>The reduce ufunc method</H6>
<P CLASS="Body">
<A NAME="pgfId-61696"></A>If you don't know about the <EM CLASS="Code">
reduce</EM>
 command in Python, review section 5.1.1 of the Python Tutorial (<EM CLASS="URL">
http://www.python.org/doc/tut/functional.html</EM>
). Briefly, <EM CLASS="Code">
reduce</EM>
 is most often used with two arguments, a callable object (such as a function), and a sequence.  It calls the callable object with the first two elements of the sequence, then with the result of that operation and the third element, and so on, returning at the end the successive &quot;reduction&quot; of the specified callable object over the sequence elements.  Similarly, the <EM CLASS="Code">
reduce</EM>
 method of ufuncs is called with a sequence as an argument, and performs the reduction of that ufunc on the sequence. As an example, adding all of the elements in a rank-1 array can be done with:</P>
<P CLASS="Python">
<A NAME="pgfId-36251"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = array([1,2,3,4])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36252"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print add.reduce(a)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36253"></A>10 </P>
<P CLASS="Body">
<A NAME="pgfId-36254"></A>When applied to arrays which are of rank greater than one, the reduction proceeds by default along the first axis:</P>
<P CLASS="Python">
<A NAME="pgfId-36255"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
b = array([[1,2,3,4],[6,7,8,9]])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36256"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print b</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36257"></A>[[1 2 3 4]</P>
<P CLASS="Python">
<A NAME="pgfId-36258"></A> [6 7 8 9]]</P>
<P CLASS="Python">
<A NAME="pgfId-36259"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print add.reduce(b)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36260"></A>[ 7  9 11 13]</P>
<P CLASS="Body">
<A NAME="pgfId-36261"></A>A different axis of reduction can be specified with a second integer argument:</P>
<P CLASS="Python">
<A NAME="pgfId-36262"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print b</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36263"></A>[[1 2 3 4]</P>
<P CLASS="Python">
<A NAME="pgfId-36264"></A> [6 7 8 9]]</P>
<P CLASS="Python">
<A NAME="pgfId-36265"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print add.reduce(b, 1)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36266"></A>[10 30] </P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-61704"></A>The accumulate ufunc method</H6>
<P CLASS="Body">
<A NAME="pgfId-36267"></A>The <EM CLASS="Code">
accumulate</EM>
 ufunc method is simular to <EM CLASS="Code">
reduce</EM>
, except that it returns an array containing the intermediate results of the reduction: </P>
<P CLASS="Python">
<A NAME="pgfId-36268"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = arange(10)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36269"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36270"></A>[0 1 2 3 4 5 6 7 8 9]</P>
<P CLASS="Python">
<A NAME="pgfId-36271"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print add.accumulate(a)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36272"></A>[ 0  1  3  6 10 15 21 28 36 45]	# 0, 0+1, 0+1+2, 0+1+2+3, ... 0+...+9</P>
<P CLASS="Python">
<A NAME="pgfId-36273"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print add.reduce(a)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36274"></A>45	# same as add.accumulate(...)[-1]</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-61715"></A>The outer ufunc method</H6>
<P CLASS="Body">
<A NAME="pgfId-61718"></A>The third ufunc method is <EM CLASS="Code">
outer</EM>
, which takes two arrays as arguments and returns the &quot;outer ufunc&quot; of the two arguments. Thus the <EM CLASS="Code">
outer</EM>
 method of the <EM CLASS="Code">
multiply</EM>
 ufunc, results in the outer product. The outer method is only supported for binary methods. </P>
<P CLASS="Python">
<A NAME="pgfId-36276"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36277"></A>[0 1 2 3 4]</P>
<P CLASS="Python">
<A NAME="pgfId-36278"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print b</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36279"></A>[0 1 2 3]</P>
<P CLASS="Python">
<A NAME="pgfId-36280"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print add.outer(a,b)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36281"></A>[[0 1 2 3]</P>
<P CLASS="Python">
<A NAME="pgfId-36282"></A> [1 2 3 4]</P>
<P CLASS="Python">
<A NAME="pgfId-36283"></A> [2 3 4 5]</P>
<P CLASS="Python">
<A NAME="pgfId-36284"></A> [3 4 5 6]</P>
<P CLASS="Python">
<A NAME="pgfId-36285"></A> [4 5 6 7]]</P>
<P CLASS="Python">
<A NAME="pgfId-36286"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print multiply.outer(b,a)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36287"></A>[[ 0  0  0  0  0]</P>
<P CLASS="Python">
<A NAME="pgfId-36288"></A> [ 0  1  2  3  4]</P>
<P CLASS="Python">
<A NAME="pgfId-36289"></A> [ 0  2  4  6  8]</P>
<P CLASS="Python">
<A NAME="pgfId-36290"></A> [ 0  3  6  9 12]]</P>
<P CLASS="Python">
<A NAME="pgfId-36291"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print power.outer(a,b)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36292"></A>[[ 1  0  0  0]</P>
<P CLASS="Python">
<A NAME="pgfId-36293"></A> [ 1  1  1  1]</P>
<P CLASS="Python">
<A NAME="pgfId-36294"></A> [ 1  2  4  8]</P>
<P CLASS="Python">
<A NAME="pgfId-36295"></A> [ 1  3  9 27]</P>
<P CLASS="Python">
<A NAME="pgfId-36296"></A> [ 1  4 16 64]]</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-61737"></A>The reduceat ufunc method</H6>
<P CLASS="Body">
<A NAME="pgfId-61738"></A>The final ufunc method is the <EM CLASS="Code">
reduceat</EM>
 method, which I'd love to explain it, but I don't understand it (XXX).</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-61739"></A>Ufuncs always return new arrays</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-36299"></A>Except when the 'output' argument are used as described above, ufuncs always return new arrays which do not share any data with the input array.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36300"></A>Which are the Ufuncs?</H6>
<P CLASS="Body">
<A NAME="pgfId-36301"></A>Table 1 lists all the ufuncs. We will first discuss the mathematical ufuncs, which perform operations very similar to the functions in the <EM CLASS="Code">
math</EM>
 and <EM CLASS="Code">
cmath</EM>
 modules, albeit elementwise, on arrays.  These come in two forms, unary and binary:</P>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-36302"></A><A NAME="marker-59625"></A>Unary Mathematical Ufuncs (take only one argument) </H6>
<P CLASS="Body">
<A NAME="pgfId-36303"></A>The following ufuncs apply the predictable functions on their single array arguments, one element at a time: <EM CLASS="Code">
arccos</EM>
, <EM CLASS="Code">
arccosh</EM>
, <EM CLASS="Code">
 arcsin</EM>
, <EM CLASS="Code">
 arcsinh</EM>
, <EM CLASS="Code">
 arctan</EM>
, <EM CLASS="Code">
 arctanh</EM>
, <EM CLASS="Code">
 cos</EM>
, <EM CLASS="Code">
 cosh</EM>
, <EM CLASS="Code">
 exp</EM>
, <EM CLASS="Code">
 log</EM>
, <EM CLASS="Code">
 log10</EM>
, <EM CLASS="Code">
 sin</EM>
, <EM CLASS="Code">
 sinh</EM>
, <EM CLASS="Code">
 sqrt</EM>
, <EM CLASS="Code">
 tan</EM>
, <EM CLASS="Code">
 tanh</EM>
.</P>
<P CLASS="Body">
<A NAME="pgfId-36304"></A>As an example:</P>
<P CLASS="Python">
<A NAME="pgfId-36305"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36306"></A>[0 1 2 3 4]</P>
<P CLASS="Python">
<A NAME="pgfId-36307"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print cos(x)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36308"></A>[ 1.          0.54030231 -0.41614684 -0.9899925  -0.65364362]</P>
<P CLASS="Python">
<A NAME="pgfId-36309"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print arccos(cos(x))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36310"></A>[ 0.          1.          2.          3.          2.28318531]</P>
<P CLASS="Python">
<A NAME="pgfId-36311"></A># not a bug, but wraparound: 2*pi%4 is 2.28318531</P>
<P CLASS="Body">
<A NAME="pgfId-36312"></A>The <EM CLASS="Code">
conjugate</EM>
 ufunc takes an array of complex numbers and returns the array with entries which are the complex conjugates of the entries in the input array.  If it is called with real numbers, a copy of the array is returned unchanged.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-36313"></A>Binary Mathematical Ufuncs</H6>
<P CLASS="Body">
<A NAME="pgfId-36314"></A>These ufuncs take two arrays as arguments, and perform the specified mathematical operation on them, one pair of elements at a time: <EM CLASS="Code">
add</EM>
, <EM CLASS="Code">
subtract</EM>
, <EM CLASS="Code">
multiply</EM>
, <EM CLASS="Code">
divide</EM>
, <EM CLASS="Code">
remainder</EM>
, <EM CLASS="Code">
power</EM>
. </P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-36315"></A><A NAME="marker-59626"></A><A NAME="93991"></A>Logical Ufuncs</H6>
<P CLASS="Body">
<A NAME="pgfId-36316"></A>The ``logical'' ufuncs also perform their operations on arrays in elementwise fashion, just like the ``mathematical'' ones.</P>
<P CLASS="Body">
<A NAME="pgfId-36317"></A>Two are special (<EM CLASS="Code">
maximum</EM>
 and <EM CLASS="Code">
miminum</EM>
) in that they return arrays with entries taken from their input arrays:</P>
<P CLASS="Python">
<A NAME="pgfId-36318"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36319"></A>[0 1 2 3 4]</P>
<P CLASS="Python">
<A NAME="pgfId-36320"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print y</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36321"></A>[ 2.   2.5  3.   3.5  4. ]</P>
<P CLASS="Python">
<A NAME="pgfId-36322"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print maximum(x, y)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36323"></A>[ 2.   2.5  3.   3.5  4. ]</P>
<P CLASS="Python">
<A NAME="pgfId-36324"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print minimum(x, y)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36325"></A>[ 0.  1.  2.  3.  4.]</P>
<P CLASS="Body">
<A NAME="pgfId-36326"></A>The others all return arrays of 0's or 1's: <EM CLASS="Code">
logical_and</EM>
, <EM CLASS="Code">
logical_or</EM>
, <EM CLASS="Code">
logical_xor</EM>
, <EM CLASS="Code">
logical_not</EM>
, <EM CLASS="Code">
bitwise_and</EM>
, <EM CLASS="Code">
bitwise_or</EM>
, <EM CLASS="Code">
bitwise_xor</EM>
, <EM CLASS="Code">
bitwise_not</EM>
.</P>
<P CLASS="Body">
<A NAME="pgfId-36327"></A>These are fairly self-explanatory, especially with the associated symbols from the standard Python version of the same operations in Table 1 above.  The <EM CLASS="Code">
logical_*</EM>
 ufuncs perform their operations (and, or, etc.) using the truth value of the elements in the array (equality to 0 for numbers and the standard truth test for PyObject arrays).  The <EM CLASS="Code">
bitwise_*</EM>
 ufuncs, on the other hand, can be used only with integer arrays (of any word size), and will return integer arrays of the larger bit size of the two input arrays:</P>
<P CLASS="Python">
<A NAME="pgfId-36328"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36329"></A>array([7, 7, 0],'1')</P>
<P CLASS="Python">
<A NAME="pgfId-36330"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
y</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36331"></A>array([4, 5, 6])</P>
<P CLASS="Python">
<A NAME="pgfId-36332"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
bitwise_and(x,y)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36333"></A>array([4, 5, 0],'i')</P>
<P CLASS="Body">
<A NAME="pgfId-36334"></A>We've already discussed how to find out about the contents of arrays based on the indices in the arrays - that's what the various slice mechanisms are for. Often, especially when dealing with the result of computations or data analysis, one needs to ``pick out'' parts of matrices based on the content of those matrices. For example, it might be useful to find out which elements of an array are negative, and which are positive. The comparison ufuncs are designed for just this type of operation. Assume an array with various positive and negative numbers in it (for the sake of the example we'll generate it from scratch): </P>
<P CLASS="Python">
<A NAME="pgfId-36335"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36336"></A>[[ 0  1  2  3  4]</P>
<P CLASS="Python">
<A NAME="pgfId-36337"></A> [ 5  6  7  8  9]</P>
<P CLASS="Python">
<A NAME="pgfId-36338"></A> [10 11 12 13 14]</P>
<P CLASS="Python">
<A NAME="pgfId-36339"></A> [15 16 17 18 19]</P>
<P CLASS="Python">
<A NAME="pgfId-36340"></A> [20 21 22 23 24]]</P>
<P CLASS="Python">
<A NAME="pgfId-36341"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
b = sin(a)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36342"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print b</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36343"></A>[[ 0.          0.84147098  0.90929743  0.14112001 -0.7568025 ]</P>
<P CLASS="Python">
<A NAME="pgfId-36344"></A> [-0.95892427 -0.2794155   0.6569866   0.98935825  0.41211849]</P>
<P CLASS="Python">
<A NAME="pgfId-36345"></A> [-0.54402111 -0.99999021 -0.53657292  0.42016704  0.99060736]</P>
<P CLASS="Python">
<A NAME="pgfId-36346"></A> [ 0.65028784 -0.28790332 -0.96139749 -0.75098725  0.14987721]</P>
<P CLASS="Python">
<A NAME="pgfId-36347"></A> [ 0.91294525  0.83665564 -0.00885131 -0.8462204  -0.90557836]]</P>
<P CLASS="Python">
<A NAME="pgfId-36355"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
view(greater(greeceBW, .3))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36356"></A><EM CLASS="Emphasis">
# shows a binary image with white where the pixel value was greater than .3</EM>
</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-86369"></A>Comparisons</H6>
<P CLASS="Body">
<A NAME="pgfId-86370"></A><EM CLASS="Code">
The comparison functions equal</EM>
, <EM CLASS="Code">
not_equal</EM>
, <EM CLASS="Code">
greater</EM>
, <EM CLASS="Code">
greater_equal</EM>
, <EM CLASS="Code">
less</EM>
, and <EM CLASS="Code">
less_equal</EM>
 are invoked by the operators ==, !=, &gt;, &gt;=, &lt;, and &lt;= respectively, but they can also be called directly as functions. Continuing with the preceding example, </P>
<P CLASS="Python">
<A NAME="pgfId-86389"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print less_equal(b, 0)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-86390"></A>[[1 0 0 0 1]</P>
<P CLASS="Python">
<A NAME="pgfId-86391"></A> [1 1 0 0 0]</P>
<P CLASS="Python">
<A NAME="pgfId-86392"></A> [1 1 1 0 0]</P>
<P CLASS="Python">
<A NAME="pgfId-86393"></A> [0 1 1 1 0]</P>
<P CLASS="Python">
<A NAME="pgfId-86394"></A> [0 0 1 1 1]]</P>
<P CLASS="Body">
<A NAME="pgfId-86395"></A>This last example has 1's where the corresponding elements are less than or equal to 0, and 0's everywhere else.</P>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-86430"></A><A NAME="91621"></A>The operators and the comparison functions are not exactly equivalent</H6>
<P CLASS="Body">
<A NAME="pgfId-86410"></A>To compare an array a with an object b, if b can be converted to an array, the result of the comparison is returned. Otherwise, zero is returned. In particular one can compare arrays of type object. This means that comparing a list and comparing an array can return quite different answers. Since the functional forms such as <EM CLASS="Code">
equal</EM>
 will try to make arrays from their arguments, using equal can result in a different result than using ==.</P>
<P CLASS="Python">
<A NAME="pgfId-86416"></A>&gt;&gt;&gt; from Numeric import *</P>
<P CLASS="Python">
<A NAME="pgfId-86417"></A>&gt;&gt;&gt; x=[1,None,2]</P>
<P CLASS="Python">
<A NAME="pgfId-86418"></A>&gt;&gt;&gt; print x == None</P>
<P CLASS="Python">
<A NAME="pgfId-86419"></A>0</P>
<P CLASS="Python">
<A NAME="pgfId-86420"></A>&gt;&gt;&gt; print equal(x,None)</P>
<P CLASS="Python">
<A NAME="pgfId-86421"></A>[0 1 0]</P>
<P CLASS="Python">
<A NAME="pgfId-86411"></A>&nbsp;</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-36357"></A><A NAME="marker-59630"></A>Ufunc shorthands</H6>
<P CLASS="Body">
<A NAME="pgfId-36358"></A><EM CLASS="Code">
Numeric</EM>
 defines a few functions which correspond to often-used uses of ufuncs: for example, <EM CLASS="Code">
add.reduce()</EM>
 is synonymous with the <EM CLASS="Code">
sum()</EM>
 utility function: </P>
<P CLASS="Python">
<A NAME="pgfId-36359"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = arange(5)	</EM>
<EM CLASS="Emphasis">
# [0 1 2 3 4]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36360"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print sum(a)	</EM>
<EM CLASS="Emphasis">
# 0 + 1 + 2 + 3 + 4</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36361"></A>10</P>
<P CLASS="Body">
<A NAME="pgfId-36362"></A>Similarly, <EM CLASS="Code">
cumsum</EM>
 is equivalent to <EM CLASS="Code">
add.accumulate</EM>
 (for ``cumulative sum``), <EM CLASS="Code">
product</EM>
 to <EM CLASS="Code">
multiply.reduce</EM>
, and <EM CLASS="Code">
cumproduct</EM>
 to <EM CLASS="Code">
multiply.accumulate</EM>
.</P>
<P CLASS="Body">
<A NAME="pgfId-36363"></A>Additional ``utility'' functions which are often useful are <EM CLASS="Code">
alltrue</EM>
 and <EM CLASS="Code">
sometrue</EM>
, which are defined as <EM CLASS="Code">
logical_and.reduce</EM>
 and <EM CLASS="Code">
logical_or.reduce</EM>
 respectively:</P>
<P CLASS="Python">
<A NAME="pgfId-36364"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = array([0,1,2,3,4])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36365"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print greater(a,0)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36366"></A>[0 1 1 1 1]</P>
<P CLASS="Python">
<A NAME="pgfId-36367"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
alltrue(greater(a,0))	</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36368"></A>0</P>
<P CLASS="Python">
<A NAME="pgfId-36369"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
sometrue(greater(a,0))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36370"></A>1</P>
</DIV>
</DIV>
<P><A HREF="numpy.html">Go to Main</A>      <A HREF="numpy-6.html">Go to Previous</A>       <A HREF="numpy-8.html">Go to Next</A></P>
</BODY>
</HTML>
