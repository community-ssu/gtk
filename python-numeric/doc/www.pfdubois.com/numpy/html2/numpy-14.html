<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 6.0/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="numpy.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE> 13.	 C API Reference</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">
<H1 CLASS="Chapter">
<A NAME="pgfId-57398"></A>13.	 <A NAME="36241"></A>C API Reference</H1>
<P CLASS="ChapterDescription">
<A NAME="pgfId-57399"></A>This chapter describes the API for ArrayObjects and Ufuncs.</P>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-25107"></A>ArrayObject C Structure and API</H6>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-57404"></A>Structures</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-32745"></A>The <A NAME="marker-59742"></A>PyArrayObject is, like all Python types, a kind of PyObject. Its definition is:</P>
<P CLASS="C-Code">
<A NAME="pgfId-32746"></A>typedef struct { </P>
<P CLASS="C-Code">
<A NAME="pgfId-32747"></A>  PyObject_HEAD </P>
<P CLASS="C-Code">
<A NAME="pgfId-32748"></A>  char *data; </P>
<P CLASS="C-Code">
<A NAME="pgfId-25145"></A>  int nd; </P>
<P CLASS="C-Code">
<A NAME="pgfId-25147"></A>  int *dimensions, *strides; </P>
<P CLASS="C-Code">
<A NAME="pgfId-25149"></A>  PyObject *base; </P>
<P CLASS="C-Code">
<A NAME="pgfId-25151"></A>  PyArray_Descr *descr; </P>
<P CLASS="C-Code">
<A NAME="pgfId-25153"></A>  int flags; </P>
<P CLASS="C-Code">
<A NAME="pgfId-25155"></A>} PyArrayObject; </P>
<P CLASS="Body">
<A NAME="pgfId-25137"></A>Where <EM CLASS="Code">
PyObject_HEAD</EM>
 is the standard <EM CLASS="Code">
PyObject</EM>
 header, and the other fields are:</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-32763"></A><EM CLASS="Code">
char</EM>
 *<EM CLASS="Code">
data</EM>
</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-32764"></A>A pointer to the first data element of the array.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-25119"></A><EM CLASS="Code">
int nd</EM>
</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-25120"></A>The number of dimensions in the array.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-25121"></A><EM CLASS="Code">
int</EM>
 *<EM CLASS="Code">
dimensions</EM>
</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-25122"></A>A pointer to an array of <EM CLASS="Code">
nd</EM>
 integers, describing the number of elements along each dimension. The sizes are in the conventional order, so that for any array <EM CLASS="Code">
a</EM>
, <BR>
<EM CLASS="Code">
a.shape==(dimensions[0], dimensions[1], ..., dimensions[nd-1])</EM>
.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-25123"></A><EM CLASS="Code">
int</EM>
 *<EM CLASS="Code">
strides</EM>
</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-25124"></A>A pointer to an array of <EM CLASS="Code">
nd</EM>
 integers, describing the address offset between two successive data elements along each dimension. Note that strides can also be negative!  Each number gives the number of bytes to add to a pointer to get to the next element in that dimension. For example, if <EM CLASS="Code">
myptr</EM>
 currently points to an element in a rank-5 array at indices <EM CLASS="Code">
1,0,5,3,2</EM>
 and you want it to point to element <EM CLASS="Code">
1,0,5,4,2</EM>
 then you should add <EM CLASS="Code">
strides[3]</EM>
 to the pointer: <EM CLASS="Code">
myptr += strides[3]</EM>
. This works even if (and is especially useful when) the array is not contiguous in memory.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-32771"></A><EM CLASS="Code">
PyObject</EM>
 *<EM CLASS="Code">
base</EM>
</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-32784"></A>Used internally in arrays that are created as slices of other arrays. Since the new array shares its data area with the old one, the original array's reference count is incremented.  When the subarray is garbage collected, the base array's reference count is decremented.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-32775"></A><EM CLASS="Code">
PyArray_Desc</EM>
 *<EM CLASS="Code">
descr</EM>
</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-32830"></A>See below.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-32831"></A><EM CLASS="Code">
int flags</EM>
</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-32832"></A>A bitfield indicating whether the array:</P>
<UL>
<LI CLASS="BulletLev3">
<A NAME="pgfId-32835"></A>is contiguous (rightmost bit)</LI>
<LI CLASS="BulletLev3">
<A NAME="pgfId-32839"></A>owns the dimensions (next bit to the left) (???)</LI>
<LI CLASS="BulletLev3">
<A NAME="pgfId-32840"></A>owns the strides (next bit to the left) (???)</LI>
<LI CLASS="BulletLev3">
<A NAME="pgfId-32841"></A>owns the data area</LI>
</UL>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-32842"></A>The ownership bits are used by NumPy internally to manage memory allocation and deallocation. They can be false if the array is the result of e.g. a slicing operation on an existing array.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-55326"></A>PyArrayDescr *descr</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-55329"></A>a pointer to a data structure that describes the array and has some handy functions. The slots in this structure are:</P>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-32848"></A>PyArray_VectorUnaryFunc *cast[]</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-32885"></A>an array of function pointers which will cast this arraytype to each of the other data types.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-32852"></A>PyArray_GetItemFunc *getitem </H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-32853"></A>a pointer to a function which returns a PyObject of the appropriate type given a (char) pointer to the data to get.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-32856"></A>PyArray_SetItemFunc *setitem</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-32857"></A>a pointer to a function which sets the element pointed to by the second argument to converted Python Ojbect given as the first argument. </P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-32860"></A>int type_num</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-32900"></A>A number indicating the datatype of the array (i.e. a <EM CLASS="Code">
PyArray_XXXX</EM>
)</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-32863"></A>char *one</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-32905"></A>A pointer to a representation of one for this datatype.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-32866"></A>char *zero </H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-32910"></A>A pointer to a representation of zero for this datatype (especially useful for PyArray_OBJECT types)</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-32870"></A>char type</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-32917"></A>A character representing the array's typecode (one of <EM CLASS="Code">
'cb1silfdFDO'</EM>
). </P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-34282"></A>The ArrayObject API</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-34283"></A>In the following <EM CLASS="Code">
op</EM>
 is a pointer to a <EM CLASS="Code">
PyObject</EM>
 and <EM CLASS="Code">
arp</EM>
 is a pointer to a <EM CLASS="Code">
PyArrayObject</EM>
. Routines which return <EM CLASS="Code">
PyObject</EM>
 * return <EM CLASS="Code">
NULL</EM>
 to indicate failure (and follow the standard exception-setting mechanism). Functions followed by a dagger (|) are functions which return PyObjects whose reference count has been increased by one (new references). See the Python Extending/Embedding manual for details on reference-count management.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34284"></A>int <A NAME="marker-59743"></A>PyArray_Check(op) </H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34285"></A>returns <EM CLASS="Code">
1</EM>
 if <EM CLASS="Code">
op</EM>
 is a <EM CLASS="Code">
PyArrayObject</EM>
 or <EM CLASS="Code">
0</EM>
 if it is not.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34286"></A>int <A NAME="marker-59744"></A>PyArray_SetNumericOps(d) </H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34287"></A>internally used by <EM CLASS="Code">
umath</EM>
 to setup some of its functions.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34288"></A>int <A NAME="marker-59745"></A>PyArray_INCREF(op)</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34289"></A>Used for arrays of python objects (<EM CLASS="Code">
PyArray_OBJECT</EM>
) to increment the reference count of every python object in the array <EM CLASS="Code">
op</EM>
. User code does not typically need to call this.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34290"></A>int <A NAME="marker-59746"></A>PyArray_XDECREF(op)</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34291"></A>Used for arrays of python objects (<EM CLASS="Code">
PyArray_OBJECT</EM>
) to decrement the reference count of every python object in the array <EM CLASS="Code">
op</EM>
.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34292"></A><A NAME="marker-59747"></A>PyArrayError</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34293"></A>Exports the array error object. I don't know its use.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34294"></A>void <A NAME="marker-59748"></A>PyArray_SetStringFunction(op,repr)</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34295"></A>Sets the function for representation of all arrays to <EM CLASS="Code">
op </EM>
which should be a callable <EM CLASS="Code">
PyObject</EM>
. If <EM CLASS="Code">
repr</EM>
 is non-zero then the function corresponding to the <EM CLASS="Code">
repr</EM>
 string representationis set, otherwise, that for the <EM CLASS="Code">
str</EM>
 string representation is set.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34296"></A>PyArray_Descr <A NAME="marker-59749"></A>PyArray_DescrFromType(type)</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34297"></A>returns a <EM CLASS="Code">
PyArray_Descr</EM>
 structure for the datatype given by <EM CLASS="Code">
type</EM>
. The input type can be either the enumerated types (<EM CLASS="Code">
PyArray_Float</EM>
, etc.) or a character (<EM CLASS="Code">
'cb1silfdFDO'</EM>
).</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-55586"></A>PyObject *<A NAME="marker-59750"></A>PyArray_Cast(arp, type) |</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34298"></A>returns a pointer to a <EM CLASS="Code">
PyArrayObject</EM>
 that is <EM CLASS="Code">
arp</EM>
 cast to the array type specified by <EM CLASS="Code">
type</EM>
. It is just a wrapper around the function defined in <EM CLASS="Code">
arp-&gt;descr-&gt;cast</EM>
 that handles non-contiguous arrays and arrays of Python objects appropriately.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34299"></A>int <A NAME="marker-59751"></A>PyArray_CanCastSafely(fromtype,totype)</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34300"></A>returns <EM CLASS="Code">
1</EM>
 if the array with type <EM CLASS="Code">
fromtype</EM>
 can be cast to an array of type <EM CLASS="Code">
totype</EM>
 without loss of accuracy, otherwise it returns <EM CLASS="Code">
0</EM>
. It allows conversion of <EM CLASS="Code">
long</EM>
s to <EM CLASS="Code">
int</EM>
s which is not safe on 64-bit machines. The inputs <EM CLASS="Code">
fromtype</EM>
 and <EM CLASS="Code">
totype</EM>
 are the enumerated array types (e.g. <EM CLASS="Code">
PyArray_SBYTE</EM>
).</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34301"></A>int <A NAME="marker-59752"></A>PyArray_ObjectType(op, min_type)</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34302"></A>returns the typecode to use for a call to an array creation function given an input python sequence object <EM CLASS="Code">
op</EM>
 and a minimum type value, <EM CLASS="Code">
min_type</EM>
. It looks at the datatypes used in <EM CLASS="Code">
op</EM>
, compares this with <EM CLASS="Code">
min_type</EM>
 and returns a consistent type value that can be used to store all of the data in <EM CLASS="Code">
op</EM>
 and satisfying at the minimum the precision of <EM CLASS="Code">
min_type</EM>
.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34303"></A>int <A NAME="marker-59753"></A>_PyArray_multiply_list(list,n) </H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34304"></A>is a utility routine to multiply an array of <EM CLASS="Code">
n</EM>
 integers pointed to by <EM CLASS="Code">
list</EM>
.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34305"></A>int <A NAME="marker-59754"></A>PyArray_Size(op) </H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34306"></A>is a useful function for returning the total number of elements in <EM CLASS="Code">
op</EM>
 if <EM CLASS="Code">
op</EM>
 is a <EM CLASS="Code">
PyArrayObject</EM>
, <EM CLASS="Code">
0</EM>
 otherwise.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34307"></A>PyObject *<A NAME="marker-59755"></A>PyArray_FromDims(nd,dims,type) |</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34308"></A>returns a pointer to a newly constructed <EM CLASS="Code">
PyArrayObject</EM>
 (returned as a <EM CLASS="Code">
PyObject</EM>
) given the number of dimensions in <EM CLASS="Code">
nd</EM>
, an array <EM CLASS="Code">
dims</EM>
 of <EM CLASS="Code">
nd</EM>
 integers specifying the size of the array, and the enumerated type of the array in <EM CLASS="Code">
type</EM>
.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34309"></A>PyObject *<A NAME="marker-59756"></A>PyArray_FromDimsAndData(nd,dims,type,data) |</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34310"></A>This function should only be used to access global data that will never be freed (like FORTRAN common blocks). It builds a <EM CLASS="Code">
PyArrayObject</EM>
 in the same way as <EM CLASS="Code">
PyArray_FromDims</EM>
 but instead of allocating new memory for the array elements it uses the bytes pointed to by <EM CLASS="Code">
data</EM>
 (a <EM CLASS="Code">
char *</EM>
).</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34311"></A>PyObject *<A NAME="marker-59757"></A>PyArray_ContiguousFromObject(op,type,min_dim,max_dim) |</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34312"></A>returns a contiguous array of type <EM CLASS="Code">
type</EM>
 from the (possibly nested) sequence object <EM CLASS="Code">
op</EM>
. If <EM CLASS="Code">
op</EM>
 is a contiguous <EM CLASS="Code">
PyArrayObject</EM>
 then a reference is made; if <EM CLASS="Code">
op</EM>
 is a non-contiguous then a copy is performed to get a contiguous array; if <EM CLASS="Code">
op</EM>
 is not a <EM CLASS="Code">
PyArrayObject</EM>
 then a new <EM CLASS="Code">
PyArrayObject</EM>
 is created from the sequence object and returned. The two parameters <EM CLASS="Code">
min_dim</EM>
 and <EM CLASS="Code">
max_dim</EM>
 let you specify the expected rank of the input sequence. An error will result if the resulting <EM CLASS="Code">
PyArrayObject</EM>
 does not have rank bounded by these limits. To specify an exact rank requirement set <EM CLASS="Code">
min_dim = max_dim</EM>
. To allow for an arbitrary number of dimensions specify <EM CLASS="Code">
min_dim = max_dim = 0</EM>
.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34315"></A>PyObject *<A NAME="marker-59758"></A>PyArray_CopyFromObject(op,type,min_dim,max_dim) |</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34316"></A>returns a contiguous array similar to <EM CLASS="Code">
PyArray_ContiguousFromObject</EM>
 except that a copy of <EM CLASS="Code">
op</EM>
 is performed even if a shared array could have been used.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34317"></A>PyObject *<A NAME="marker-59759"></A>PyArray_FromObject(op,type,min_dim,max_dim) |</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-55829"></A>returns a reference to <EM CLASS="Code">
op</EM>
 if <EM CLASS="Code">
op</EM>
 is a <EM CLASS="Code">
PyArrayObject</EM>
 and a newly constructed <EM CLASS="Code">
PyArrayObject</EM>
 if <EM CLASS="Code">
op</EM>
 is any other (nested) sequence object. You must use strides to access the elements of this possibly discontiguous array correctly.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-55830"></A>PyObject *<A NAME="marker-59760"></A>PyArray_Return(apr) </H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34320"></A>returns a pointer to <EM CLASS="Code">
apr</EM>
 with some extra code to check for errors and be sure that zero-dimensional arrays are returned as scalars. If a scalar is returned instead of <EM CLASS="Code">
apr</EM>
 then <EM CLASS="Code">
apr</EM>
's reference count is decremented, so it is safe to use this function in the form :<BR>
<EM CLASS="Code">
return PyArray_Return (apr);</EM>
</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34321"></A>PyObject *<A NAME="marker-59761"></A>PyArray_Reshape(apr,op) |</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34322"></A>returns a reference to <EM CLASS="Code">
apr</EM>
 with a new shape specified by <EM CLASS="Code">
op</EM>
 which must be a one dimensional sequence object. One dimension may be specified as unknown by giving a value less than zero, its value will be calculated from the size of <EM CLASS="Code">
apr</EM>
.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34323"></A>PyObject *<A NAME="marker-59762"></A>PyArray_Copy(apr) |</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34324"></A>returns an element-for-element copy of <EM CLASS="Code">
apr</EM>
</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34325"></A>PyObject *<A NAME="marker-59763"></A>PyArray_Take(a,indices,axis) |</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34326"></A>the equivalent of <EM CLASS="Code">
take(a, indices, axis)</EM>
 which is a method defined in the Numeric module that just calls this function. </P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-55910"></A>int <A NAME="marker-59764"></A>PyArray_As1D(*op, char **ptr, int *n, int type)</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-55911"></A>This function replaces <EM CLASS="Code">
op</EM>
 with a pointer to a contiguous 1-D <EM CLASS="Code">
PyArrayObject</EM>
 (using <EM CLASS="Code">
PyArray_ContiguousFromObject</EM>
) and sets as output parameters a pointer to the first byte of the array in <EM CLASS="Code">
ptr</EM>
 and the number of elements in the array in <EM CLASS="Code">
n</EM>
. It returns <EM CLASS="Code">
-1</EM>
 on failure (<EM CLASS="Code">
op</EM>
 is not a 1-D array or sequence object that can be cast to type <EM CLASS="Code">
type</EM>
) and <EM CLASS="Code">
0</EM>
 on success. </P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34329"></A>int <A NAME="marker-59765"></A>PyArray_As2D(*op, char **ptr, int *m, int *n, int type) </H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34330"></A>This function replaces <EM CLASS="Code">
op</EM>
 with a pointer to a contiguous 2-D <EM CLASS="Code">
PyArrayObject</EM>
 (using <EM CLASS="Code">
PyArray_ContiguousFromObject</EM>
). It returns -1 on failure (op is not a 2-D array or nested sequence object that can be cast to type type) and 0 on success. It also sets as output parameters: an array of pointers in <EM CLASS="Code">
ptr</EM>
 which can be used to access the data as a 2-D array so that ptr[i][j] is a pointer to the first byte of element [i,j] in the array; <EM CLASS="Code">
m</EM>
 and <EM CLASS="Code">
n</EM>
 are set to respectively the number of rows and columns of the array. </P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34331"></A>int <A NAME="marker-59766"></A>PyArray_Free(op,ptr) </H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34280"></A>is supposed to free the allocated data structures and decrease object references when using <EM CLASS="Code">
PyArray_As1D</EM>
 and <EM CLASS="Code">
PyArray_As2D</EM>
 but there are suspicions that this code is buggy.</P>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-586"></A>Notes</H6>
<P CLASS="Body">
<A NAME="pgfId-17649"></A>Number formats, overflow issues, NaN/Inf representations, fpectl module, how to deal with 'missing' values.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-587"></A><A NAME="marker-59767"></A>UfuncObject C Structure and API</H6>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-589"></A>C Structure</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-33025"></A>The ufuncobject is a generic function object that can be used to perform fast operations over Numeric Arrays with very useful broadcasting rules and type conversions performed automatically. The ufuncobject and its API make it easy and graceful to add arbitrary functions to Python which operate over Numeric arrays. All of the unary and binary operators currently available in the Numerical extensions (like sin, cos, +, logical_or, etc.) are implemented using this object. The hooks are all in place to make it very easy to add any function that takes one or two (double) arguments and returns a single (double) argument.  It is not difficult to add support routines in order to handle arbitrary functions whose total number of input/output arguments is less than some maximum number (currently 10).</P>
<P CLASS="C-Code">
<A NAME="pgfId-33047"></A>typedef struct { </P>
<P CLASS="C-Code">
<A NAME="pgfId-33049"></A>  PyObject_HEAD </P>
<P CLASS="C-Code">
<A NAME="pgfId-33051"></A>  int *ranks, *canonical_ranks; </P>
<P CLASS="C-Code">
<A NAME="pgfId-33109"></A>  int nin, nout, nargs; </P>
<P CLASS="C-Code">
<A NAME="pgfId-33110"></A>  int identity; </P>
<P CLASS="C-Code">
<A NAME="pgfId-33111"></A>  PyUFuncGenericFunction *functions; </P>
<P CLASS="C-Code">
<A NAME="pgfId-33059"></A>  void **data; </P>
<P CLASS="C-Code">
<A NAME="pgfId-33061"></A>  int ntypes, nranks, attributes; </P>
<P CLASS="C-Code">
<A NAME="pgfId-33063"></A>  char *name, *types; </P>
<P CLASS="C-Code">
<A NAME="pgfId-33065"></A>  int check_return; </P>
<P CLASS="C-Code">
<A NAME="pgfId-33022"></A>} PyUFuncObject;</P>
<P CLASS="Body">
<A NAME="pgfId-33134"></A>where:</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-33140"></A>int *ranks</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-35227"></A>unused.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-35249"></A>int *canonical_ranks</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-35250"></A>unused</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-35251"></A>int nin</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-33145"></A>the number of input arguments to function</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-33147"></A>int nout</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-33148"></A>the number of output arguments for the function</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-33150"></A>int nargs</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-33151"></A>the total number of arguments  <EM CLASS="Code">
= nin + nout</EM>
</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-33153"></A>int identity</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-35255"></A>a flag telling whether the identity for this function is <EM CLASS="Code">
0</EM>
 or <EM CLASS="Code">
1</EM>
 for use in the <EM CLASS="Code">
reduce</EM>
 method for a zero size array input.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-33155"></A>PyUFuncGenericFunction *functions</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-35267"></A>an array of functions that perform the innermost looping over the input and output arrays (I think this is over a single axis). These functions call the underlying math function with the data from the input arguments along this axis and return the outputs of the function into the correct place in the output arrayobject (with appropriate typecasting). These functions are called by the general looping code. There is one function for each of the supported datatypes. Function pointers to do this looping for types <EM CLASS="Code">
'f'</EM>
, <EM CLASS="Code">
'd'</EM>
, <EM CLASS="Code">
'F'</EM>
, and <EM CLASS="Code">
'D'</EM>
, are provided in the C-API for functions that take one or two arguments and return one argument. Each <EM CLASS="Code">
PyUFuncGenericFunction</EM>
 returns <EM CLASS="Code">
void</EM>
 and has the following argument list (in order):</P>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-33157"></A>args</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-35318"></A>an array of pointers to the data for each of the input and output arguments with input arguments first and output arguments immediately following. Each element of <EM CLASS="Code">
args</EM>
 is a <EM CLASS="Code">
char</EM>
 * to the first byte in the corresponding input or output array.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-35344"></A>dimensions</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-35348"></A>a pointer to a single <EM CLASS="Code">
int</EM>
 giving the size of the axis being looped over.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-35351"></A>steps</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-35371"></A>an array of <EM CLASS="Code">
int</EM>
s giving the number of bytes to skip to go to the next element of the array for this loop. There is an entry in the array for each of the input and output arguments, with input arguments first and output arguments immediately following.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-35352"></A>func</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-35387"></A>a pointer to the underlying math function to be called at each point in this inner loop. This is a <EM CLASS="Code">
void</EM>
 * and must be recast to the required type before actually calling the function e.g. to a pointer to a function that takes two <EM CLASS="Code">
double</EM>
s and returns a <EM CLASS="Code">
double</EM>
). If you need to write your own <EM CLASS="Code">
PyUFuncGenericFunction</EM>
, it is most readable to also have a <EM CLASS="Code">
typedef</EM>
 statement that defines your specific underlying function type so the function pointer cast is somewhat readable.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-33159"></A>void **data</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-35429"></A>a pointer to an array of functions (each cast to <EM CLASS="Code">
void</EM>
 *) that compute the actual mathematical function for each set of inputs and outputs. There should be a function in the array for each supported data type. This function will be called from the <EM CLASS="Code">
PyUFuncGenericFunction</EM>
 for the corresponding type.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-35336"></A>int ntypes</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-35460"></A>the number of datatypes supported by this function. For datatypes that are not directly supported, a coercion will be performed if possible safely, otherwise an error will be reported.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-33161"></A>int nranks</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-33162"></A>unused.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-33163"></A>int attributes</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-35470"></A>unused.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-33165"></A>char *name</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-35481"></A>the name of this function (not the same as the dictionary label for this function object, but it is usually set to the same string). It is printed when <EM CLASS="Code">
__repr__</EM>
 is called for this object, defaults to <EM CLASS="Code">
&quot;?&quot;</EM>
 if set to <EM CLASS="Code">
NULL</EM>
.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-33167"></A>char *types</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-35503"></A>an array of supported types for this function object. I'm not sure why but each supported datatype (<EM CLASS="Code">
PyArray_FLOAT</EM>
, etc.) is entered as many times as there are arguments for this function. (<EM CLASS="Code">
nargs</EM>
)</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-33169"></A>int check_return</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-35528"></A>Usually best to set to 1. If this is non-zero then returned matrices will be cleaned up so that rank-0 arrays will be returned as python scalars. Also, if non-zero, then any math error that sets the <EM CLASS="Code">
errno</EM>
 global variable will cause an appropriate Python exception to be raised.</P>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-590"></A>UfuncObject C API</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-34384"></A>There are currently 15 pointers in the C-API array for the ufuncobject which is loaded by <EM CLASS="Code">
import_ufunc()</EM>
. The macros implemented by this API, available by including the file <EM CLASS="Code">
ufuncobject.h</EM>
,' are given below. The only function normally called by user code is the ufuncobject creation function <EM CLASS="Code">
PyUFunc_FromFuncAndData</EM>
. Some of the other functions can be used as elements of an array to be passed to this creation function.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34392"></A>int <A NAME="marker-59768"></A>PyUFunc_Check(op)</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34554"></A>returns <EM CLASS="Code">
1</EM>
 if op is a ufunc object otherwise returns <EM CLASS="Code">
0</EM>
.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34555"></A>PyObject *<A NAME="marker-59769"></A>PyUFunc_FromFuncAndData(functions, data, types, ntypes, nin, nout, identity, name, check_return)</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34561"></A>returns the ufunc object given its parameters. This is the most important function call. It requires defining three arrays to be passed as parameters: <EM CLASS="Code">
functions</EM>
, <EM CLASS="Code">
data</EM>
, and <EM CLASS="Code">
types</EM>
. The arguments to be passed are:</P>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-34402"></A>functions</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-34570"></A>an array of functions of type <EM CLASS="Code">
PyUFuncGenericFunction</EM>
, there should be one function for each supported datatype. The functions should be in order so that datatypes listed toward the beginning of the array could be cast as datatypes listed toward the end.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-34406"></A>data</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-34577"></A>an array of pointers to void* the same size as the functions array and in the same datatype order. Each element of this array is the actual underlying math function (recast to a <EM CLASS="Code">
void</EM>
 *) that will be called from one of the <EM CLASS="Code">
PyUFuncGenericFunctions</EM>
. It will operate on each element of the input NumPy <EM CLASS="Code">
arrayobject</EM>
(s) and return its element-by-element result in the output NumPy arrayobject(s). There is one function call for each datatype supported, (though functions can be repeated if you handle the typecasting appropriately with the <EM CLASS="Code">
PyUFuncGenericFunction</EM>
).</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-34415"></A>types</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-34594"></A>an array of<EM CLASS="Code">
 PyArray_Type</EM>
s. The size of this array should be (<EM CLASS="Code">
nin+nout</EM>
) times the size of one of the previous two arrays. There should be <EM CLASS="Code">
nin+nout</EM>
 copies of <EM CLASS="Code">
PyArray_XXXXX</EM>
 for each datatype explicitly supported. (Remember datatypes not explicitly supported will still be accepted as input arguments to the ufunc if they can be cast safely to a supported type.) </P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-34422"></A>ntypes</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-34607"></A>the number of supported types for this ufunc.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-34424"></A>nin</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-34610"></A>the number of input arguments</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-34426"></A>nout</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-34427"></A>the number of output arguments</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-34429"></A>identity</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-34615"></A><EM CLASS="Code">
PyUFunc_One</EM>
, <EM CLASS="Code">
PyUFunc_Zero</EM>
, or <EM CLASS="Code">
PyUFunc_None</EM>
, depending on the desired value for the identity. This is only relevant for functions that take two input arguments and return one output argument. If not relevant use <EM CLASS="Code">
PyUFunc_None</EM>
.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-34434"></A>name</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-34435"></A>the name of this <EM CLASS="Code">
ufuncobject</EM>
 for use in the <EM CLASS="Code">
__repr__</EM>
 method.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-34437"></A>check_return</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-34626"></A>the desired value for check_return for this ufuncobject.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34631"></A>int <A NAME="marker-59770"></A>PyUFunc_GenericFunction(self,args,mps)</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34668"></A>allows calling the ufunc from user C routine. It returns 0 on success and -1 on any failures. This is the core of what happens when a ufunc is called from Python. Its arguments are:</P>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-34446"></A>self</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-34675"></A>the ufunc object to be called. INPUT</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-34447"></A>args</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-34676"></A>a Python tuple object containing the input arguments to the ufunc (should be Python sequence objects). INPUT</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-34449"></A>mps</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-34679"></A>an array of pointers to PyArrayObjects for the input and output arguments to this function. The input NumPy arrays are elements <EM CLASS="Code">
mps[0]...mps[self-&gt;nin-1]</EM>
. The output NumPy arrays are elements <EM CLASS="Code">
mps[self-&gt;nin]...mps[self-&gt;nargs-1]</EM>
. OUTPUT</P>
<P CLASS="FirstBody">
<A NAME="pgfId-34455"></A>The following are all functions of type <EM CLASS="Code">
PyUFuncGenericFunction</EM>
 and are suitable for use in the <EM CLASS="Code">
functions</EM>
 argument passed to <EM CLASS="Code">
PyUFunc_FromFuncAndData</EM>
:</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34458"></A>PyUFunc_f_f_As_d_d</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34792"></A>for a unary function that takes a <EM CLASS="Code">
double</EM>
 input and returns a <EM CLASS="Code">
double</EM>
 output as a ufunc that takes <EM CLASS="Code">
PyArray_FLOAT</EM>
 input and returns <EM CLASS="Code">
PyArray_FLOAT</EM>
 output. </P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-56074"></A>PyUFunc_d_d</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-56075"></A>for a using a unary function that takes a <EM CLASS="Code">
double</EM>
 input and returns a <EM CLASS="Code">
double</EM>
 output as a ufunc that takes <EM CLASS="Code">
PyArray_DOUBLE</EM>
 input and returns <EM CLASS="Code">
PyArray_DOUBLE</EM>
 output.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34466"></A>PyUFunc_F_F_As_D_D</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34790"></A>for a unary function that takes a <EM CLASS="Code">
Py_complex</EM>
 input and returns a <EM CLASS="Code">
Py_complex</EM>
 output as a ufunc that takes <EM CLASS="Code">
PyArray_CFLOAT</EM>
 input and returns <EM CLASS="Code">
PyArray_CFLOAT</EM>
 output.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34470"></A>PyUFunc_D_D</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34789"></A>for a unary function that takes a <EM CLASS="Code">
Py_complex</EM>
 input and returns a <EM CLASS="Code">
Py_complex</EM>
 output as a ufunc that takes <EM CLASS="Code">
PyArray_CFLOAT</EM>
 input and returns <EM CLASS="Code">
PyArray_CFLOAT</EM>
 output.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34474"></A>PyUFunc_O_O</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34786"></A>for a unary function that takes a <EM CLASS="Code">
Py_Object</EM>
 * input and returns a <EM CLASS="Code">
Py_Object</EM>
 * output as a ufunc that takes <EM CLASS="Code">
PyArray_OBJECT</EM>
 input and returns <EM CLASS="Code">
PyArray_OBJECT</EM>
 output</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34731"></A>PyUFunc_ff_f_As_dd_d</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34785"></A>for a binary function that takes two <EM CLASS="Code">
double</EM>
 inputs and returns one <EM CLASS="Code">
double</EM>
 output as a ufunc that takes <EM CLASS="Code">
PyArray_FLOAT</EM>
 input and returns <EM CLASS="Code">
PyArray_FLOAT</EM>
 output.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34482"></A>PyUFunc_dd_d</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34784"></A>for a binary function that takes two <EM CLASS="Code">
double</EM>
 inputs and returns one <EM CLASS="Code">
double</EM>
 output as a ufunc that takes <EM CLASS="Code">
PyArray_DOUBLE</EM>
 input and returns <EM CLASS="Code">
PyArray_DOUBLE</EM>
 output.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34486"></A>PyUFunc_FF_F_As_DD_D</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34783"></A>for a binary function that takes two <EM CLASS="Code">
Py_complex</EM>
 inputs and returns a <EM CLASS="Code">
Py_complex</EM>
 output as a ufunc that takes <EM CLASS="Code">
PyArray_CFLOAT</EM>
 input and returns <EM CLASS="Code">
PyArray_CFLOAT</EM>
 output.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34490"></A>PyUFunc_DD_D</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34782"></A>for a binary function that takes two <EM CLASS="Code">
Py_complex</EM>
 inputs and returns a <EM CLASS="Code">
Py_complex</EM>
 output as a ufunc that takes <EM CLASS="Code">
PyArray_CFLOAT</EM>
 input and returns <EM CLASS="Code">
PyArray_CFLOAT</EM>
 output </P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-56204"></A><EM CLASS="Code">
PyUFunc_OO_O</EM>
</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-56200"></A>for a unary function that takes two <EM CLASS="Code">
Py_Object</EM>
 * input and returns a <EM CLASS="Code">
Py_Object</EM>
 *<EM CLASS="Code">
 </EM>
output as a ufunc that takes <EM CLASS="Code">
PyArray_OBJECT</EM>
 input and returns <EM CLASS="Code">
PyArray_OBJECT</EM>
 output</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34498"></A>PyUFunc_O_O_method</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34775"></A>for a unary function that takes a <EM CLASS="Code">
Py_Object</EM>
 * input and returns a <EM CLASS="Code">
Py_Object *</EM>
 output and is pointed to by a Python method as a ufunc that takes PyArray_OBJECT input and returns PyArray_OBJECT output</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34503"></A>PyArrayMap</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34774"></A>an exported API that was apparently considered but never implemented probably because the functionality is already available with Python's <EM CLASS="Code">
map</EM>
 function. </P>
</DIV>
</DIV>
<P><A HREF="numpy.html">Go to Main</A>      <A HREF="numpy-13.html">Go to Previous</A>       <A HREF="numpy-15.html">Go to Next</A></P>
</BODY>
</HTML>
