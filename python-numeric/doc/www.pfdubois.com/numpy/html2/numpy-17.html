<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 6.0/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="numpy.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE> 15.	 FFT Reference</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">
<H1 CLASS="Chapter">
<A NAME="pgfId-304711"></A>15.	 <A NAME="FFT"></A>FFT Reference</H1>
<P CLASS="ChapterDescription">
<A NAME="pgfId-302951"></A>The <A NAME="marker-302950"></A>FFT.py module provides a simple interface to the FFTPACK FORTRAN library, which is a powerful standard library for doing fast Fourier transforms of real and complex data sets, or the C fftpack library, which is algorithmically based on FFTPACK and provides a compatible interface.  On some platforms, optimized version of one of these libraries may be available, and can be used to provide optimal performance (see <A HREF="numpy-17.html#41147" CLASS="XRef">Compilation Notes</A>).</P>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-302955"></A>Python Interface</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-302956"></A>The Python user imports the FFT module, which provides a set of utility functions which provide access to the most commonly used FFT routines, and allows the specification of which axes (dimensions) of the input arrays are to be used for the FFT's.  These routines are:</P>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-302958"></A><A NAME="marker-302957"></A>fft(data, n=None, axis=-1)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-302959"></A>Performs a n-point discrete Fourier transform of the array data.  <EM CLASS="Code">
n</EM>
 defaults to the size of data.  It is most efficient for n a power of two.   If n is larger than <EM CLASS="Code">
data</EM>
, then <EM CLASS="Code">
data</EM>
 will be zero-padded to make up the difference. If n is smaller than data, then <EM CLASS="Code">
data</EM>
 will be aliased to reduce its size. This also stores a cache of working memory for different sizes of fft's, so you could theoretically run into memory problems if you call this too many times with too many different n's.</P>
<P CLASS="Body">
<A NAME="pgfId-302960"></A>The FFT is performed along the axis indicated by the <EM CLASS="Code">
axis</EM>
 argument, which defaults to be the last dimension of <EM CLASS="Code">
data</EM>
.</P>
<P CLASS="Body">
<A NAME="pgfId-302961"></A>The format of the returned array is a complex array of the same shape as <EM CLASS="Code">
data</EM>
, where the first element in the result array contains the DC (steady-state) value of the FFT, and where each successive ...XXX</P>
<P CLASS="Body">
<A NAME="pgfId-302962"></A>Example of use:</P>
<P CLASS="Python">
<A NAME="pgfId-302963"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print fft(array((1,0,1,0,1,0,1,0))+ 10).real</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-302964"></A>[ 84.   0.   0.   0.   4.   0.   0.   0.]</P>
<P CLASS="Python">
<A NAME="pgfId-302965"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print fft(array((0,1,0,1,0,1,0,1))+ 10).real</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-302966"></A>[ 84.   0.   0.   0.  -4.   0.   0.   0.]</P>
<P CLASS="Python">
<A NAME="pgfId-302967"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print fft(array((0,1,0,0,0,1,0,0))+ 10).real</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-302968"></A>[ 82.   0.   0.   0.  -2.   0.   0.   0.]</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-302970"></A><A NAME="marker-302969"></A>inverse_fft(data, n=None, axis=-1)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-302971"></A>Will return the <EM CLASS="Code">
n</EM>
 point inverse discrete Fourier transform of <EM CLASS="Code">
data</EM>
. <EM CLASS="Code">
n</EM>
 defaults to the length of <EM CLASS="Code">
data</EM>
. This is most efficient for <EM CLASS="Code">
n</EM>
 a power of two. If <EM CLASS="Code">
n</EM>
 is larger than <EM CLASS="Code">
data</EM>
, then <EM CLASS="Code">
data</EM>
 will be zero-padded to make up the difference. If <EM CLASS="Code">
n</EM>
 is smaller than <EM CLASS="Code">
data</EM>
, then <EM CLASS="Code">
data</EM>
 will be aliased to reduce its size. This also stores a cache of working memory for different sizes of FFT's, so you could theoretically run into memory problems if you call this too many times with too many different <EM CLASS="Code">
n</EM>
's. </P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-302973"></A><A NAME="marker-302972"></A>real_fft(data, n=None, axis=-1)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-302974"></A>Will return the <EM CLASS="Code">
n</EM>
 point discrete Fourier transform of the real valued array <EM CLASS="Code">
data</EM>
. <EM CLASS="Code">
n</EM>
 defaults to the length of <EM CLASS="Code">
data</EM>
. This is most efficient for <EM CLASS="Code">
n</EM>
 a power of two. The returned array will be one half of the symmetric complex transform of the real array. </P>
<P CLASS="Python">
<A NAME="pgfId-302975"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x = cos(arange(30.0)/30.0*2*pi)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-302976"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print real_fft(x)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-302977"></A>[ -1.        +0.j          13.69406641+2.91076367j</P>
<P CLASS="Python">
<A NAME="pgfId-302978"></A>       -0.91354546-0.40673664j  -0.80901699-0.58778525j</P>
<P CLASS="Python">
<A NAME="pgfId-302979"></A>       -0.66913061-0.74314483j  -0.5       -0.8660254j</P>
<P CLASS="Python">
<A NAME="pgfId-302980"></A>       -0.30901699-0.95105652j  -0.10452846-0.9945219j</P>
<P CLASS="Python">
<A NAME="pgfId-302981"></A>        0.10452846-0.9945219j    0.30901699-0.95105652j</P>
<P CLASS="Python">
<A NAME="pgfId-302982"></A>        0.5       -0.8660254j    0.66913061-0.74314483j</P>
<P CLASS="Python">
<A NAME="pgfId-302983"></A>        0.80901699-0.58778525j   0.91354546-0.40673664j</P>
<P CLASS="Python">
<A NAME="pgfId-302984"></A>        0.9781476 -0.20791169j   1.        +0.j        ]</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-302986"></A><A NAME="marker-302985"></A>inverse_real_fft(data, n=None, axis=-1)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-302987"></A>Will return the inverse FFT of the real valued array <EM CLASS="Code">
data</EM>
.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-302988"></A>fft2d(data, s=None, axes=(-2,-1))	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-302989"></A>Will return the 2-dimensional FFT of the array <EM CLASS="Code">
data</EM>
.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-302990"></A>real_fft2d(data, s=None, axes=(-2,-1))	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-302991"></A>Will return the 2d FFT of the real valued array <EM CLASS="Code">
data</EM>
. </P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-302992"></A>C API</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-302993"></A>The interface to the FFTPACK library is performed via the fftpackmodule module, which is responsible for making sure that the arrays sent to the FFTPACK routines are in the right format (contiguous memory locations, right numerical storage format, etc).  It provides interfaces to the following FFTPACK routines, which are also the names of the Python functions:</P>
<UL>
<LI CLASS="BulletLev2">
<A NAME="pgfId-302994"></A><EM CLASS="Code">
cffti(i)</EM>
</LI>
<LI CLASS="BulletLev2">
<A NAME="pgfId-302995"></A><EM CLASS="Code">
cfftf(data, savearea)</EM>
</LI>
<LI CLASS="BulletLev2">
<A NAME="pgfId-302996"></A><EM CLASS="Code">
cfftb(data, savearea)</EM>
</LI>
<LI CLASS="BulletLev2">
<A NAME="pgfId-302997"></A><EM CLASS="Code">
rffti(i)</EM>
</LI>
<LI CLASS="BulletLev2">
<A NAME="pgfId-302998"></A><EM CLASS="Code">
rfftf(data, savearea)</EM>
</LI>
<LI CLASS="BulletLev2">
<A NAME="pgfId-302999"></A><EM CLASS="Code">
rfftb(data, savearea)</EM>
</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-303000"></A>The routines which start with <EM CLASS="Code">
c</EM>
 expect arrays of complex numbers, the routines which start with <EM CLASS="Code">
r</EM>
 expect real numbers only. The routines which end with <EM CLASS="Code">
i</EM>
 are the initalization functions, those which end with <EM CLASS="Code">
f</EM>
 perform the forward FFTs and those which end with <EM CLASS="Code">
b</EM>
 perform the backwards FFTs.</P>
<P CLASS="Body">
<A NAME="pgfId-303001"></A>The initialization functions require a single integer argument corresponding to the size of the dataset, and returns a work array. The forward and backwards FFTs require two array arguments -- the first is the data array, the second is the work array returned by the initialization function. They return arrays corresponding to the coefficients of the FFT, with the first element in the returned array corresponding to the DC component, the second one to the first fundamental, etc.The length of the returned array is 1 + half the length of the input array in the case of real FFTs, and the same size as the input array in the case of complex data.</P>
<P CLASS="Python">
<A NAME="pgfId-303002"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x = cos(arange(30.0)/30.0*2*pi)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303003"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
w = rffti(30)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303004"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
f = rfftf(x, w)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303005"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
f[0]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303006"></A>(-1+0j)</P>
<P CLASS="Python">
<A NAME="pgfId-303007"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
f[1]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303008"></A>(13.6940664103+2.91076367145j)</P>
<P CLASS="Python">
<A NAME="pgfId-303009"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
f[2]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303010"></A>(-0.913545457643-0.406736643076j)</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-303012"></A><A NAME="41147"></A>Compilation Notes</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-303013"></A>On some platforms, precompiled optimized versions of the FFTPACK library are preinstalled on the operating system, and the compilation procedure needs to be modified to force the fftpackmodule file to be linked against those rather than the fftpacklite.c file which is shipped with NumPy.</P>
</DIV>
<P><A HREF="numpy.html">Go to Main</A>      <A HREF="numpy-16.html">Go to Previous</A>       <A HREF="numpy-18.html">Go to Next</A></P>
</BODY>
</HTML>
