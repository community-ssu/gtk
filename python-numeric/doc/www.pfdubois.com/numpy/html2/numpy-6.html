<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 6.0/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="numpy.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE> 5.	 Array Basics</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">
<H1 CLASS="Chapter">
<A NAME="pgfId-57315"></A>5.	 <A NAME="82200"></A>Array Basics</H1>
<P CLASS="ChapterDescription">
<A NAME="pgfId-35604"></A>This chapter introduces some of the basic functions which will be used throughout the text.</P>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-37311"></A>Basics</H6>
<P CLASS="Body">
<A NAME="pgfId-37312"></A>Before we explore the world of image manipulation as a case-study in array manipulation, we should first define a few terms which we'll use over and over again. Discussions of arrays and matrices and vectors can get confusing due to disagreements on the nomenclature. Here is a brief definition of the terms used in this tutorial, and more or less consistently in the error messages of NumPy.</P>
<P CLASS="Body">
<A NAME="pgfId-37313"></A>The python objects under discussion are formally called &quot;<A NAME="marker-59540"></A>multiarray&quot; objects, but informally we'll just call them &quot;array&quot; objects or just &quot;arrays.&quot; These are different from the array objects defined in the standard Python <EM CLASS="Code">
array</EM>
 module (which is an older module designed for processing one-dimensional data such as sound files). </P>
<P CLASS="Body">
<A NAME="pgfId-37314"></A>These array objects hold their data in a <A NAME="marker-59541"></A>homogeneous block of elements, i.e. their elements all have the same C type (such as a 64-bit floating-point number). This is quite different from most Python container objects, which can contain heterogeneous collections. (You can, however, have an array of Python objects, as discussed later).</P>
<P CLASS="Body">
<A NAME="pgfId-37318"></A>Any given array object has a <A NAME="marker-59542"></A>rank, which is the number of &quot;<A NAME="marker-59543"></A>dimensions&quot; or &quot;<A NAME="marker-59544"></A>axes&quot; it has. For example, a point in 3D space [1, 2, 1] is an array of rank 1 - it has one dimension. That dimension has a <EM CLASS="Emphasis">
length</EM>
 of 3. </P>
<P CLASS="Body">
<A NAME="pgfId-37319"></A>As another example, the array </P>
<P CLASS="Python">
<A NAME="pgfId-37320"></A>1.0 0.0 0.0</P>
<P CLASS="Python">
<A NAME="pgfId-37321"></A>0.0 1.0 2.0</P>
<P CLASS="Body">
<A NAME="pgfId-61092"></A>is an array of rank 2 (it is 2-dimensional). The first dimension has a length of 2, the second dimension has a length of 3. Because the word &quot;dimension&quot; has many different meanings to different folks, in general the word &quot;axis&quot; will be used instead. Axes are numbered just like Python list indices: they start at 0, and can also be counted from the end, so that axis -1 is the last axis of an array, axis -2 is the penultimate axis, etc. </P>
<P CLASS="Body">
<A NAME="pgfId-61093"></A>There are two important and potentially unintuitive behaviors of NumPy arrays which take some getting used to. The first is that by default, operations on arrays are performed <A NAME="marker-61094"></A>element-wise. This means that when adding two arrays, the resulting array has as elements the pairwise sums of the two operand arrays. This is true for all operations, including multiplication. Thus, array multiplication using the * operator will default to element-wise multiplication, not matrix multiplication as used in linear algebra. Many people will want to use arrays as linear algebra-type matrices (including their rank-1 versions, vectors). For those users, the Matrix class provides a more intuitive interface. We defer discussion of the Matrix class until later. </P>
<P CLASS="Body">
<A NAME="pgfId-67591"></A>The second behavior which will catch many users by surprise is that functions which return arrays which are simply different views at the same data will in fact share their data. This will be discussed at length when we have more concrete examples of what exactly this means.</P>
<P CLASS="Body">
<A NAME="pgfId-37324"></A>Now that all of these definitions and warnings are laid out, let's see what we can do with these arrays. </P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-35605"></A>Creating arrays from scratch</H6>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-35606"></A><A NAME="marker-59546"></A>array() and <A NAME="marker-59547"></A>typecodes</H6>
<P CLASS="Body">
<A NAME="pgfId-35607"></A>There are many ways to create arrays. The most basic one is the use of the <EM CLASS="Code">
array()</EM>
 function: </P>
<P CLASS="Python">
<A NAME="pgfId-35608"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = array([1.2, 3.5, -1])</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-35609"></A>to make sure this worked, do: </P>
<P CLASS="Python">
<A NAME="pgfId-35610"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35611"></A>[ 1.2  3.5 -1. ]</P>
<P CLASS="Body">
<A NAME="pgfId-35615"></A>The <EM CLASS="Code">
array(numbers, typecode=None, savespace=0) </EM>
function takes three arguments - the first one is the values, which have to be in a Python sequence object (such as a list or a tuple). The optional second argument is the typecode of the elements. If it is omitted, as in the example above, Python tries to find the one type which can represent all the elements. The third is discussed in <A HREF="numpy-6.html#29152" CLASS="XRef">Saving space</A>. </P>
<P CLASS="Body">
<A NAME="pgfId-68273"></A>Since the elements we gave our example were two floats and one integer, it chose `float' as the type of the resulting array. If one specifies the typecode, one can specify unequivocally the type of the elements - this is especially useful when, for example, one wants to make sure that an array contains floats even though in some cases all of its elements are integers: </P>
<P CLASS="Python">
<A NAME="pgfId-35616"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x,y,z = 1,2,3</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35617"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = array([x,y,z])	</EM>
# integers are enough for 1, 2 and 3</P>
<P CLASS="Python">
<A NAME="pgfId-35618"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35619"></A>[1 2 3]</P>
<P CLASS="Python">
<A NAME="pgfId-35620"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = array([x,y,z], Float) 	</EM>
# not the default type</P>
<P CLASS="Python">
<A NAME="pgfId-35621"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35622"></A>[ 1.  2.  3.]</P>
<DIV>
<H6 CLASS="NoteTip">
<A NAME="pgfId-85572"></A><DIV>
<IMG SRC="numpy-4.gif" width="469" height="12">
</DIV>
&nbsp;</H6>
<P CLASS="Note">
<A NAME="pgfId-85579"></A>Pop Quiz:	 What will be the type of an array defined as follows:<BR>
</P>
<P CLASS="PythonNote">
<A NAME="pgfId-61028"></A><EM CLASS="Code">
&gt;&gt;&gt; </EM>
<EM CLASS="CodeInput">
mystery = array([1, 2.0, -3j])</EM>
</P>
<P CLASS="PythonNote">
<A NAME="pgfId-84465"></A>&nbsp;</P>
<P CLASS="Note">
<A NAME="pgfId-61029"></A>Hint: <EM CLASS="Code">
-3j</EM>
 is an imaginary number.</P>
<P CLASS="Note">
<A NAME="pgfId-61032"></A><A NAME="marker-84325"></A>Answer: complex</P>
<P CLASS="Note">
<A NAME="pgfId-61047"></A>A very common mistake is to call array with a set of numbers as arguments, as in <EM CLASS="Code">
array(1,2,3,4,5)</EM>
. This doesn't produce the expected result as soon as at least two numbers are used, because the first argument to <EM CLASS="Code">
array()</EM>
 must be the entire data for the array -- thus, in most cases, a sequence of numbers.  The correct way to write the preceding invocation is most likely <EM CLASS="Code">
array((1,2,3,4,5))</EM>
.</P>
<DIV>
<H6 CLASS="NoteBottom">
<A NAME="pgfId-84466"></A><DIV>
<IMG SRC="numpy-4.gif" width="469" height="12">
</DIV>
&nbsp;</H6>
<P CLASS="Body">
<A NAME="pgfId-35625"></A>Possible values for the second argument to the <EM CLASS="Code">
array</EM>
 creator function (and indeed to any function which accepts a so-called typecode for arrays) are: </P>
<OL>
<LI CLASS="Step">
<A NAME="pgfId-35626"></A>One type corresponding to single ASCII characters: <EM CLASS="Code">
Character</EM>
<A NAME="marker-59548"></A>.</LI>
<LI CLASS="Step">
<A NAME="pgfId-35627"></A>One unsigned numeric type: <EM CLASS="Code">
UnsignedInt8</EM>
<A NAME="marker-59549"></A>, used to store numbers between 0 and 255.</LI>
<LI CLASS="Step">
<A NAME="pgfId-35628"></A>Many signed numeric types:</LI>
<LI CLASS="BulletLev2">
<A NAME="pgfId-59564"></A>Signed integer choices: <EM CLASS="Code">
Int</EM>
<A NAME="marker-59558"></A>, <EM CLASS="Code">
Int0</EM>
<A NAME="marker-59559"></A>, <EM CLASS="Code">
Int8</EM>
<A NAME="marker-59560"></A>, <EM CLASS="Code">
Int16</EM>
<A NAME="marker-59561"></A>, <EM CLASS="Code">
Int32</EM>
<A NAME="marker-59562"></A>, and on some platforms, <EM CLASS="Code">
Int64</EM>
<A NAME="marker-59563"></A> and <EM CLASS="Code">
Int128</EM>
<A NAME="marker-59565"></A> (their ranges depend on their size).</LI>
<LI CLASS="BulletLev2">
<A NAME="pgfId-59567"></A>Floating point choices: <EM CLASS="Code">
Float</EM>
<A NAME="marker-59566"></A>, <EM CLASS="Code">
Float0</EM>
<A NAME="marker-59570"></A>, <EM CLASS="Code">
Float8</EM>
<A NAME="marker-59571"></A>, <EM CLASS="Code">
Float16</EM>
<A NAME="marker-59572"></A>, <EM CLASS="Code">
Float32</EM>
<A NAME="marker-59573"></A>, <EM CLASS="Code">
Float64</EM>
<A NAME="marker-59574"></A>, and on some platforms, <EM CLASS="Code">
Float128</EM>
<A NAME="marker-59575"></A>.</LI>
<LI CLASS="BulletLev2">
<A NAME="pgfId-35631"></A>Complex number choices: <EM CLASS="Code">
Complex</EM>
<A NAME="marker-59576"></A>, <EM CLASS="Code">
Complex0</EM>
<A NAME="marker-59577"></A>, <EM CLASS="Code">
Complex8</EM>
<A NAME="marker-59578"></A>, <EM CLASS="Code">
Complex16</EM>
<A NAME="marker-59579"></A>, <EM CLASS="Code">
Complex32</EM>
<A NAME="marker-59580"></A>, <EM CLASS="Code">
Complex64</EM>
<A NAME="marker-59581"></A>, <EM CLASS="Code">
Complex128</EM>
<A NAME="marker-59582"></A>.</LI>
</OL>
<P CLASS="Body">
<A NAME="pgfId-35632"></A>The meaning of these is as follows:</P>
<UL>
<LI CLASS="BulletLev2">
<A NAME="pgfId-35633"></A>The versions without any numbers (<EM CLASS="Code">
Int</EM>
, <EM CLASS="Code">
Float</EM>
, <EM CLASS="Code">
Complex</EM>
) correspond to the <EM CLASS="Code">
int</EM>
, <EM CLASS="Code">
float</EM>
 and <EM CLASS="Code">
complex</EM>
 datatypes in Python.  They are thus long integers and double-precision floating point numbers, with a complex number corresponding to two double-precision floats.</LI>
<LI CLASS="BulletLev2">
<A NAME="pgfId-35634"></A>The versions with a number following correspond to whatever words are available on the specific platform you are using which have <EM CLASS="Emphasis">
at least</EM>
 that many bits in them.  Thus, <EM CLASS="Code">
Int0</EM>
 corresponds to the smallest integer word size available, <EM CLASS="Code">
Int8</EM>
 corresponds to the smallest integer word size available which has at least 8 bits, etc.  The word sizes for the complex numbers refer to the total number of bits used by both the real and imaginary parts (in other words, the data portion of an array of N <EM CLASS="Code">
Complex128</EM>
 elements uses up the same amount of memory as the data portions of two arrays of typecode  <EM CLASS="Code">
Float64</EM>
 with 2N elements).</LI>
<LI CLASS="Step">
<A NAME="pgfId-35635"></A>One non-numeric type, <EM CLASS="Code">
PyObject</EM>
<A NAME="marker-59583"></A>.  Arrays of typecode <EM CLASS="Code">
PyObject</EM>
 are arrays of Python references, and as such their data area can contain references to any kind of Python objects.</LI>
</UL>
<P CLASS="FirstBody">
<A NAME="pgfId-35636"></A>The last typecode deserves a little comment. Indeed, it seems to indicate that arrays can be filled with any Python objects. This appears to violate the notion that arrays are homogeneous. In fact, the typecode <EM CLASS="Code">
PyObject</EM>
 does allow heterogeneous arrays. However, if you plan to do numerical computation, you're much better off with a homogeneous array with a potentially &quot;large&quot; type than with a heterogeneous array. This is because a heterogeneous array stores references to objects, which incurs a memory cost, and because the speed of computation is much slower with arrays of <EM CLASS="Code">
PyObject</EM>
's than with uniform number arrays. Why does it exist, then? </P>
<P CLASS="Body">
<A NAME="pgfId-68287"></A>A very useful feature of arrays is the ability to slice them, dice them, select and choose from them, etc. This feature is so nice that sometimes one wants to do the same operations with, e.g., arrays of class instances. In such cases, computation speed is not as important as convenience. Also, if the array is filled with objects which are instances of classes which define the appropriate methods, then NumPy will let you do math with those objects. For example, if one creates an object class which has an <EM CLASS="Code">
__add__</EM>
 method, then arrays (created with the <EM CLASS="Code">
PyObject</EM>
 typecode) of instances of such a class can be added together. </P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-35637"></A>Multidimensional Arrays</H6>
<P CLASS="Body">
<A NAME="pgfId-35638"></A>The following example shows one way of creating multidimensional arrays: </P>
<P CLASS="Python">
<A NAME="pgfId-35639"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
ma = array([[1,2,3],[4,5,6]])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35640"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print ma</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35641"></A>[[1 2 3]</P>
<P CLASS="Python">
<A NAME="pgfId-35642"></A> [4 5 6]]</P>
<P CLASS="Body">
<A NAME="pgfId-35643"></A>The first argument to <EM CLASS="Code">
array()</EM>
 in the code above is a single list containing two lists, each containing three elements. If we wanted floats instead, we could specify, as discussed in the previous section, the optional typecode we wished: </P>
<P CLASS="Python">
<A NAME="pgfId-35644"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
ma_floats = array([[1,2,3],[4,5,6]], Float)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35645"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print ma_floats</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35646"></A>[[ 1.  2.  3.]</P>
<P CLASS="Python">
<A NAME="pgfId-35647"></A> [ 4.  5.  6.]]</P>
<P CLASS="Body">
<A NAME="pgfId-35648"></A>This array allows us to introduce the notion of `shape'. The shape of an array is the set of numbers which define its dimensions. The shape of the array <EM CLASS="Code">
ma</EM>
 defined above is 2 by 3.  More precisely, all arrays have a shape attribute which is a tuple of integers.  So, in this case: </P>
<P CLASS="Python">
<A NAME="pgfId-35649"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print ma.shape</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35650"></A>(2, 3)</P>
<P CLASS="Body">
<A NAME="pgfId-35651"></A>Using the earlier definitions, this is a shape of rank 2, where the first axis has length 2, and the seond axis has length 3. The rank of an array <EM CLASS="Code">
A</EM>
 is always equal to <EM CLASS="Code">
len(A.shape)</EM>
. </P>
<P CLASS="Body">
<A NAME="pgfId-35652"></A>Note that <EM CLASS="Code">
shape</EM>
 is an <EM CLASS="Emphasis">
attribute</EM>
 of  <EM CLASS="Code">
array</EM>
 objects. It is the first of several which we will see throughout this tutorial. If you're not used to object-oriented programming, you can think of attributes as  &quot;features&quot; or &quot;qualities&quot; of individual arrays. The relation between an array and its shape is similar to the relation between a person and their hair color. In Python, it's called an object/attribute relation. </P>
<P CLASS="Body">
<A NAME="pgfId-35653"></A>What if one wants to change the dimensions of an array? For now, let us consider changing the shape of an array without making it &quot;grow.&quot; Say, for example, we want to make the 2x3 array defined above (<EM CLASS="Code">
ma</EM>
) an array of rank 1: </P>
<P CLASS="Python">
<A NAME="pgfId-35654"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
flattened_ma = reshape(ma, (6,))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35655"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print flattened_ma</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35656"></A>[1 2 3 4 5 6]</P>
<P CLASS="Body">
<A NAME="pgfId-35657"></A>One can change the shape of arrays to any shape as long as the product of all the lengths of all the axes is kept constant (in other words, as long as the number of elements in the array doesn't change): </P>
<P CLASS="Python">
<A NAME="pgfId-35658"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = array([1,2,3,4,5,6,7,8])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35660"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-85936"></A>[1 2 3 4 5 6 7 8]</P>
<P CLASS="Python">
<A NAME="pgfId-35661"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
b = reshape(a, (2,4))	</EM>
# 2*4 == 8</P>
<P CLASS="Python">
<A NAME="pgfId-85946"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print b</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35662"></A>[[1 2 3 4]</P>
<P CLASS="Python">
<A NAME="pgfId-35663"></A> [5 6 7 8]]</P>
<P CLASS="Python">
<A NAME="pgfId-35665"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
c = reshape(b, (4,2))	</EM>
# 4*2 == 8 </P>
<P CLASS="Python">
<A NAME="pgfId-35666"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print c</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35667"></A>[[1 2]</P>
<P CLASS="Python">
<A NAME="pgfId-35668"></A> [3 4]</P>
<P CLASS="Python">
<A NAME="pgfId-35669"></A> [5 6]</P>
<P CLASS="Python">
<A NAME="pgfId-35670"></A> [7 8]]</P>
<P CLASS="Body">
<A NAME="pgfId-35671"></A>Notice that we used a new function, <EM CLASS="Code">
reshape()</EM>
<A NAME="marker-59584"></A>. It, like <EM CLASS="Code">
array()</EM>
, is a function defined in the <EM CLASS="Code">
Numeric</EM>
 module. It expects an array as its first argument, and a shape as its second argument. The shape has to be a sequence of integers (a list or a tuple). Keep in mind that a tuple with a single element needs a comma at the end; the right shape tuple for a rank-1 array with 5 elements is <EM CLASS="Code">
(5,)</EM>
, not <EM CLASS="Code">
(5)</EM>
. </P>
<P CLASS="Body">
<A NAME="pgfId-35672"></A>One nice feature of shape tuples is that one entry in the shape tuple is allowed to be <EM CLASS="Code">
-1</EM>
.  The <EM CLASS="Code">
-1</EM>
 will be automatically replaced by whatever number is needed to build a shape which does not change the size of the array. Thus: </P>
<P CLASS="Python">
<A NAME="pgfId-35673"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = reshape(array(range(25)), (5,-1))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35674"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a, a.shape </EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35675"></A>[[ 0  1  2  3  4]</P>
<P CLASS="Python">
<A NAME="pgfId-35676"></A> [ 5  6  7  8  9]</P>
<P CLASS="Python">
<A NAME="pgfId-35677"></A> [10 11 12 13 14]</P>
<P CLASS="Python">
<A NAME="pgfId-35678"></A> [15 16 17 18 19]</P>
<P CLASS="Python">
<A NAME="pgfId-35679"></A> [20 21 22 23 24]] (5, 5)</P>
<P CLASS="Body">
<A NAME="pgfId-35680"></A>The shape of an array is a modifiable attribute of the array. You can therefore change the shape of an array simply by assigning a new shape to it: </P>
<P CLASS="Python">
<A NAME="pgfId-35681"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = array([1,2,3,4,5,6,7,8,9,10]) </EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35682"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a.shape</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35683"></A>(10,) </P>
<P CLASS="Python">
<A NAME="pgfId-35684"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a.shape = (2,5) </EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35685"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35686"></A>[[ 1  2  3  4  5]</P>
<P CLASS="Python">
<A NAME="pgfId-35687"></A> [ 6  7  8  9 10]]</P>
<P CLASS="Python">
<A NAME="pgfId-35688"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a.shape = (10,1)	</EM>
	# second axis has length 1</P>
<P CLASS="Python">
<A NAME="pgfId-35689"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35690"></A>[[ 1]</P>
<P CLASS="Python">
<A NAME="pgfId-35691"></A> [ 2]</P>
<P CLASS="Python">
<A NAME="pgfId-35692"></A> [ 3]</P>
<P CLASS="Python">
<A NAME="pgfId-35693"></A> [ 4]</P>
<P CLASS="Python">
<A NAME="pgfId-35694"></A> [ 5]</P>
<P CLASS="Python">
<A NAME="pgfId-35695"></A> [ 6]</P>
<P CLASS="Python">
<A NAME="pgfId-35696"></A> [ 7]</P>
<P CLASS="Python">
<A NAME="pgfId-35697"></A> [ 8]</P>
<P CLASS="Python">
<A NAME="pgfId-35698"></A> [ 9]</P>
<P CLASS="Python">
<A NAME="pgfId-35699"></A> [10]]</P>
<P CLASS="Python">
<A NAME="pgfId-35700"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a.shape = (5,-1)	</EM>
# note the -1 trick described above</P>
<P CLASS="Python">
<A NAME="pgfId-35701"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35702"></A>[[ 1  2]</P>
<P CLASS="Python">
<A NAME="pgfId-35703"></A> [ 3  4]</P>
<P CLASS="Python">
<A NAME="pgfId-35704"></A> [ 5  6]</P>
<P CLASS="Python">
<A NAME="pgfId-35705"></A> [ 7  8]</P>
<P CLASS="Python">
<A NAME="pgfId-35706"></A> [ 9 10]]</P>
<P CLASS="Body">
<A NAME="pgfId-35707"></A>As in the rest of Python, violating rules (such as the one about which shapes are allowed) results in exceptions:</P>
<P CLASS="Python">
<A NAME="pgfId-35708"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a.shape = (6,-1)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35709"></A>Traceback (innermost last):</P>
<P CLASS="Python">
<A NAME="pgfId-35710"></A>  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</P>
<P CLASS="Python">
<A NAME="pgfId-35711"></A>ValueError: total size of new array must be unchanged</P>
<DIV>
<H6 CLASS="MoreTip">
<A NAME="pgfId-35713"></A><DIV>
<IMG SRC="numpy-4.gif" width="469" height="12">
</DIV>
&nbsp;</H6>
<P CLASS="Note">
<A NAME="pgfId-85952"></A>Sections denoted &quot;For Advanced Users&quot; will be used to indicate aspects of the functions which may not be needed for a first introduction at NumPy, but which should be mentioned for the sake of completeness.</P>
<P CLASS="Note">
<A NAME="pgfId-61102"></A>The default printing routine provided by the Numeric module prints arrays as follows:</P>
<OL>
<LI CLASS="NoteEnum">
<A NAME="pgfId-35714"></A>The last axis is always printed left to right</LI>
<LI CLASS="NoteEnum">
<A NAME="pgfId-35715"></A>The next-to-last axis is printed top to bottom</LI>
</OL>
<P CLASS="Note">
<A NAME="pgfId-35716"></A>The remaining axes are printed top to bottom with increasing numbers of separators.</P>
<P CLASS="Note">
<A NAME="pgfId-35717"></A>This explains why rank-1 arrays are printed from left to right, rank-2 arrays have the first dimension going down the screen and the second dimension going from left to right, etc. </P>
<DIV>
<H6 CLASS="NoteBottom">
<A NAME="pgfId-85613"></A><DIV>
<IMG SRC="numpy-4.gif" width="469" height="12">
</DIV>
&nbsp;</H6>
<P CLASS="Body">
<A NAME="pgfId-35718"></A>If you want to change the shape of an array so that it has more elements than it started with (i.e. grow it), then you have many options: One solution is to use the <EM CLASS="Code">
concat()</EM>
 method discussed later. An alternative is to use the <EM CLASS="Code">
array()</EM>
 creator function with existing arrays as arguments: </P>
<P CLASS="Python">
<A NAME="pgfId-35719"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35720"></A>[0 1 2 3 4 5 6 6 7]</P>
<P CLASS="Python">
<A NAME="pgfId-35721"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
b = array([a,a]) </EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35722"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print b</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35723"></A>[[0 1 2 3 4 5 6 7]</P>
<P CLASS="Python">
<A NAME="pgfId-35724"></A> [0 1 2 3 4 5 6 7]] </P>
<P CLASS="Python">
<A NAME="pgfId-35725"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print b.shape</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35726"></A>(2, 8) </P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-68290"></A>resize</H6>
<P CLASS="Body">
<A NAME="pgfId-65778"></A>A final possibility is the <EM CLASS="Code">
resize()</EM>
<A NAME="marker-59585"></A>function, which takes a &quot;base&quot; array as its first argument and the desired shape as the second argument. Unlike <EM CLASS="Code">
reshape()</EM>
, the shape argument to <EM CLASS="Code">
resize()</EM>
 can correspond to a smaller or larger shape than the input array.  Smaller shapes will result in arrays with the data at the &quot;beginning&quot; of the input array, and larger shapes result in arrays with data containing as many replications of the input array as are needed to fill the shape. For example, starting with a simple array</P>
<P CLASS="Python">
<A NAME="pgfId-35728"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
base = array([0,1])</EM>
 </P>
<P CLASS="Body">
<A NAME="pgfId-35729"></A>one can quickly build a large array with replicated data: </P>
<P CLASS="Python">
<A NAME="pgfId-35730"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
big = resize(base, (9,9)) </EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35731"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print big</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35732"></A>[[0 1 0 1 0 1 0 1 0]</P>
<P CLASS="Python">
<A NAME="pgfId-35733"></A> [1 0 1 0 1 0 1 0 1]</P>
<P CLASS="Python">
<A NAME="pgfId-35734"></A> [0 1 0 1 0 1 0 1 0]</P>
<P CLASS="Python">
<A NAME="pgfId-35735"></A> [1 0 1 0 1 0 1 0 1]</P>
<P CLASS="Python">
<A NAME="pgfId-35736"></A> [0 1 0 1 0 1 0 1 0]</P>
<P CLASS="Python">
<A NAME="pgfId-35737"></A> [1 0 1 0 1 0 1 0 1]</P>
<P CLASS="Python">
<A NAME="pgfId-35738"></A> [0 1 0 1 0 1 0 1 0]</P>
<P CLASS="Python">
<A NAME="pgfId-35739"></A> [1 0 1 0 1 0 1 0 1]</P>
<P CLASS="Python">
<A NAME="pgfId-35740"></A> [0 1 0 1 0 1 0 1 0]]</P>
<P CLASS="Body">
<A NAME="pgfId-35741"></A>and if you imported the <EM CLASS="Code">
view</EM>
 function from the <EM CLASS="Code">
NumTut</EM>
 package, you can do:</P>
<P CLASS="Python">
<A NAME="pgfId-35742"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
view(resize(base, (100,100)))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35743"></A><EM CLASS="Emphasis">
# grey grid of horizontal lines is shown</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59939"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
view(resize(base, (101,101)))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59947"></A><EM CLASS="Emphasis">
# grey grid of alternating black and white pixels is shown</EM>
</P>
<DIV>
<H6 CLASS="MoreTip">
<A NAME="pgfId-60322"></A><DIV>
<IMG SRC="numpy-4.gif" width="469" height="12">
</DIV>
&nbsp;</H6>
<P CLASS="Note">
<A NAME="pgfId-60338"></A>The <EM CLASS="Code">
array</EM>
 constructor takes a mandatory <EM CLASS="Code">
data</EM>
 argument, an optional typecode, and optional <EM CLASS="Code">
savespace</EM>
 argument, and an optional <EM CLASS="Code">
copy</EM>
 argument.  If the <EM CLASS="Code">
data</EM>
 argument is a sequence, then array creates a new object of type multiarray, and fills the array with the elements of the <EM CLASS="Code">
data</EM>
 object. The shape of the array is determined by the size and nesting arrangement of the elements of data.</P>
<P CLASS="Note">
<A NAME="pgfId-60301"></A>If <EM CLASS="Code">
data</EM>
 is not a sequence, then the array returned is an array of shape <EM CLASS="Code">
()</EM>
 (the empty tuple), of typecode <EM CLASS="Code">
'O'</EM>
, containing a single element, which is <EM CLASS="Code">
data</EM>
.</P>
<DIV>
<H6 CLASS="NoteBottom">
<A NAME="pgfId-85628"></A><DIV>
<IMG SRC="numpy-4.gif" width="469" height="12">
</DIV>
&nbsp;</H6>
</DIV>
</DIV>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-60291"></A>Creating arrays with values specified `on-the-fly' </H6>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-60120"></A><A NAME="marker-60118"></A>zeros() and <A NAME="marker-60119"></A>ones() </H6>
<P CLASS="Body">
<A NAME="pgfId-35748"></A>Often, one needs to manipulate arrays filled with numbers which aren't available beforehand. The Numeric module provides a few functions which create arrays from scratch: </P>
<P CLASS="Body">
<A NAME="pgfId-35749"></A><EM CLASS="Code">
zeros()</EM>
 and <EM CLASS="Code">
ones()</EM>
 simply create arrays of a given shape filled with zeros and ones respectively: </P>
<P CLASS="Python">
<A NAME="pgfId-35750"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
z = zeros((3,3))</EM>
 </P>
<P CLASS="Python">
<A NAME="pgfId-35751"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print z</EM>
 </P>
<P CLASS="Python">
<A NAME="pgfId-35752"></A>[[0 0 0]</P>
<P CLASS="Python">
<A NAME="pgfId-35753"></A> [0 0 0]</P>
<P CLASS="Python">
<A NAME="pgfId-35754"></A> [0 0 0]]</P>
<P CLASS="Python">
<A NAME="pgfId-35755"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
o = ones([2,3])</EM>
 </P>
<P CLASS="Python">
<A NAME="pgfId-35756"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print o</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35757"></A>[[1 1 1]</P>
<P CLASS="Python">
<A NAME="pgfId-35758"></A> [1 1 1]]</P>
<P CLASS="Body">
<A NAME="pgfId-35759"></A>Note that the first argument is a shape - it needs to be a list or a tuple of integers. Also note that the default type for the returned arrays is <EM CLASS="Code">
Int</EM>
, which you can feel free to override using something like: </P>
<P CLASS="Python">
<A NAME="pgfId-35760"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
o = ones((2,3), Float)</EM>
 </P>
<P CLASS="Python">
<A NAME="pgfId-35761"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print o</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35762"></A>[[ 1.  1.  1.]</P>
<P CLASS="Python">
<A NAME="pgfId-35763"></A> [ 1.  1.  1.]]</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-35764"></A><A NAME="marker-59594"></A>arrayrange() </H6>
<P CLASS="Body">
<A NAME="pgfId-35765"></A>The <EM CLASS="Code">
arrayrange()</EM>
 function is similar to the <EM CLASS="Code">
range()</EM>
 function in Python, except that it returns an array as opposed to a list. </P>
<P CLASS="Python">
<A NAME="pgfId-35766"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
r = arrayrange(10) </EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35767"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print r</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35768"></A>[0 1 2 3 4 5 6 7 8 9] </P>
<P CLASS="Body">
<A NAME="pgfId-35769"></A>Combining the <EM CLASS="Code">
arrayrange()</EM>
 with the <EM CLASS="Code">
reshape()</EM>
 function, we can get: </P>
<P CLASS="Python">
<A NAME="pgfId-35770"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
big = reshape(arrayrange(100),(10,10))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35771"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print big<BR>
</EM>
[[ 0  1  2  3  4  5  6  7  8  9]</P>
<P CLASS="Python">
<A NAME="pgfId-35772"></A> [10 11 12 13 14 15 16 17 18 19]</P>
<P CLASS="Python">
<A NAME="pgfId-35773"></A> [20 21 22 23 24 25 26 27 28 29]</P>
<P CLASS="Python">
<A NAME="pgfId-35774"></A> [30 31 32 33 34 35 36 37 38 39]</P>
<P CLASS="Python">
<A NAME="pgfId-35775"></A> [40 41 42 43 44 45 46 47 48 49]</P>
<P CLASS="Python">
<A NAME="pgfId-35776"></A> [50 51 52 53 54 55 56 57 58 59]</P>
<P CLASS="Python">
<A NAME="pgfId-35777"></A> [60 61 62 63 64 65 66 67 68 69]</P>
<P CLASS="Python">
<A NAME="pgfId-35778"></A> [70 71 72 73 74 75 76 77 78 79]</P>
<P CLASS="Python">
<A NAME="pgfId-35779"></A> [80 81 82 83 84 85 86 87 88 89]</P>
<P CLASS="Python">
<A NAME="pgfId-35780"></A> [90 91 92 93 94 95 96 97 98 99]]</P>
<P CLASS="Python">
<A NAME="pgfId-35781"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
view(reshape(arrayrange(10000),(100,100)))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35782"></A><EM CLASS="Emphasis">
# array of increasing lightness from top down (slowly) and from left to</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35783"></A><EM CLASS="Emphasis">
# right (faster) is shown</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-35784"></A><EM CLASS="Code">
arange()</EM>
 is a shorthand for <EM CLASS="Code">
arrayrange()</EM>
.  </P>
<P CLASS="Body">
<A NAME="pgfId-35785"></A>One can set the start, stop and step arguments, which allows for more varied ranges: </P>
<P CLASS="Python">
<A NAME="pgfId-35786"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print arrayrange(10,-10,-2)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35787"></A>[10  8  6  4  2  0  -2  -4  -6  -8]</P>
<P CLASS="Body">
<A NAME="pgfId-35788"></A>An important feature of arrayrange is that it can be used with non-integer starting points and strides:</P>
<P CLASS="Python">
<A NAME="pgfId-35789"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print arrayrange(5.0)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35790"></A>[ 0. 1. 2. 3. 4.]</P>
<P CLASS="Python">
<A NAME="pgfId-35791"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print arrayrange(0, 1, .2)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35792"></A>[ 0.   0.2  0.4  0.6  0.8]</P>
<P CLASS="Body">
<A NAME="pgfId-60244"></A>If you want to create an array with just one value, repeated over and over, you can use the * operator applied to lists </P>
<P CLASS="Python">
<A NAME="pgfId-60245"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = array([[3]*5]*5)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-60246"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35796"></A>[[3 3 3 3 3]</P>
<P CLASS="Python">
<A NAME="pgfId-35797"></A> [3 3 3 3 3]</P>
<P CLASS="Python">
<A NAME="pgfId-35798"></A> [3 3 3 3 3]</P>
<P CLASS="Python">
<A NAME="pgfId-35799"></A> [3 3 3 3 3]</P>
<P CLASS="Python">
<A NAME="pgfId-35800"></A> [3 3 3 3 3]]</P>
<P CLASS="Body">
<A NAME="pgfId-35801"></A>but that is relatively slow, since the duplication is done on Python lists. A quicker way would be to start with 0's and add 3: </P>
<P CLASS="Python">
<A NAME="pgfId-35802"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = zeros([5,5]) + 3</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35803"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35804"></A>[[3 3 3 3 3]</P>
<P CLASS="Python">
<A NAME="pgfId-35805"></A> [3 3 3 3 3]</P>
<P CLASS="Python">
<A NAME="pgfId-35806"></A> [3 3 3 3 3]</P>
<P CLASS="Python">
<A NAME="pgfId-35807"></A> [3 3 3 3 3]</P>
<P CLASS="Python">
<A NAME="pgfId-35808"></A> [3 3 3 3 3]]</P>
<P CLASS="FirstBody">
<A NAME="pgfId-66497"></A>The optional typecode argument can force the typecode of the resulting array, which is otherwise the &quot;highest&quot; of the starting and stopping arguments. The starting argument defaults to 0 if not specified. Note that if a typecode is specified which is &quot;lower&quot; than that which arrayrange would normally use, the array is the result of a precision-losing cast (a round-down, as that used in the <EM CLASS="Code">
astype</EM>
 method for arrays.)</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-35809"></A>Creating an array from a function: <A NAME="marker-59598"></A>fromfunction()</H6>
<P CLASS="Body">
<A NAME="pgfId-35810"></A>Finally, one may want to create an array with contents which are the result of a function evaluation. This is done using the <EM CLASS="Code">
fromfunction()</EM>
 function, which takes two arguments, a shape and a callable object (usually a function).  For example: </P>
<P CLASS="Python">
<A NAME="pgfId-35811"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
def dist(x,y):</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35812"></A>... <EM CLASS="CodeInput">
  return (x-5)**2+(y-5)**2	</EM>
# distance from point (5,5) squared</P>
<P CLASS="Python">
<A NAME="pgfId-35813"></A>...</P>
<P CLASS="Python">
<A NAME="pgfId-35814"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
m = fromfunction(dist, (10,10))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35815"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print m</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35816"></A>[[50 41 34 29 26 25 26 29 34 41]</P>
<P CLASS="Python">
<A NAME="pgfId-35817"></A> [41 32 25 20 17 16 17 20 25 32]</P>
<P CLASS="Python">
<A NAME="pgfId-35818"></A> [34 25 18 13 10  9 10 13 18 25]</P>
<P CLASS="Python">
<A NAME="pgfId-35819"></A> [29 20 13  8  5  4  5  8 13 20]</P>
<P CLASS="Python">
<A NAME="pgfId-35820"></A> [26 17 10  5  2  1  2  5 10 17]</P>
<P CLASS="Python">
<A NAME="pgfId-35821"></A> [25 16  9  4  1  0  1  4  9 16]</P>
<P CLASS="Python">
<A NAME="pgfId-35822"></A> [26 17 10  5  2  1  2  5 10 17]</P>
<P CLASS="Python">
<A NAME="pgfId-35823"></A> [29 20 13  8  5  4  5  8 13 20]</P>
<P CLASS="Python">
<A NAME="pgfId-35824"></A> [34 25 18 13 10  9 10 13 18 25]</P>
<P CLASS="Python">
<A NAME="pgfId-35825"></A> [41 32 25 20 17 16 17 20 25 32]]</P>
<P CLASS="Python">
<A NAME="pgfId-35826"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
view(fromfunction(dist, (100,100))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35827"></A><EM CLASS="Emphasis">
# shows image which is dark in topleft corner, and lighter away from it.</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35828"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
m = fromfunction(lambda i,j,k: 100*(i+1)+10*(j+1)+(k+1), (4,2,3))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35829"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print m</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35830"></A>[[[111 112 113]</P>
<P CLASS="Python">
<A NAME="pgfId-35831"></A>  [121 122 123]]</P>
<P CLASS="Python">
<A NAME="pgfId-35832"></A> [[211 212 213]</P>
<P CLASS="Python">
<A NAME="pgfId-35833"></A>  [221 222 223]]</P>
<P CLASS="Python">
<A NAME="pgfId-35834"></A> [[311 312 313]</P>
<P CLASS="Python">
<A NAME="pgfId-35835"></A>  [321 322 323]]</P>
<P CLASS="Python">
<A NAME="pgfId-35836"></A> [[411 412 413]</P>
<P CLASS="Python">
<A NAME="pgfId-35837"></A>  [421 422 423]]]</P>
<P CLASS="Body">
<A NAME="pgfId-35838"></A>By examining the above examples, one can see that <EM CLASS="Code">
fromfunction()</EM>
 creates an array of the shape specified by its second argument, and with the contents corresponding to the value of the function argument (the first argument) evaluated at the indices of the array.  Thus the value of <EM CLASS="Code">
m[3,4]</EM>
 in the first example above is the value of <EM CLASS="Code">
dist</EM>
 when <EM CLASS="Code">
x=3</EM>
 and <EM CLASS="Code">
y=4</EM>
.  Similarly for the lambda function in the second example, but with a rank-3 array.</P>
<P CLASS="Body">
<A NAME="pgfId-66372"></A>The implementation of fromfunction consists of:</P>
<P CLASS="Python">
<A NAME="pgfId-66373"></A>def fromfunction(function, dimensions):</P>
<P CLASS="Python">
<A NAME="pgfId-66374"></A>    return apply(function, tuple(indices(dimensions)))</P>
<P CLASS="Body">
<A NAME="pgfId-66375"></A>which means that the function function is called with arguments given by the sequence indices(dimensions). As described in the definition of indices, this consists of arrays of indices which will be of rank one less than that specified by dimensions. This means that the function argument must accept the same number of arguments as there are dimensions in dimensions, and that each argument will be an array of the same shape as that specified by dimensions. Furthermore, the array which is passed as the first argument corresponds to the indices of each element in the resulting array along the first axis, that which is passed as the second argument corresponds to the indices of each element in the resulting array along the second axis, etc. A consequence of this is that the function which is used with fromfunction will work as expected only if it performs a separable computation on its arguments, and expects its arguments to be indices along each axis. Thus, no logical operation on the arguments can be performed, or any non-shape preserving operation. Thus, the following will not work as expected:</P>
<P CLASS="Python">
<A NAME="pgfId-66411"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
def buggy(test):</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66412"></A>...     <EM CLASS="CodeInput">
if test &gt; 4: return 1</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66413"></A>...    <EM CLASS="CodeInput">
 else: return 0</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66414"></A>...</P>
<P CLASS="Python">
<A NAME="pgfId-85993"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print fromfunction(buggy,(10,))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-85994"></A>1</P>
<P CLASS="BodyAfterHead">
<A NAME="pgfId-86004"></A>Here is how to do it properly. We add a print statement to the function for clarity:</P>
<P CLASS="Python">
<A NAME="pgfId-86013"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
def notbuggy(test):</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-86014"></A><EM CLASS="CodeInput">
...     print test</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-86015"></A><EM CLASS="CodeInput">
...     return where(test&gt;4,1,0)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-86016"></A><EM CLASS="CodeInput">
...</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-86017"></A><EM CLASS="CodeInput">
&gt;&gt;&gt; fromfunction(notbuggy,(10,))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-86018"></A>[0 1 2 3 4 5 6 7 8 9]</P>
<P CLASS="Python">
<A NAME="pgfId-86019"></A>array([0, 0, 0, 0, 0, 1, 1, 1, 1, 1])</P>
<P CLASS="Body">
<A NAME="pgfId-86008"></A>We leave it as an excercise for the reader to figure out why the &quot;buggy&quot; example gave the result 1.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-59602"></A><A NAME="marker-59606"></A>identity()</H6>
<P CLASS="Body">
<A NAME="pgfId-59603"></A>The simplest array constructor is the <EM CLASS="Code">
identity(n)</EM>
 function, which takes a single integer argument and returns a square identity array of that size of integers: </P>
<P CLASS="Python">
<A NAME="pgfId-35844"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print identity(5)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35845"></A>[[1 0 0 0 0]</P>
<P CLASS="Python">
<A NAME="pgfId-35846"></A> [0 1 0 0 0]</P>
<P CLASS="Python">
<A NAME="pgfId-35847"></A> [0 0 1 0 0]</P>
<P CLASS="Python">
<A NAME="pgfId-35848"></A> [0 0 0 1 0]</P>
<P CLASS="Python">
<A NAME="pgfId-35849"></A> [0 0 0 0 1]]</P>
<P CLASS="Python">
<A NAME="pgfId-35850"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
view(identity(100))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35851"></A><EM CLASS="Emphasis">
# shows black square with a single white diagonal</EM>
</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-35852"></A><A NAME="marker-59607"></A>Coercion and <A NAME="marker-59608"></A>Casting</H6>
<P CLASS="Body">
<A NAME="pgfId-35853"></A>We've mentioned the typecodes of arrays, and how to create arrays with the right typecode, but we haven't covered what happens when arrays with different typecodes interact.</P>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-35854"></A><A NAME="marker-59609"></A>Automatic Coercions and Binary Operations</H6>
<P CLASS="Body">
<A NAME="pgfId-35855"></A>The rules followed by NumPy when performing binary operations on arrays mirror those used by Python in general.  Operations between numeric and non-numeric types are not allowed (e.g. an array of characters can't be added to an array of numbers), and operations between mixed number types (e.g. floats and integers, floats and omplex numbers, or in the case of NumPy, operations between any two arrays with different numeric typecodes) first perform a coercion of the 'smaller' numeric type to the type of the `larger' numeric type.  Finally, when scalars and arrays are operated on together, the scalar is converted to a rank-0 array first. Thus, adding a &quot;small&quot; integer to a &quot;large&quot; floating point array is equivalent to first casting the integer &quot;up&quot; to the typecode of the array:</P>
<P CLASS="Python">
<A NAME="pgfId-35856"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
arange(0, 1.0, .1) + 12</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35857"></A>array([ 12. ,  12.1,  12.2,  12.3,  12.4,  12.5,  12.6,  12.7,  12.8,  12.9])</P>
<P CLASS="Body">
<A NAME="pgfId-35858"></A>The automatic coercions are described in Figure 1. Avoiding upcasting is discussed in <A HREF="numpy-6.html#29152" CLASS="XRef">Saving space</A>.</P>
<P CLASS="Body">
<A NAME="pgfId-35862"></A><EM CLASS="Code">
</EM>
&nbsp;</P>
<DIV>
<IMG SRC="numpy-6.gif" width="445" height="250">
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Figure">
<A NAME="pgfId-35863"></A>Up-casts are indicated with arrows.  Down-casts are allowed by the <EM CLASS="Code">
astype()</EM>
 method, but may result in loss of information.</H6>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-35864"></A>Deliberate up-casting: The asarray function</H6>
<P CLASS="Body">
<A NAME="pgfId-35865"></A>One more array constructor is the <EM CLASS="Code">
asarray()</EM>
 function. It is used if you want to have an array of a specific typecode and you don't know what typecode array you have (for example, in a generic function which can operate on all kinds of arrays, but needs them to be converted to complex arrays). If the array it gets as an argument is of the right typecode, it will get sent back unchanged. If the array is not of the right typecode, each element of the new array will be the result of the coercion to the new type of the old elements.  <EM CLASS="Code">
asarray()</EM>
 will refuse to operate if there might be loss of information -- in other words, <EM CLASS="Code">
asarray()</EM>
 only casts 'up'. </P>
<P CLASS="Body">
<A NAME="pgfId-35866"></A><EM CLASS="Code">
asarray</EM>
 is also used when you have a function that operates on arrays, but you want to allow people to call it with an arbitrary python sequence object. This gives your function a behavior similar to that of most of the builtin functions that operate on arrays. </P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-35867"></A>The <A NAME="marker-59613"></A>typecode value table</H6>
<P CLASS="Body">
<A NAME="pgfId-35868"></A>The typecodes identifiers (<EM CLASS="Code">
Float0</EM>
, etc.) have as values single-character strings.  The mapping between typecode and character strings is machine dependent.  An example of the correspondences between typecode characters and the typecode identifiers for 32-bit architectures are shown in Table 3-X.</P>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="TableTitle">
<A NAME="pgfId-35871"></A>Typecode character/identifier table on a Pentium computer</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId-35879"></A>Character</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId-35881"></A># of bytes</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId-35883"></A># of bits</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId-35885"></A>Identifiers</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35887"></A><EM CLASS="Code">
D</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35889"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35891"></A>128</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35893"></A><EM CLASS="Code">
Complex, Complex64</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35895"></A><EM CLASS="Code">
F</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35897"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35899"></A>64</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35901"></A><EM CLASS="Code">
Complex0, Complex16, Complex32, Complex8</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35903"></A><EM CLASS="Code">
d</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35905"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35907"></A>64</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35909"></A><EM CLASS="Code">
Float, Float64</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35911"></A><EM CLASS="Code">
f</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35913"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35915"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35917"></A><EM CLASS="Code">
Float0, Float16, Float32, Float8</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35919"></A><EM CLASS="Code">
l</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35921"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35923"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35925"></A><EM CLASS="Code">
Int</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35927"></A><EM CLASS="Code">
1</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35929"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35931"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35933"></A><EM CLASS="Code">
Int0, Int8</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35935"></A><EM CLASS="Code">
s</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35937"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35939"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35941"></A><EM CLASS="Code">
Int16</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35943"></A><EM CLASS="Code">
i</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35945"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35947"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35949"></A><EM CLASS="Code">
Int32</EM>
</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-35950"></A>Consequences of silent upcasting</H6>
<P CLASS="Body">
<A NAME="pgfId-35951"></A>When dealing with very large arrays of floats and if precision is not important (or arrays of small integers), then it may be worthwhile to cast the arrays to &quot;small&quot; typecodes, such as <EM CLASS="Code">
Int8</EM>
, <EM CLASS="Code">
Int16</EM>
 or <EM CLASS="Code">
Float32</EM>
.  As the standard Python integers and floats correspond to the typecodes <EM CLASS="Code">
Int32</EM>
 and <EM CLASS="Code">
Float64</EM>
, using them in apparently &quot;innocent&quot; ways will result in up-casting, which may null the benefit of the use of small typecode arrays.  For example:</P>
<P CLASS="Python">
<A NAME="pgfId-35952"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
mylargearray.typecode()</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35953"></A>'f'	#  a.k.a. Float32 on a Pentium</P>
<P CLASS="Python">
<A NAME="pgfId-35954"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
mylargearray.itemsize()</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35955"></A>4</P>
<P CLASS="Python">
<A NAME="pgfId-35956"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
mylargearray = mylargearray + 1</EM>
	# 1 is an Int64 on a Pentium</P>
<P CLASS="Python">
<A NAME="pgfId-35957"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
mylargearray.typecode()</EM>
	# see Fig. 1 for explanation.</P>
<P CLASS="Python">
<A NAME="pgfId-35958"></A>'d'</P>
<P CLASS="Python">
<A NAME="pgfId-35959"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
mylargearray.itemsize()</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35960"></A>8</P>
<P CLASS="Body">
<A NAME="pgfId-35961"></A>Note that the sizes returned by the <EM CLASS="Code">
itemsize()</EM>
 method are expressed in bytes.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-68241"></A><A NAME="29152"></A>Saving space</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-68245"></A>Numeric arrays can be created using an optional, keyworded argument to the constructor, savespace. If savespace is set to 1, Numeric will attempt to avoid the silent upcasting behavior. The status of an array can be queried with the spacesaver() method. If x.spacesaver() is true, x has its space-saving flag set. The flag can be set with the savespace method: x.savespace(1) to set it, x.savespace(0) to clear it.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-35975"></A>Deliberate casts (potentially down): the <A NAME="marker-59617"></A>astype method</H6>
<P CLASS="Body">
<A NAME="pgfId-35976"></A>You may also force NumPy to cast any number array to another number array.  For example, to take an array of any numeric type (IntX or FloatX or ComplexX or UnsignedInt8) and convert it to a 64-bit float, one can do:</P>
<P CLASS="Python">
<A NAME="pgfId-35977"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
floatarray = otherarray.astype(Float64)</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-35978"></A>The typecode can be any of the number typecodes, &quot;larger&quot; or &quot;smaller&quot;.  If it is larger, this is a cast-up, as if asarray() had been used.  If it is smaller, the standard casting rules of the underlying language (C) are used, which means that truncation or loss of precision can occur:</P>
<P CLASS="Python">
<A NAME="pgfId-35979"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35980"></A>[ 0.   0.4  0.8  1.2  1.6]</P>
<P CLASS="Python">
<A NAME="pgfId-35981"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x.astype(Int)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35982"></A>array([0, 0, 0, 1, 1])</P>
<P CLASS="Body">
<A NAME="pgfId-35983"></A>If the typecode used with <EM CLASS="Code">
astype()</EM>
 is the original array's typecode, then a copy of the original array is returned.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-35984"></A>Operating on Arrays</H6>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-35985"></A>Simple operations </H6>
<P CLASS="Body">
<A NAME="pgfId-35986"></A>If you have a keen eye, you have noticed that some of the previous examples did something new: they added a number to an array. Indeed, most Python operations applicable to numbers are directly applicable to arrays: </P>
<P CLASS="Python">
<A NAME="pgfId-35987"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35988"></A>[1 2 3]</P>
<P CLASS="Python">
<A NAME="pgfId-35989"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a * 3</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35990"></A>[3 6 9]</P>
<P CLASS="Python">
<A NAME="pgfId-35991"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a + 3</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35992"></A>[4 5 6]</P>
<P CLASS="Body">
<A NAME="pgfId-35993"></A>Note that the mathematical operators behave differently depending on the types of their operands. When one of the operands is an array and the other is a number, the number is added to all the elements of the array and the resulting array is returned. This is called <EM CLASS="Emphasis">
broadcasting</EM>
. This also occurs for unary mathematical operations such as sin and the negative sign</P>
<P CLASS="Python">
<A NAME="pgfId-35994"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print sin(a)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35995"></A>[ 0.84147098  0.90929743  0.14112001]</P>
<P CLASS="Python">
<A NAME="pgfId-35996"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print -a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35997"></A>[-1 -2 -3]</P>
<P CLASS="Body">
<A NAME="pgfId-35998"></A>When both elements are arrays with the same shape, then a new array is created, where each element is the sum of the corresponding elements in the original arrays: </P>
<P CLASS="Python">
<A NAME="pgfId-35999"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a + a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36000"></A>[2 4 6]</P>
<P CLASS="Body">
<A NAME="pgfId-36001"></A>If the operands of operations such as addition are arrays which have the same rank but different non-integer dimensions, then an exception is generated: </P>
<P CLASS="Python">
<A NAME="pgfId-36002"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36003"></A>[1 2 3]</P>
<P CLASS="Python">
<A NAME="pgfId-36004"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
b = array([4,5,6,7])</EM>
	# note this has four elements</P>
<P CLASS="Python">
<A NAME="pgfId-36005"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a + b</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36006"></A>Traceback (innermost last):</P>
<P CLASS="Python">
<A NAME="pgfId-36007"></A>  File ``&lt;stdin&gt;``, line 1, in ?</P>
<P CLASS="Python">
<A NAME="pgfId-36008"></A>ArrayError: frames are not aligned</P>
<P CLASS="Body">
<A NAME="pgfId-36009"></A>This is because there is no reasonable way for NumPy to interpret addition of a <EM CLASS="Code">
(3,)</EM>
 shaped array and a <EM CLASS="Code">
(4,) </EM>
shaped array.</P>
<P CLASS="Body">
<A NAME="pgfId-36010"></A>Note what happens  when adding arrays with different rank </P>
<P CLASS="Python">
<A NAME="pgfId-36011"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36012"></A>[1 2 3]</P>
<P CLASS="Python">
<A NAME="pgfId-36013"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print b</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36014"></A>[[ 4  8 12]</P>
<P CLASS="Python">
<A NAME="pgfId-36015"></A> [ 5  9 13]</P>
<P CLASS="Python">
<A NAME="pgfId-36016"></A> [ 6 10 14]</P>
<P CLASS="Python">
<A NAME="pgfId-36017"></A> [ 7 11 15]]</P>
<P CLASS="Python">
<A NAME="pgfId-36018"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a + b</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36019"></A>[[ 5 10 15]</P>
<P CLASS="Python">
<A NAME="pgfId-36020"></A> [ 6 11 16]</P>
<P CLASS="Python">
<A NAME="pgfId-36021"></A> [ 7 12 17]</P>
<P CLASS="Python">
<A NAME="pgfId-36022"></A> [ 8 13 18]]</P>
<P CLASS="Body">
<A NAME="pgfId-36023"></A>This is another form of broadcasting. To understand this, one needs to look carefully at the shapes of <EM CLASS="Code">
a</EM>
 and <EM CLASS="Code">
b</EM>
: </P>
<P CLASS="Python">
<A NAME="pgfId-36024"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a.shape</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36025"></A>(3,)</P>
<P CLASS="Python">
<A NAME="pgfId-36026"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
b.shape</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36027"></A>(4,3)</P>
<P CLASS="Body">
<A NAME="pgfId-36028"></A>Because array <EM CLASS="Code">
a</EM>
's last dimension had length 3 and array <EM CLASS="Code">
b</EM>
's last dimension also had length 3, those two dimensions were &quot;matched&quot; and a new dimension was created and automatically &quot;assumed&quot; for array a.  The data already in <EM CLASS="Code">
a</EM>
 was &quot;replicated&quot; as many times as needed (4, in this case) to make the two shapes of the operand arrays conform.  This replication (broadcasting) occurs when arrays are operands to binary operations and their shapes differ and when the following conditions are true:</P>
<UL>
<LI CLASS="BulletLev2">
<A NAME="pgfId-36029"></A>starting from the last axis, the axis lengths (dimensions) of the operands are compared</LI>
<LI CLASS="BulletLev2">
<A NAME="pgfId-36030"></A>if both arrays have an axis length greater than 1, an exception is raised</LI>
<LI CLASS="BulletLev2">
<A NAME="pgfId-36031"></A>if one array has an axis length greater than 1, then the other array's axis is &quot;stretched&quot; to match the length of the first axis -- if the other array's axis is not present (i.e., if the other array has smaller rank), then a new axis of the same length is created.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-36032"></A>This algorithm is complex, but intuitive in practice.  For more details, consult the Numeric Reference.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-85860"></A>In-place operations</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-85864"></A>Beginning with Python 2.0, Python supports the in-place operators +=, -=, *=, and /=. Numeric supports these operations but you need to be careful. The right-hand side should be of the same typecode. Some violation of this is possible as the following example shows, but in general contortions may be necessary for using the smaller &quot;kinds&quot; of typecodes.</P>
<P CLASS="Python">
<A NAME="pgfId-85870"></A><EM CLASS="CodeInput">
&gt;&gt;&gt; x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-85871"></A>array([ 5.,  6.,  7.])</P>
<P CLASS="Python">
<A NAME="pgfId-85872"></A><EM CLASS="CodeInput">
&gt;&gt;&gt; x+= 3.</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-85873"></A><EM CLASS="CodeInput">
&gt;&gt;&gt; id(x)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-85874"></A>8253904</P>
<P CLASS="Python">
<A NAME="pgfId-85875"></A><EM CLASS="CodeInput">
&gt;&gt;&gt; y=x.astype(Float32)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-85876"></A><EM CLASS="CodeInput">
&gt;&gt;&gt; y+=2</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-85877"></A>Traceback (most recent call last):</P>
<P CLASS="Python">
<A NAME="pgfId-85878"></A>  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</P>
<P CLASS="Python">
<A NAME="pgfId-85879"></A>TypeError: return array has incorrect type</P>
<P CLASS="Python">
<A NAME="pgfId-85880"></A><EM CLASS="CodeInput">
&gt;&gt;&gt; y+=array(2.).astype(Float32)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-85881"></A><EM CLASS="CodeInput">
&gt;&gt;&gt; y</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-85882"></A>array([ 10.,  11.,  12.],'f')</P>
<P CLASS="FirstBody">
<A NAME="pgfId-85926"></A>This area clearly needs improvement.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36033"></A><A NAME="marker-59618"></A>Getting and <A NAME="marker-59619"></A>Setting array values</H6>
<P CLASS="Body">
<A NAME="pgfId-36034"></A>Just like other Python sequences, array contents are manipulated with the [] notation. For rank-1 arrays, there are no differences between list and array notations:</P>
<P CLASS="Python">
<A NAME="pgfId-36035"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = arrayrange(10)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36036"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[0]	</EM>
# get first element</P>
<P CLASS="Python">
<A NAME="pgfId-36037"></A>0</P>
<P CLASS="Python">
<A NAME="pgfId-36038"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[1:5]	</EM>
# get second through fifth element</P>
<P CLASS="Python">
<A NAME="pgfId-36039"></A>[1 2 3 4]</P>
<P CLASS="Python">
<A NAME="pgfId-36040"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[-1]	</EM>
# get last element</P>
<P CLASS="Python">
<A NAME="pgfId-36041"></A>9</P>
<P CLASS="Python">
<A NAME="pgfId-86082"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[:-1] </EM>
	# get all but last element</P>
<P CLASS="Python">
<A NAME="pgfId-86083"></A>[0 1 2 3 4 5 6 7 8]</P>
<P CLASS="Body">
<A NAME="pgfId-36042"></A>The first difference with lists comes with multidimensional indexing.  If an array is multidimensional (of rank &gt; 1), then specifying a single integer index will return an array of dimension one less than the original array. </P>
<P CLASS="Python">
<A NAME="pgfId-36043"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = arrayrange(9)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36044"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a.shape = (3,3)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36045"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36046"></A>[[0 1 2]</P>
<P CLASS="Python">
<A NAME="pgfId-36047"></A> [3 4 5]</P>
<P CLASS="Python">
<A NAME="pgfId-36048"></A> [6 7 8]]</P>
<P CLASS="Python">
<A NAME="pgfId-36049"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[0]	</EM>
# get first row, not first element!</P>
<P CLASS="Python">
<A NAME="pgfId-36050"></A>[0 1 2]</P>
<P CLASS="Python">
<A NAME="pgfId-36051"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[1]	</EM>
# get second row</P>
<P CLASS="Python">
<A NAME="pgfId-36052"></A>[3 4 5]</P>
<P CLASS="Body">
<A NAME="pgfId-36053"></A>To get to individual elements in a rank-2 array, one specifies both indices separated by commas:</P>
<P CLASS="Python">
<A NAME="pgfId-36054"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[0,0]	</EM>
# get elt at first row, first column</P>
<P CLASS="Python">
<A NAME="pgfId-36055"></A>0</P>
<P CLASS="Python">
<A NAME="pgfId-36056"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[0,1]	</EM>
# get elt at first row, second column</P>
<P CLASS="Python">
<A NAME="pgfId-36057"></A>1</P>
<P CLASS="Python">
<A NAME="pgfId-36058"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[1,0]	</EM>
# get elt at second row, first column</P>
<P CLASS="Python">
<A NAME="pgfId-36059"></A>3</P>
<P CLASS="Python">
<A NAME="pgfId-36060"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[2,-1]	</EM>
# get elt at third row, last column</P>
<P CLASS="Python">
<A NAME="pgfId-36061"></A>8</P>
<P CLASS="Body">
<A NAME="pgfId-36062"></A>Of course, the <EM CLASS="Code">
[]</EM>
 notation can be used to <EM CLASS="Emphasis">
set</EM>
 values as well: </P>
<P CLASS="Python">
<A NAME="pgfId-36063"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a[0,0] = 123</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36064"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36065"></A>[[123   1   2]</P>
<P CLASS="Python">
<A NAME="pgfId-36066"></A> [  3   4   5]</P>
<P CLASS="Python">
<A NAME="pgfId-36067"></A> [  6   7   8]]</P>
<P CLASS="Body">
<A NAME="pgfId-36068"></A>Note that when referring to rows, the right hand side of the equal sign needs to be a sequence which &quot;fits&quot; in the referred array subset (in the code sample below, a 3-element row):</P>
<P CLASS="Python">
<A NAME="pgfId-36069"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a[1] = [10,11,12]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36070"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36071"></A>[[123   1   2]</P>
<P CLASS="Python">
<A NAME="pgfId-36072"></A> [ 10  11  12]</P>
<P CLASS="Python">
<A NAME="pgfId-36073"></A> [  6   7   8]]</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36074"></A><A NAME="marker-59620"></A>Slicing Arrays </H6>
<P CLASS="Body">
<A NAME="pgfId-36075"></A>The standard rules of Python slicing apply to arrays, on a per-dimension basis. Assuming a 3x3 array: </P>
<P CLASS="Python">
<A NAME="pgfId-36076"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = reshape(arrayrange(9),(3,3))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36077"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36078"></A>[[0 1 2]</P>
<P CLASS="Python">
<A NAME="pgfId-36079"></A> [3 4 5]</P>
<P CLASS="Python">
<A NAME="pgfId-36080"></A> [6 7 8]]</P>
<P CLASS="Body">
<A NAME="pgfId-36081"></A>The plain [<A NAME="marker-59830"></A>:] operator slices from beginning to end:</P>
<P CLASS="Python">
<A NAME="pgfId-36082"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[:,:]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36083"></A>[[0 1 2]</P>
<P CLASS="Python">
<A NAME="pgfId-36084"></A> [3 4 5]</P>
<P CLASS="Python">
<A NAME="pgfId-36085"></A> [6 7 8]]</P>
<P CLASS="Body">
<A NAME="pgfId-36086"></A>In other words, [:] with no arguments is the same as [:] for lists - it can be read &quot;all indices along this axis&quot;. So, to get the second row along the second dimension: </P>
<P CLASS="Python">
<A NAME="pgfId-36087"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[:,1]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36088"></A>[1 4 7]</P>
<P CLASS="Body">
<A NAME="pgfId-36089"></A>Note that what was a &quot;column&quot; vector is now a &quot;row&quot; vector -- any &quot;integer slice&quot; (as in the 1 in the example above) results in a returned array with rank one less than the input array.</P>
<P CLASS="Body">
<A NAME="pgfId-36090"></A>If one does not specify as many slices as there are dimensions in an array, then the remaining slices are assumed to be &quot;all&quot;. If <EM CLASS="Code">
A</EM>
 is a rank-3 array, then</P>
<P CLASS="Python">
<A NAME="pgfId-36091"></A><EM CLASS="Code">
A[1] == A[1,:] == A[1,:,:]</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-36092"></A>There is one addition to the slice notation for arrays which does not exist for lists, and that is the optional third argument, meaning the ``step size'' also called stride or increment.  Its default value is 1, meaning return every element in the specified range.  Alternate values allow one to skip some of the elements in the slice: </P>
<P CLASS="Python">
<A NAME="pgfId-36093"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = arange(12)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36094"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36095"></A>[ 0  1  2  3  4  5  6  7  8  9 10 11]</P>
<P CLASS="Python">
<A NAME="pgfId-36096"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[::2]</EM>
<A NAME="marker-59831"></A>	# return every *other* element</P>
<P CLASS="Python">
<A NAME="pgfId-36097"></A>[ 0  2  4  6  8 10]</P>
<P CLASS="Body">
<A NAME="pgfId-36098"></A>Negative strides are allowed as long as the starting index is greater than the stopping index:</P>
<P CLASS="Python">
<A NAME="pgfId-36099"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = reshape(arrayrange(9),(3,3))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36100"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36101"></A>[[0 1 2]</P>
<P CLASS="Python">
<A NAME="pgfId-36102"></A> [3 4 5]</P>
<P CLASS="Python">
<A NAME="pgfId-36103"></A> [6 7 8]]</P>
<P CLASS="Python">
<A NAME="pgfId-36104"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[:, 0]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36105"></A>[0 3 6]</P>
<P CLASS="Python">
<A NAME="pgfId-36106"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[0:3, 0]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36107"></A>[0 3 6]</P>
<P CLASS="Python">
<A NAME="pgfId-36108"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[2::-1, 0]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36109"></A>[6 3 0]</P>
<P CLASS="Body">
<A NAME="pgfId-36110"></A>If a negative stride is specified and the starting or stopping indices are omitted, they default to &quot;end of axis&quot; and &quot;beginning of axis&quot; respectively.  Thus, the following two statements are equivalent for the array given:</P>
<P CLASS="Python">
<A NAME="pgfId-36111"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[2::-1, 0]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36112"></A>[6 3 0]</P>
<P CLASS="Python">
<A NAME="pgfId-36113"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[::-1, 0]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36114"></A>[6 3 0]</P>
<P CLASS="Python">
<A NAME="pgfId-36115"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[::-1]</EM>
	# this reverses only the first axis</P>
<P CLASS="Python">
<A NAME="pgfId-36116"></A>[[6 7 8]</P>
<P CLASS="Python">
<A NAME="pgfId-36117"></A> [3 4 5]</P>
<P CLASS="Python">
<A NAME="pgfId-36118"></A> [0 1 2]]</P>
<P CLASS="Python">
<A NAME="pgfId-36119"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[::-1,::-1]</EM>
	# this reverses both axes  </P>
<P CLASS="Python">
<A NAME="pgfId-36120"></A>[[8 7 6]</P>
<P CLASS="Python">
<A NAME="pgfId-36121"></A> [5 4 3]</P>
<P CLASS="Python">
<A NAME="pgfId-36122"></A> [2 1 0]]</P>
<P CLASS="Body">
<A NAME="pgfId-36123"></A>One final way of slicing arrays is with the keyword <EM CLASS="Code">
...</EM>
<A NAME="marker-59821"></A> This keyword is somewhat complicated. It stands for ``however many `:' I need depending on the rank of the object I'm indexing, so that the indices I *do* specify are at the end of the index list as opposed to the usual beginning.`` </P>
<P CLASS="Body">
<A NAME="pgfId-59823"></A>So, if one has a rank-3 array <EM CLASS="Code">
A</EM>
, then <EM CLASS="Code">
A[...,0]</EM>
 is the same thing as <EM CLASS="Code">
A[:,:,0]</EM>
 but if <EM CLASS="Code">
B</EM>
 is rank-4, then  <EM CLASS="Code">
B[...,0] </EM>
is the same thing as: <EM CLASS="Code">
B[:,:,:,0]</EM>
. Only one <EM CLASS="CodeInput">
...</EM>
 is expanded in an index expression, so if one has a rank-5 array <EM CLASS="Code">
C</EM>
, then:  <EM CLASS="Code">
C[...,0,...]</EM>
 is the same thing as  <EM CLASS="Code">
C[:,:,:,0,:]</EM>
.</P>
<P CLASS="Body">
<A NAME="pgfId-36125"></A>&nbsp;</P>
</DIV>
</DIV>
<P><A HREF="numpy.html">Go to Main</A>      <A HREF="numpy-5.html">Go to Previous</A>       <A HREF="numpy-7.html">Go to Next</A></P>
</BODY>
</HTML>
