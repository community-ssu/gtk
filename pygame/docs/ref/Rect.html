<html>
<title>Rect</title>
<body bgcolor=#aaeebb text=#000000 link=#331111 vlink=#331111>


<table cellspacing=3 width=100%><tr><td bgcolor=#00000>
<table width=100%><tr><td bgcolor=c2fc20 align=center>
    <a href=http://www.pygame.org>
    <img src=../pygame_tiny.gif border=0 width=200 height=60></a><br>
    <b>pygame&nbsp;&nbsp;&nbsp;documentation</b>
</td><td bgcolor=6aee28 align=center valign=top width=100%>

	||&nbsp;
	<a href=http://www.pygame.org>Home</a> &nbsp;||&nbsp;
	<a href=../index.html>Help Contents</a> &nbsp;||
	<br>&nbsp;<br>

|| <a href=pygame.html>pygame</a> || 
<a href=pygame_cdrom.html>cdrom</a> || 
<a href=pygame_constants.html>constants</a> || 
<a href=pygame_display.html>display</a> || 
<a href=pygame_draw.html>draw</a> || 
<a href=pygame_event.html>event</a> ||<br>
|| <a href=pygame_font.html>font</a> || 
<a href=pygame_image.html>image</a> || 
<a href=pygame_joystick.html>joystick</a> || 
<a href=pygame_key.html>key</a> || 
<a href=pygame_mixer.html>mixer</a> || 
<a href=pygame_mixer_music.html>mixer_music</a> ||<br>
|| <a href=pygame_mouse.html>mouse</a> || 
<a href=pygame_movie.html>movie</a> || 
<a href=pygame_sndarray.html>sndarray</a> || 
<a href=pygame_surfarray.html>surfarray</a> || 
<a href=pygame_time.html>time</a> || 
<a href=pygame_transform.html>transform</a> ||<br>
&nbsp;<br>|| <a href=CD.html>CD</a> || 
<a href=Channel.html>Channel</a> || 
<a href=Clock.html>Clock</a> || 
<a href=Font.html>Font</a> || 
<a href=Joystick.html>Joystick</a> || 
<a href=Movie.html>Movie</a> ||<br>
|| <a href=Rect.html>Rect</a> || 
<a href=Sound.html>Sound</a> || 
<a href=Surface.html>Surface</a> ||<br>
&nbsp;<br>|| <a href=pygame_color.html>color</a> || 
<a href=pygame_cursors.html>cursors</a> || 
<a href=pygame_sprite.html>sprite</a> ||<br>


</td></tr></table></td></tr></table>
<br>
<h2 align=center>Rect</h2>
The rectangle object is a useful object
representing a rectangle area. Rectangles are
created from the <a href=pygame.html#Rect>pygame.Rect()</a> function. This routine
is also in the locals module, so importing the locals
into your namespace allows you to just use <a href=pygame.html#Rect>Rect()</a>.
<br>&nbsp;<br>
Rect contains helpful methods, as well as a list of
modifiable members:
<table border="0" cellspacing=0 cellpadding=0 width=66%><tr valign=top><td align=left><ul><li>top<li>bottom<li>left<li>right</ul></td>
<td align=left><ul><li>topleft<li>topright<li>bottomleft<li>bottomright</ul></td>
<td align=left><ul><li>midleft<li>midright<li>midtop<li>midbottom</ul></td>
<td align=left><ul><li>center<li>centerx<li>centery</ul></td>
<td align=left><ul><li>size<li>width<li>height</ul></td>
</tr></table><br>
When changing these members, the rectangle
will be moved to the given assignment. (except when
changing the size, width, or height member, which will
resize the rectangle from the topleft corner)
<br>&nbsp;<br>
The rectstyle arguments used frequently with the
Rect object (and elsewhere in pygame) is one of
the following things.
<table border=0 cellspacing=0 cellpadding=0 width=80%>
<tr align=left valign=top><td align=left valign=middle width=20%><blockquote> </blockquote></td><td align=left valign=top><ul>
<li>an actual Rect object. 
<li>a sequence of [xpos, ypos, width, height]. 
<li>a pair of sequences, representing the position and size [[xpos, ypos], [width,height]]. 
<li>if a method takes a rectstyle argument <b>as its <i>only</i> argument</b>, you can simply pass four arguments representing xpos, ypos, width, height. 
</ul>and perhaps most importantly:
<ul><li>A rectstyle argument can also be <b><strong>_any_ python object</b> with an attribute named <b>'rect'.</b></strong>
</ul></td></tr></table>

<hr>

<table>
<tr><td><a href=#clamp>clamp</a></td><td> -
move rectangle inside another</td></tr>


<tr><td><a href=#clamp_ip>clamp_ip</a></td><td> -
moves the rectangle inside another</td></tr>


<tr><td><a href=#clip>clip</a></td><td> -
rectangle cropped inside another</td></tr>


<tr><td><a href=#collidedict>collidedict</a></td><td> -
find overlapping rectangle in a dictionary</td></tr>


<tr><td><a href=#collidedictall>collidedictall</a></td><td> -
find all overlapping rectangles</td></tr>


<tr><td><a href=#collidelist>collidelist</a></td><td> -
find overlapping rectangle</td></tr>


<tr><td><a href=#collidelistall>collidelistall</a></td><td> -
find all overlapping rectangles</td></tr>


<tr><td><a href=#collidepoint>collidepoint</a></td><td> -
point inside rectangle</td></tr>


<tr><td><a href=#colliderect>colliderect</a></td><td> -
check overlapping rectangles</td></tr>


<tr><td><a href=#contains>contains</a></td><td> -
check if rectangle fully inside another</td></tr>


<tr><td><a href=#inflate>inflate</a></td><td> -
new rectangle with size changed</td></tr>


<tr><td><a href=#inflate_ip>inflate_ip</a></td><td> -
changes the Rect size</td></tr>


<tr><td><a href=#move>move</a></td><td> -
new rectangle with position changed</td></tr>


<tr><td><a href=#move_ip>move_ip</a></td><td> -
move the Rect by the given offset</td></tr>


<tr><td><a href=#normalize>normalize</a></td><td> -
corrects negative sizes</td></tr>


<tr><td><a href=#union>union</a></td><td> -
makes new rectangle covering both inputs</td></tr>


<tr><td><a href=#union_ip>union_ip</a></td><td> -
rectangle covering both input</td></tr>


<tr><td><a href=#unionall>unionall</a></td><td> -
rectangle covering all inputs</td></tr>


<tr><td><a href=#unionall_ip>unionall_ip</a></td><td> -
rectangle covering all inputs</td></tr>


</table>

<hr>

<a name=clamp><font size=+2><b>clamp
</b></font><br><font size=+1><tt>
Rect.clamp(rectstyle) -> Rect
</tt></font><ul>
Returns a new rectangle that is moved to be
completely inside the argument rectangle. If the base
rectangle is too large for the argument rectangle in
an axis, it will be centered on that axis.
</ul><br>&nbsp;<br>

<a name=clamp_ip><font size=+2><b>clamp_ip
</b></font><br><font size=+1><tt>
Rect.clamp_ip(rectstyle) -> None
</tt></font><ul>
Moves the Rect to be
completely inside the argument rectangle. If the given
rectangle is too large for the argument rectangle in
an axis, it will be centered on that axis.
</ul><br>&nbsp;<br>

<a name=clip><font size=+2><b>clip
</b></font><br><font size=+1><tt>
Rect.clip(rectstyle) -> Rect
</tt></font><ul>
Returns a new rectangle that is the given
rectangle cropped to the inside of the base
rectangle. If the two rectangles do not overlap to
begin with, you will get a rectangle with 0 size.
</ul><br>&nbsp;<br>

<a name=collidedict><font size=+2><b>collidedict
</b></font><br><font size=+1><tt>
Rect.collidedict(dict if rectstyle keys) -> key/value pair
</tt></font><ul>
Returns the key/value pair of the first rectangle key
in the dict that overlaps the base rectangle. Once an
overlap is found, this will stop checking the
remaining list. If no overlap is found, it will
return None.
<br>&nbsp;<br>
Remember python dictionary keys must be immutable,
Rects are not immutable, so they cannot directly be,
dictionary keys. You can convert the Rect to a tuple
with the tuple() builtin command.
</ul><br>&nbsp;<br>

<a name=collidedictall><font size=+2><b>collidedictall
</b></font><br><font size=+1><tt>
Rect.collidedictall(rectstyle list) -> key/val list
</tt></font><ul>
Returns a list of the indexes that contain
rectangles overlapping the base rectangle. If no
overlap is found, it will return an empty
sequence.
<br>&nbsp;<br>
Remember python dictionary keys must be immutable,
Rects are not immutable, so they cannot directly be,
dictionary keys. You can convert the Rect to a tuple
with the tuple() builtin command.
</ul><br>&nbsp;<br>

<a name=collidelist><font size=+2><b>collidelist
</b></font><br><font size=+1><tt>
Rect.collidelist(rectstyle list) -> int index
</tt></font><ul>
Returns the index of the first rectangle in the
list to overlap the base rectangle. Once an
overlap is found, this will stop checking the
remaining list. If no overlap is found, it will
return -1.
</ul><br>&nbsp;<br>

<a name=collidelistall><font size=+2><b>collidelistall
</b></font><br><font size=+1><tt>
Rect.collidelistall(rectstyle list) -> index list
</tt></font><ul>
Returns a list of the indexes that contain
rectangles overlapping the base rectangle. If no
overlap is found, it will return an empty
sequence.
</ul><br>&nbsp;<br>

<a name=collidepoint><font size=+2><b>collidepoint
</b></font><br><font size=+1><tt>
Rect.collidepoint(x, y) -> bool
</tt></font><ul>
Returns true if the given point position is inside
the rectangle. If a point is on the border, it is
counted as inside.
</ul><br>&nbsp;<br>

<a name=colliderect><font size=+2><b>colliderect
</b></font><br><font size=+1><tt>
Rect.colliderect(rectstyle) -> bool
</tt></font><ul>
Returns true if any area of the two rectangles
overlaps.
</ul><br>&nbsp;<br>

<a name=contains><font size=+2><b>contains
</b></font><br><font size=+1><tt>
Rect.contains(rectstyle) -> bool
</tt></font><ul>
Returns true when the given rectangle is entirely
inside the base rectangle.
</ul><br>&nbsp;<br>

<a name=inflate><font size=+2><b>inflate
</b></font><br><font size=+1><tt>
Rect.inflate(x, y) -> Rect
</tt></font><ul>
Returns a new rectangle which has the sizes
changed by the given amounts. The rectangle
shrinks and expands around the rectangle's center.
Negative values will shrink the rectangle.
</ul><br>&nbsp;<br>

<a name=inflate_ip><font size=+2><b>inflate_ip
</b></font><br><font size=+1><tt>
Rect.inflate_ip(x, y) -> None
</tt></font><ul>
Changes the Rect by the given amounts. The rectangle
shrinks and expands around the rectangle's center.
Negative values will shrink the rectangle.
</ul><br>&nbsp;<br>

<a name=move><font size=+2><b>move
</b></font><br><font size=+1><tt>
Rect.move(x, y) -> Rect
</tt></font><ul>
Returns a new rectangle which is the base
rectangle moved by the given amount.
</ul><br>&nbsp;<br>

<a name=move_ip><font size=+2><b>move_ip
</b></font><br><font size=+1><tt>
Rect.move_ip(x, y) -> None
</tt></font><ul>
Moves the rectangle which by the given amount.
</ul><br>&nbsp;<br>

<a name=normalize><font size=+2><b>normalize
</b></font><br><font size=+1><tt>
Rect.normalize() -> None
</tt></font><ul>
If the rectangle has a a negative size in width or
height, this will flip that axis so the sizes are
positive, and the rectangle remains in the same
place.
</ul><br>&nbsp;<br>

<a name=union><font size=+2><b>union
</b></font><br><font size=+1><tt>
Rect.union(rectstyle) -> Rect
</tt></font><ul>
Returns a new Rect to completely cover the
given input. There may be area inside the new
Rect that is not covered by either input.
</ul><br>&nbsp;<br>

<a name=union_ip><font size=+2><b>union_ip
</b></font><br><font size=+1><tt>
Rect.union_ip(rectstyle) -> None
</tt></font><ul>
Resizes the Rect to completely cover the
given input. There may be area inside the new
dimensions that is not covered by either input.
</ul><br>&nbsp;<br>

<a name=unionall><font size=+2><b>unionall
</b></font><br><font size=+1><tt>
Rect.unionall(sequence_of_rectstyles) -> Rect
</tt></font><ul>
Returns a new rectangle that completely covers all the
given inputs. There may be area inside the new
rectangle that is not covered by the inputs.
</ul><br>&nbsp;<br>

<a name=unionall_ip><font size=+2><b>unionall_ip
</b></font><br><font size=+1><tt>
Rect.unionall_ip(sequence_of_rectstyles) -> None
</tt></font><ul>
Resizes the rectangle to completely cover all the
given inputs. There may be area inside the new
rectangle that is not covered by the inputs.
</ul><br>&nbsp;<br>


<hr>
</body></html>
