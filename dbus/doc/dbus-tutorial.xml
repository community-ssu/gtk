<?xml version="1.0" standalone="no"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd"
[
]>

<article id="index">
  <articleinfo>
    <title>D-BUS Tutorial</title>
    <releaseinfo>Version 0.2</releaseinfo>
    <date>10 August 2004</date>
    <authorgroup>
      <author>
	<firstname>Havoc</firstname>
	<surname>Pennington</surname>
	<affiliation>
	  <orgname>Red Hat, Inc.</orgname>
	  <address>
	    <email>hp@pobox.com</email>
	  </address>
	</affiliation>
      </author>
    </authorgroup>
  </articleinfo>

  <sect1 id="whatis">
    <title>What is D-BUS?</title>
    <para>
      D-BUS is a system for <firstterm>interprocess communication</firstterm>
      (IPC). Architecturally, it has several layers:

      <itemizedlist>
        <listitem>
          <para>
            A library, <firstterm>libdbus</firstterm>, that allows two
            applications to connect to each other and exchange messages.
          </para>
        </listitem>
        <listitem>
          <para>
            A <firstterm>message bus daemon</firstterm> executable, built on
            libdbus, that multiple applications can connect to. The daemon can
            route messages from one application to zero or more other
            applications.
          </para>
        </listitem>
        <listitem>
          <para>
            <firstterm>Wrapper libraries</firstterm> based on particular
            application frameworks.  For example, libdbus-glib and
            libdbus-qt. There are also bindings to languages such as
            Python. These wrapper libraries are the API most people should use,
            as they simplify the details of D-BUS programming. libdbus is 
            intended to be a low-level backend for the higher level bindings.
            Much of the libdbus API is only useful for binding implementation.
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      If you just want to use D-BUS and don't care how it works, jump directly
      to <xref linkend="concepts"/>.
      Otherwise, read on.
    </para>

    <para>
      libdbus only supports one-to-one connections, just like a raw network
      socket. However, rather than sending byte streams over the connection, you
      send <firstterm>messages</firstterm>. Messages have a header identifying
      the kind of message, and a body containing a data payload. libdbus also
      abstracts the exact transport used (sockets vs. whatever else), and
      handles details such as authentication.
    </para>

    <para>
      The message bus daemon forms the hub of a wheel. Each spoke of the wheel
      is a one-to-one connection to an application using libdbus.  An
      application sends a message to the bus daemon over its spoke, and the bus
      daemon forwards the message to other connected applications as
      appropriate. Think of the daemon as a router.
    </para>

    <para>
      The bus daemon has multiple instances on a typical computer.  The
      first instance is a machine-global singleton, that is, a system daemon
      similar to sendmail or Apache. This instance has heavy security
      restrictions on what messages it will accept, and is used for systemwide
      communication. The other instances are created one per user login session.
      These instances allow applications in the user's session to communicate 
      with one another.
    </para>

    <para>
      The systemwide and per-user daemons are separate.  Normal within-session
      IPC does not involve the systemwide message bus process and vice versa.
    </para>

    <sect2 id="uses">
      <title>D-BUS applications</title>
      <para>
        There are many, many technologies in the world that have "Inter-process
        communication" or "networking" in their stated purpose: <ulink
        url="http://www.mbus.org/">MBUS</ulink>, <ulink
        url="http://www.omg.org">CORBA</ulink>, <ulink
        url="http://www.xmlrpc.com">XML-RPC</ulink>, <ulink
        url="http://www.w3.org/TR/SOAP/">SOAP</ulink>, and probably hundreds
        more.  Each of these is tailored for particular kinds of application.
        D-BUS is designed for two specific cases:
        <itemizedlist>
          <listitem>
            <para>
              Communication between desktop applications in the same desktop
              session; to allow integration of the desktop session as a whole,
              and address issues of process lifecycle (when do desktop components 
              start and stop running).
            </para>
          </listitem>
          <listitem>
            <para>
              Communication between the desktop session and the operating system, 
              where the operating system would typically include the kernel 
              and any system daemons or processes.
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
        For the within-desktop-session use case, the GNOME and KDE desktops 
        have significant previous experience with different IPC solutions
        such as CORBA and DCOP. D-BUS is built on that experience and 
        carefully tailored to meet the needs of these desktop projects 
        in particular.
      </para>
      <para>
        The problem solved by the systemwide or communication-with-the-OS case 
        is explained well by the following text from the Linux Hotplug project:
        <blockquote>
          <para>
           A gap in current Linux support is that policies with any sort of
           dynamic "interact with user" component aren't currently
           supported. For example, that's often needed the first time a network
           adapter or printer is connected, and to determine appropriate places
           to mount disk drives. It would seem that such actions could be
           supported for any case where a responsible human can be identified:
           single user workstations, or any system which is remotely
           administered.
          </para>

          <para>
            This is a classic "remote sysadmin" problem, where in this case
            hotplugging needs to deliver an event from one security domain
            (operating system kernel, in this case) to another (desktop for
            logged-in user, or remote sysadmin). Any effective response must go
            the other way: the remote domain taking some action that lets the
            kernel expose the desired device capabilities. (The action can often
            be taken asynchronously, for example letting new hardware be idle
            until a meeting finishes.) At this writing, Linux doesn't have
            widely adopted solutions to such problems. However, the new D-Bus
            work may begin to solve that problem.
          </para>
        </blockquote>
      </para>
      <para>
        D-BUS may happen to be useful for purposes other than the one it was
        designed for. Its general properties that distinguish it from 
        other forms of IPC are:
        <itemizedlist>
          <listitem>
            <para>
              Binary protocol designed to be used asynchronously 
              (similar in spirit to the X Window System protocol).
            </para>
          </listitem>
          <listitem>
            <para>
              Stateful, reliable connections held open over time.
            </para>
          </listitem>
          <listitem>
            <para>
              The message bus is a daemon, not a "swarm" or 
              distributed architecture.
            </para>
          </listitem>
          <listitem>
            <para>
              Many implementation and deployment issues are specified rather
              than left ambiguous.
            </para>
          </listitem>
          <listitem>
            <para>
              Semantics are similar to the existing DCOP system, allowing 
              KDE to adopt it more easily.
            </para>
          </listitem>
          <listitem>
            <para>
              Security features to support the systemwide mode of the 
              message bus.
            </para>
          </listitem>
        </itemizedlist>
      </para>
    </sect2>
  </sect1>
  <sect1 id="concepts">
    <title>Concepts</title>
    <para>
      Some basic concepts apply no matter what application framework you're
      using to write a D-BUS application. The exact code you write will be
      different for GLib vs. Qt vs. Python applications, however.
    </para>

    <sect2 id="objects">
      <title>Objects and Object Paths</title>
      <para>
        Each application using D-BUS contains <firstterm>objects</firstterm>,
        which generally map to GObject, QObject, C++ objects, or Python objects
        (but need not).  An object is an <emphasis>instance</emphasis> rather
        than a type.  When messages are received over a D-BUS connection, they
        are sent to a specific object, not to the application as a whole.
      </para>
      <para>
        To allow messages to specify their destination object, there has to be a
        way to refer to an object. In your favorite programming language, this
        is normally called a <firstterm>pointer</firstterm> or
        <firstterm>reference</firstterm>. However, these references are
        implemented as memory addresses relative to the address space of your
        application, and thus can't be passed from one application to another.
      </para>
      <para>
        To solve this, D-BUS introduces a name for each object. The name 
        looks like a filesystem path, for example an object could be 
        named <literal>/org/kde/kspread/sheets/3/cells/4/5</literal>. 
        Human-readable paths are nice, but you are free to create an 
        object named <literal>/com/mycompany/c5yo817y0c1y1c5b</literal> 
        if it makes sense for your application.
      </para>
      <para>
        Namespacing object paths is smart, by starting them with the components
        of a domain name you own (e.g. <literal>/org/kde</literal>). This 
        keeps different code modules in the same process from stepping 
        on one another's toes.
      </para>
    </sect2>    

    <sect2 id="interfaces">
      <title>Interfaces</title>
      <para>
        Each object supports one or more <firstterm>interfaces</firstterm>.
        Think of an interface as a named group of methods and signals, 
        just as it is in GLib or Qt or Java. Interfaces define the 
        <emphasis>type</emphasis> of an object instance.
      </para>
    </sect2>
      
    <sect2 id="messages">
      <title>Message Types</title>
      <para>
        Messages are not all the same; in particular, D-BUS has 
        4 built-in message types:
        <itemizedlist>
          <listitem>
            <para>
              Method call messages ask to invoke a method 
              on an object.
            </para>
          </listitem>
          <listitem>
            <para>
              Method return messages return the results 
              of invoking a method.
            </para>
          </listitem>
          <listitem>
            <para>
              Error messages return an exception caused by 
              invoking a method.
            </para>
          </listitem>
          <listitem>
            <para>
              Signal messages are notifications that a given signal 
              has been emitted (that an event has occurred). 
              You could also think of these as "event" messages.
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
        A method call maps very simply to messages, then: you send a method call
        message, and receive either a method return message or an error message
        in reply.
      </para>
    </sect2>

    <sect2 id="services">
      <title>Services</title>
      
      <para>
        Object paths, interfaces, and messages exist on the level of 
        libdbus and the D-BUS protocol; they are used even in the 
        1-to-1 case with no message bus involved.
      </para>

      <para>
        Services, on the other hand, are a property of the message bus daemon.
        A <firstterm>service</firstterm> is simply a name mapped to 
        some application connected to the message bus daemon.
        These names are used to specify the origin and destination
        of messages passing through the message bus. When a name is mapped 
        to a particular application, the application is said to 
        <firstterm>own</firstterm> that service.
      </para>

      <para>
        On connecting to the bus daemon, each application immediately owns a
        special name called the <firstterm>base service</firstterm>.  A base
        service begins with a ':' (colon) character; no other services are
        allowed to begin with that character. Base services are special because
        each one is unique. They are created dynamically, and are never re-used
        during the lifetime of the same bus daemon. You know that a given
        base service name will have the same owner at all times.
        An example of a base service name might be <literal>:34-907</literal>.
      </para>

      <para>
        Applications may ask to own additional <firstterm>well-known
        services</firstterm>. For example, you could write a specification to
        define a service called <literal>com.mycompany.TextEditor</literal>.
        Your definition could specify that to own this service, an application
        should have an object at the path
        <literal>/com/mycompany/TextFileManager</literal> supporting the
        interface <literal>org.freedesktop.FileHandler</literal>.        
      </para>
      
      <para>
        Applications could then send messages to this service, 
        object, and interface to execute method calls.
      </para>

      <para>
        You could think of the base service names as IP addresses, and the
        well-known services as domain names. So
        <literal>com.mycompany.TextEditor</literal> might map to something like
        <literal>:34-907</literal> just as <literal>mycompany.com</literal> maps
        to something like <literal>192.168.0.5</literal>.
      </para>
      
      <para>
        Services have a second important use, other than routing messages.  They
        are used to track lifecycle. When an application exits (or crashes), its
        connection to the message bus will be closed by the operating system
        kernel. The message bus then sends out notification messages telling
        remaining applications that the application's services have lost their
        owner. By tracking these notifications, your application can reliably
        monitor the lifetime of other applications.
      </para>

    </sect2>

    <sect2 id="addresses">
      <title>Addresses</title>

      <para>
        Applications using D-BUS are either servers or clients.  A server
        listens for incoming connections; a client connects to a server. Once
        the connection is established, it is a symmetric flow of messages; the
        client-server distinction only matters when setting up the 
        connection.
      </para>

      <para>
        A D-BUS <firstterm>address</firstterm> specifies where a server will
        listen, and where a client will connect.  For example, the address
        <literal>unix:path=/tmp/abcdef</literal> specifies that the server will
        listen on a UNIX domain socket at the path
        <literal>/tmp/abcdef</literal> and the client will connect to that
        socket. An address can also specify TCP/IP sockets, or any other
        transport defined in future iterations of the D-BUS specification.
      </para>

      <para>
        When using D-BUS with a message bus, the bus daemon is a server 
        and all other applications are clients of the bus daemon.
        libdbus automatically discovers the address of the per-session bus 
        daemon by reading an environment variable. It discovers the 
        systemwide bus daemon by checking a well-known UNIX domain socket path
        (though you can override this address with an environment variable).
      </para>

      <para>
        If you're using D-BUS without a bus daemon, it's up to you to 
        define which application will be the server and which will be 
        the client, and specify a mechanism for them to agree on 
        the server's address.
      </para>

    </sect2>

    <sect2 id="bigpicture">
      <title>Big Conceptual Picture</title>

      <para>
        Pulling all these concepts together, to specify a particular 
        method call on a particular object instance, a number of 
        nested components have to be named:
        <programlisting>
          Address -> [Service] -> Path -> Interface -> Method
        </programlisting>
        The service is in brackets to indicate that it's optional -- you only
        provide a service name to route the method call to the right application
        when using the bus daemon. If you have a direct connection to another
        application, services aren't used; there's no bus daemon.
      </para>

      <para>
        The interface is also optional, primarily for historical 
        reasons; DCOP does not require specifying the interface, 
        instead simply forbidding duplicate method names 
        on the same object instance. D-BUS will thus let you 
        omit the interface, but if your method name is ambiguous 
        it is undefined which method will be invoked.
      </para>
      
    </sect2>

  </sect1>

  <sect1 id="glib-client">
    <title>GLib API: Using Remote Objects</title>

    <para>
      
      The GLib binding is defined in the header file
      &lt;dbus/dbus-glib.h&gt;. The API is very small, in sharp contrast to the
      low-level &lt;dbus/dbus.h&gt;.

    </para>

    <para>
      The GLib bindings are incomplete, see the TODO file and comments in the
      source code.
    </para>

    <para>
Here is a D-BUS program using the GLib bindings.
<programlisting>      
int
main (int argc, char **argv)
{
  DBusGConnection *connection;
  GError *error;
  DBusGProxy *proxy;
  DBusGPendingCall *call;
  char **service_list;
  int service_list_len;
  int i;
  
  g_type_init ();

  error = NULL;
  connection = dbus_g_bus_get (DBUS_BUS_SESSION,
                               &amp;error);
  if (connection == NULL)
    {
      g_printerr ("Failed to open connection to bus: %s\n",
                  error->message);
      g_error_free (error);
      exit (1);
    }

  /* Create a proxy object for the "bus driver" (service org.freedesktop.DBus) */
  
  proxy = dbus_g_proxy_new_for_service (connection,
                                        DBUS_SERVICE_ORG_FREEDESKTOP_DBUS,
                                        DBUS_PATH_ORG_FREEDESKTOP_DBUS,
                                        DBUS_INTERFACE_ORG_FREEDESKTOP_DBUS);

  /* Call ListServices method */
  
  call = dbus_g_proxy_begin_call (proxy, "ListServices", DBUS_TYPE_INVALID);

  error = NULL;
  if (!dbus_g_proxy_end_call (proxy, call, &amp;error,
                              DBUS_TYPE_ARRAY, DBUS_TYPE_STRING,
                              &amp;service_list, &amp;service_list_len,
                              DBUS_TYPE_INVALID))
    {
      g_printerr ("Failed to complete ListServices call: %s\n",
                  error->message);
      g_error_free (error);
      exit (1);
    }

  /* Print the results */
 
  g_print ("Services on the message bus:\n");
  i = 0;
  while (i &lt; service_list_len)
    {
      g_assert (service_list[i] != NULL);
      g_print ("  %s\n", service_list[i]);
      ++i;
    }
  g_assert (service_list[i] == NULL);

  g_strfreev (service_list);

  return 0;
}
</programlisting>
    </para>

    <para>

      DBusGProxy represents a remote object. dbus_g_proxy_begin_call() sends 
      a method call to the remote object, and dbus_g_proxy_end_call() retrieves 
      any return values or exceptions resulting from the method call. 
      There are also DBusGProxy functions to connect and disconnect signals, 
      not shown in the code example.

    </para>

    <para>
      
      dbus_g_bus_get() assumes that the application will use GMainLoop. The
      created connection will be associated with the main loop such that
      messages will be sent and received when the main loop runs.  However, in
      the above code example the main loop never runs; D-BUS will not run the
      loop implicitly. Instead, dbus_g_proxy_end_call() will block until the
      method call has been sent and the reply received. A more complex GUI
      application might run the main loop while waiting for the method call
      reply.  (DBusGPendingCall is currently missing the "notify me when the
      call is complete" functionality found in DBusPendingCall, but it should be
      added.)

    </para>

    <para>
      
      Future plans (see doc/TODO) are to use G_TYPE_STRING in place of
      DBUS_TYPE_STRING and so forth. In fact the above code is slightly
      incorrect at the moment, since it uses g_strfreev() to free a string array
      that was not allocated with g_malloc(). dbus_free_string_array() should
      really be used. However, once the GLib bindings are complete the returned
      data from dbus_g_proxy_end_call() will be allocated with g_malloc().

    </para>

  </sect1>

  <sect1 id="glib-server">
    <title>GLib API: Implementing Objects</title>

    <para>
      
      The GLib binding is defined in the header file
      &lt;dbus/dbus-glib.h&gt;. To implement an object, it's also necessary
      to use the dbus-glib-tool command line tool.

    </para>

    <para>
      The GLib bindings are incomplete.  Implementing an object is not yet
      possible, see the TODO file and comments in the source code for details
      on what work needs doing.
    </para>
      
  </sect1>

  <sect1 id="qt-client">
    <title>Qt API: Using Remote Objects</title>
    <para>
      
      The Qt bindings are not yet documented.

    </para>
  </sect1>

  <sect1 id="qt-server">
    <title>Qt API: Implementing Objects</title>
    <para>
      The Qt bindings are not yet documented.
    </para>
  </sect1>


  <sect1 id="python-client">
    <title>Python API: Using Remote Objects</title>
    <para>
      The Python bindings are not yet documented, but the 
      bindings themselves are in good shape.
    </para>
  </sect1>

  <sect1 id="python-server">
    <title>Python API: Implementing Objects</title>
    <para>
      The Python bindings are not yet documented, but the 
      bindings themselves are in good shape.
    </para>
  </sect1>

</article>
