This is osso-application-installer, version 4
---------------------------------------------

[ About versions:

  1.x initial 'prototype'

  2.x working version of 1.x series with app-installer tool

  3.x intermediate version with the UI of 2.x that uses system-wide
      package management tools

  4.x completely new design that uses libapt-pkg and repositories
]

The osso-application-installer is a program to manage user packages in
the OSSO platform.  It uses the system-wide package management tools
(thru libapt-pkg) and presents a 'end user oriented' interface to
them.

The package management tools are powerful enough to manage the whole
system, but osso-application installer is not intended to offer that
power to the user.  If you want it, synaptic is quite easy to compile
and runs reasonable well on the 770...

Osso-application-installer is intended to be fully compatible with
existing and future interfaces for package management.  It should be
possible to, for example, freely alternate between apt-get, synaptic
and osso-application installer and not have anything break.


Design notes
------------

The libapt-pkg specific code is written in C++, but some of the GUI
code will be plain C to enable easier transportation into external
libraries or reuse.  This is not a deeply object oriented program, but
we'll use STL without prejudice.

The internal design uses two processes: one to run the GUI, one to do
stuff with libapt-pkg.  They communicate via pipes (or sockets).  The
libapt-pkg will be command driven: it reads a command, executes it,
ships back the result, and then reads the next command.  It
periodically sends status upates.  Some long running commands are
interuptible in certain phases.

Stdout and stderr from the libapt-pkg process are being redirected to
the 'log'.

The GUI process will do the usual event-loop thing.  It will request
stuff from the libapt-pkg process and then react to it when the result
arrives.  Somewhat unusually, it will just run one event loop and no
recursive ones for modal dialogs.  In effect, the control flow is
implemented in continuation passing style.  (The event loop is the
trampoline that gives us the needed tail-call elimination for this.)
The motivation for using continuation passing style was to avoid
spontanous recursive calls of event callbacks, which are not supported
by Gtk+ and are tricky in general, but still have a fully concurrent
'UI experience'.  Not having recursive calls allows us to confidently
access data structures so that we can run background jobs that gather
expensive information while showing dialogs, for example.

Writing in continuation passing style in C is a bit cumbersome, but
worth it, in my opinion.


BUGS
----

- depcache.Init () is too slow
- maybe restart apt-worker when it exits after handling a request
- handle broken packages
- handle removed, non-purged packages

- Format description nicely in details dialog.

- search results has wrong parent sometimes.

- Provide "All" section or no sections, optionally.

- Save toolbar shown/hidden state.

- Show/hide toolbar correctly.

- Context sensitive menu

- Dim Edit and Delete in Catalog dialog.

- Put new catalogs at end of list.

- Don't show search results when result is empty.

- Show all info banners when appropriate

Progress indications
--------------------

- Refreshing list of packages

  - Downloading        (size)
  - Creating cache     (percent)

- Installing/updating package

  - Checking           (???)
  - Downloading        (size)
  - Installing         (pmstatus)
  - Creating cache     (percent)

- Removing package

  - Removing           (pmstatus)
  - Creating cache     (percent)

- Installing from file

  - Copying to local   (size)
  - Installing         (pulse)
  - Creating cache     (percent)

[test]
