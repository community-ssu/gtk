This is osso-application-installer, version 4
---------------------------------------------

[ About versions:

  1.x initial 'prototype'

  2.x working version of 1.x series with app-installer tool

  3.x intermediate version with the UI of 2.x that uses system-wide
      package management tools

  4.x completely new design that uses libapt-pkg and repositories
]

The osso-application-installer is a program to manage user packages in
the OSSO platform.  It uses the system-wide package management tools
(thru libapt-pkg) and presents a 'end user oriented' interface to
them.

The package management tools are powerful enough to manage the whole
system, but osso-application installer is not intended to offer that
power to the user.  If you want it, synaptic is quite easy to compile
and runs reasonable well on the 770...

Osso-application-installer is intended to be fully compatible with
existing and future interfaces for package management.  It should be
possible to, for example, freely alternate between apt-get, synaptic
and osso-application installer and not have anything break.


Design notes
------------

First phase: wild experimentation with libapt-pkg and widget writing
for Gtk+.  No design whatsoever.

The libapt-pkg specific code is written in C++, but some of the GUI
code will be plain C to enable easier transportation into external
libraries or reuse.  This is not a deeply object oriented program, but
we'll use STL without prejudice.

The current way to keep the GUI alive is the put PM->DoInstall into a
new thread.  That seems to work fine on the target, but the DoInstall
thread sometimes blocks indefinitely when running in x86 scratchbox.
This is very weird, I declare it non-debuggable for now, and blame it
on scratchbox oddities.  In any case, using libapt-pkg in the
'obvious' way and keeping the GUI alive from OpProgress and
pkgAcquireStatus objects does not feel sufficiently smooth on a slow
device.  Also, I don't feel confident enough about using threads.

Therefore, the internal design will be changed to use two processes:
one to run the GUI, one to do stuff with libapt-pkg.  They will
communicate via pipes (or sockets).  The libapt-pkg will be command
driven: it reads a command, executes it, ships back the result, adn
then reads the next command.  Long running commands might or might not
be interuptible, depending on how feasible that is.  The GUI process
will do the usual event-loop thing.  It will request stuff from the
libapt-pkg process and then react to it when the result arrives.
Commands and results are linked with sequence numbers, making it
simple to just forget about some request.

Stdout and stderr from the libapt-pkg process are being redirected to
the 'log'.

Commands will be:

 - get list of packages.  This will include just enough information
   for the package list: name, version, section, status.

 - get package info: more, like download size, installability, etc.
   This will be used to fill the displayed list asynchronously.

 - get package details: all the rest of a package for the details dialog.

 - install package, remove package: this executes the operation.
