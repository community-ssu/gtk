--- gtk+/configure	(.../2.6.4)	(revision 904)
+++ gtk+/configure	(.../2.6.4-1.osso62)	(revision 904)
@@ -1057,6 +1057,7 @@
   --enable-xkb            support XKB [default=maybe]
   --disable-rebuilds      disable all source autogeneration rules
   --disable-visibility    don't use ELF visibility attributes
+  --disable-shortcuts     disable keyboard shortcuts
   --disable-shadowfb      disable shadowfb support for linux-fb
   --enable-fbmanager      enable framebuffer manager support (GtkFB)
   --enable-explicit-deps=[yes/no/auto]
@@ -1197,7 +1198,7 @@
     else
       echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
     fi
-    cd $ac_popdir
+    cd "$ac_popdir"
   done
 fi
 
@@ -2663,8 +2664,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2722,8 +2722,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2839,8 +2838,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2894,8 +2892,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2940,8 +2937,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2985,8 +2981,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3759,7 +3754,7 @@
   ;;
 *-*-irix6*)
   # Find out which ABI we are using.
-  echo '#line 3762 "configure"' > conftest.$ac_ext
+  echo '#line 3757 "configure"' > conftest.$ac_ext
   if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
@@ -3879,8 +3874,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4189,8 +4183,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4360,8 +4353,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4428,8 +4420,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4689,8 +4680,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4748,8 +4738,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4820,8 +4809,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4865,8 +4853,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5331,7 +5318,7 @@
 
 
 # Provide some information about the compiler.
-echo "$as_me:5334:" \
+echo "$as_me:5321:" \
      "checking for Fortran 77 compiler version" >&5
 ac_compiler=`set X $ac_compile; echo $2`
 { (eval echo "$as_me:$LINENO: \"$ac_compiler --version </dev/null >&5\"") >&5
@@ -5377,8 +5364,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_f77_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_f77_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5427,8 +5413,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_f77_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_f77_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6388,11 +6373,11 @@
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:6391: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:6376: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:6395: \$? = $ac_status" >&5
+   echo "$as_me:6380: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
@@ -6631,11 +6616,11 @@
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:6634: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:6619: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:6638: \$? = $ac_status" >&5
+   echo "$as_me:6623: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
@@ -6691,11 +6676,11 @@
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:6694: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:6679: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:6698: \$? = $ac_status" >&5
+   echo "$as_me:6683: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -7082,8 +7067,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7143,8 +7127,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8026,7 +8009,7 @@
   libsuff=
   case "$host_cpu" in
   x86_64*|s390x*|powerpc64*)
-    echo '#line 8029 "configure"' > conftest.$ac_ext
+    echo '#line 8012 "configure"' > conftest.$ac_ext
     if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
@@ -8357,8 +8340,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8461,8 +8443,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8527,8 +8508,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8621,8 +8601,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8687,8 +8666,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8754,8 +8732,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8821,8 +8798,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8897,7 +8873,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 8900 "configure"
+#line 8876 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -8995,7 +8971,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 8998 "configure"
+#line 8974 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -10032,8 +10008,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -10094,8 +10069,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -11188,11 +11162,11 @@
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:11191: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:11165: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:11195: \$? = $ac_status" >&5
+   echo "$as_me:11169: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
@@ -11248,11 +11222,11 @@
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:11251: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:11225: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:11255: \$? = $ac_status" >&5
+   echo "$as_me:11229: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -11759,7 +11733,7 @@
   libsuff=
   case "$host_cpu" in
   x86_64*|s390x*|powerpc64*)
-    echo '#line 11762 "configure"' > conftest.$ac_ext
+    echo '#line 11736 "configure"' > conftest.$ac_ext
     if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
@@ -12090,8 +12064,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -12194,8 +12167,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -12260,8 +12232,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -12354,8 +12325,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -12420,8 +12390,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -12487,8 +12456,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -12554,8 +12522,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -12630,7 +12597,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 12633 "configure"
+#line 12600 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -12728,7 +12695,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 12731 "configure"
+#line 12698 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -13565,11 +13532,11 @@
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:13568: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:13535: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:13572: \$? = $ac_status" >&5
+   echo "$as_me:13539: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
@@ -13625,11 +13592,11 @@
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:13628: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:13595: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:13632: \$? = $ac_status" >&5
+   echo "$as_me:13599: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -14006,8 +13973,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_f77_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_f77_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -14057,8 +14023,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_f77_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_f77_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -14940,7 +14905,7 @@
   libsuff=
   case "$host_cpu" in
   x86_64*|s390x*|powerpc64*)
-    echo '#line 14943 "configure"' > conftest.$ac_ext
+    echo '#line 14908 "configure"' > conftest.$ac_ext
     if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
@@ -15681,11 +15646,11 @@
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:15684: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:15649: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:15688: \$? = $ac_status" >&5
+   echo "$as_me:15653: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
@@ -15924,11 +15889,11 @@
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:15927: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:15892: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:15931: \$? = $ac_status" >&5
+   echo "$as_me:15896: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
@@ -15984,11 +15949,11 @@
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:15987: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:15952: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:15991: \$? = $ac_status" >&5
+   echo "$as_me:15956: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -16375,8 +16340,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -16436,8 +16400,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -17319,7 +17282,7 @@
   libsuff=
   case "$host_cpu" in
   x86_64*|s390x*|powerpc64*)
-    echo '#line 17322 "configure"' > conftest.$ac_ext
+    echo '#line 17285 "configure"' > conftest.$ac_ext
     if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
@@ -17650,8 +17613,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -17754,8 +17716,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -17820,8 +17781,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -17914,8 +17874,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -17980,8 +17939,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -18047,8 +18005,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -18114,8 +18071,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -18190,7 +18146,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 18193 "configure"
+#line 18149 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -18288,7 +18244,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 18291 "configure"
+#line 18247 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -19354,8 +19310,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -19384,8 +19339,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -19455,8 +19409,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -19508,8 +19461,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -19580,8 +19532,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -19633,8 +19584,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -19849,6 +19799,18 @@
 else
   enable_visibility=yes
 fi;
+# Modification for Nokia 770 to disable keyboard shortcuts
+# Check whether --enable-shortcuts or --disable-shortcuts was given.
+if test "${enable_shortcuts+set}" = set; then
+  enableval="$enable_shortcuts"
+
+else
+  enable_shortcuts=yes
+fi;
+
+if test "x$enable_shortcuts" = "xno"; then
+  GTK_EXTRA_CFLAGS="$GTK_EXTRA_CFLAGS -DDISABLE_KEYBOARD_SHORTCUTS"
+fi;
 
 
 # Check whether --with-xinput or --without-xinput was given.
@@ -20018,8 +19980,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -20124,8 +20085,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -20439,7 +20399,8 @@
 if test "$os_win32" != yes; then
     # libtool option to control which symbols are exported
     # right now, symbols starting with _ are not exported
-    LIBTOOL_EXPORT_OPTIONS='-export-symbols-regex "^[^_].*"'
+    # Disabled until -export-symbols-regex works (RH patch)
+    LIBTOOL_EXPORT_OPTIONS=
 else
     # We currently use .def files on Windows (for gdk-pixbuf, gdk and gtk)
     LIBTOOL_EXPORT_OPTIONS=
@@ -20651,8 +20612,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -20715,8 +20675,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -20752,7 +20711,7 @@
 # sure that both po/ and po-properties/ have .po files that correspond
 # to your language.  If you only add one to po/, the build will break
 # in po-properties/.
-ALL_LINGUAS="af am ar az az_IR be bg bn br bs ca cs cy da de el en_CA en_GB es et eu fa fi fr ga gl gu he hi hr hu ia id is it ja ko li lt lv mi mk ml mn mr ms nb ne nl nn no nso pa pl pt pt_BR ro ru rw sk sl sq sr sr@ije sr@Latn sv ta th tk tr uk uz uz@Latn vi wa xh yi zh_CN zh_TW"
+ALL_LINGUAS=""
 
 
 for ac_header in locale.h
@@ -20788,8 +20747,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -20934,8 +20892,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -21006,8 +20963,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -21151,8 +21107,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -21210,8 +21165,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -21308,8 +21262,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -21388,8 +21341,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -21453,8 +21405,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -21518,8 +21469,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -21596,8 +21546,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -21661,8 +21610,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -21778,8 +21726,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -21946,8 +21893,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -22080,8 +22026,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -22166,8 +22111,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -22468,8 +22412,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -22513,8 +22456,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -22821,8 +22763,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -22948,8 +22889,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -23017,8 +22957,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -23170,8 +23109,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -23323,8 +23261,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -23485,8 +23422,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -23571,8 +23507,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -23665,8 +23600,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -23875,8 +23809,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -23948,8 +23881,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -24013,8 +23945,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -24198,8 +24129,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -24476,8 +24406,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -24578,8 +24507,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -24677,8 +24605,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -24895,8 +24822,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -24961,8 +24887,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -25036,8 +24961,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -25248,8 +25172,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -25305,8 +25228,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -25459,8 +25381,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -25516,8 +25437,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -25670,8 +25590,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -25727,8 +25646,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -25904,8 +25822,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -26021,8 +25938,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -26126,8 +26042,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -26183,8 +26098,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -26329,8 +26243,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -26487,8 +26400,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -26559,8 +26471,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -26880,8 +26791,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -26938,8 +26848,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -27182,8 +27091,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -27294,8 +27202,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -27346,8 +27253,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -27423,8 +27329,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -27479,8 +27384,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -27548,8 +27452,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -27657,8 +27560,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -27722,8 +27624,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -27791,8 +27692,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -27896,8 +27796,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -27961,8 +27860,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -28059,8 +27957,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -28124,8 +28021,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -28222,8 +28118,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -28287,8 +28182,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -28367,8 +28261,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -28461,8 +28354,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -28536,8 +28428,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -28608,8 +28499,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -28708,8 +28598,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -28765,8 +28654,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -28855,8 +28743,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -28906,8 +28793,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -28998,8 +28884,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -29042,8 +28927,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -29118,8 +29002,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -29197,8 +29080,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -29271,8 +29153,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -29349,8 +29230,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -29446,8 +29326,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -29557,8 +29436,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -29608,8 +29486,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -29808,8 +29685,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -29859,8 +29735,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -30014,6 +29889,116 @@
     GDK_EXTRA_LIBS="`$PKG_CONFIG --libs xfixes` $GDK_EXTRA_LIBS"
   fi
 
+  # Checks for XFixes extension
+
+  have_xfixes=false
+
+  succeeded=no
+
+  if test -z "$PKG_CONFIG"; then
+    # Extract the first word of "pkg-config", so it can be a program name with args.
+set dummy pkg-config; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_PKG_CONFIG+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $PKG_CONFIG in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_PKG_CONFIG="$PKG_CONFIG" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  test -z "$ac_cv_path_PKG_CONFIG" && ac_cv_path_PKG_CONFIG="no"
+  ;;
+esac
+fi
+PKG_CONFIG=$ac_cv_path_PKG_CONFIG
+
+if test -n "$PKG_CONFIG"; then
+  echo "$as_me:$LINENO: result: $PKG_CONFIG" >&5
+echo "${ECHO_T}$PKG_CONFIG" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  fi
+
+  if test "$PKG_CONFIG" = "no" ; then
+     echo "*** The pkg-config script could not be found. Make sure it is"
+     echo "*** in your path, or set the PKG_CONFIG environment variable"
+     echo "*** to the full path to pkg-config."
+     echo "*** Or see http://www.freedesktop.org/software/pkgconfig to get pkg-config."
+  else
+     PKG_CONFIG_MIN_VERSION=0.9.0
+     if $PKG_CONFIG --atleast-pkgconfig-version $PKG_CONFIG_MIN_VERSION; then
+        echo "$as_me:$LINENO: checking for xfixes" >&5
+echo $ECHO_N "checking for xfixes... $ECHO_C" >&6
+
+        if $PKG_CONFIG --exists "xfixes" ; then
+            echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+            succeeded=yes
+
+            echo "$as_me:$LINENO: checking XFIXES_CFLAGS" >&5
+echo $ECHO_N "checking XFIXES_CFLAGS... $ECHO_C" >&6
+            XFIXES_CFLAGS=`$PKG_CONFIG --cflags "xfixes"`
+            echo "$as_me:$LINENO: result: $XFIXES_CFLAGS" >&5
+echo "${ECHO_T}$XFIXES_CFLAGS" >&6
+
+            echo "$as_me:$LINENO: checking XFIXES_LIBS" >&5
+echo $ECHO_N "checking XFIXES_LIBS... $ECHO_C" >&6
+            XFIXES_LIBS=`$PKG_CONFIG --libs "xfixes"`
+            echo "$as_me:$LINENO: result: $XFIXES_LIBS" >&5
+echo "${ECHO_T}$XFIXES_LIBS" >&6
+        else
+            XFIXES_CFLAGS=""
+            XFIXES_LIBS=""
+            ## If we have a custom action on failure, don't print errors, but
+            ## do set a variable so people can do so.
+            XFIXES_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "xfixes"`
+
+        fi
+
+
+
+     else
+        echo "*** Your version of pkg-config is too old. You need version $PKG_CONFIG_MIN_VERSION or newer."
+        echo "*** See http://www.freedesktop.org/software/pkgconfig"
+     fi
+  fi
+
+  if test $succeeded = yes; then
+     have_xfixes=true
+  else
+     :
+  fi
+
+
+  if $have_xfixes ; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_XFIXES 1
+_ACEOF
+
+    GDK_EXTRA_CFLAGS="`$PKG_CONFIG --cflags xfixes` $GDK_EXTRA_CFLAGS"
+    GDK_EXTRA_LIBS="`$PKG_CONFIG --libs xfixes` $GDK_EXTRA_LIBS"
+  fi
+
   # Xshm checks
 
   if test "x$enable_shm" = "xyes"; then
@@ -30048,8 +30033,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -30195,8 +30179,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -30354,8 +30337,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -30650,8 +30632,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -30764,8 +30745,7 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -30797,7 +30777,6 @@
 
 GTK_PACKAGES=atk
 GTK_EXTRA_LIBS=
-GTK_EXTRA_CFLAGS=
 GTK_DEP_LIBS="$GDK_EXTRA_LIBS $GTK_DEP_LIBS_FOR_X `$PKG_CONFIG --libs $GDK_PIXBUF_PACKAGES $GDK_PACKAGES $GTK_PACKAGES` $GTK_EXTRA_LIBS $GDK_PIXBUF_EXTRA_LIBS"
 GTK_DEP_CFLAGS="`$PKG_CONFIG --cflags  gthread-2.0 $GDK_PIXBUF_PACKAGES $GDK_PACKAGES $GTK_PACKAGES` $GDK_PIXBUF_EXTRA_CFLAGS $GDK_EXTRA_CFLAGS $GTK_EXTRA_CFLAGS"
 
@@ -32513,11 +32492,6 @@
   *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
   esac
 
-  if test x"$ac_file" != x-; then
-    { echo "$as_me:$LINENO: creating $ac_file" >&5
-echo "$as_me: creating $ac_file" >&6;}
-    rm -f "$ac_file"
-  fi
   # Let's still pretend it is `configure' which instantiates (i.e., don't
   # use $as_me), people would be surprised to read:
   #    /* config.h.  Generated by config.status.  */
@@ -32556,6 +32530,12 @@
 	 fi;;
       esac
     done` || { (exit 1); exit 1; }
+
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF
   sed "$ac_vpsub
--- gtk+/gtk/gtkprogressbar.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkprogressbar.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -40,11 +40,18 @@
 
 
 #define MIN_HORIZONTAL_BAR_WIDTH   150
-#define MIN_HORIZONTAL_BAR_HEIGHT  20
+#define MIN_HORIZONTAL_BAR_HEIGHT  30 /* OSSO mod. was 20 */
 #define MIN_VERTICAL_BAR_WIDTH     22
 #define MIN_VERTICAL_BAR_HEIGHT    80
 #define MAX_TEXT_LENGTH            80
-#define TEXT_SPACING               2
+#define DEFAULT_TEXT_SPACING       2 /* OSSO mod. Changed from
+				      * TEXT_SPACING. Now controlled
+				      * by "text-spacing" style
+				      * property */
+#define DEFAULT_WIDTH_INCREMENT    3
+#define DEFAULT_HEIGHT_INCREMENT   3
+#define DEFAULT_TEXT_XNUDGE        1
+#define DEFAULT_TEXT_YNUDGE        1
 
 enum {
   PROP_0,
@@ -245,6 +252,51 @@
 						      PANGO_ELLIPSIZE_NONE,
                                                       G_PARAM_READWRITE));
 
+  /* OSSO addition. */
+  gtk_widget_class_install_style_property (widget_class,
+					   g_param_spec_int ("text-spacing",
+							     "Text Spacing",
+							     "The amount of pixels between the trough and text.",
+							     G_MININT,
+							     G_MAXINT,
+							     DEFAULT_TEXT_SPACING,
+							     G_PARAM_READWRITE));
+
+  gtk_widget_class_install_style_property (widget_class,
+					   g_param_spec_int ("width-increment",
+							     "width Increment",
+							     "The amount of pixels to add to the width size request.",
+							     G_MININT,
+							     G_MAXINT,
+							     DEFAULT_WIDTH_INCREMENT,
+							     G_PARAM_READWRITE));
+
+  gtk_widget_class_install_style_property (widget_class,
+					   g_param_spec_int ("height-increment",
+							     "Height Increment",
+							     "The amount of pixels to add to the height size request.",
+							     G_MININT,
+							     G_MAXINT,
+							     DEFAULT_WIDTH_INCREMENT,
+							     G_PARAM_READWRITE));
+
+  gtk_widget_class_install_style_property (widget_class,
+					   g_param_spec_int ("text-xnudge",
+							     "Text XNudge",
+							     "Amount of pixels to move the text x position.",
+							     G_MININT,
+							     G_MAXINT,
+							     DEFAULT_TEXT_XNUDGE,
+							     G_PARAM_READWRITE));
+
+  gtk_widget_class_install_style_property (widget_class,
+					   g_param_spec_int ("text-ynudge",
+							     "Text YNudge",
+							     "Amount of pixels to move the text y position.",
+							     G_MININT,
+							     G_MAXINT,
+							     DEFAULT_TEXT_YNUDGE,
+							     G_PARAM_READWRITE));
 }
 
 static void
@@ -364,7 +416,9 @@
 {
   GtkWidget *pbar;
 
-  pbar = gtk_widget_new (GTK_TYPE_PROGRESS_BAR, NULL);
+  pbar = gtk_widget_new (GTK_TYPE_PROGRESS_BAR, 
+			 "text-xalign", 0.0, /* OSSO addition. */
+			 NULL);
 
   return pbar;
 }
@@ -494,15 +548,23 @@
   PangoRectangle logical_rect;
   PangoLayout *layout;
   gint width, height;
+  gint text_spacing;
+  gint width_increment, height_increment;
 
   g_return_if_fail (GTK_IS_PROGRESS_BAR (widget));
   g_return_if_fail (requisition != NULL);
+  
+  gtk_widget_style_get (widget,
+			"text-spacing", &text_spacing,
+			"width-increment", &width_increment,
+			"height-increment", &height_increment,
+			NULL);
 
   progress = GTK_PROGRESS (widget);
   pbar = GTK_PROGRESS_BAR (widget);
 
-  width = 2 * widget->style->xthickness + 3 + 2 * TEXT_SPACING;
-  height = 2 * widget->style->ythickness + 3 + 2 * TEXT_SPACING;
+  width = 2 * widget->style->xthickness + width_increment + 2 * text_spacing;
+  height = 2 * widget->style->ythickness + height_increment + 2 * text_spacing;
 
   if (progress->show_text && pbar->bar_style != GTK_PROGRESS_DISCRETE)
     {
@@ -780,6 +842,13 @@
   PangoRectangle logical_rect;
   GdkRectangle prelight_clip, normal_clip;
   
+  gint text_xnudge, text_ynudge;
+  
+  gtk_widget_style_get (widget,
+			"text-xnudge", &text_xnudge,
+			"text-ynudge", &text_ynudge,
+			NULL);
+  
   buf = gtk_progress_get_current_text (progress);
   
   layout = gtk_widget_create_pango_layout (widget, buf);
@@ -789,12 +858,12 @@
 
   pango_layout_get_pixel_extents (layout, NULL, &logical_rect);
   
-  x = widget->style->xthickness + 1 +
+  x = widget->style->xthickness + text_xnudge +
     (widget->allocation.width - 2 * widget->style->xthickness -
      2 - logical_rect.width)
     * progress->x_align; 
 
-  y = widget->style->ythickness + 1 +
+  y = widget->style->ythickness + text_ynudge +
     (widget->allocation.height - 2 * widget->style->ythickness -
      2 - logical_rect.height)
     * progress->y_align;
--- gtk+/gtk/gtkwidget.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkwidget.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -28,6 +28,8 @@
 #include <stdarg.h>
 #include <string.h>
 #include <locale.h>
+#include <stdlib.h>
+#include <x11/gdkx.h>
 #include "gtkalias.h"
 #include "gtkcontainer.h"
 #include "gtkaccelmap.h"
@@ -44,6 +46,11 @@
 #include "gtkwindow.h"
 #include "gtkbindings.h"
 #include "gtkprivate.h"
+#include "gtktreeview.h"
+#include "gtkentry.h"
+#include "gtktextview.h"
+#include "gtkimcontext.h"
+#include "gtkmenu.h"
 #include "gdk/gdk.h"
 #include "gdk/gdkprivate.h" /* Used in gtk_reset_shapes_recurse to avoid copy */
 #include <gobject/gvaluecollector.h>
@@ -53,10 +60,33 @@
 #include "gtkaccessible.h"
 #include "gtktooltips.h"
 #include "gtkinvisible.h"
+#include "gtkscrollbar.h"   /* Following are needed for special focus changes */
+#include "gtktoolbar.h"
+#include "gtkmenu.h"
+#include "gtkmenuitem.h"
+#include "gtktogglebutton.h"
+#include "gtkcomboboxentry.h"
+#include "gtktogglebutton.h"
+#include "gtkcomboboxentry.h"
 
 #define WIDGET_CLASS(w)	 GTK_WIDGET_GET_CLASS (w)
 #define	INIT_PATH_SIZE	(512)
 
+#define GTK_TAP_THRESHOLD 30
+#define GTK_TAP_MENU_THRESHOLD 20
+#define GTK_TAP_AND_HOLD_TIMER_COUNTER 11
+#define GTK_TAP_AND_HOLD_TIMER_INTERVAL 100
+
+typedef struct _GtkWidgetPrivate GtkWidgetPrivate;
+
+#define GTK_WIDGET_GET_PRIVATE(obj) ( G_TYPE_INSTANCE_GET_PRIVATE ((obj),\
+                                      GTK_TYPE_WIDGET, GtkWidgetPrivate) )
+
+#define TAP_AND_HOLD_ANIMATION 1
+                                      
+#ifdef TAP_AND_HOLD_ANIMATION
+  #include <gdk-pixbuf/gdk-pixbuf.h>
+#endif
 
 enum {
   SHOW,
@@ -120,6 +150,10 @@
   ACCEL_CLOSURES_CHANGED,
   SCREEN_CHANGED,
   CAN_ACTIVATE_ACCEL,
+	INSENSITIVE_PRESS,
+  TAP_AND_HOLD,
+  TAP_AND_HOLD_SETUP,
+  TAP_AND_HOLD_QUERY,
   LAST_SIGNAL
 };
 
@@ -142,7 +176,8 @@
   PROP_STYLE,
   PROP_EVENTS,
   PROP_EXTENSION_EVENTS,
-  PROP_NO_SHOW_ALL
+  PROP_NO_SHOW_ALL,
+  PROP_TAP_AND_HOLD
 };
 
 typedef	struct	_GtkStateData	 GtkStateData;
@@ -155,6 +190,37 @@
   guint		use_forall : 1;
 };
 
+struct _GtkWidgetPrivate
+{
+  GtkWidget *menu;
+  guint timer_id;
+
+  GtkMenuPositionFunc func;
+  gint x, y;
+  gint timer_counter;
+  gint signals_connected : 1;
+  gboolean state_set;
+  guint interval;
+  GdkWindow *tah_on_window;
+  
+#ifdef TAP_AND_HOLD_ANIMATION
+  GdkPixbufAnimation *anim;
+  GdkPixbufAnimationIter *iter;
+  guint width, height;
+#endif
+};
+
+/* --- Tap And Hold --- */
+static gboolean gtk_widget_tap_and_hold_timeout( GtkWidget *widget );
+static gboolean gtk_widget_tap_and_hold_button_press( GtkWidget *widget,
+                                     GdkEvent *event, GtkWidgetPrivate *priv );
+static gboolean gtk_widget_tap_and_hold_event_stop( GtkWidget *widget,
+                                     gpointer unused, GtkWidgetPrivate *priv );
+static void gtk_widget_tap_and_hold_setup_real( GtkWidget *widget,
+            GtkWidget *menu, GtkCallback func, GtkWidgetTapAndHoldFlags flags );
+static void gtk_widget_real_tap_and_hold(GtkWidget *widget);
+static gboolean gtk_widget_tap_and_hold_query (GtkWidget *widget, GdkEvent *event);
+static gboolean gtk_widget_tap_and_hold_real_query (GtkWidget *widget, GdkEvent *event);
 
 /* --- prototypes --- */
 static void	gtk_widget_class_init		 (GtkWidgetClass    *klass);
@@ -185,6 +251,8 @@
 static void	gtk_widget_direction_changed	 (GtkWidget	    *widget,
 						  GtkTextDirection   previous_direction);
 
+static void     gtk_widget_set_valid_context     (GtkIMContext     **valid_context,
+                                                  GtkWidget         *widget);
 static void	gtk_widget_real_grab_focus	 (GtkWidget         *focus_widget);
 static gboolean gtk_widget_real_show_help        (GtkWidget         *widget,
                                                   GtkWidgetHelpType  help_type);
@@ -228,6 +296,13 @@
 					   gint       width,
 					   gint       height);
 
+/*Hildon focus handling*/
+static void gtk_widget_set_focus_handling( GtkWidget *widget, gboolean state );
+
+static gboolean gtk_widget_enter_notify_event( GtkWidget *widget, GdkEventCrossing *event );
+static gboolean gtk_widget_leave_notify_event( GtkWidget *widget, GdkEventCrossing *event );
+static gint gtk_widget_button_release_event( GtkWidget *widget, GdkEventButton *event );
+static gint gtk_widget_button_press_event( GtkWidget *widget, GdkEventButton *event );
 
 /* --- variables --- */
 static gpointer         parent_class = NULL;
@@ -238,6 +313,10 @@
 static guint            composite_child_stack = 0;
 static GtkTextDirection gtk_default_direction = GTK_TEXT_DIR_LTR;
 static GParamSpecPool  *style_property_spec_pool = NULL;
+static GtkWidget       *selection_widget = NULL;
+
+static gboolean on_same_widget = FALSE; /*Hildon focus handling*/
+static gboolean mouse_pressed = FALSE; /*Hildon focus handling*/
 
 static GQuark		quark_property_parser = 0;
 static GQuark		quark_aux_info = 0;
@@ -396,6 +475,10 @@
   klass->drag_data_received = NULL;
   klass->screen_changed = NULL;
   klass->can_activate_accel = gtk_widget_real_can_activate_accel;
+  klass->tap_and_hold_setup = gtk_widget_tap_and_hold_setup_real;
+  klass->insensitive_press = NULL;
+  klass->tap_and_hold = gtk_widget_real_tap_and_hold;
+  klass->tap_and_hold_query = gtk_widget_tap_and_hold_real_query;
 
   klass->show_help = gtk_widget_real_show_help;
   
@@ -404,6 +487,18 @@
 
   klass->no_expose_event = NULL;
 
+  g_type_class_add_private( klass, sizeof(GtkWidgetPrivate) );
+
+  g_object_class_install_property (gobject_class,
+				   PROP_TAP_AND_HOLD,
+				   g_param_spec_int ("tap_and_hold_state",
+ 						     P_("Tap and hold State type"),
+ 						     P_("Sets the state to be used to the tap and hold functionality. The default is GTK_STATE_NORMAL"),
+ 						     0,
+ 						     4, /*4 == Last state in GTK+-2.0*/
+ 						     GTK_STATE_NORMAL,
+ 						     G_PARAM_READWRITE));
+
   g_object_class_install_property (gobject_class,
 				   PROP_NAME,
 				   g_param_spec_string ("name",
@@ -1389,6 +1484,78 @@
 		  _gtk_marshal_BOOLEAN__UINT,
                   G_TYPE_BOOLEAN, 1, G_TYPE_UINT);
 
+  /**	
+   * GtkWidget::insensitive-press	
+   * @widget: the object which received the signal	
+   *	
+   * If a widget is insensitive and it receives click event,	
+   * the signal is emited.  Signal is made to clarify situations where	
+   * a widget is not easily noticable as an insenitive widget.	
+   */
+  widget_signals[INSENSITIVE_PRESS] =
+    g_signal_new ("insensitive_press",
+                  G_TYPE_FROM_CLASS (gobject_class),
+                  G_SIGNAL_RUN_FIRST,
+                  G_STRUCT_OFFSET (GtkWidgetClass, insensitive_press),
+                  NULL, NULL,
+                  _gtk_marshal_VOID__VOID,
+                  G_TYPE_NONE, 0);
+  
+  /**	
+   * GtkWidget::tap-and-hold	
+   * @widget: the object which received the signal	
+   *	
+   * The signal is emited when tap and hold activity occurs.	
+   */
+  widget_signals[TAP_AND_HOLD] =
+    g_signal_new("tap_and_hold", G_TYPE_FROM_CLASS(gobject_class),
+                  G_SIGNAL_RUN_LAST,
+                  G_STRUCT_OFFSET(GtkWidgetClass, tap_and_hold),
+                  NULL, NULL,
+                  _gtk_marshal_VOID__VOID,
+                  G_TYPE_NONE, 0);
+
+  /**	
+   * GtkWidget::tap-and-hold-setup	
+   * @widget: the object which received the signal	
+   * @menu: the menu to be opened.	
+   * @func: the menu position function	
+   * @flags: debricated	
+   *	
+   * Enables the tap and hold functionality to the @widget.	
+   * Usually a @menu is used at tap and hold signal,	
+   * but this is optional.  Setup can be run and some other functionality	
+   * may be connected to it as well.  Usually this signal is not used,	
+   * instead the virtual function is over written.	
+   * Signal is deprecated and should not be used.
+   */
+  widget_signals[TAP_AND_HOLD_SETUP] =  
+    g_signal_new("tap_and_hold_setup", G_TYPE_FROM_CLASS(gobject_class),
+                  G_SIGNAL_RUN_LAST,
+                  G_STRUCT_OFFSET(GtkWidgetClass, tap_and_hold_setup),
+                  NULL, NULL, /*FIXME -- OBJECT_POINTER_FLAGS*/
+                  _gtk_marshal_VOID__OBJECT_UINT_FLAGS,
+		 G_TYPE_NONE, 3, G_TYPE_OBJECT, G_TYPE_POINTER, G_TYPE_UINT);
+
+  /**
+   * GtkWidget::tap-and-hold-query
+   * @widget: the object which received the signal
+   * @returns: %FALSE if tap and hold is allowed to be started
+   *
+   * Signal is used in a situation where tap and hold is not allowed to be
+   * started in some mysterious reason.  A good mysterious reason could be,
+   * a widget which area is big and only part of it is allowed to start
+   * tap and hold.
+   */
+    widget_signals[TAP_AND_HOLD_QUERY] =
+    g_signal_new ("tap_and_hold_query",
+		  G_TYPE_FROM_CLASS (gobject_class),
+		  G_SIGNAL_RUN_LAST,
+		  G_STRUCT_OFFSET (GtkWidgetClass, tap_and_hold_query),
+		  _gtk_boolean_handled_accumulator, NULL,
+		  _gtk_marshal_BOOLEAN__BOXED,
+		  G_TYPE_BOOLEAN, 1, GDK_TYPE_EVENT);
+
   binding_set = gtk_binding_set_by_class (klass);
   gtk_binding_entry_add_signal (binding_set, GDK_F10, GDK_SHIFT_MASK,
                                 "popup_menu", 0);
@@ -1418,7 +1585,12 @@
 								 P_("Whether to draw the focus indicator inside widgets"),
 								 TRUE,
 								 G_PARAM_READABLE));
-
+  gtk_widget_class_install_style_property (klass,
+				   g_param_spec_boolean ("hildon-focus-handling",
+ 							 P_("Hildon focus handling"),
+ 							 P_("Whether the widget is using the hildon like focus handling or not"),
+ 							 FALSE,
+								 G_PARAM_READABLE));
   gtk_widget_class_install_style_property (klass,
 					   g_param_spec_int ("focus-line-width",
 							     P_("Focus linewidth"),
@@ -1543,6 +1715,8 @@
     case PROP_NO_SHOW_ALL:
       gtk_widget_set_no_show_all (widget, g_value_get_boolean (value));
       break;
+    case PROP_TAP_AND_HOLD:
+      break;
     default:
       break;
     }
@@ -1637,16 +1811,44 @@
     case PROP_NO_SHOW_ALL:
       g_value_set_boolean (value, gtk_widget_get_no_show_all (widget));
       break;
+    case PROP_TAP_AND_HOLD:
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
     }
 }
 
+static void gtk_widget_set_focus_handling( GtkWidget *widget, gboolean state )
+{
+      GtkWidgetPrivate *priv;
+      priv = GTK_WIDGET_GET_PRIVATE (widget);
+
+      if( state && GTK_WIDGET_CAN_FOCUS(widget) )
+      {
+         if (!priv->state_set)
+            {  
+               g_signal_connect( G_OBJECT(widget), "button-press-event",
+                                      G_CALLBACK(gtk_widget_button_press_event), NULL );
+               g_signal_connect( G_OBJECT(widget), "button-release-event",
+                                      G_CALLBACK(gtk_widget_button_release_event), NULL );
+               g_signal_connect( G_OBJECT(widget), "enter-notify-event",
+                                      G_CALLBACK(gtk_widget_enter_notify_event), NULL );
+               g_signal_connect( G_OBJECT(widget), "leave-notify-event",
+                                      G_CALLBACK(gtk_widget_leave_notify_event), NULL );
+               priv->state_set = TRUE;
+            }
+      }
+}
+
 static void
 gtk_widget_init (GtkWidget *widget)
 {
+  GtkWidgetPrivate *priv;
   GTK_PRIVATE_FLAGS (widget) = PRIVATE_GTK_CHILD_VISIBLE;
+
+  priv = GTK_WIDGET_GET_PRIVATE(widget);
+
   widget->state = GTK_STATE_NORMAL;
   widget->saved_state = GTK_STATE_NORMAL;
   widget->name = NULL;
@@ -1659,6 +1861,16 @@
   widget->window = NULL;
   widget->parent = NULL;
 
+  priv->timer_id = 0;
+  priv->menu = NULL;
+  priv->signals_connected = FALSE;
+  priv->x = priv->y = 0;
+  priv->func = NULL;
+  priv->timer_counter = 0;
+  priv->state_set = FALSE;
+  priv->interval = GTK_TAP_AND_HOLD_TIMER_INTERVAL;
+  priv->tah_on_window = NULL;
+  
   GTK_WIDGET_SET_FLAGS (widget,
 			GTK_SENSITIVE |
 			GTK_PARENT_SENSITIVE |
@@ -1670,6 +1882,7 @@
   GTK_PRIVATE_SET_FLAG (widget, GTK_ALLOC_NEEDED);
 
   widget->style = gtk_widget_get_default_style ();
+
   g_object_ref (widget->style);
 }
 
@@ -2153,6 +2366,7 @@
 
   if ((GTK_WIDGET_FLAGS (widget) & GTK_NO_SHOW_ALL) != 0)
     return;
+ 
 
   class = GTK_WIDGET_GET_CLASS (widget);
 
@@ -3400,6 +3614,131 @@
   return FALSE;
 }
 
+/**
+ * gtk_widget_button_press_event
+ * @widget: a #GtkWidget
+ * @event: a #GtkEventKey
+ *
+**/
+static gboolean gtk_widget_button_press_event (GtkWidget *widget, GdkEventButton *event )
+{
+  if (!mouse_pressed)
+    {
+      GtkWidget *toplevel;
+      toplevel = gtk_widget_get_toplevel (widget);
+      if (GTK_IS_WINDOW (toplevel))
+	{
+	  mouse_pressed = TRUE;
+
+	  if (GTK_IS_WIDGET (GTK_WINDOW (toplevel)->focus_widget))
+	    gtk_window_set_prev_focus_widget (GTK_WINDOW (toplevel),
+					      GTK_WINDOW (toplevel)->focus_widget);
+	}
+    }
+  return FALSE;
+}
+
+/**
+ * gtk_widget_button_release_event
+ * @widget: a #GtkWidget
+ * @event: a #GtkEventKey
+ *
+**/
+static gboolean gtk_widget_button_release_event (GtkWidget *widget, GdkEventButton *event)
+{
+  if (mouse_pressed)
+    {
+      GtkWidget *toplevel;
+      GtkWidget *event_widget;
+      event_widget = gtk_get_event_widget ((GdkEvent*)event);
+      toplevel = gtk_widget_get_toplevel (widget);
+
+      mouse_pressed = FALSE;
+      on_same_widget = TRUE;
+
+      if (GTK_IS_WINDOW (toplevel))
+	{
+	  if (!on_same_widget &&
+	      GTK_IS_WIDGET (GTK_WINDOW (toplevel)->focus_widget))
+	    gtk_window_set_prev_focus_widget (GTK_WINDOW (toplevel),
+					      GTK_WINDOW (toplevel)->focus_widget);
+	  else if (GTK_IS_WIDGET (event_widget))
+	    gtk_window_set_prev_focus_widget (GTK_WINDOW (toplevel),
+					      event_widget);
+	}
+    }
+  return FALSE;
+}
+
+/**
+ * gtk_widget_enter_notify_event
+ * @widget: a #GtkWidget
+ * @event: a #GtkEventCrossing
+ *
+**/
+static gboolean gtk_widget_enter_notify_event (GtkWidget *widget, GdkEventCrossing *event)
+{
+  GtkWidget *toplevel;
+  GtkWidget *event_widget;
+
+  toplevel = gtk_widget_get_toplevel (widget);
+  event_widget = gtk_get_event_widget ((GdkEvent*) event);
+
+  if (mouse_pressed && !on_same_widget && gtk_window_get_prev_focus_widget( GTK_WINDOW(toplevel) ) == event_widget)
+    {
+      on_same_widget = TRUE;
+
+      if (GTK_IS_WIDGET (GTK_WINDOW (toplevel)->focus_widget))
+	{
+	  gtk_window_set_prev_focus_widget (GTK_WINDOW(toplevel), GTK_WINDOW(toplevel)->focus_widget);
+	  if (GTK_WIDGET_CAN_FOCUS (event_widget))
+	    gtk_widget_grab_focus (event_widget);
+	}
+    }
+  return FALSE;
+}
+
+
+/**
+ * gtk_widget_leave_notify_event
+ * @widget: a #GtkWidget
+ * @event: a #GtkEventCrossing
+ * 
+**/
+static gboolean gtk_widget_leave_notify_event (GtkWidget *widget, GdkEventCrossing *event)
+{
+  if (mouse_pressed && on_same_widget)
+    {
+      GtkWidget *event_widget;
+      GtkWidget *toplevel;
+      GtkWidget *temp;
+      toplevel = gtk_widget_get_toplevel (widget);
+      event_widget = gtk_get_event_widget ((GdkEvent*) event);
+      on_same_widget = FALSE;
+
+      /* in general what we're trying to do here is to cancel widget selection
+         and go back to previous one if mouse is moved out from it while
+         button is still being pressed.
+
+         this isn't wanted at least between two entry widgets, so there's a
+         special case for it. it might not be wanted with entries at all, but
+         apparently just checking that caused some bug, so playing safe
+         here.. */
+      temp = gtk_window_get_prev_focus_widget (GTK_WINDOW (toplevel));
+      if (GTK_IS_WIDGET (temp) && GTK_IS_WIDGET (event_widget) &&
+          gtk_window_has_toplevel_focus (GTK_WINDOW (toplevel)) &&
+          (!GTK_IS_ENTRY(widget) || !GTK_IS_ENTRY(temp)))
+	{
+	  gtk_window_set_prev_focus_widget (GTK_WINDOW (toplevel),
+					    event_widget);
+	  if (GTK_WIDGET_CAN_FOCUS (temp))
+	    gtk_widget_grab_focus (temp);
+	}
+    }
+  return FALSE;
+}
+
+
 #define WIDGET_REALIZED_FOR_EVENT(widget, event) \
      (event->type == GDK_FOCUS_CHANGE || GTK_WIDGET_REALIZED(widget))
 
@@ -3945,13 +4284,40 @@
 }
 
 static void
+gtk_widget_set_valid_context (GtkIMContext **valid_context, GtkWidget *widget)
+{
+  GtkIMContext *context;
+
+  if (GTK_IS_ENTRY (widget))
+    context = GTK_ENTRY (widget)->im_context;
+  else if (GTK_IS_TEXT_VIEW (widget))
+    context = GTK_TEXT_VIEW (widget)->im_context;
+  else
+    return;
+
+  if (*valid_context != NULL)
+    g_object_unref (*valid_context);
+  *valid_context = context;
+  g_object_ref (*valid_context);
+}
+
+static void
 gtk_widget_real_grab_focus (GtkWidget *focus_widget)
 {
-  if (GTK_WIDGET_CAN_FOCUS (focus_widget))
+  if (GTK_WIDGET_CAN_FOCUS (focus_widget) &&
+      GTK_WIDGET_VISIBLE (focus_widget))
     {
+      /* we can't hide IM without IM context. it's possible to move
+       * focus to widget which doesn't have IM context, but which
+       * doesn't want IM to be hidden either. So, we have this
+       * static valid_context variable which is used... */
+      static GtkIMContext *valid_context = NULL;
       GtkWidget *toplevel;
       GtkWidget *widget;
-      
+      GtkIMContext *context;
+
+      gtk_widget_set_valid_context (&valid_context, focus_widget);
+
       /* clear the current focus setting, break if the current widget
        * is the focus widget's parent, since containers above that will
        * be set by the next loop.
@@ -3972,7 +4338,89 @@
 
 	      return;
 	    }
-	  
+
+	  gtk_widget_set_valid_context (&valid_context, widget);
+
+          if (valid_context)
+            {
+              gboolean is_combo, is_inside_toolbar;
+	      gboolean is_editable_entry, is_editable_text_view;
+              gboolean allow_deselect;
+              GtkWidget *parent, *deselect = NULL;
+
+              parent = gtk_widget_get_parent (focus_widget);
+              is_combo = GTK_IS_TOGGLE_BUTTON (focus_widget) &&
+                (GTK_IS_COMBO_BOX_ENTRY (parent) ||
+                 GTK_IS_COMBO_BOX (parent));
+              is_inside_toolbar =
+                gtk_widget_get_ancestor (focus_widget,
+                                         GTK_TYPE_TOOLBAR) != NULL;
+	      is_editable_entry = GTK_IS_ENTRY (focus_widget) &&
+		gtk_editable_get_editable (GTK_EDITABLE(focus_widget));
+	      is_editable_text_view = GTK_IS_TEXT_VIEW (focus_widget) &&
+		gtk_text_view_get_editable (GTK_TEXT_VIEW (focus_widget));
+
+              if (focus_widget == NULL ||
+		  !is_editable_entry &&
+		  !is_editable_text_view &&
+                  !GTK_IS_SCROLLBAR (focus_widget) &&
+                  !GTK_IS_MENU_ITEM (focus_widget) &&
+                  !GTK_IS_MENU (focus_widget) &&
+                  !is_inside_toolbar &&
+                  !is_combo)
+                {
+                  gtk_im_context_hide (valid_context);
+                }
+
+              /* remove text highlight (selection) unless focus is not moved
+                 inside a toolbar */
+              allow_deselect = (!is_inside_toolbar ||
+                                GTK_IS_ENTRY (focus_widget) ||
+                                GTK_IS_TEXT_VIEW (focus_widget));
+
+              if (selection_widget && allow_deselect)
+                {
+                  g_object_remove_weak_pointer (G_OBJECT (selection_widget),
+                                                (gpointer) &selection_widget);
+                  deselect = selection_widget;
+                  selection_widget = NULL;
+                }
+              else if (GTK_IS_ENTRY (widget) || GTK_IS_TEXT_VIEW (widget))
+                {
+                  if (allow_deselect)
+                    deselect = widget;
+                  else
+                    {
+                      selection_widget = widget;
+                      g_object_add_weak_pointer (G_OBJECT (selection_widget),
+                                                 (gpointer) &selection_widget);
+                    }
+                }
+
+              if (deselect)
+                {
+                  if (GTK_IS_ENTRY (deselect) &&
+                      gtk_editable_get_selection_bounds (GTK_EDITABLE (deselect), NULL, NULL))
+                    {
+                      gint pos;
+                      pos = gtk_editable_get_position (GTK_EDITABLE (deselect));
+                      gtk_editable_set_position (GTK_EDITABLE (deselect), pos);
+                    }
+                  else if (GTK_IS_TEXT_VIEW (deselect))
+                    {
+                      GtkTextBuffer *text_buff = gtk_text_view_get_buffer (GTK_TEXT_VIEW (deselect));
+
+                      if (gtk_text_buffer_get_selection_bounds (text_buff, NULL, NULL))
+                        {
+                          GtkTextIter insert;
+                          gtk_text_buffer_get_iter_at_mark (text_buff, &insert,
+                                  gtk_text_buffer_get_insert (text_buff));
+                          gtk_text_buffer_place_cursor (text_buff, &insert);
+                        }
+                    }
+                }
+            }
+
 	  if (widget)
 	    {
 	      while (widget->parent && widget->parent != focus_widget->parent)
@@ -4462,9 +4910,13 @@
 {
   g_return_if_fail (GTK_IS_WIDGET (widget));
 
-  if (!GTK_WIDGET_USER_STYLE (widget) &&
-      !GTK_WIDGET_RC_STYLE (widget))
+  if (!GTK_WIDGET_USER_STYLE (widget) && !GTK_WIDGET_RC_STYLE (widget))
+  {
+    gboolean hfh = FALSE;
     gtk_widget_reset_rc_style (widget);
+    gtk_widget_style_get( widget, "hildon-focus-handling", &hfh, NULL );
+    gtk_widget_set_focus_handling( widget, hfh );
+  }
 }
 
 /* Look up the RC style for this widget, unsetting any user style that
@@ -6396,7 +6848,7 @@
   
   if (!GTK_WIDGET_DIRECTION_SET (widget))
     gtk_widget_emit_direction_changed (widget, old_dir);
-  
+
   if (GTK_IS_CONTAINER (widget))
     gtk_container_forall (GTK_CONTAINER (widget),
 			  gtk_widget_set_default_direction_recurse,
@@ -6405,6 +6857,13 @@
   g_object_unref (widget);
 }
 
+/* Non static */
+void gtk_widget_set_direction_recursive(GtkWidget * widget,  GtkTextDirection dir )
+{
+  gtk_widget_set_default_direction_recurse( widget, GUINT_TO_POINTER(dir) );
+}
+               
+
 /**
  * gtk_widget_set_default_direction:
  * @dir: the new default direction. This cannot be
@@ -6422,7 +6881,7 @@
     {
       GList *toplevels, *tmp_list;
       GtkTextDirection old_dir = gtk_default_direction;
-      
+
       gtk_default_direction = dir;
 
       tmp_list = toplevels = gtk_window_list_toplevels ();
@@ -6476,6 +6935,9 @@
 {
   /* gtk_object_destroy() will already hold a refcount on object */
   GtkWidget *widget = GTK_WIDGET (object);
+#ifdef TAP_AND_HOLD_ANIMATION
+  GtkWidgetPrivate *priv = GTK_WIDGET_GET_PRIVATE(widget);
+#endif
 
   /* wipe accelerator closures (keep order) */
   g_object_set_qdata (G_OBJECT (widget), quark_accel_path, NULL);
@@ -6490,6 +6952,14 @@
   widget->style = gtk_widget_get_default_style ();
   g_object_ref (widget->style);
 
+#ifdef TAP_AND_HOLD_ANIMATION
+  if( priv->anim )
+  {
+    g_object_unref(priv->anim);
+    priv->anim = NULL;
+  }
+#endif
+
   GTK_OBJECT_CLASS (parent_class)->destroy (object);
 }
 
@@ -6497,6 +6967,7 @@
 gtk_widget_finalize (GObject *object)
 {
   GtkWidget *widget = GTK_WIDGET (object);
+  GtkWidgetPrivate *priv = GTK_WIDGET_GET_PRIVATE(object);
   GtkWidgetAuxInfo *aux_info;
   gint *events;
   GdkExtensionMode *mode;
@@ -6507,6 +6978,12 @@
   g_object_unref (widget->style);
   widget->style = NULL;
 
+  if (priv->timer_id)
+    {
+      g_source_remove (priv->timer_id);
+      priv->timer_id = 0;
+    }
+  
   if (widget->name)
     g_free (widget->name);
   
@@ -6526,6 +7003,9 @@
   if (accessible)
     g_object_unref (accessible);
 
+  if  (GTK_IS_MENU(priv->menu))
+    gtk_widget_destroy (priv->menu);
+
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
 
@@ -7574,6 +8054,386 @@
     GTK_WIDGET_SET_FLAGS (widget, GTK_NO_SHOW_ALL);
   else
     GTK_WIDGET_UNSET_FLAGS (widget, GTK_NO_SHOW_ALL);
-  
+
   g_object_notify (G_OBJECT (widget), "no_show_all");
 }
+
+void gtk_widget_insensitive_press ( GtkWidget *widget )
+{
+  g_return_if_fail (GTK_IS_WIDGET (widget));
+
+  g_signal_emit(widget, widget_signals[INSENSITIVE_PRESS], 0);
+}
+
+/*Tap And Hold*/
+
+#ifdef TAP_AND_HOLD_ANIMATION
+static void
+stop_tap_and_hold_animation (GtkWidget *widget)
+{
+  GtkWidgetPrivate *priv = GTK_WIDGET_GET_PRIVATE (widget);
+  if (!GDK_IS_WINDOW (priv->tah_on_window))
+    return;
+
+  if (priv->anim)
+    gdk_window_set_cursor (priv->tah_on_window, NULL);
+  priv->tah_on_window = NULL;
+}
+#endif
+
+void tap_and_hold_remove_timer (GtkWidget *widget)
+{
+  GtkWidgetPrivate *priv = GTK_WIDGET_GET_PRIVATE (widget);
+  if (priv->timer_id)
+    {
+      g_source_remove (priv->timer_id);
+      priv->timer_id = 0;
+    }
+
+  priv->x = priv->y = priv->timer_counter = 0;
+#ifdef TAP_AND_HOLD_ANIMATION
+  stop_tap_and_hold_animation (widget);
+#endif
+}
+
+#ifdef TAP_AND_HOLD_ANIMATION
+static void
+init_tap_and_hold_animation (GtkWidgetPrivate *priv)
+{
+  GTimeVal time;
+  if (priv->anim)
+    {
+      g_get_current_time (&time);
+      priv->iter = gdk_pixbuf_animation_get_iter (priv->anim, &time);
+      priv->interval = gdk_pixbuf_animation_iter_get_delay_time (priv->iter);
+    }
+}
+
+static gboolean
+timeout_tap_and_hold_animation (GtkWidget *widget)
+{
+  GtkWidgetPrivate *priv = GTK_WIDGET_GET_PRIVATE (widget);
+
+  if (!GDK_IS_WINDOW (priv->tah_on_window))
+    {
+      tap_and_hold_remove_timer (widget);
+      return FALSE;
+    }
+
+  if (priv->anim)
+    {
+      guint new_interval = 0;
+      GTimeVal time;
+      GdkScreen *screen;
+      GdkPixbuf *pic;
+      GdkCursor *cursor;
+
+      g_get_current_time (&time);
+      screen = gdk_screen_get_default ();
+      pic = gdk_pixbuf_animation_iter_get_pixbuf (priv->iter);
+      
+      pic = gdk_pixbuf_copy (pic);
+      
+      if (!GDK_IS_PIXBUF (pic))
+      	return TRUE;
+
+      cursor = gdk_cursor_new_from_pixbuf (gdk_display_get_default (), pic,
+					   priv->width, priv->height);
+      g_object_unref (pic);
+
+      if (!cursor)
+      	return TRUE;
+
+      gdk_window_set_cursor (priv->tah_on_window, cursor);
+      gdk_cursor_unref (cursor);
+
+      gdk_pixbuf_animation_iter_advance (priv->iter, &time);
+
+      new_interval = gdk_pixbuf_animation_iter_get_delay_time (priv->iter);
+
+      if (new_interval != priv->interval && priv->timer_counter)
+	{
+	  priv->interval = new_interval;
+	  priv->timer_id = g_timeout_add (priv->interval,
+					  (GSourceFunc)gtk_widget_tap_and_hold_timeout, widget);
+	  return FALSE;
+	}
+    }
+  return TRUE;
+}
+
+#endif
+
+/**
+ * gtk_widget_tap_and_hold_setup:
+ *
+ * @widget : A @GtkWidget
+ * @menu : A @GtkWidget
+ * @func : A @GtkCallback
+ * @flags : A @GtkWidgetTapAndHoldFlags
+ *
+ * Setups the tap and hold functionality to the @widget.
+ * The @menu is shown when the functionality is activated.
+ * If the @menu is wanted to be positioned in a different way than the
+ * gtk+ default, the menuposition @func can be passed as a third parameter.
+ * Fourth parameter, @flags is debricated and has no effect.
+ */
+void gtk_widget_tap_and_hold_setup (GtkWidget *widget, GtkWidget *menu,
+				    GtkCallback func,
+				    GtkWidgetTapAndHoldFlags flags)
+{
+  /*GtkWidgetClass *klass = GTK_WIDGET_GET_CLASS(widget);*/
+  g_return_if_fail (GTK_IS_WIDGET (widget));
+  g_return_if_fail (menu == NULL || GTK_IS_MENU (menu));
+  g_signal_emit (widget, widget_signals[TAP_AND_HOLD_SETUP], 0, menu, func,
+		 flags);
+}
+
+static void gtk_widget_tap_and_hold_setup_real (GtkWidget *widget,
+						GtkWidget *menu,
+						GtkCallback func,
+						GtkWidgetTapAndHoldFlags flags)
+{
+#ifdef TAP_AND_HOLD_ANIMATION
+  GtkIconTheme *theme = NULL;
+  GtkIconInfo *info = NULL;
+  GError *error = NULL;
+  const gchar *filename = NULL;
+  GdkWindow *window = NULL;
+#endif
+
+  GtkWidgetPrivate *priv;
+  g_return_if_fail (GTK_IS_WIDGET (widget));
+  g_return_if_fail (menu == NULL || GTK_IS_MENU (menu));
+  priv = GTK_WIDGET_GET_PRIVATE (widget);
+  if (priv->signals_connected)
+    return;
+
+  if (menu != NULL)
+    _gtk_menu_enable_context_menu_behavior (GTK_MENU (menu));
+
+  priv->menu = menu;
+  priv->func = (GtkMenuPositionFunc)func;
+  priv->signals_connected = TRUE;
+  priv->timer_counter = 0;
+
+  g_signal_connect (widget, "button-press-event",
+		    G_CALLBACK (gtk_widget_tap_and_hold_button_press), priv);
+  g_signal_connect (widget, "button-release-event",
+		    G_CALLBACK (gtk_widget_tap_and_hold_event_stop), priv);
+  g_signal_connect (widget, "leave-notify-event",
+		    G_CALLBACK (gtk_widget_tap_and_hold_event_stop), priv);
+  g_signal_connect (widget, "drag-begin",
+		    G_CALLBACK (gtk_widget_tap_and_hold_event_stop), priv);
+
+#ifdef TAP_AND_HOLD_ANIMATION
+  window = gdk_get_default_root_window ();
+  priv->anim = g_object_get_data (G_OBJECT (window),
+				  "gtk-tap-and-hold-animation");
+  if (!GDK_IS_PIXBUF_ANIMATION (priv->anim))
+    {
+      theme = gtk_icon_theme_get_default ();
+      if (!theme)
+	{
+	  g_warning ("Unable to find icon theme");
+	  return;
+	}
+
+      info = gtk_icon_theme_lookup_icon (theme, "qgn_indi_tap_hold_a", GTK_ICON_SIZE_BUTTON,
+					 GTK_ICON_LOOKUP_NO_SVG);
+      if (!info)
+	{
+	  g_warning ("Unable to find icon info");
+	  return;
+	}
+
+      filename = gtk_icon_info_get_filename (info);
+      if (!filename)
+	{
+	  gtk_icon_info_free (info);
+	  g_warning ("Unable to find tap and hold icon filename");
+	  return;
+	}
+
+      priv->anim = gdk_pixbuf_animation_new_from_file (filename, &error);
+
+      if (error)
+	{
+	  g_warning ("Unable to create tap and hold animation: %s", error->message);
+	  priv->anim = NULL;
+	  g_error_free (error);
+	  gtk_icon_info_free (info);
+	  return;
+	}
+
+      gtk_icon_info_free (info);
+
+      priv->width = gdk_pixbuf_animation_get_width (priv->anim)/2;
+      priv->height = gdk_pixbuf_animation_get_height (priv->anim)/2;
+      g_object_set_data (G_OBJECT (window),
+			 "gtk-tap-and-hold-animation", priv->anim);
+    }
+  g_object_ref (priv->anim);
+#endif
+}
+
+static void gtk_widget_real_tap_and_hold (GtkWidget *widget)
+{
+  GtkWidgetPrivate *priv = GTK_WIDGET_GET_PRIVATE (widget);
+  if (GTK_IS_MENU (priv->menu))
+    gtk_menu_popup (GTK_MENU (priv->menu), NULL, NULL,
+		    (GtkMenuPositionFunc)priv->func,
+		    widget, 1, gdk_x11_get_server_time (widget->window));
+}
+
+static gboolean gtk_widget_tap_and_hold_timeout (GtkWidget *widget)
+{
+  GtkWidgetPrivate *priv= GTK_WIDGET_GET_PRIVATE (widget);
+  gboolean result = TRUE;
+  gint x = 0, y = 0;
+
+  if (!GDK_IS_WINDOW (priv->tah_on_window))
+    {
+      tap_and_hold_remove_timer (widget);
+      return FALSE;
+    }
+  /* A small timeout before starting the tap and hold */
+  if (priv->timer_counter == GTK_TAP_AND_HOLD_TIMER_COUNTER)
+    {
+      priv->timer_counter--;
+      return TRUE;
+    }
+
+#ifdef TAP_AND_HOLD_ANIMATION
+  result = timeout_tap_and_hold_animation (widget);
+#endif
+
+  if (priv->timer_counter)
+    priv->timer_counter--;
+  else
+    priv->timer_id = 0;
+
+  gdk_display_get_pointer (gdk_x11_lookup_xdisplay (
+			   GDK_WINDOW_XDISPLAY (
+			   priv->tah_on_window)),
+			   NULL, &x, &y, NULL);
+
+  /* Did we dragged too far from the start point */
+  if ((abs (x - priv->x) > GTK_TAP_THRESHOLD) ||
+      (abs (y - priv->y) > GTK_TAP_THRESHOLD))
+    {
+      tap_and_hold_remove_timer (widget);
+      return FALSE;
+    }
+
+  /* Was that the last cycle -> tah starts */
+  if (!priv->timer_id)
+    {
+      tap_and_hold_remove_timer (widget);
+      _gtk_widget_grab_notify (widget, FALSE);
+      g_signal_emit (widget, widget_signals[TAP_AND_HOLD], 0);
+      return FALSE;
+    }
+  return result;
+}
+
+static gboolean gtk_widget_tap_and_hold_real_query (GtkWidget *widget, GdkEvent *event)
+{
+  return FALSE;
+}
+
+static gboolean gtk_widget_tap_and_hold_query (GtkWidget *widget, GdkEvent *event)
+{
+  gboolean return_value = FALSE;
+  g_signal_emit (G_OBJECT (widget), widget_signals[TAP_AND_HOLD_QUERY],
+		 0, event, &return_value);
+  return return_value;
+}
+
+static gboolean gtk_widget_tap_and_hold_button_press (GtkWidget *widget,
+						      GdkEvent *event,
+						      GtkWidgetPrivate *priv)
+{
+  if (event->button.type == GDK_2BUTTON_PRESS)
+    return FALSE;
+
+  if (!gtk_widget_tap_and_hold_query (widget, event) && !priv->timer_id)
+    {
+      gdk_display_get_pointer (gdk_x11_lookup_xdisplay (
+                               GDK_WINDOW_XDISPLAY (widget->window)),
+			       NULL, &priv->x, &priv->y, NULL);
+
+      priv->timer_counter = GTK_TAP_AND_HOLD_TIMER_COUNTER;
+      priv->tah_on_window = widget->window;
+
+#ifdef TAP_AND_HOLD_ANIMATION
+      init_tap_and_hold_animation (priv);
+#endif
+      priv->timer_id = g_timeout_add (priv->interval,
+				      (GSourceFunc)
+				      gtk_widget_tap_and_hold_timeout, widget);
+    }
+  return FALSE;
+}
+
+static gboolean gtk_widget_tap_and_hold_event_stop (GtkWidget *widget,
+						    gpointer unused,
+						    GtkWidgetPrivate *priv)
+{
+  if (priv->timer_id)
+    tap_and_hold_remove_timer (widget);
+  return FALSE;
+}
+
+/**
+ * gtk_widget_tap_and_hold_menu_position_top:
+ * @menu: a #GtkMenu
+ * @x: x cordinate to be returned
+ * @y: y cordinate to be returned
+ * @push_in: If going off screen, push it pack on the screen
+ * @widget: a #GtkWidget
+ *
+ * Pre-made menu positioning function.
+ * It positiones the @menu over the @widget.
+ *
+ **/
+void gtk_widget_tap_and_hold_menu_position_top (GtkWidget *menu,
+						gint *x, gint *y,
+						gboolean *push_in,
+						GtkWidget *widget)
+{
+  /*
+   * This function positiones the menu above widgets.
+   * This is a modified version of the position function
+   * gtk_combo_box_position_over.
+   */
+  GtkWidget *topw;
+  GtkRequisition requisition;
+  gint screen_width = 0;
+  gint menu_xpos = 0;
+  gint menu_ypos = 0;
+  gint w_xpos = 0, w_ypos = 0;
+  gtk_widget_size_request (menu, &requisition);
+
+  topw = gtk_widget_get_toplevel (widget);
+  gdk_window_get_origin (topw->window, &w_xpos, &w_ypos);
+
+  menu_xpos += widget->allocation.x + w_xpos;
+  menu_ypos += widget->allocation.y + w_ypos - requisition.height;
+
+  if (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_RTL)
+    menu_xpos = menu_xpos + widget->allocation.width - requisition.width;
+
+  screen_width = gdk_screen_get_width (gtk_widget_get_screen (widget));
+
+  if (menu_xpos < w_xpos)
+    menu_xpos = w_xpos;
+  else if ((menu_xpos + requisition.width) > screen_width)
+    menu_xpos -= ((menu_xpos + requisition.width) - screen_width);
+  if (menu_ypos < w_ypos)
+    menu_ypos = w_ypos;
+
+  *x = menu_xpos;
+  *y = menu_ypos;
+  *push_in = TRUE;
+}
--- gtk+/gtk/gtktreemodelfilter.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtktreemodelfilter.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -1210,14 +1210,22 @@
       if (gtk_tree_path_get_depth (filter->priv->virtual_root) >=
           gtk_tree_path_get_depth (c_path))
         {
-          gint level;
+          gint level, i;
           gint *v_indices, *c_indices;
+          gboolean common_prefix = TRUE;
 
           level = gtk_tree_path_get_depth (c_path) - 1;
           v_indices = gtk_tree_path_get_indices (filter->priv->virtual_root);
           c_indices = gtk_tree_path_get_indices (c_path);
 
-          if (v_indices[level] >= c_indices[level])
+          for (i = 0; i < level; i++)
+            if (v_indices[i] != c_indices[i])
+            {
+              common_prefix = FALSE;
+              break;
+            }
+
+          if (common_prefix && v_indices[level] >= c_indices[level])
             (v_indices[level])++;
         }
     }
@@ -1381,6 +1389,7 @@
   GtkTreeModelFilter *filter = GTK_TREE_MODEL_FILTER (data);
   GtkTreePath *path;
   GtkTreeIter iter;
+  FilterElt *elt;
 
   g_return_if_fail (c_path != NULL && c_iter != NULL);
 
@@ -1397,6 +1406,13 @@
     return;
 
   gtk_tree_model_get_iter (GTK_TREE_MODEL (data), &iter, path);
+  elt = FILTER_ELT (iter.user_data2);
+
+  /* Make sure that we clear children of this node if
+     child model has no children */
+  if (elt->children && !gtk_tree_model_iter_has_child(c_model, c_iter))
+    gtk_tree_model_filter_free_level(filter, elt->children);
+
   gtk_tree_model_row_has_child_toggled (GTK_TREE_MODEL (data), path, &iter);
 
   gtk_tree_path_free (path);
@@ -1455,14 +1471,22 @@
       if (gtk_tree_path_get_depth (filter->priv->virtual_root) >=
           gtk_tree_path_get_depth (c_path))
         {
-          gint level;
+          gint level, i;
           gint *v_indices, *c_indices;
+          gboolean common_prefix = TRUE;
 
           level = gtk_tree_path_get_depth (c_path) - 1;
           v_indices = gtk_tree_path_get_indices (filter->priv->virtual_root);
           c_indices = gtk_tree_path_get_indices (c_path);
 
-          if (v_indices[level] > c_indices[level])
+          for (i = 0; i < level; i++)
+            if (v_indices[i] != c_indices[i])
+            {
+              common_prefix = FALSE;
+              break;
+            }
+
+          if (common_prefix && v_indices[level] > c_indices[level])
             (v_indices[level])--;
         }
     }
--- gtk+/gtk/gtkmarshal.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkmarshal.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -48,7 +48,7 @@
 #endif /* !G_ENABLE_DEBUG */
 
 
-/* BOOL:NONE (./gtkmarshal.list:1) */
+/* BOOL:NONE (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:1) */
 void
 gtk_marshal_BOOLEAN__VOID (GClosure     *closure,
                            GValue       *return_value,
@@ -85,7 +85,7 @@
   g_value_set_boolean (return_value, v_return);
 }
 
-/* BOOL:POINTER (./gtkmarshal.list:2) */
+/* BOOL:POINTER (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:2) */
 void
 gtk_marshal_BOOLEAN__POINTER (GClosure     *closure,
                               GValue       *return_value,
@@ -124,7 +124,7 @@
   g_value_set_boolean (return_value, v_return);
 }
 
-/* BOOL:POINTER,POINTER,INT,INT (./gtkmarshal.list:3) */
+/* BOOL:POINTER,POINTER,INT,INT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:3) */
 void
 gtk_marshal_BOOLEAN__POINTER_POINTER_INT_INT (GClosure     *closure,
                                               GValue       *return_value,
@@ -169,7 +169,7 @@
   g_value_set_boolean (return_value, v_return);
 }
 
-/* BOOL:POINTER,INT,INT (./gtkmarshal.list:4) */
+/* BOOL:POINTER,INT,INT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:4) */
 void
 gtk_marshal_BOOLEAN__POINTER_INT_INT (GClosure     *closure,
                                       GValue       *return_value,
@@ -212,7 +212,7 @@
   g_value_set_boolean (return_value, v_return);
 }
 
-/* BOOL:POINTER,INT,INT,UINT (./gtkmarshal.list:5) */
+/* BOOL:POINTER,INT,INT,UINT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:5) */
 void
 gtk_marshal_BOOLEAN__POINTER_INT_INT_UINT (GClosure     *closure,
                                            GValue       *return_value,
@@ -257,7 +257,7 @@
   g_value_set_boolean (return_value, v_return);
 }
 
-/* BOOL:POINTER,STRING,STRING,POINTER (./gtkmarshal.list:6) */
+/* BOOL:POINTER,STRING,STRING,POINTER (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:6) */
 void
 gtk_marshal_BOOLEAN__POINTER_STRING_STRING_POINTER (GClosure     *closure,
                                                     GValue       *return_value,
@@ -302,7 +302,7 @@
   g_value_set_boolean (return_value, v_return);
 }
 
-/* ENUM:ENUM (./gtkmarshal.list:7) */
+/* ENUM:ENUM (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:7) */
 void
 gtk_marshal_ENUM__ENUM (GClosure     *closure,
                         GValue       *return_value,
@@ -341,7 +341,7 @@
   g_value_set_enum (return_value, v_return);
 }
 
-/* INT:POINTER (./gtkmarshal.list:8) */
+/* INT:POINTER (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:8) */
 void
 gtk_marshal_INT__POINTER (GClosure     *closure,
                           GValue       *return_value,
@@ -380,7 +380,7 @@
   g_value_set_int (return_value, v_return);
 }
 
-/* INT:POINTER,CHAR,CHAR (./gtkmarshal.list:9) */
+/* INT:POINTER,CHAR,CHAR (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:9) */
 void
 gtk_marshal_INT__POINTER_CHAR_CHAR (GClosure     *closure,
                                     GValue       *return_value,
@@ -423,13 +423,13 @@
   g_value_set_int (return_value, v_return);
 }
 
-/* NONE:BOOL (./gtkmarshal.list:10) */
+/* NONE:BOOL (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:10) */
 
-/* NONE:BOXED (./gtkmarshal.list:11) */
+/* NONE:BOXED (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:11) */
 
-/* NONE:ENUM (./gtkmarshal.list:12) */
+/* NONE:ENUM (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:12) */
 
-/* NONE:ENUM,FLOAT (./gtkmarshal.list:13) */
+/* NONE:ENUM,FLOAT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:13) */
 void
 gtk_marshal_VOID__ENUM_FLOAT (GClosure     *closure,
                               GValue       *return_value,
@@ -466,7 +466,7 @@
             data2);
 }
 
-/* NONE:ENUM,FLOAT,BOOL (./gtkmarshal.list:14) */
+/* NONE:ENUM,FLOAT,BOOL (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:14) */
 void
 gtk_marshal_VOID__ENUM_FLOAT_BOOLEAN (GClosure     *closure,
                                       GValue       *return_value,
@@ -505,9 +505,9 @@
             data2);
 }
 
-/* NONE:INT (./gtkmarshal.list:15) */
+/* NONE:INT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:15) */
 
-/* NONE:INT,INT (./gtkmarshal.list:16) */
+/* NONE:INT,INT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:16) */
 void
 gtk_marshal_VOID__INT_INT (GClosure     *closure,
                            GValue       *return_value,
@@ -544,7 +544,7 @@
             data2);
 }
 
-/* NONE:INT,INT,POINTER (./gtkmarshal.list:17) */
+/* NONE:INT,INT,POINTER (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:17) */
 void
 gtk_marshal_VOID__INT_INT_POINTER (GClosure     *closure,
                                    GValue       *return_value,
@@ -583,13 +583,13 @@
             data2);
 }
 
-/* NONE:NONE (./gtkmarshal.list:18) */
+/* NONE:NONE (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:18) */
 
-/* NONE:OBJECT (./gtkmarshal.list:19) */
+/* NONE:OBJECT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:19) */
 
-/* NONE:POINTER (./gtkmarshal.list:20) */
+/* NONE:POINTER (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:20) */
 
-/* NONE:POINTER,INT (./gtkmarshal.list:21) */
+/* NONE:POINTER,INT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:21) */
 void
 gtk_marshal_VOID__POINTER_INT (GClosure     *closure,
                                GValue       *return_value,
@@ -626,7 +626,7 @@
             data2);
 }
 
-/* NONE:POINTER,POINTER (./gtkmarshal.list:22) */
+/* NONE:POINTER,POINTER (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:22) */
 void
 gtk_marshal_VOID__POINTER_POINTER (GClosure     *closure,
                                    GValue       *return_value,
@@ -663,7 +663,7 @@
             data2);
 }
 
-/* NONE:POINTER,POINTER,POINTER (./gtkmarshal.list:23) */
+/* NONE:POINTER,POINTER,POINTER (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:23) */
 void
 gtk_marshal_VOID__POINTER_POINTER_POINTER (GClosure     *closure,
                                            GValue       *return_value,
@@ -702,7 +702,7 @@
             data2);
 }
 
-/* NONE:POINTER,STRING,STRING (./gtkmarshal.list:24) */
+/* NONE:POINTER,STRING,STRING (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:24) */
 void
 gtk_marshal_VOID__POINTER_STRING_STRING (GClosure     *closure,
                                          GValue       *return_value,
@@ -741,7 +741,7 @@
             data2);
 }
 
-/* NONE:POINTER,UINT (./gtkmarshal.list:25) */
+/* NONE:POINTER,UINT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:25) */
 void
 gtk_marshal_VOID__POINTER_UINT (GClosure     *closure,
                                 GValue       *return_value,
@@ -778,7 +778,7 @@
             data2);
 }
 
-/* NONE:POINTER,UINT,ENUM (./gtkmarshal.list:26) */
+/* NONE:POINTER,UINT,ENUM (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:26) */
 void
 gtk_marshal_VOID__POINTER_UINT_ENUM (GClosure     *closure,
                                      GValue       *return_value,
@@ -817,7 +817,7 @@
             data2);
 }
 
-/* NONE:POINTER,POINTER,UINT,UINT (./gtkmarshal.list:27) */
+/* NONE:POINTER,POINTER,UINT,UINT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:27) */
 void
 gtk_marshal_VOID__POINTER_POINTER_UINT_UINT (GClosure     *closure,
                                              GValue       *return_value,
@@ -858,7 +858,7 @@
             data2);
 }
 
-/* NONE:POINTER,INT,INT,POINTER,UINT,UINT (./gtkmarshal.list:28) */
+/* NONE:POINTER,INT,INT,POINTER,UINT,UINT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:28) */
 void
 gtk_marshal_VOID__POINTER_INT_INT_POINTER_UINT_UINT (GClosure     *closure,
                                                      GValue       *return_value,
@@ -903,7 +903,7 @@
             data2);
 }
 
-/* NONE:POINTER,UINT,UINT (./gtkmarshal.list:29) */
+/* NONE:POINTER,UINT,UINT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:29) */
 void
 gtk_marshal_VOID__POINTER_UINT_UINT (GClosure     *closure,
                                      GValue       *return_value,
@@ -942,11 +942,11 @@
             data2);
 }
 
-/* NONE:POINTER,UINT,UINT (./gtkmarshal.list:30) */
+/* NONE:POINTER,UINT,UINT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:30) */
 
-/* NONE:STRING (./gtkmarshal.list:31) */
+/* NONE:STRING (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:31) */
 
-/* NONE:STRING,INT,POINTER (./gtkmarshal.list:32) */
+/* NONE:STRING,INT,POINTER (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:32) */
 void
 gtk_marshal_VOID__STRING_INT_POINTER (GClosure     *closure,
                                       GValue       *return_value,
@@ -985,9 +985,9 @@
             data2);
 }
 
-/* NONE:UINT (./gtkmarshal.list:33) */
+/* NONE:UINT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:33) */
 
-/* NONE:UINT,POINTER,UINT,ENUM,ENUM,POINTER (./gtkmarshal.list:34) */
+/* NONE:UINT,POINTER,UINT,ENUM,ENUM,POINTER (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:34) */
 void
 gtk_marshal_VOID__UINT_POINTER_UINT_ENUM_ENUM_POINTER (GClosure     *closure,
                                                        GValue       *return_value,
@@ -1032,7 +1032,7 @@
             data2);
 }
 
-/* NONE:UINT,POINTER,UINT,UINT,ENUM (./gtkmarshal.list:35) */
+/* NONE:UINT,POINTER,UINT,UINT,ENUM (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:35) */
 void
 gtk_marshal_VOID__UINT_POINTER_UINT_UINT_ENUM (GClosure     *closure,
                                                GValue       *return_value,
@@ -1075,7 +1075,7 @@
             data2);
 }
 
-/* NONE:UINT,STRING (./gtkmarshal.list:36) */
+/* NONE:UINT,STRING (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:36) */
 void
 gtk_marshal_VOID__UINT_STRING (GClosure     *closure,
                                GValue       *return_value,
--- gtk+/gtk/gtkwidget.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkwidget.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -22,6 +22,9 @@
  * file for a list of people on the GTK+ Team.  See the ChangeLog
  * files for a list of changes.  These files are distributed with
  * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
+
+ * Changes made to create Hildon focus handling and the tap and hold functionality
+ *
  */
 
 #ifndef __GTK_WIDGET_H__
@@ -87,6 +90,15 @@
   GTK_WIDGET_HELP_WHATS_THIS
 } GtkWidgetHelpType;
 
+/*Tap And Hold type flags*/
+typedef enum
+{
+  GTK_TAP_AND_HOLD_NONE         = 0,
+  GTK_TAP_AND_HOLD_PASS_PRESS   = 1 << 0,
+  GTK_TAP_AND_HOLD_NO_SIGNALS   = 1 << 1,
+  GTK_TAP_AND_HOLD_NO_INTERNALS = 1 << 2
+} GtkWidgetTapAndHoldFlags;
+
 /* Macro for casting a pointer to a GtkWidget or GtkWidgetClass pointer.
  * Macros for testing whether `widget' or `klass' are of type GTK_TYPE_WIDGET.
  */
@@ -409,10 +421,11 @@
   /* Padding for future expansion */
   void (*_gtk_reserved2) (void);
   void (*_gtk_reserved3) (void);
-  void (*_gtk_reserved4) (void);
-  void (*_gtk_reserved5) (void);
-  void (*_gtk_reserved6) (void);
-  void (*_gtk_reserved7) (void);
+  void (*tap_and_hold) (GtkWidget *widget);   /* Tap and hold action */
+  void (*tap_and_hold_setup) (GtkWidget *widget, GtkWidget *menu,
+			      GtkCallback func, GtkWidgetTapAndHoldFlags flags);
+  gboolean (*tap_and_hold_query) (GtkWidget *widget, GdkEvent *event);
+  void (*insensitive_press) (GtkWidget *widget);
 };
 
 struct _GtkWidgetAuxInfo
@@ -787,6 +800,16 @@
 
 GdkColormap* _gtk_widget_peek_colormap (void);
 
+/*Hildon functions for focus handling*/
+void gtk_widget_set_hildon_focus_handling( GtkWidget *widget, gboolean hildon_like );
+gboolean gtk_widget_get_hildon_focus_handling( GtkWidget *widget );
+
+/*Tap And Hold functions*/
+void gtk_widget_tap_and_hold_menu_position_top (GtkWidget *menu,
+                       gint *x, gint *y, gboolean *push_in, GtkWidget *widget);
+void gtk_widget_tap_and_hold_setup (GtkWidget *widget, GtkWidget *menu,
+                        GtkCallback func, GtkWidgetTapAndHoldFlags flags);
+
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
--- gtk+/gtk/gtkmarshal.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkmarshal.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -7,7 +7,7 @@
 
 G_BEGIN_DECLS
 
-/* BOOL:NONE (./gtkmarshal.list:1) */
+/* BOOL:NONE (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:1) */
 extern void gtk_marshal_BOOLEAN__VOID (GClosure     *closure,
                                        GValue       *return_value,
                                        guint         n_param_values,
@@ -16,7 +16,7 @@
                                        gpointer      marshal_data);
 #define gtk_marshal_BOOL__NONE	gtk_marshal_BOOLEAN__VOID
 
-/* BOOL:POINTER (./gtkmarshal.list:2) */
+/* BOOL:POINTER (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:2) */
 extern void gtk_marshal_BOOLEAN__POINTER (GClosure     *closure,
                                           GValue       *return_value,
                                           guint         n_param_values,
@@ -25,7 +25,7 @@
                                           gpointer      marshal_data);
 #define gtk_marshal_BOOL__POINTER	gtk_marshal_BOOLEAN__POINTER
 
-/* BOOL:POINTER,POINTER,INT,INT (./gtkmarshal.list:3) */
+/* BOOL:POINTER,POINTER,INT,INT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:3) */
 extern void gtk_marshal_BOOLEAN__POINTER_POINTER_INT_INT (GClosure     *closure,
                                                           GValue       *return_value,
                                                           guint         n_param_values,
@@ -34,7 +34,7 @@
                                                           gpointer      marshal_data);
 #define gtk_marshal_BOOL__POINTER_POINTER_INT_INT	gtk_marshal_BOOLEAN__POINTER_POINTER_INT_INT
 
-/* BOOL:POINTER,INT,INT (./gtkmarshal.list:4) */
+/* BOOL:POINTER,INT,INT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:4) */
 extern void gtk_marshal_BOOLEAN__POINTER_INT_INT (GClosure     *closure,
                                                   GValue       *return_value,
                                                   guint         n_param_values,
@@ -43,7 +43,7 @@
                                                   gpointer      marshal_data);
 #define gtk_marshal_BOOL__POINTER_INT_INT	gtk_marshal_BOOLEAN__POINTER_INT_INT
 
-/* BOOL:POINTER,INT,INT,UINT (./gtkmarshal.list:5) */
+/* BOOL:POINTER,INT,INT,UINT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:5) */
 extern void gtk_marshal_BOOLEAN__POINTER_INT_INT_UINT (GClosure     *closure,
                                                        GValue       *return_value,
                                                        guint         n_param_values,
@@ -52,7 +52,7 @@
                                                        gpointer      marshal_data);
 #define gtk_marshal_BOOL__POINTER_INT_INT_UINT	gtk_marshal_BOOLEAN__POINTER_INT_INT_UINT
 
-/* BOOL:POINTER,STRING,STRING,POINTER (./gtkmarshal.list:6) */
+/* BOOL:POINTER,STRING,STRING,POINTER (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:6) */
 extern void gtk_marshal_BOOLEAN__POINTER_STRING_STRING_POINTER (GClosure     *closure,
                                                                 GValue       *return_value,
                                                                 guint         n_param_values,
@@ -61,7 +61,7 @@
                                                                 gpointer      marshal_data);
 #define gtk_marshal_BOOL__POINTER_STRING_STRING_POINTER	gtk_marshal_BOOLEAN__POINTER_STRING_STRING_POINTER
 
-/* ENUM:ENUM (./gtkmarshal.list:7) */
+/* ENUM:ENUM (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:7) */
 extern void gtk_marshal_ENUM__ENUM (GClosure     *closure,
                                     GValue       *return_value,
                                     guint         n_param_values,
@@ -69,7 +69,7 @@
                                     gpointer      invocation_hint,
                                     gpointer      marshal_data);
 
-/* INT:POINTER (./gtkmarshal.list:8) */
+/* INT:POINTER (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:8) */
 extern void gtk_marshal_INT__POINTER (GClosure     *closure,
                                       GValue       *return_value,
                                       guint         n_param_values,
@@ -77,7 +77,7 @@
                                       gpointer      invocation_hint,
                                       gpointer      marshal_data);
 
-/* INT:POINTER,CHAR,CHAR (./gtkmarshal.list:9) */
+/* INT:POINTER,CHAR,CHAR (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:9) */
 extern void gtk_marshal_INT__POINTER_CHAR_CHAR (GClosure     *closure,
                                                 GValue       *return_value,
                                                 guint         n_param_values,
@@ -85,19 +85,19 @@
                                                 gpointer      invocation_hint,
                                                 gpointer      marshal_data);
 
-/* NONE:BOOL (./gtkmarshal.list:10) */
+/* NONE:BOOL (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:10) */
 #define gtk_marshal_VOID__BOOLEAN	g_cclosure_marshal_VOID__BOOLEAN
 #define gtk_marshal_NONE__BOOL	gtk_marshal_VOID__BOOLEAN
 
-/* NONE:BOXED (./gtkmarshal.list:11) */
+/* NONE:BOXED (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:11) */
 #define gtk_marshal_VOID__BOXED	g_cclosure_marshal_VOID__BOXED
 #define gtk_marshal_NONE__BOXED	gtk_marshal_VOID__BOXED
 
-/* NONE:ENUM (./gtkmarshal.list:12) */
+/* NONE:ENUM (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:12) */
 #define gtk_marshal_VOID__ENUM	g_cclosure_marshal_VOID__ENUM
 #define gtk_marshal_NONE__ENUM	gtk_marshal_VOID__ENUM
 
-/* NONE:ENUM,FLOAT (./gtkmarshal.list:13) */
+/* NONE:ENUM,FLOAT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:13) */
 extern void gtk_marshal_VOID__ENUM_FLOAT (GClosure     *closure,
                                           GValue       *return_value,
                                           guint         n_param_values,
@@ -106,7 +106,7 @@
                                           gpointer      marshal_data);
 #define gtk_marshal_NONE__ENUM_FLOAT	gtk_marshal_VOID__ENUM_FLOAT
 
-/* NONE:ENUM,FLOAT,BOOL (./gtkmarshal.list:14) */
+/* NONE:ENUM,FLOAT,BOOL (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:14) */
 extern void gtk_marshal_VOID__ENUM_FLOAT_BOOLEAN (GClosure     *closure,
                                                   GValue       *return_value,
                                                   guint         n_param_values,
@@ -115,11 +115,11 @@
                                                   gpointer      marshal_data);
 #define gtk_marshal_NONE__ENUM_FLOAT_BOOL	gtk_marshal_VOID__ENUM_FLOAT_BOOLEAN
 
-/* NONE:INT (./gtkmarshal.list:15) */
+/* NONE:INT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:15) */
 #define gtk_marshal_VOID__INT	g_cclosure_marshal_VOID__INT
 #define gtk_marshal_NONE__INT	gtk_marshal_VOID__INT
 
-/* NONE:INT,INT (./gtkmarshal.list:16) */
+/* NONE:INT,INT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:16) */
 extern void gtk_marshal_VOID__INT_INT (GClosure     *closure,
                                        GValue       *return_value,
                                        guint         n_param_values,
@@ -128,7 +128,7 @@
                                        gpointer      marshal_data);
 #define gtk_marshal_NONE__INT_INT	gtk_marshal_VOID__INT_INT
 
-/* NONE:INT,INT,POINTER (./gtkmarshal.list:17) */
+/* NONE:INT,INT,POINTER (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:17) */
 extern void gtk_marshal_VOID__INT_INT_POINTER (GClosure     *closure,
                                                GValue       *return_value,
                                                guint         n_param_values,
@@ -137,19 +137,19 @@
                                                gpointer      marshal_data);
 #define gtk_marshal_NONE__INT_INT_POINTER	gtk_marshal_VOID__INT_INT_POINTER
 
-/* NONE:NONE (./gtkmarshal.list:18) */
+/* NONE:NONE (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:18) */
 #define gtk_marshal_VOID__VOID	g_cclosure_marshal_VOID__VOID
 #define gtk_marshal_NONE__NONE	gtk_marshal_VOID__VOID
 
-/* NONE:OBJECT (./gtkmarshal.list:19) */
+/* NONE:OBJECT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:19) */
 #define gtk_marshal_VOID__OBJECT	g_cclosure_marshal_VOID__OBJECT
 #define gtk_marshal_NONE__OBJECT	gtk_marshal_VOID__OBJECT
 
-/* NONE:POINTER (./gtkmarshal.list:20) */
+/* NONE:POINTER (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:20) */
 #define gtk_marshal_VOID__POINTER	g_cclosure_marshal_VOID__POINTER
 #define gtk_marshal_NONE__POINTER	gtk_marshal_VOID__POINTER
 
-/* NONE:POINTER,INT (./gtkmarshal.list:21) */
+/* NONE:POINTER,INT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:21) */
 extern void gtk_marshal_VOID__POINTER_INT (GClosure     *closure,
                                            GValue       *return_value,
                                            guint         n_param_values,
@@ -158,7 +158,7 @@
                                            gpointer      marshal_data);
 #define gtk_marshal_NONE__POINTER_INT	gtk_marshal_VOID__POINTER_INT
 
-/* NONE:POINTER,POINTER (./gtkmarshal.list:22) */
+/* NONE:POINTER,POINTER (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:22) */
 extern void gtk_marshal_VOID__POINTER_POINTER (GClosure     *closure,
                                                GValue       *return_value,
                                                guint         n_param_values,
@@ -167,7 +167,7 @@
                                                gpointer      marshal_data);
 #define gtk_marshal_NONE__POINTER_POINTER	gtk_marshal_VOID__POINTER_POINTER
 
-/* NONE:POINTER,POINTER,POINTER (./gtkmarshal.list:23) */
+/* NONE:POINTER,POINTER,POINTER (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:23) */
 extern void gtk_marshal_VOID__POINTER_POINTER_POINTER (GClosure     *closure,
                                                        GValue       *return_value,
                                                        guint         n_param_values,
@@ -176,7 +176,7 @@
                                                        gpointer      marshal_data);
 #define gtk_marshal_NONE__POINTER_POINTER_POINTER	gtk_marshal_VOID__POINTER_POINTER_POINTER
 
-/* NONE:POINTER,STRING,STRING (./gtkmarshal.list:24) */
+/* NONE:POINTER,STRING,STRING (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:24) */
 extern void gtk_marshal_VOID__POINTER_STRING_STRING (GClosure     *closure,
                                                      GValue       *return_value,
                                                      guint         n_param_values,
@@ -185,7 +185,7 @@
                                                      gpointer      marshal_data);
 #define gtk_marshal_NONE__POINTER_STRING_STRING	gtk_marshal_VOID__POINTER_STRING_STRING
 
-/* NONE:POINTER,UINT (./gtkmarshal.list:25) */
+/* NONE:POINTER,UINT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:25) */
 extern void gtk_marshal_VOID__POINTER_UINT (GClosure     *closure,
                                             GValue       *return_value,
                                             guint         n_param_values,
@@ -194,7 +194,7 @@
                                             gpointer      marshal_data);
 #define gtk_marshal_NONE__POINTER_UINT	gtk_marshal_VOID__POINTER_UINT
 
-/* NONE:POINTER,UINT,ENUM (./gtkmarshal.list:26) */
+/* NONE:POINTER,UINT,ENUM (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:26) */
 extern void gtk_marshal_VOID__POINTER_UINT_ENUM (GClosure     *closure,
                                                  GValue       *return_value,
                                                  guint         n_param_values,
@@ -203,7 +203,7 @@
                                                  gpointer      marshal_data);
 #define gtk_marshal_NONE__POINTER_UINT_ENUM	gtk_marshal_VOID__POINTER_UINT_ENUM
 
-/* NONE:POINTER,POINTER,UINT,UINT (./gtkmarshal.list:27) */
+/* NONE:POINTER,POINTER,UINT,UINT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:27) */
 extern void gtk_marshal_VOID__POINTER_POINTER_UINT_UINT (GClosure     *closure,
                                                          GValue       *return_value,
                                                          guint         n_param_values,
@@ -212,7 +212,7 @@
                                                          gpointer      marshal_data);
 #define gtk_marshal_NONE__POINTER_POINTER_UINT_UINT	gtk_marshal_VOID__POINTER_POINTER_UINT_UINT
 
-/* NONE:POINTER,INT,INT,POINTER,UINT,UINT (./gtkmarshal.list:28) */
+/* NONE:POINTER,INT,INT,POINTER,UINT,UINT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:28) */
 extern void gtk_marshal_VOID__POINTER_INT_INT_POINTER_UINT_UINT (GClosure     *closure,
                                                                  GValue       *return_value,
                                                                  guint         n_param_values,
@@ -221,7 +221,7 @@
                                                                  gpointer      marshal_data);
 #define gtk_marshal_NONE__POINTER_INT_INT_POINTER_UINT_UINT	gtk_marshal_VOID__POINTER_INT_INT_POINTER_UINT_UINT
 
-/* NONE:POINTER,UINT,UINT (./gtkmarshal.list:29) */
+/* NONE:POINTER,UINT,UINT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:29) */
 extern void gtk_marshal_VOID__POINTER_UINT_UINT (GClosure     *closure,
                                                  GValue       *return_value,
                                                  guint         n_param_values,
@@ -230,13 +230,13 @@
                                                  gpointer      marshal_data);
 #define gtk_marshal_NONE__POINTER_UINT_UINT	gtk_marshal_VOID__POINTER_UINT_UINT
 
-/* NONE:POINTER,UINT,UINT (./gtkmarshal.list:30) */
+/* NONE:POINTER,UINT,UINT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:30) */
 
-/* NONE:STRING (./gtkmarshal.list:31) */
+/* NONE:STRING (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:31) */
 #define gtk_marshal_VOID__STRING	g_cclosure_marshal_VOID__STRING
 #define gtk_marshal_NONE__STRING	gtk_marshal_VOID__STRING
 
-/* NONE:STRING,INT,POINTER (./gtkmarshal.list:32) */
+/* NONE:STRING,INT,POINTER (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:32) */
 extern void gtk_marshal_VOID__STRING_INT_POINTER (GClosure     *closure,
                                                   GValue       *return_value,
                                                   guint         n_param_values,
@@ -245,11 +245,11 @@
                                                   gpointer      marshal_data);
 #define gtk_marshal_NONE__STRING_INT_POINTER	gtk_marshal_VOID__STRING_INT_POINTER
 
-/* NONE:UINT (./gtkmarshal.list:33) */
+/* NONE:UINT (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:33) */
 #define gtk_marshal_VOID__UINT	g_cclosure_marshal_VOID__UINT
 #define gtk_marshal_NONE__UINT	gtk_marshal_VOID__UINT
 
-/* NONE:UINT,POINTER,UINT,ENUM,ENUM,POINTER (./gtkmarshal.list:34) */
+/* NONE:UINT,POINTER,UINT,ENUM,ENUM,POINTER (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:34) */
 extern void gtk_marshal_VOID__UINT_POINTER_UINT_ENUM_ENUM_POINTER (GClosure     *closure,
                                                                    GValue       *return_value,
                                                                    guint         n_param_values,
@@ -258,7 +258,7 @@
                                                                    gpointer      marshal_data);
 #define gtk_marshal_NONE__UINT_POINTER_UINT_ENUM_ENUM_POINTER	gtk_marshal_VOID__UINT_POINTER_UINT_ENUM_ENUM_POINTER
 
-/* NONE:UINT,POINTER,UINT,UINT,ENUM (./gtkmarshal.list:35) */
+/* NONE:UINT,POINTER,UINT,UINT,ENUM (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:35) */
 extern void gtk_marshal_VOID__UINT_POINTER_UINT_UINT_ENUM (GClosure     *closure,
                                                            GValue       *return_value,
                                                            guint         n_param_values,
@@ -267,7 +267,7 @@
                                                            gpointer      marshal_data);
 #define gtk_marshal_NONE__UINT_POINTER_UINT_UINT_ENUM	gtk_marshal_VOID__UINT_POINTER_UINT_UINT_ENUM
 
-/* NONE:UINT,STRING (./gtkmarshal.list:36) */
+/* NONE:UINT,STRING (/home/jlehto/teema4/3rdparty/gtk+2.0-2.6/gtk/gtkmarshal.list:36) */
 extern void gtk_marshal_VOID__UINT_STRING (GClosure     *closure,
                                            GValue       *return_value,
                                            guint         n_param_values,
--- gtk+/gtk/gtkrange.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkrange.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -25,6 +25,10 @@
  * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
  */
 
+/* Modified by Nokia Corporation - 2005.
+ * 
+ */
+
 #include <config.h>
 #include <stdio.h>
 #include <math.h>
@@ -44,7 +48,10 @@
   PROP_0,
   PROP_UPDATE_POLICY,
   PROP_ADJUSTMENT,
-  PROP_INVERTED
+  PROP_INVERTED,
+  PROP_STREAM_INDICATOR,
+  PROP_MINIMUM_VISIBLE_BARS,
+  PROP_STREAM_POSITION
 };
 
 enum {
@@ -88,8 +95,20 @@
   /* "grabbed" mouse location, OUTSIDE for no grab */
   MouseLocation grab_location;
   gint grab_button; /* 0 if none */
+
+  /* OSSO hack: stream trough split position */
+  gint stream_pixel_position;
+  gint minimum_visible_bars;  
 };
 
+#define OSSO_GTK_RANGE_GET_PRIVATE(o)       (G_TYPE_INSTANCE_GET_PRIVATE ((o), GTK_TYPE_RANGE, OssoGtkRangePrivate))
+typedef struct _OssoGtkRangePrivate OssoGtkRangePrivate;
+
+struct _OssoGtkRangePrivate
+{
+  gboolean     stream_indicator;
+  gdouble      stream_position;
+};
 
 static void gtk_range_class_init     (GtkRangeClass    *klass);
 static void gtk_range_init           (GtkRange         *range);
@@ -135,6 +154,7 @@
 				      gint              mouse_x,
 				      gint              mouse_y);
 
+static gint osso_gtk_range_focus_out (GtkWidget *widget, GdkEventFocus *event);
 
 /* Range methods */
 
@@ -247,6 +267,9 @@
   widget_class->state_changed = gtk_range_state_changed;
   widget_class->style_set = gtk_range_style_set;
 
+  /* OSSO addition (see bug #1653) */
+  widget_class->focus_out_event = osso_gtk_range_focus_out;
+
   class->move_slider = gtk_range_move_slider;
   class->change_value = gtk_range_real_change_value;
 
@@ -344,6 +367,34 @@
                                                          FALSE,
                                                          G_PARAM_READWRITE));
   
+  g_object_class_install_property (gobject_class,
+                                   PROP_STREAM_INDICATOR,
+                                   g_param_spec_boolean ("stream_indicator",
+							P_("Stream Indicator"),
+							P_("Whether to display a stream indicator graphics on trough."),
+                                                        FALSE,
+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
+
+  g_object_class_install_property (gobject_class,
+		  PROP_MINIMUM_VISIBLE_BARS,
+		  g_param_spec_int ("minimum_visible_bars",
+			  P_("Minimum visible bars"),
+			  P_("The minimum number of visible bars in a HildonControlBar"),
+			  0,
+			  G_MAXINT,
+			  0,
+			  G_PARAM_READWRITE));
+  
+  g_object_class_install_property (gobject_class,
+                                   PROP_STREAM_POSITION,
+                                   g_param_spec_double ("stream_position",
+							P_("Stream Position"),
+							P_("The position of the streaming."),
+							-G_MAXDOUBLE,
+							G_MAXDOUBLE,
+                                                        0.0,
+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
+  
   gtk_widget_class_install_style_property (widget_class,
 					   g_param_spec_int ("slider_width",
 							     P_("Slider Width"),
@@ -392,6 +443,52 @@
 							     G_MAXINT,
 							     0,
 							     G_PARAM_READABLE));
+
+  gtk_widget_class_install_style_property (widget_class,
+                                           g_param_spec_boolean ("hildonlike",
+                                                                 _("hildonlike"),
+                                                                 _("Change focus out behaviour, 1/0"),
+                                                                 FALSE,
+                                                                 G_PARAM_READABLE));
+
+  gtk_widget_class_install_style_property (widget_class,
+                                           g_param_spec_boolean ("two_part_trough",
+                                                                 _("Two-part trough"),
+                                                                 _("Allow different trough graphics on different sides of the slider, 1/0"),
+                                                                 FALSE,
+                                                                 G_PARAM_READABLE));
+
+  gtk_widget_class_install_style_property (widget_class,
+					   g_param_spec_int ("stream_indicator_padding",
+                                                             P_("Stream Indicator Padding"),
+                                                             P_("How many pixels smallerthan the trough the stream indicator is drawn from both ends ."),
+                                                             0,
+                                                             G_MAXINT,
+                                                             1,
+                                                             G_PARAM_READABLE));
+
+  gtk_widget_class_install_style_property (widget_class,
+                                           g_param_spec_boolean ("autodimmed_steppers",
+                                                                 _("Autodimmed steppers"),
+                                                                 _("Automatically dim steppers when maximum or minimum value has been reached"),
+                                                                 FALSE,
+                                                                 G_PARAM_READABLE));
+
+  gtk_widget_class_install_style_property (widget_class,
+                                           g_param_spec_boolean ("arrow_paint_box_layout",
+                                                                 _("Arrow paint box layout"),
+                                                                 _("Allows to use images instead of normal arrows."),
+                                                                 FALSE,
+                                                                 G_PARAM_READABLE));
+
+  gtk_widget_class_install_style_property (widget_class,
+                                           g_param_spec_boolean ("draw_trough_under_steppers",
+                                                                 _("Draw trough under steppers"),
+                                                                 _("Whether to draw trought for full length of range or exclude the steppers and spacing"),
+                                                                 TRUE,
+                                                                 G_PARAM_READABLE));
+   
+  g_type_class_add_private (gobject_class, sizeof (OssoGtkRangePrivate));
 }
 
 static void
@@ -415,6 +512,15 @@
     case PROP_INVERTED:
       gtk_range_set_inverted (range, g_value_get_boolean (value));
       break;
+    case PROP_STREAM_INDICATOR:
+      osso_gtk_range_set_stream_indicator (range, g_value_get_boolean (value));
+      break;
+    case PROP_STREAM_POSITION:
+      osso_gtk_range_set_stream_position (range, g_value_get_double (value));
+      break;
+    case PROP_MINIMUM_VISIBLE_BARS:
+      range->layout->minimum_visible_bars = g_value_get_int(value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -442,6 +548,15 @@
     case PROP_INVERTED:
       g_value_set_boolean (value, range->inverted);
       break;
+    case PROP_STREAM_INDICATOR:
+      g_value_set_boolean (value, osso_gtk_range_get_stream_indicator (range));
+      break;
+    case PROP_STREAM_POSITION:
+      g_value_set_double (value, osso_gtk_range_get_stream_indicator (range));
+      break;
+    case PROP_MINIMUM_VISIBLE_BARS:
+      g_value_set_int (value, range->layout->minimum_visible_bars);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -451,6 +566,7 @@
 static void
 gtk_range_init (GtkRange *range)
 {
+  OssoGtkRangePrivate *priv = OSSO_GTK_RANGE_GET_PRIVATE (range);
   GTK_WIDGET_SET_FLAGS (range, GTK_NO_WINDOW);
 
   range->adjustment = NULL;
@@ -471,6 +587,9 @@
   range->layout->grab_location = MOUSE_OUTSIDE;
   range->layout->grab_button = 0;
   range->timer = NULL;  
+
+  priv->stream_indicator = FALSE;
+  priv->stream_position = 0.0;
 }
 
 /**
@@ -584,7 +703,10 @@
       g_signal_connect (adjustment, "changed",
 			G_CALLBACK (gtk_range_adjustment_changed),
 			range);
-      g_signal_connect (adjustment, "value_changed",
+      /* OSSO modification : Changed for controlbar.
+       * There we intercept this signal and put forth
+       * our own, with modified parameters. */
+      g_signal_connect_after (adjustment, "value_changed",
 			G_CALLBACK (gtk_range_adjustment_value_changed),
 			range);
       
@@ -677,16 +799,21 @@
                      gdouble   max)
 {
   gdouble value;
+  OssoGtkRangePrivate *priv;
   
   g_return_if_fail (GTK_IS_RANGE (range));
   g_return_if_fail (min < max);
   
+  priv = OSSO_GTK_RANGE_GET_PRIVATE (range);
+  
   range->adjustment->lower = min;
   range->adjustment->upper = max;
 
   value = CLAMP (range->adjustment->value,
                  range->adjustment->lower,
                  (range->adjustment->upper - range->adjustment->page_size));
+  if (priv->stream_indicator && value > priv->stream_position)
+    value = (gdouble)priv->stream_position;
 
   gtk_adjustment_set_value (range->adjustment, value);
   gtk_adjustment_changed (range->adjustment);
@@ -707,10 +834,16 @@
 gtk_range_set_value (GtkRange *range,
                      gdouble   value)
 {
+  OssoGtkRangePrivate *priv;
+
   g_return_if_fail (GTK_IS_RANGE (range));
   
+  priv = OSSO_GTK_RANGE_GET_PRIVATE (range);
+  
   value = CLAMP (value, range->adjustment->lower,
                  (range->adjustment->upper - range->adjustment->page_size));
+  if (priv->stream_indicator && value > priv->stream_position)
+    value = (gdouble)priv->stream_position;
 
   gtk_adjustment_set_value (range->adjustment, value);
 }
@@ -913,6 +1046,10 @@
   gint arrow_width;
   gint arrow_height;
 
+  /* OSSO modification: state of our style properties */
+  gboolean autodimmed_steppers = FALSE;
+  gboolean arrow_paint_box_layout = FALSE;
+
   /* More to get the right clip region than for efficiency */
   if (!gdk_rectangle_intersect (area, rect, &intersection))
     return;
@@ -929,6 +1066,37 @@
   else 
     state_type = GTK_STATE_NORMAL;
   
+  /* OSSO modification : read all of our style properties needed in this func */
+  gtk_widget_style_get (widget,
+                        "autodimmed_steppers", &autodimmed_steppers,
+                        "arrow_paint_box_layout", &arrow_paint_box_layout,
+                        NULL);
+  
+  /* OSSO modification : dim the stepper if maximum or minimum value has been reached */
+  if (autodimmed_steppers)
+    {
+      OssoGtkRangePrivate *priv = OSSO_GTK_RANGE_GET_PRIVATE (range);
+      if (((!range->inverted && (arrow_type == GTK_ARROW_DOWN ||
+                                 arrow_type == GTK_ARROW_RIGHT)) ||
+           (range->inverted && (arrow_type == GTK_ARROW_UP ||
+                                arrow_type == GTK_ARROW_LEFT))) &&
+          range->adjustment->value >=
+          (priv->stream_indicator
+           ? priv->stream_position
+           : range->adjustment->upper - range->adjustment->page_size))
+        {
+          state_type = GTK_STATE_INSENSITIVE;
+        }
+      else if (((!range->inverted && (arrow_type == GTK_ARROW_UP ||
+                                      arrow_type == GTK_ARROW_LEFT)) ||
+                (range->inverted && (arrow_type == GTK_ARROW_DOWN ||
+                                     arrow_type == GTK_ARROW_RIGHT))) &&
+               range->adjustment->value <= range->adjustment->lower)
+        {
+          state_type = GTK_STATE_INSENSITIVE;
+        }
+    }
+  
   if (clicked)
     shadow_type = GTK_SHADOW_IN;
   else
@@ -944,10 +1112,20 @@
 		 rect->width,
 		 rect->height);
 
-  arrow_width = rect->width / 2;
-  arrow_height = rect->height / 2;
-  arrow_x = widget->allocation.x + rect->x + (rect->width - arrow_width) / 2;
-  arrow_y = widget->allocation.y + rect->y + (rect->height - arrow_height) / 2;
+  if (arrow_paint_box_layout)
+  {
+    arrow_width = rect->width;
+    arrow_height = rect->height;
+    arrow_x = widget->allocation.x + rect->x;
+    arrow_y = widget->allocation.y + rect->y;
+  }
+  else
+  {
+    arrow_width = rect->width / 2;
+    arrow_height = rect->height / 2;
+    arrow_x = widget->allocation.x + rect->x + (rect->width - arrow_width) / 2;
+    arrow_y = widget->allocation.y + rect->y + (rect->height - arrow_height) / 2;
+  }
   
   if (clicked)
     {
@@ -982,8 +1160,11 @@
   GdkRectangle area;
   gint focus_line_width = 0;
   gint focus_padding = 0;
+  OssoGtkRangePrivate *priv;
 
   range = GTK_RANGE (widget);
+  
+  priv = OSSO_GTK_RANGE_GET_PRIVATE (range);
 
   if (GTK_WIDGET_CAN_FOCUS (range))
     {
@@ -1011,18 +1192,118 @@
   if (gdk_rectangle_intersect (&expose_area, &range->range_rect,
                                &area))
     {
+      gint x = widget->allocation.x + range->range_rect.x + focus_line_width + focus_padding;
+      gint y = widget->allocation.y + range->range_rect.y + focus_line_width + focus_padding;
+      gint width = range->range_rect.width - 2 * (focus_line_width + focus_padding);
+      gint height = range->range_rect.height - 2 * (focus_line_width + focus_padding);
+      gint *virtual_position, *virtual_size;
+      gboolean two_part_trough = 0;
+      gint stepper_size = 0;
+      gint stepper_spacing = 0;
+      gboolean draw_trough_under_steppers = TRUE;
+      
       area.x += widget->allocation.x;
       area.y += widget->allocation.y;
+
+      gtk_widget_style_get (GTK_WIDGET (range),
+			    "two_part_trough", &two_part_trough,
+			    "stepper_size", &stepper_size,
+			    "stepper_spacing", &stepper_spacing,
+			    "draw_trough_under_steppers", &draw_trough_under_steppers,
+			    NULL);
+
+      if (range->orientation == GTK_ORIENTATION_HORIZONTAL)
+	{
+	  virtual_position = &x;
+	  virtual_size = &width;
+	}
+      else
+	{
+	  virtual_position = &y;
+	  virtual_size = &height;
+	}
+
+      if (draw_trough_under_steppers == FALSE)
+	{
+	  *virtual_position += stepper_size + stepper_spacing;
+	  *virtual_size -= 2 * (stepper_size + stepper_spacing);
+	}
       
-      gtk_paint_box (widget->style,
-                     widget->window,
-                     sensitive ? GTK_STATE_ACTIVE : GTK_STATE_INSENSITIVE,
-                     GTK_SHADOW_IN,
-                     &area, GTK_WIDGET(range), "trough",
-                     widget->allocation.x + range->range_rect.x + focus_line_width + focus_padding,
-                     widget->allocation.y + range->range_rect.y + focus_line_width + focus_padding,
-                     range->range_rect.width - 2 * (focus_line_width + focus_padding),
-                     range->range_rect.height - 2 * (focus_line_width + focus_padding));
+      if (two_part_trough == FALSE)
+	{
+          gtk_paint_box (widget->style,
+                         widget->window,
+                         sensitive ? GTK_STATE_ACTIVE : GTK_STATE_INSENSITIVE,
+                         GTK_SHADOW_IN,
+                         &area, GTK_WIDGET(range), "trough",
+                         x, y,
+                         width, height);
+	}
+      else
+	{
+	  gint trough_change_pos_x = width;
+	  gint trough_change_pos_y = height;
+
+	  if (range->orientation == GTK_ORIENTATION_HORIZONTAL)
+	    trough_change_pos_x = range->layout->slider.x + (range->layout->slider.width / 2) - stepper_size - stepper_spacing;
+	  else
+	    trough_change_pos_y = range->layout->slider.y + (range->layout->slider.height / 2) - stepper_size - stepper_spacing;
+
+          gtk_paint_box (widget->style,
+                         widget->window,
+                         sensitive ? GTK_STATE_ACTIVE : GTK_STATE_INSENSITIVE,
+                         GTK_SHADOW_IN,
+                         &area, GTK_WIDGET(range), "trough_northwest",
+                         x, y, 
+                         trough_change_pos_x, trough_change_pos_y);
+
+	  if (range->orientation == GTK_ORIENTATION_HORIZONTAL)
+	    trough_change_pos_y = 0;
+	  else
+	    trough_change_pos_x = 0;
+
+          gtk_paint_box (widget->style,
+                         widget->window,
+                         sensitive ? GTK_STATE_ACTIVE : GTK_STATE_INSENSITIVE,
+                         GTK_SHADOW_IN,
+                         &area, GTK_WIDGET(range), "trough_southeast",
+                         x + trough_change_pos_x, y + trough_change_pos_y, 
+                         width - trough_change_pos_x, height - trough_change_pos_y);
+	}
+
+      /* Stream indicator drawing does not support inverted state. */
+      if (priv->stream_indicator)
+	{
+	  gchar *used_detail;
+	  gint stream_start_pos_x = 0;
+	  gint stream_start_pos_y = 0;
+	  gint stream_width = width;
+	  gint stream_height = height;
+
+	  if (range->orientation == GTK_ORIENTATION_HORIZONTAL)
+	    {
+	      stream_start_pos_x = range->layout->slider.x;
+	      stream_width = range->layout->stream_pixel_position - stream_start_pos_x;
+	    }
+	  else
+	    {
+	      stream_start_pos_y = range->layout->slider.y;
+	      stream_height = range->layout->stream_pixel_position - stream_start_pos_y;
+	    }
+
+	  if (priv->stream_position == range->adjustment->upper)
+	    used_detail = "trough_stream_complete";
+	  else
+	    used_detail = "trough_stream";
+
+          gtk_paint_box (widget->style,
+                         widget->window,
+                         sensitive ? GTK_STATE_ACTIVE : GTK_STATE_INSENSITIVE,
+                         GTK_SHADOW_IN,
+                         &area, GTK_WIDGET(range), used_detail,
+                         widget->allocation.x + stream_start_pos_x, widget->allocation.y + stream_start_pos_y, 
+                         stream_width, stream_height);
+	}
       
                  
       if (sensitive &&
@@ -1189,19 +1470,40 @@
 {
   gdouble frac;
   gdouble value;
-  
-  if (range->orientation == GTK_ORIENTATION_VERTICAL)
+  gint stepper_spacing = 0;
+  gint minimum_visible_blocks = 0;
+  gfloat magic_value = 0.0;
+  
+  g_object_get(range, "minimum_visible_bars", &minimum_visible_blocks, NULL);
+  
+  gtk_widget_style_get (GTK_WIDGET (range),
+                        "stepper_spacing", &stepper_spacing,
+			NULL);
+  
+  if (range->orientation == GTK_ORIENTATION_VERTICAL) {
+    if (minimum_visible_blocks > 0)
+      magic_value =  ((range->layout->trough.height -(2*stepper_spacing)) / (range->adjustment->upper - range->adjustment->lower + 1)) * minimum_visible_blocks;
     if (range->layout->trough.height == range->layout->slider.height)
       frac = 1.0;
     else 
-      frac = ((coord - range->layout->trough.y) /
-	      (gdouble) (range->layout->trough.height - range->layout->slider.height));
-  else
+      frac = ((coord - range->layout->trough.y - magic_value - stepper_spacing) /
+	      (gdouble) (range->layout->trough.height - magic_value - range->layout->slider.height - (2 * stepper_spacing)));
+  }
+  else {
+    if (minimum_visible_blocks > 0)
+      magic_value =  ((range->layout->trough.width -(2*stepper_spacing)) / (range->adjustment->upper - range->adjustment->lower + 1)) * minimum_visible_blocks;
     if (range->layout->trough.width == range->layout->slider.width)
       frac = 1.0;
     else
-      frac = ((coord - range->layout->trough.x) /
-	      (gdouble) (range->layout->trough.width - range->layout->slider.width));
+      frac = ((coord - range->layout->trough.x - magic_value - stepper_spacing) /
+	      (gdouble) (range->layout->trough.width - magic_value - range->layout->slider.width - (2 * stepper_spacing)));
+  }
+
+  if (frac < 0.0)
+    frac = 0.0;
+  else
+    if (frac > 1.0)
+      frac = 1.0;
 
   if (should_invert (range))
     frac = 1.0 - frac;
@@ -1286,7 +1588,9 @@
        * On button 2 press, we warp the slider to mouse position,
        * then begin the slider drag.
        */
-      if (event->button == 2)
+      /* OSSO modification : We want this to be
+       * the default behaviour. */
+      if (range->layout->mouse_location == MOUSE_TROUGH)
         {
           gdouble slider_low_value, slider_high_value, new_value;
           
@@ -1347,16 +1651,22 @@
   gint c;
   gdouble new_value;
   gboolean handled;
+  gint minimum_visible_bars = 0;
+  gint stepper_spacing = 0;
 
+  g_object_get(range, "minimum_visible_bars", &minimum_visible_bars, NULL);
+  gtk_widget_style_get (GTK_WIDGET (range),
+		  "stepper_spacing", &stepper_spacing,
+		  NULL);
+  
   if (range->orientation == GTK_ORIENTATION_VERTICAL)
     delta = mouse_y - range->slide_initial_coordinate;
   else
     delta = mouse_x - range->slide_initial_coordinate;
 
-  c = range->slide_initial_slider_position + delta;
-
+  c = ((minimum_visible_bars > 0)? range->slide_initial_coordinate : range->slide_initial_slider_position) + delta;
   new_value = coord_to_value (range, c);
-  
+
   g_signal_emit (range, signals[CHANGE_VALUE], 0, GTK_SCROLL_JUMP, new_value,
                  &handled);
 }
@@ -1395,9 +1705,12 @@
   
   if (range->layout->grab_button == event->button)
     {
+      /* OSSO modification : Commented out.
+       * Not sure about the reason unfortunately. */
+/*
       if (range->layout->grab_location == MOUSE_SLIDER)
         update_slider_position (range, range->layout->mouse_x, range->layout->mouse_y);
-
+*/
       stop_scrolling (range);
       
       return TRUE;
@@ -2026,6 +2339,7 @@
   GdkRectangle range_rect;
   GtkRangeLayout *layout;
   GtkWidget *widget;
+  gint minimum_visible_bars = 0;
   
   if (!range->need_recalc)
     return;
@@ -2047,6 +2361,8 @@
                        &slider_width, &stepper_size, &trough_border, &stepper_spacing,
 		       NULL, NULL);
 
+  g_object_get(range, "minimum_visible_bars", &minimum_visible_bars, NULL);
+  
   gtk_range_calc_request (range, 
                           slider_width, stepper_size, trough_border, stepper_spacing,
                           &range_rect, &border, &n_steppers, &slider_length);
@@ -2167,10 +2483,16 @@
       /* Compute slider position/length */
       {
         gint y, bottom, top, height;
-        
-        top = layout->trough.y + stepper_spacing;
-        bottom = layout->trough.y + layout->trough.height - stepper_spacing;
-        
+	gfloat magic_value;
+	gint minimum_visible_blocks = 0;
+                                                                                                                                                                                   
+        g_object_get(range, "minimum_visible_bars", &minimum_visible_blocks, NULL);
+	
+	magic_value = (layout->trough.height / (range->adjustment->upper - range->adjustment->lower + 1)) * minimum_visible_blocks;
+
+	top = layout->trough.y + stepper_spacing + (minimum_visible_bars * magic_value);
+	bottom = layout->trough.y + layout->trough.height - stepper_spacing;
+
         /* slider height is the fraction (page_size /
          * total_adjustment_range) times the trough height in pixels
          */
@@ -2307,8 +2629,14 @@
       /* Compute slider position/length */
       {
         gint x, left, right, width;
+	gfloat magic_value;
+	gint minimum_visible_blocks = 0;
+
+      	g_object_get(range, "minimum_visible_bars", &minimum_visible_blocks, NULL);
+	
+	magic_value = ((layout->trough.width - (2*stepper_spacing))/(range->adjustment->upper - range->adjustment->lower + 1)) * minimum_visible_blocks;
         
-        left = layout->trough.x + stepper_spacing;
+        left = layout->trough.x + stepper_spacing + (minimum_visible_bars * magic_value);
         right = layout->trough.x + layout->trough.width - stepper_spacing;
         
         /* slider width is the fraction (page_size /
@@ -2332,7 +2660,7 @@
 	if (range->adjustment->upper - range->adjustment->lower - range->adjustment->page_size != 0)
           x += (right - left - width) * ((adjustment_value - range->adjustment->lower) /
                                          (range->adjustment->upper - range->adjustment->lower - range->adjustment->page_size));
-        
+	
         x = CLAMP (x, left, right);
         
         if (should_invert (range))
@@ -2340,6 +2668,32 @@
         
         layout->slider.x = x;
         layout->slider.width = width;
+	
+	/* Hildon modification : Calculate the x point of streaming
+	 * indicator.
+	 */
+	  {
+	    gint stream_indicator_padding = 0;
+	    OssoGtkRangePrivate *priv = OSSO_GTK_RANGE_GET_PRIVATE (range);
+	    gtk_widget_style_get (widget,
+	                          "stream_indicator_padding", &stream_indicator_padding,
+				  NULL);
+
+	    if (priv->stream_indicator == TRUE)
+	      {
+		if (range->adjustment->upper - range->adjustment->lower != 0)
+		  layout->stream_pixel_position =
+		    (right - left - (2 * stream_indicator_padding)) *
+		    ((priv->stream_position - range->adjustment->lower) /
+		    (range->adjustment->upper - range->adjustment->lower)) +
+		    left + stream_indicator_padding;
+		else
+		  layout->stream_pixel_position = left + stream_indicator_padding;
+	
+		if (layout->stream_pixel_position < left + stream_indicator_padding)
+		  layout->stream_pixel_position = left + stream_indicator_padding;
+	      }
+	  }
 
         /* These are publically exported */
         range->slider_start = layout->slider.x;
@@ -2382,12 +2736,17 @@
                              GtkScrollType scroll,
                              gdouble       value)
 {
+  OssoGtkRangePrivate *priv = OSSO_GTK_RANGE_GET_PRIVATE (range);
+
   /* potentially adjust the bounds _before we clamp */
   g_signal_emit (range, signals[ADJUST_BOUNDS], 0, value);
 
   value = CLAMP (value, range->adjustment->lower,
                  (range->adjustment->upper - range->adjustment->page_size));
 
+  if (priv->stream_indicator && value > priv->stream_position)
+    value = (gdouble)priv->stream_position;
+
   if (range->round_digits >= 0)
     {
       gdouble power;
@@ -2465,11 +2824,16 @@
 initial_timeout (gpointer data)
 {
   GtkRange *range;
+  GtkSettings *settings;
+  guint timeout = SCROLL_LATER_DELAY;
+
+  settings = gtk_settings_get_default ();
+  g_object_get (settings, "gtk-update-timeout", &timeout, NULL);
 
   GDK_THREADS_ENTER ();
   range = GTK_RANGE (data);
   range->timer->timeout_id = 
-    g_timeout_add (SCROLL_LATER_DELAY,
+    g_timeout_add (/*SCROLL_LATER_DELAY*/timeout,
                    second_timeout,
                    range);
   GDK_THREADS_LEAVE ();
@@ -2482,13 +2846,19 @@
 gtk_range_add_step_timer (GtkRange      *range,
                           GtkScrollType  step)
 {
+  GtkSettings *settings;
+  guint timeout = SCROLL_INITIAL_DELAY;
+
   g_return_if_fail (range->timer == NULL);
   g_return_if_fail (step != GTK_SCROLL_NONE);
   
+  settings = gtk_settings_get_default ();
+  g_object_get (settings, "gtk-initial-timeout", &timeout, NULL);
+
   range->timer = g_new (GtkRangeStepTimer, 1);
 
   range->timer->timeout_id =
-    g_timeout_add (SCROLL_INITIAL_DELAY,
+    g_timeout_add (/*SCROLL_INITIAL_DELAY*/timeout,
                    initial_timeout,
                    range);
   range->timer->step = step;
@@ -2528,9 +2898,15 @@
 static void
 gtk_range_reset_update_timer (GtkRange *range)
 {
+  /*GtkSettings *settings;
+  guint timeout = UPDATE_DELAY;
+
+  settings = gtk_settings_get_default ();
+  g_object_get (settings, "gtk-update-timeout", &timeout, NULL);*/
+
   gtk_range_remove_update_timer (range);
 
-  range->update_timeout_id = g_timeout_add (UPDATE_DELAY,
+  range->update_timeout_id = g_timeout_add (/*timeout*/UPDATE_DELAY,
                                             update_timeout,
                                             range);
 }
@@ -2544,3 +2920,116 @@
       range->update_timeout_id = 0;
     }
 }
+
+/**
+ * osso_gtk_range_set_stream_indicator:
+ * @range: A GtkRange
+ * @stream_indicator: Whether stream indicator graphics is shown and restricts slider.
+ *
+ * Sets whether a graphical stream indicator
+ * is show on the trough and the slider is restricted
+ * to streamed area.
+ **/
+void
+osso_gtk_range_set_stream_indicator (GtkRange *range, gboolean stream_indicator)
+{
+  OssoGtkRangePrivate *priv;
+
+  g_return_if_fail (GTK_IS_RANGE (range));
+  
+  priv = OSSO_GTK_RANGE_GET_PRIVATE (range);
+  
+  if (stream_indicator == priv->stream_indicator)
+    return;
+  
+  priv->stream_indicator = stream_indicator;
+  g_signal_emit_by_name (G_OBJECT (range), "value_changed", NULL);
+}
+
+/**
+ * osso_gtk_range_get_stream_indicator:
+ * @range: A GtkRange
+ *
+ * Return value: Whether GtkRange displays an 
+ *   stream indicator graphics and slider is restricted
+ *   to streamed area
+ **/
+gboolean
+osso_gtk_range_get_stream_indicator (GtkRange *range)
+{
+  OssoGtkRangePrivate *priv;
+
+  g_return_val_if_fail (GTK_IS_RANGE (range), FALSE);
+  
+  priv = OSSO_GTK_RANGE_GET_PRIVATE (range);
+  
+  return priv->stream_indicator;
+}
+
+/**
+ * osso_gtk_range_set_stream_position:
+ * @range : A GtkRange
+ * @position : The new position of the stream indicator
+ *
+ * Sets the new position of the stream indicator.
+ * It is automatically clamped between lower and upper.
+ * Note that you need to enable stream_indicator
+ * before any stream-functionality is active.
+ **/
+void
+osso_gtk_range_set_stream_position (GtkRange *range,
+				    gdouble position)
+{
+  OssoGtkRangePrivate *priv;
+  gdouble new_pos;
+
+  g_return_if_fail (GTK_IS_RANGE (range));
+  
+  new_pos = CLAMP (position,
+		   range->adjustment->lower,
+		   range->adjustment->upper);
+  priv = OSSO_GTK_RANGE_GET_PRIVATE (range);
+  
+  priv->stream_position = new_pos;
+  /* Reset the value to clamp it with the stream_position. */
+  if (priv->stream_indicator == TRUE)
+    gtk_range_set_value (range, gtk_range_get_value (range));
+  
+  g_object_notify (G_OBJECT (range), "stream_position");
+}
+/**
+ * osso_gtk_range_get_stream_position:
+ * @range : A GtkRange
+ *
+ * Return value: The current position of the stream
+ *   indicator. Note that this value is undefined
+ *   when stream indicator is not enabled.
+ **/
+gdouble
+osso_gtk_range_get_stream_position (GtkRange *range)
+{
+  OssoGtkRangePrivate *priv;
+
+  g_return_if_fail (GTK_IS_RANGE (range));
+  
+  priv = OSSO_GTK_RANGE_GET_PRIVATE (range);
+  
+  return priv->stream_position;
+}
+
+/* OSSO addition : A function to ensure that
+ * scrolling stops if widget loses focus (example:
+ * dialog pops up) */
+static gint
+osso_gtk_range_focus_out (GtkWidget *widget, GdkEventFocus *event)
+{
+  gboolean hildonlike;
+
+  gtk_widget_style_get (widget, "hildonlike", &hildonlike, NULL);
+   
+  if (hildonlike)
+    {
+      stop_scrolling (GTK_RANGE (widget));
+    }
+  return GTK_WIDGET_CLASS (parent_class)->focus_out_event (widget, event);
+}
--- gtk+/gtk/gtkrange.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkrange.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -24,6 +24,10 @@
  * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
  */
 
+/* Modified by Nokia Corporation - 2005
+ * 
+ */
+
 #ifndef __GTK_RANGE_H__
 #define __GTK_RANGE_H__
 
@@ -155,6 +159,15 @@
 gdouble	      _gtk_range_get_wheel_delta   (GtkRange           *range,
 					    GdkScrollDirection  direction);
 
+/* OSSO additions for streaming indicator support. */
+void           osso_gtk_range_set_stream_indicator (GtkRange *range, 
+						    gboolean stream_indicator);
+gboolean       osso_gtk_range_get_stream_indicator (GtkRange *range);
+
+void           osso_gtk_range_set_stream_position (GtkRange *range, 
+						   gdouble position);
+gdouble        osso_gtk_range_get_stream_position (GtkRange *range);
+
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
--- gtk+/gtk/gtktextview.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtktextview.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -99,6 +99,11 @@
 
 #define SPACE_FOR_CURSOR 1
 
+typedef struct _GtkTextViewPrivate GtkTextViewPrivate;
+
+#define GTK_TEXT_VIEW_GET_PRIVATE(obj) ( G_TYPE_INSTANCE_GET_PRIVATE ((obj),\
+                                      GTK_TYPE_TEXT_VIEW, GtkTextViewPrivate) )
+
 struct _GtkTextPendingScroll
 {
   GtkTextMark   *mark;
@@ -145,6 +150,8 @@
   PROP_BUFFER,
   PROP_OVERWRITE,
   PROP_ACCEPTS_TAB,
+  PROP_AUTOCAP,
+  PROP_INPUT_MODE,
   LAST_PROP
 };
 
@@ -198,6 +205,7 @@
                                                 GtkDirectionType  direction);
 static void gtk_text_view_select_all           (GtkWidget        *widget,
                                                 gboolean          select);
+static void gtk_text_view_unmap                (GtkWidget        *widget);
 
 
 /* Source side drag signals */
@@ -343,6 +351,13 @@
 
 static void gtk_text_view_update_im_spot_location (GtkTextView *text_view);
 
+static void     gtk_text_view_set_autocap          (GtkTextView *text_view,
+                                                    gboolean    autocap);
+static gboolean gtk_text_view_get_autocap          (GtkTextView *text_view);
+static void     gtk_text_view_set_input_mode       (GtkTextView *text_view,
+                                                    gint         mode);
+static gint     gtk_text_view_get_input_mode       (GtkTextView *text_view);
+
 /* Container methods */
 static void gtk_text_view_add    (GtkContainer *container,
                                   GtkWidget    *child);
@@ -408,10 +423,15 @@
                                                    gint               dy);
 static void           text_window_invalidate_rect (GtkTextWindow     *win,
                                                    GdkRectangle      *rect);
+static void           text_window_invalidate_cursors (GtkTextWindow  *win);
 
 static gint           text_window_get_width       (GtkTextWindow     *win);
 static gint           text_window_get_height      (GtkTextWindow     *win);
 
+struct _GtkTextViewPrivate
+{
+  guint release_selection : 1;
+};
 
 static const GtkTargetEntry target_table[] = {
   { "GTK_TEXT_BUFFER_CONTENTS", GTK_TARGET_SAME_APP, 0 },
@@ -481,6 +501,7 @@
 
   parent_class = g_type_class_peek_parent (klass);
 
+  g_type_class_add_private( klass, sizeof(GtkTextViewPrivate) );
   /* Default handlers and virtual methods
    */
   gobject_class->set_property = gtk_text_view_set_property;
@@ -517,6 +538,7 @@
   widget_class->drag_motion = gtk_text_view_drag_motion;
   widget_class->drag_drop = gtk_text_view_drag_drop;
   widget_class->drag_data_received = gtk_text_view_drag_data_received;
+  widget_class->unmap = gtk_text_view_unmap;
 
   widget_class->popup_menu = gtk_text_view_popup_menu;
   
@@ -667,6 +689,24 @@
 							 TRUE,
 							 G_PARAM_READWRITE));
 
+  g_object_class_install_property (gobject_class,
+                                   PROP_AUTOCAP,
+                                   g_param_spec_boolean ("autocap",
+                                                         P_("auto capitalization"),
+                                                         P_("Enable autocap support"),
+                                                         TRUE,
+                                                         G_PARAM_READABLE | G_PARAM_WRITABLE)); 
+  
+  g_object_class_install_property (gobject_class,
+                                   PROP_INPUT_MODE,
+                                   g_param_spec_int ("input_mode",
+                                                     P_("input mode"),
+                                                     P_("Define widget's input mode"),
+                                                     0,
+                                                     9, /* keep me updated */
+                                                     0,
+                                                     G_PARAM_READABLE | G_PARAM_WRITABLE)); 
+
   /*
    * Style properties
    */
@@ -676,6 +716,14 @@
 							       P_("Color with which to draw error-indication underlines"),
 							       GDK_TYPE_COLOR,
 							       G_PARAM_READABLE));
+
+  gtk_widget_class_install_style_property (widget_class,
+                                          g_param_spec_boolean ("autocap",
+                                                                _("auto capitalization"),
+                                                                _("Enable autocap support"),
+                                                            TRUE,
+                                                            G_PARAM_READABLE));
+  
   
   /*
    * Signals
@@ -1040,8 +1088,9 @@
 gtk_text_view_init (GtkTextView *text_view)
 {
   GtkWidget *widget;
-
+  GtkTextViewPrivate *priv = NULL;
   widget = GTK_WIDGET (text_view);
+  priv = GTK_TEXT_VIEW_GET_PRIVATE(text_view);
 
   GTK_WIDGET_SET_FLAGS (widget, GTK_CAN_FOCUS);
 
@@ -1057,6 +1106,8 @@
   text_view->tabs = NULL;
   text_view->editable = TRUE;
 
+  priv->release_selection = TRUE;
+
   gtk_drag_dest_set (widget,
 		     0,
                      target_table, G_N_ELEMENTS (target_table),
@@ -1070,6 +1121,10 @@
    * to it; so we create it here and destroy it in finalize ().
    */
   text_view->im_context = gtk_im_multicontext_new ();
+  /* Set default stuff. */
+  gtk_text_view_set_autocap (text_view, TRUE);
+  gtk_text_view_set_input_mode (text_view, 0); /* alpha-numeric-special */
+  g_object_set (G_OBJECT (text_view->im_context), "use-show-hide", TRUE, NULL);
 
   g_signal_connect (text_view->im_context, "commit",
                     G_CALLBACK (gtk_text_view_commit_handler), text_view);
@@ -1728,7 +1783,7 @@
                                          scroll->use_align,
                                          scroll->xalign,
                                          scroll->yalign);
-  
+
   free_pending_scroll (scroll);
 
   return retval;
@@ -1776,6 +1831,9 @@
 
   if (text_view->width != width || text_view->height != height)
     {
+      if (text_view->width != width)
+	text_view->width_changed = TRUE;
+
       text_view->width = width;
       text_view->height = height;
 
@@ -2664,6 +2722,14 @@
       gtk_text_view_set_accepts_tab (text_view, g_value_get_boolean (value));
       break;
       
+    case PROP_AUTOCAP:
+      gtk_text_view_set_autocap (text_view, g_value_get_boolean (value));
+      break;
+
+    case PROP_INPUT_MODE:
+      gtk_text_view_set_input_mode (text_view, g_value_get_int (value));
+      break;
+      
     default:
       g_assert_not_reached ();
       break;
@@ -2738,6 +2804,14 @@
       g_value_set_boolean (value, text_view->accepts_tab);
       break;
       
+    case PROP_AUTOCAP:
+      g_value_set_boolean (value, gtk_text_view_get_autocap (text_view));
+      break;
+      
+    case PROP_INPUT_MODE:
+      g_value_set_int (value, gtk_text_view_get_input_mode (text_view));
+      break;
+      
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -3144,7 +3218,16 @@
    * be invalidated
    */
   if (size_changed && GTK_WIDGET_REALIZED (widget))
-    gdk_window_invalidate_rect (widget->window, NULL, FALSE);
+    {
+      gdk_window_invalidate_rect (widget->window, NULL, FALSE);
+
+      /* Hildon: also keep cursor visible (when IM opens, for instance) */
+      gtk_text_view_scroll_to_mark(text_view,
+                                   gtk_text_buffer_get_mark(get_buffer(text_view),
+                                                            "insert"),
+                                   0.0, FALSE, 0.0, 0.0);
+    }
+
 }
 
 static void
@@ -3916,7 +3999,7 @@
   GtkTextView *text_view = GTK_TEXT_VIEW (widget);
   GtkTextMark *insert;
   GtkTextIter iter;
-
+  
   if (text_view->layout == NULL || get_buffer (text_view) == NULL)
     return FALSE;
       
@@ -4039,6 +4122,9 @@
   if (event->window != text_view->text_window->bin_window)
     return FALSE;
 
+  if (text_view->editable)
+    gtk_im_context_show (text_view->im_context);
+  
   if (event->button == 1)
     {
       if (text_view->drag_start_x >= 0)
@@ -4083,7 +4169,15 @@
 static gint
 gtk_text_view_focus_in_event (GtkWidget *widget, GdkEventFocus *event)
 {
+  /*gboolean have_selection;
+  GtkTextIter sel_start, sel_end;*/
+	
   GtkTextView *text_view = GTK_TEXT_VIEW (widget);
+  
+  /*have_selection = gtk_text_buffer_get_selection_bounds(text_view->buffer, &sel_start, &sel_end);
+  
+  if(!have_selection)
+    gtk_text_view_move_cursor(text_view, GTK_MOVEMENT_BUFFER_ENDS, 1, FALSE);*//*FIXME some other way to place the cursor in the end*/
 
   gtk_widget_queue_draw (widget);
 
@@ -4099,10 +4193,8 @@
 		    "direction_changed",
 		    G_CALLBACK (keymap_direction_changed), text_view);
   gtk_text_view_check_keymap_direction (text_view);
-  
-  text_view->need_im_reset = TRUE;
-  gtk_im_context_focus_in (GTK_TEXT_VIEW (widget)->im_context);
 
+  gtk_im_context_focus_in (GTK_TEXT_VIEW (widget)->im_context);
   return FALSE;
 }
 
@@ -4110,6 +4202,14 @@
 gtk_text_view_focus_out_event (GtkWidget *widget, GdkEventFocus *event)
 {
   GtkTextView *text_view = GTK_TEXT_VIEW (widget);
+  GtkTextViewPrivate *priv = GTK_TEXT_VIEW_GET_PRIVATE(text_view);
+  /*{
+    GtkTextIter start;
+    GtkTextIter end;
+    
+    gtk_text_buffer_get_bounds(text_view->buffer, &start, &end);
+    gtk_text_buffer_select_range(text_view->buffer, &start, &start);
+  }*//*FIXME need a hack here to take away the focus*/
 
   gtk_widget_queue_draw (widget);
 
@@ -4125,8 +4225,11 @@
 					keymap_direction_changed,
 					text_view);
 
-  text_view->need_im_reset = TRUE;
-  gtk_im_context_focus_out (GTK_TEXT_VIEW (widget)->im_context);
+  /* This is commented out to disable unselect feature.
+     When the decition of this has been made, we can either remove this patch
+     or to leave it.
+  if( priv->release_selection )
+    gtk_text_view_unselect( text_view );*/
 
   return FALSE;
 }
@@ -4492,9 +4595,22 @@
     text_view->blink_timeout = g_timeout_add (get_cursor_time (text_view) * CURSOR_ON_MULTIPLIER,
 					      blink_cb,
 					      text_view);
-  
-  gtk_text_layout_set_cursor_visible (text_view->layout,
-                                      !visible);
+
+ /* Block changed_handler while changing the layout's cursor visibility
+  * because it would expose the whole paragraph. Instead, we expose
+  * the cursor's area(s) manually below.
+  */
+  g_signal_handlers_block_by_func (text_view->layout,
+          changed_handler,
+          text_view);
+
+  gtk_text_layout_set_cursor_visible (text_view->layout, !visible);
+
+  g_signal_handlers_unblock_by_func (text_view->layout,
+          changed_handler,
+          text_view);
+
+  text_window_invalidate_cursors (text_view->text_window);
 
   GDK_THREADS_LEAVE ();
 
@@ -5082,7 +5198,8 @@
   GtkTextIter end;
   gboolean leave_one = FALSE;
 
-  gtk_text_view_reset_im_context (text_view);
+  /*gtk_text_view_reset_im_context (text_view);*/ /*backspace should not clear
+                                                    the word completion*/
 
   if (type == GTK_DELETE_CHARS)
     {
@@ -5200,7 +5317,8 @@
 {
   GtkTextIter insert;
 
-  gtk_text_view_reset_im_context (text_view);
+  /*gtk_text_view_reset_im_context (text_view);*/ /*backspace should not clear
+                                                    the word completion*/
 
   /* Backspace deletes the selection, if one exists */
   if (gtk_text_buffer_delete_selection (get_buffer (text_view), TRUE,
@@ -5928,11 +6046,11 @@
 static void
 gtk_text_view_reset_im_context (GtkTextView *text_view)
 {
-  if (text_view->need_im_reset)
+/*  if (text_view->need_im_reset)
     {
-      text_view->need_im_reset = FALSE;
+      text_view->need_im_reset = FALSE;*/
       gtk_im_context_reset (text_view->im_context);
-    }
+/*    }*/
 }
 
 /*
@@ -6482,6 +6600,17 @@
     {
       dx = text_view->xoffset - (gint)adj->value;
       text_view->xoffset = adj->value;
+
+      /* If the change is due to a size change we need 
+       * to invalidate the entire text window because there might be
+       * right-aligned or centered text 
+       */
+      if (text_view->width_changed)
+	{
+	  gdk_window_invalidate_rect (text_view->text_window->bin_window, NULL, FALSE);
+	  
+	  text_view->width_changed = FALSE;
+	}
     }
   else if (adj == text_view->vadjustment)
     {
@@ -6660,25 +6789,45 @@
 }
 
 static gboolean
+not_whitespace_crlf (gunichar ch, gpointer user_data)
+{
+  return !whitespace (ch, user_data) && ch != '\r' && ch != '\n';
+}
+
+static gboolean
 gtk_text_view_retrieve_surrounding_handler (GtkIMContext  *context,
 					    GtkTextView   *text_view)
 {
   GtkTextIter start;
   GtkTextIter end;
+  GtkTextIter cursor;
   gint pos;
   gchar *text;
+  gchar *text_between = NULL;
 
-  gtk_text_buffer_get_iter_at_mark (text_view->buffer, &start,  
+  gtk_text_buffer_get_iter_at_mark (text_view->buffer, &cursor,  
 				    gtk_text_buffer_get_insert (text_view->buffer));
-  end = start;
+  end = start = cursor;
 
-  pos = gtk_text_iter_get_line_index (&start);
   gtk_text_iter_set_line_offset (&start, 0);
   gtk_text_iter_forward_to_line_end (&end);
 
+  /* we want to include the previous non-whitespace character in the
+     surroundings. */
+  if (gtk_text_iter_backward_char (&start))
+    gtk_text_iter_backward_find_char (&start, not_whitespace_crlf, NULL, NULL);
+  
+  text_between = gtk_text_iter_get_slice(&start, &cursor);
+    
+  if(text_between  != NULL)
+    pos = strlen(text_between);
+  else
+    pos = 0;
+    
   text = gtk_text_iter_get_slice (&start, &end);
   gtk_im_context_set_surrounding (context, text, -1, pos);
   g_free (text);
+  g_free(text_between);
 
   return TRUE;
 }
@@ -6726,8 +6875,8 @@
       need_reset = TRUE;
     }
 
-  if (need_reset)
-    gtk_text_view_reset_im_context (text_view);
+  /*if (need_reset)
+    gtk_text_view_reset_im_context (text_view);*//*FIXME need a hack here*/
 }
 
 static void
@@ -6957,6 +7106,13 @@
 }                             
 
 static void
+block_selection_change( GtkMenuShell *menushell, gpointer user_data )
+{
+  GtkTextViewPrivate *priv = GTK_TEXT_VIEW_GET_PRIVATE(user_data);
+  priv->release_selection = TRUE;
+}
+
+static void
 unichar_chosen_func (const char *text,
                      gpointer    data)
 {
@@ -7064,7 +7220,12 @@
 		     signals[POPULATE_POPUP],
 		     0,
 		     text_view->popup_menu);
-      
+    {
+      GtkTextViewPrivate *priv = GTK_TEXT_VIEW_GET_PRIVATE(text_view);
+      g_signal_connect( GTK_WIDGET(text_view->popup_menu), "selection-done",
+                        G_CALLBACK(block_selection_change), text_view );
+      priv->release_selection = FALSE;
+    }
       if (info->button)
 	gtk_menu_popup (GTK_MENU (text_view->popup_menu), NULL, NULL,
 			NULL, NULL,
@@ -7338,6 +7499,72 @@
 #endif
 }
 
+static void
+text_window_invalidate_cursors (GtkTextWindow *win)
+{
+  GtkTextView *text_view = GTK_TEXT_VIEW (win->widget);
+  GtkTextIter  iter;
+  GdkRectangle strong;
+  GdkRectangle weak;
+  gboolean     draw_arrow;
+  gfloat       cursor_aspect_ratio;
+  gint         stem_width;
+  gint         arrow_width;
+
+  gtk_text_buffer_get_iter_at_mark (text_view->buffer, &iter,
+          gtk_text_buffer_get_insert (text_view->buffer));
+
+  gtk_text_layout_get_cursor_locations (text_view->layout, &iter,
+          &strong, &weak);
+
+  /* cursor width calculation as in gtkstyle.c:draw_insertion_cursor(),
+   * ignoring the text direction be exposing both sides of the cursor
+   */
+
+  draw_arrow = (strong.x != weak.x || strong.y != weak.y);
+
+  gtk_widget_style_get (win->widget,
+          "cursor-aspect-ratio", &cursor_aspect_ratio,
+          NULL);
+
+  stem_width = strong.height * cursor_aspect_ratio + 1;
+  arrow_width = stem_width + 1;
+
+  /* round up to the next even number */
+  if (stem_width & 1)
+      stem_width++;
+
+  strong.x     -= stem_width / 2;
+  strong.width += stem_width;
+
+  if (draw_arrow)
+    {
+      strong.x     -= arrow_width;
+      strong.width += arrow_width * 2;
+    }
+
+  text_window_invalidate_rect (win, &strong);
+
+  if (draw_arrow) /* == have weak */
+    {
+      stem_width = weak.height * cursor_aspect_ratio + 1;
+      arrow_width = stem_width + 1;
+
+      /* round up to the next even number */
+      if (stem_width & 1)
+          stem_width++;
+
+      weak.x     -= stem_width / 2;
+      weak.width += stem_width;
+
+      weak.x     -= arrow_width;
+      weak.width += arrow_width * 2;
+
+      text_window_invalidate_rect (win, &weak);
+    }
+}
+
+
 static gint
 text_window_get_width (GtkTextWindow *win)
 {
@@ -8301,3 +8528,91 @@
 
   return gtk_text_layout_move_iter_visually (text_view->layout, iter, count);
 }
+
+/*
+ * gtk_text_view_set_autocap:
+ * @entry: a #GtkTextView
+ * @autocap: autocap
+ *
+ * Sets autocapitalization of the widget.
+ */
+static void
+gtk_text_view_set_autocap (GtkTextView *text_view,
+                           gboolean     autocap)
+{
+  g_return_if_fail (GTK_IS_TEXT_VIEW (text_view));
+
+  if (gtk_text_view_get_autocap (text_view) != autocap)
+  {
+    g_object_set (G_OBJECT (text_view->im_context), "autocap", autocap, NULL);
+    g_object_notify (G_OBJECT (text_view), "autocap");
+  }
+}
+
+/*
+ * gtk_text_view_get_autocap:
+ * @entry: a #GtkTextView
+ *
+ * Gets autocapitalization state of the widget.
+ *
+ * Return value: a state
+ */
+static gboolean
+gtk_text_view_get_autocap (GtkTextView *text_view)
+{
+  gboolean autocap;
+  g_return_val_if_fail (GTK_IS_TEXT_VIEW (text_view), FALSE);
+
+  g_object_get (G_OBJECT (text_view->im_context), "autocap", &autocap, NULL);
+
+  return autocap;
+}
+
+/*
+ * gtk_text_view_set_input_mode:
+ * @text_view: a #GtkTextView
+ * @mode: input mode
+ *
+ * Sets autocapitalization of the widget.
+ */
+static void
+gtk_text_view_set_input_mode (GtkTextView *text_view,
+                              gint         mode)
+{
+  g_return_if_fail (GTK_IS_TEXT_VIEW (text_view));
+
+  if (gtk_text_view_get_input_mode (text_view) != mode)
+  {
+    g_object_set (G_OBJECT (text_view->im_context), "input_mode", mode, NULL);
+    g_object_notify (G_OBJECT (text_view), "input_mode");
+  }
+}
+
+/*
+ * gtk_text_view_get_input_mode:
+ * @text_view: a #GtkTextView
+ *
+ * Gets input mode of the widget.
+ *
+ * Return value: input mode
+ */
+static gint
+gtk_text_view_get_input_mode (GtkTextView *text_view)
+{
+  gint mode;
+  g_return_val_if_fail (GTK_IS_TEXT_VIEW (text_view), FALSE);
+
+  g_object_get (G_OBJECT (text_view->im_context), "input_mode", &mode, NULL);
+
+  return mode;
+}
+
+static void
+gtk_text_view_unmap (GtkWidget *widget)
+{
+  gtk_im_context_hide (GTK_TEXT_VIEW (widget)->im_context);
+
+  if (GTK_WIDGET_CLASS (parent_class)->unmap)
+    (* GTK_WIDGET_CLASS (parent_class)->unmap) (widget);
+}
+
--- gtk+/gtk/gtkrbtree.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkrbtree.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -1378,18 +1378,18 @@
   g_return_val_if_fail (node != NULL, NULL);
 
   /* Case 1: the node's below us. */
-  if (node->right != tree->nil)
+  if (node && node->right != tree->nil)
     {
       node = node->right;
-      while (node->left != tree->nil)
+      while (node && node->left != tree->nil)
 	node = node->left;
       return node;
     }
 
   /* Case 2: it's an ancestor */
-  while (node->parent != tree->nil)
+  while (node && node->parent != tree->nil)
     {
-      if (node->parent->right == node)
+      if (node->parent && node->parent->right == node)
 	node = node->parent;
       else
 	return (node->parent);
@@ -1407,18 +1407,18 @@
   g_return_val_if_fail (node != NULL, NULL);
 
   /* Case 1: the node's below us. */
-  if (node->left != tree->nil)
+  if (node != NULL && node->left != tree->nil)
     {
       node = node->left;
-      while (node->right != tree->nil)
+      while (node != NULL && node->right != tree->nil)
 	node = node->right;
       return node;
     }
 
   /* Case 2: it's an ancestor */
-  while (node->parent != tree->nil)
+  while (node != NULL && node->parent != tree->nil)
     {
-      if (node->parent->left == node)
+      if (node->parent && node->parent->left == node)
 	node = node->parent;
       else
 	return (node->parent);
--- gtk+/gtk/gtktextview.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtktextview.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -95,8 +95,7 @@
 
   guint accepts_tab : 1;
   
-  /* this flag is no longer used */
-  guint reserved : 1;
+  guint width_changed : 1;
   
   /* debug flag - means that we've validated onscreen since the
    * last "invalidate" signal from the layout
@@ -104,7 +103,7 @@
   guint onscreen_validated : 1;
 
   guint mouse_cursor_obscured : 1;
-  
+
   GtkTextWindow *text_window;
   GtkTextWindow *left_window;
   GtkTextWindow *right_window;
--- gtk+/gtk/gtkstyle.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkstyle.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -38,6 +38,7 @@
 #include "gtkthemes.h"
 #include "gtkiconfactory.h"
 #include "gtksettings.h"	/* _gtk_settings_parse_convert() */
+#include "gtkhashtable.h"
 
 #define LIGHTNESS_MULT  1.3
 #define DARKNESS_MULT   0.7
@@ -49,6 +50,14 @@
   GValue      value;
 } PropertyValue;
 
+#define GTK_STYLE_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GTK_TYPE_STYLE, GtkStylePrivate))
+
+typedef struct _GtkStylePrivate GtkStylePrivate;
+
+struct _GtkStylePrivate {
+  GSList *logical_color_hashes;
+};
+
 /* --- prototypes --- */
 static void	 gtk_style_init			(GtkStyle	*style);
 static void	 gtk_style_class_init		(GtkStyleClass	*klass);
@@ -655,6 +664,7 @@
   klass->draw_layout = gtk_default_draw_layout;
   klass->draw_resize_grip = gtk_default_draw_resize_grip;
 
+  g_type_class_add_private (object_class, sizeof (GtkStylePrivate));
   
   /**
    * GtkStyle::realize:
@@ -714,9 +724,28 @@
 }
 
 static void
+free_object_list (GSList *list)
+{
+  if (list)
+    {
+      GSList *tmp_list = list;
+
+      while (tmp_list)
+	{
+	  g_object_unref (tmp_list->data);
+	  tmp_list = tmp_list->next;
+	}
+
+      g_slist_free (list);
+    }
+    
+}
+
+static void
 gtk_style_finalize (GObject *object)
 {
   GtkStyle *style = GTK_STYLE (object);
+  GtkStylePrivate *priv = GTK_STYLE_GET_PRIVATE (style);
 
   g_return_if_fail (style->attach_count == 0);
 
@@ -745,19 +774,9 @@
           g_slist_free_1 (style->styles);
         }
     }
-
-  if (style->icon_factories)
-    {
-      GSList *tmp_list = style->icon_factories;
-
-      while (tmp_list)
-	{
-	  g_object_unref (tmp_list->data);
-	  tmp_list = tmp_list->next;
-	}
-
-      g_slist_free (style->icon_factories);
-    }
+  
+  free_object_list (style->icon_factories);
+  free_object_list (priv->logical_color_hashes);
 
   pango_font_description_free (style->font_desc);
   
@@ -1003,6 +1022,51 @@
   return gtk_icon_factory_lookup_default (stock_id);
 }
 
+ /**
+ * gtk_style_lookup_logical_color:
+ * @style: a #GtkStyle
+ * @color_name: the name of the logical color to look up
+ * @color: the #GdkColor to fill in
+ *
+ * Looks up @color_name in the style's logical color mappings,
+ * filling in @color and returning %TRUE if found, otherwise
+ * returning %FALSE. Do not cache the found mapping, because
+ * it depends on the #GtkStyle and might change when a theme
+ * switch occurs.
+ *
+ * Return value: %TRUE if the mapping was found.
+ */
+gboolean
+gtk_style_lookup_logical_color (GtkStyle   *style,
+				const char *color_name,
+				GdkColor   *color)
+{
+  GtkStylePrivate *priv = GTK_STYLE_GET_PRIVATE (style);
+  GSList *iter;
+
+  g_return_val_if_fail (GTK_IS_STYLE (style), FALSE);
+  g_return_val_if_fail (color_name != NULL, FALSE);
+  g_return_val_if_fail (color != NULL, FALSE);
+  
+  iter = priv->logical_color_hashes;
+  while (iter != NULL)
+    {
+      GdkColor *mapping = g_hash_table_lookup (GTK_HASH_TABLE (iter->data)->hash,
+					       color_name);
+      if (mapping)
+        {
+          color->red = mapping->red;
+          color->green = mapping->green;
+          color->blue = mapping->blue;
+          return TRUE;
+        }
+      
+      iter = g_slist_next (iter);
+    }
+
+  return FALSE;
+}
+
 /**
  * gtk_draw_hline:
  * @style: a #GtkStyle
@@ -1717,10 +1781,32 @@
   clear_property_cache (style);
 }
 
+static GSList *
+copy_object_list (GSList *list)
+{
+  if (list)
+    {
+      GSList *iter;
+
+      iter = list;
+      while (iter != NULL)
+        {
+          g_object_ref (iter->data);
+          iter = g_slist_next (iter);
+        }
+      
+      return g_slist_copy (list);
+    }
+  else
+    return NULL;
+}
+
 static void
 gtk_style_real_init_from_rc (GtkStyle   *style,
 			     GtkRcStyle *rc_style)
 {
+  GtkStylePrivate *priv = GTK_STYLE_GET_PRIVATE (style);
+  GSList *logical_color_hashes;
   gint i;
 
   /* cache _should_ be still empty */
@@ -1746,19 +1832,10 @@
   if (rc_style->ythickness >= 0)
     style->ythickness = rc_style->ythickness;
 
-  if (rc_style->icon_factories)
-    {
-      GSList *iter;
+  style->icon_factories = copy_object_list (rc_style->icon_factories);
 
-      style->icon_factories = g_slist_copy (rc_style->icon_factories);
-      
-      iter = style->icon_factories;
-      while (iter != NULL)
-        {
-          g_object_ref (iter->data);
-          iter = g_slist_next (iter);
-        }
-    }
+  logical_color_hashes = _gtk_rc_style_get_logical_color_hashes (rc_style);
+  priv->logical_color_hashes = copy_object_list (logical_color_hashes);
 }
 
 static gint
@@ -2065,7 +2142,7 @@
                        const gchar         *detail)
 {
   GdkPixbuf *pixbuf;
-  
+
   g_return_val_if_fail (GTK_IS_STYLE (style), NULL);
   g_return_val_if_fail (GTK_STYLE_GET_CLASS (style)->render_icon != NULL, NULL);
   
@@ -2156,7 +2233,7 @@
     {
       return gdk_pixbuf_scale_simple (src,
                                       width, height,
-                                      GDK_INTERP_BILINEAR);
+                                      GDK_INTERP_NEAREST);
     }
 }
 
@@ -2183,7 +2260,6 @@
    */
 
   base_pixbuf = gtk_icon_source_get_pixbuf (source);
-
   g_return_val_if_fail (base_pixbuf != NULL, NULL);
 
   if (widget && gtk_widget_has_screen (widget))
@@ -2213,7 +2289,9 @@
   /* If the size was wildcarded, and we're allowed to scale, then scale; otherwise,
    * leave it alone.
    */
-  if (size != (GtkIconSize)-1 && gtk_icon_source_get_size_wildcarded (source))
+  /* Hildon addition: icons are never scaled */
+  if (size != (GtkIconSize)-1 && gtk_icon_source_get_size_wildcarded (source)
+      && size < HILDON_ICON_SIZE_26)
     scaled = scale_or_ref (base_pixbuf, width, height);
   else
     scaled = g_object_ref (base_pixbuf);
@@ -2224,7 +2302,7 @@
       if (state == GTK_STATE_INSENSITIVE)
         {
           stated = gdk_pixbuf_copy (scaled);      
-          
+
           gdk_pixbuf_saturate_and_pixelate (scaled, stated,
                                             0.8, TRUE);
           
@@ -2232,8 +2310,8 @@
         }
       else if (state == GTK_STATE_PRELIGHT)
         {
-          stated = gdk_pixbuf_copy (scaled);      
-          
+          stated = gdk_pixbuf_copy (scaled);
+
           gdk_pixbuf_saturate_and_pixelate (scaled, stated,
                                             1.2, FALSE);
           
@@ -6802,6 +6880,10 @@
   
   g_return_if_fail (direction != GTK_TEXT_DIR_NONE);
   
+  /* When changing the shape or size of the cursor here,
+   * propagate the changes to gtktextview.c:text_window_invalidate_cursors().
+   */
+
   gtk_widget_style_get (widget, "cursor-aspect-ratio", &cursor_aspect_ratio, NULL);
   
   stem_width = location->height * cursor_aspect_ratio + 1;
--- gtk+/gtk/gtkstyle.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkstyle.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -454,6 +454,10 @@
 					      gint	    width, 
 					      gint	    height);
 
+gboolean  gtk_style_lookup_logical_color     (GtkStyle     *style,
+                                              const gchar  *color_name,
+                                              GdkColor     *color);
+                          
 GtkIconSet* gtk_style_lookup_icon_set (GtkStyle            *style,
                                        const gchar         *stock_id);
 GdkPixbuf*  gtk_style_render_icon     (GtkStyle            *style,
--- gtk+/gtk/gtkicontheme.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkicontheme.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -64,7 +64,8 @@
   ICON_SUFFIX_XPM = 1 << 0,
   ICON_SUFFIX_SVG = 1 << 1,
   ICON_SUFFIX_PNG = 1 << 2,
-  HAS_ICON_FILE = 1 << 3
+  HAS_ICON_FILE = 1 << 3,
+  ICON_SUFFIX_ANI = 1 << 4
 } IconSuffix;
 
 
@@ -1743,6 +1744,8 @@
       return ".svg";
     case ICON_SUFFIX_PNG:
       return ".png";
+    case ICON_SUFFIX_ANI:
+      return ".ani";
     default:
       g_assert_not_reached();
     }
@@ -1760,6 +1763,8 @@
     retval = ICON_SUFFIX_SVG;
   else if (g_str_has_suffix (name, ".xpm"))
     retval = ICON_SUFFIX_XPM;
+  else if (g_str_has_suffix (name, ".ani"))
+    retval = ICON_SUFFIX_ANI;
   else
     retval = ICON_SUFFIX_NONE;
 
@@ -1776,6 +1781,8 @@
     return ICON_SUFFIX_SVG;
   else if ((suffix & ICON_SUFFIX_XPM) != 0)
     return ICON_SUFFIX_XPM;
+  else if ((suffix & ICON_SUFFIX_ANI) != 0)
+    return ICON_SUFFIX_ANI;
   else
     return ICON_SUFFIX_NONE;
 }
@@ -2558,7 +2565,7 @@
       icon_info->pixbuf = gdk_pixbuf_scale_simple (source_pixbuf,
 						   0.5 + image_width * icon_info->scale,
 						   0.5 + image_height * icon_info->scale,
-						   GDK_INTERP_BILINEAR);
+						   GDK_INTERP_NEAREST);
       g_object_unref (source_pixbuf);
     }
 
--- gtk+/gtk/maemo-gtk-im-switch.c	(.../2.6.4)	(revision 0)
+++ gtk+/gtk/maemo-gtk-im-switch.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -0,0 +1,64 @@
+/**
+  @file maemo-gtk-im-switch.c
+
+  Utility to switch the current gtk input method globally.
+      
+  Copyright (C) 2005 Nokia Corporation.
+    
+  Contact: Tomas Junnonen <tomas.junnonen@nokia.com>
+
+  This program is free software; you can redistribute it and/or
+  modify it under the terms of the GNU General Public License as
+  published by the Free Software Foundation; either version 2 of the
+  License, or (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+	     
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+  USA
+*/
+
+#include <gtk/gtk.h>
+#include <string.h>
+
+#define IM_ATOM_NAME "gtk-global-immodule"
+
+static void set_im_property(gchar *id)
+{
+  GdkAtom atom;
+  GdkScreen *screen;
+  GdkWindow *root;
+
+  atom = gdk_atom_intern(IM_ATOM_NAME, FALSE);
+  screen = gdk_screen_get_default();
+  root = gdk_screen_get_root_window(screen);
+
+  gdk_property_change(root,
+                      atom,
+                      gdk_atom_intern ("STRING", FALSE),
+                      8,
+                      GDK_PROP_MODE_REPLACE,
+                      id,
+                      strlen(id)+1);
+}
+
+int main(int argc, char *argv[])
+{
+  gtk_init(&argc, &argv);
+
+  if (argc != 2) {
+    printf("Usage: %s [input-method-name]\n", argv[0]);
+    return 1;
+  }
+
+  set_im_property(argv[1]);
+
+  gtk_main_iteration();
+
+  return 0;
+}
--- gtk+/gtk/gtkimage.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkimage.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -1391,7 +1391,18 @@
                      animation_timeout,
                      image);
   
-  gtk_widget_queue_draw (GTK_WIDGET (image));
+  /*gtk_widget_queue_draw (GTK_WIDGET (image));*/
+  if (GTK_WIDGET_DRAWABLE (image))
+    {
+      GtkWidget     *widget = (GtkWidget*)image;
+      GdkEventExpose event;
+
+      /* ugly event hack, but the area is sufficient for gtk_image_expose */
+      event.area = widget->allocation;
+      gdk_window_begin_paint_rect (widget->window, &event.area);
+      gtk_image_expose (widget, &event);
+      gdk_window_end_paint (widget->window);
+    }
 
   GDK_THREADS_LEAVE ();
 
--- gtk+/gtk/gtktreeprivate.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtktreeprivate.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -232,6 +232,41 @@
   GtkTreeViewRowSeparatorFunc row_separator_func;
   gpointer row_separator_data;
   GtkDestroyNotify row_separator_destroy;
+
+  /* Hildon additions */
+  guint new_state : 1;        /* helper flag for pen drag in checkbox mode */
+  guint checkbox_mode : 1;       /* is checkbox mode on right now? */
+  guint allow_checkbox_mode : 1; /* is checkbox mode ever allowed to be on? */
+  guint pen_down : 1;
+  guint pen_drag_active : 1;
+  guint pen_drag_motion_counter;
+  guint pen_drag_reverse : 1;
+  gboolean pen_scroll_timer;
+  gdouble old_y;
+  gboolean pen_focus;
+  gboolean dotted_lines;
+  gboolean force_list_kludge;
+
+  /* the "pen down" row of the current pen drag */
+  GtkTreeRowReference *first_drag_row;
+
+  /* most recently toggled row during pen drag */
+  GtkTreeRowReference *last_drag_row;
+
+  /* for postponing tree node expand/collapse at
+     button_press event until button_release event */
+  GtkTreeRowReference *queued_expand_row;
+
+  /* for postponing selection clearing at button_press event
+     until button_release event in painted multiple selection mode */
+  GtkTreeRowReference *queued_select_row;
+
+  /* for postponing selection activation at button_press event
+   * until button_release event */
+  GtkTreeRowReference *queued_activate_row;
+
+  /* Hildon treeview can_focus hack */
+  guint check_if_can_focus_idle_id;
 };
 
 #ifdef __GNUC__
@@ -357,6 +392,7 @@
 							  GtkTreeViewColumn *column);
 
 gboolean         _gtk_tree_view_column_has_editable_cell (GtkTreeViewColumn *column);
+gboolean         _gtk_tree_view_column_has_activatable_cell (GtkTreeViewColumn *column);
 GtkCellRenderer *_gtk_tree_view_column_get_edited_cell   (GtkTreeViewColumn *column);
 gint             _gtk_tree_view_column_count_special_cells (GtkTreeViewColumn *column);
 GtkCellRenderer *_gtk_tree_view_column_get_cell_at_pos   (GtkTreeViewColumn *column,
@@ -366,6 +402,9 @@
 GtkTreeSelection* _gtk_tree_selection_new_with_tree_view (GtkTreeView      *tree_view);
 void              _gtk_tree_selection_set_tree_view      (GtkTreeSelection *selection,
                                                           GtkTreeView      *tree_view);
+gboolean          _gtk_tree_selection_is_row_selectable  (GtkTreeSelection *selection,
+                                                          GtkRBNode        *node,
+                                                          GtkTreePath      *path);
 
 void		  _gtk_tree_view_column_cell_render      (GtkTreeViewColumn *tree_column,
 							  GdkWindow         *window,
--- gtk+/gtk/gtkseparator.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkseparator.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -65,6 +65,18 @@
 static void
 gtk_separator_class_init (GtkSeparatorClass *class)
 {
+  GParamSpec* pspec;
+  
+  pspec = g_param_spec_boolean("hildonlike-drawing",
+                               "hildonlike looks.",
+                               "hildonlike looks. "
+			       "Draws with paint_box "
+			       "instead of paint_(vh)line, 1/0",
+                               FALSE,
+                               G_PARAM_READABLE);
+  
+  gtk_widget_class_install_style_property(GTK_WIDGET_CLASS(class),
+                                          pspec);
 }
 
 static void
--- gtk+/gtk/updateiconcache.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/updateiconcache.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -40,6 +40,7 @@
 #define HAS_SUFFIX_SVG (1 << 1)
 #define HAS_SUFFIX_PNG (1 << 2)
 #define HAS_ICON_FILE  (1 << 3)
+#define HAS_SUFFIX_ANI (1 << 4)
 
 #define MAJOR_VERSION 1
 #define MINOR_VERSION 0
@@ -55,7 +56,7 @@
   gchar *cache_path;
   int retval;
   
-  retval = g_stat (path, &path_stat);
+  retval = stat (path, &path_stat);
 
   if (retval < 0)
     {
@@ -164,7 +165,7 @@
 
       retval = g_file_test (path, G_FILE_TEST_IS_REGULAR);
       g_free (path);
-      
+
       if (retval)
 	{
 	  if (g_str_has_suffix (name, ".png"))
@@ -175,6 +176,8 @@
 	    flags |= HAS_SUFFIX_XPM;
 	  else if (g_str_has_suffix (name, ".icon"))
 	    flags |= HAS_ICON_FILE;
+	  else if (g_str_has_suffix (name, ".ani"))
+	    flags |= HAS_SUFFIX_ANI;
 	  
 	  if (flags == 0)
 	    continue;
--- gtk+/gtk/gtkcellview.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkcellview.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -82,7 +82,6 @@
                                                            GValue          *value);
 static GtkCellViewCellInfo *gtk_cell_view_get_cell_info   (GtkCellView      *cellview,
                                                            GtkCellRenderer  *renderer);
-static void        gtk_cell_view_set_cell_data            (GtkCellView      *cell_view);
 
 
 static void        gtk_cell_view_cell_layout_pack_start        (GtkCellLayout         *layout,
@@ -361,6 +360,7 @@
 
   cellview = GTK_CELL_VIEW (widget);
 
+
   /* checking how much extra space we have */
   for (i = cellview->priv->cell_list; i; i = i->next)
     {
@@ -376,38 +376,81 @@
     }
 
   extra_space = widget->allocation.width - full_requested_width;
-  if (extra_space < 0)
-    extra_space = 0;
-  else if (extra_space > 0 && expand_cell_count > 0)
+  
+  if (expand_cell_count > 0)
     extra_space /= expand_cell_count;
-
-  /* iterate list for PACK_START cells */
-  for (i = cellview->priv->cell_list; i; i = i->next)
+  
+  /* PACK_START cells */
+  if (extra_space >= 0)
     {
-      GtkCellViewCellInfo *info = (GtkCellViewCellInfo *)i->data;
-
-      if (info->pack == GTK_PACK_END)
-        continue;
-
-      if (!info->cell->visible)
-        continue;
+      /* we have more space than requested */
+      for (i = cellview->priv->cell_list; i; i = i->next)
+        {
+          GtkCellViewCellInfo *info = (GtkCellViewCellInfo *)i->data;
+          if (info->pack == GTK_PACK_END)
+              continue;
+          if (!info->cell->visible)
+              continue;
 
-      info->real_width = info->requested_width + (info->expand?extra_space:0);
+          info->real_width = info->requested_width + 
+              (info->expand ? extra_space : 0);
+        }
     }
-
-  /* iterate list for PACK_END cells */
-  for (i = cellview->priv->cell_list; i; i = i->next)
+  else
     {
-      GtkCellViewCellInfo *info = (GtkCellViewCellInfo *)i->data;
-
-      if (info->pack == GTK_PACK_START)
-        continue;
-
-      if (!info->cell->visible)
-        continue;
+      /* we have less space than requested 
+       * iterate (and take space) from last cell in list so that first 
+       * cells remain visible */ 
+      for ( i = g_list_last(cellview->priv->cell_list); i; i = i->prev )
+         {
+           GtkCellViewCellInfo *info = (GtkCellViewCellInfo *)i->data;
+           if (info->pack == GTK_PACK_END)
+             continue;
+           if (!info->cell->visible)
+             continue;
+           
+           info->real_width = info->requested_width + extra_space;         
+           if (info->real_width < 0)
+               info->real_width = info->requested_width;
+           /* if there is at most one expanding cell, take space only once */
+           if (expand_cell_count <= 1)
+               extra_space = 0;
+         }
+    }
+  
+  /* PACK_END cells */
+  if (extra_space >= 0)
+    {
+      for (i = cellview->priv->cell_list; i; i = i->next)
+        {
+          GtkCellViewCellInfo *info = (GtkCellViewCellInfo *)i->data;
+          if (info->pack == GTK_PACK_START)
+              continue;
+          if (!info->cell->visible)
+              continue;
 
-      info->real_width = info->requested_width + (info->expand?extra_space:0);
+          info->real_width = info->requested_width + 
+              (info->expand ? extra_space : 0);
+        }
     }
+  else
+    {
+       for ( i = g_list_last(cellview->priv->cell_list); i; i = i->prev )
+         {
+           GtkCellViewCellInfo *info = (GtkCellViewCellInfo *)i->data;
+           if (info->pack == GTK_PACK_START)
+               continue;
+           if (!info->cell->visible)
+               continue;
+
+           info->real_width = info->requested_width + extra_space;
+           if (info->real_width < 0)
+               info->real_width = info->requested_width;
+           if (expand_cell_count <= 1)
+               extra_space = 0;
+         }
+    }
+  
 }
 
 static gboolean
@@ -536,7 +579,7 @@
   return NULL;
 }
 
-static void
+void
 gtk_cell_view_set_cell_data (GtkCellView *cell_view)
 {
   GList *i;
--- gtk+/gtk/gtktextbuffer.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtktextbuffer.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -1,5 +1,6 @@
 /* GTK - The GIMP Toolkit
  * gtktextbuffer.c Copyright (C) 2000 Red Hat, Inc.
+ *                 Copyright (C) 2004 Nokia Corporation
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -39,6 +40,17 @@
 #include "gtktextbtree.h"
 #include "gtktextiterprivate.h"
 #include "gtkintl.h"
+#include "gtktextbufferserialize.h"
+
+#define GTK_TEXT_BUFFER_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GTK_TYPE_TEXT_BUFFER, GtkTextBufferPrivate))
+
+typedef struct _GtkTextBufferPrivate GtkTextBufferPrivate;
+
+struct _GtkTextBufferPrivate
+{
+  gboolean can_paste_rich_text;
+  gchar   *rich_text_format;
+};
 
 typedef struct _ClipboardRequest ClipboardRequest;
 
@@ -71,7 +83,10 @@
   PROP_0,
 
   /* Construct */
-  PROP_TAG_TABLE
+  PROP_TAG_TABLE,
+
+  PROP_CAN_PASTE_RICH_TEXT,
+  PROP_RICH_TEXT_FORMAT  
 };
 
 enum {
@@ -79,6 +94,8 @@
   TARGET_TEXT,
   TARGET_COMPOUND_TEXT,
   TARGET_UTF8_STRING,
+  TARGET_TEXT_VIEW_MARKUP,
+  TARGET_TEXT_VIEW_RICH_TEXT_FORMAT,
   TARGET_TEXT_BUFFER_CONTENTS
 };
 
@@ -185,7 +202,20 @@
                                                         P_("Text Tag Table"),
                                                         GTK_TYPE_TEXT_TAG_TABLE,
                                                         G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+  g_object_class_install_property (object_class,
+                                  PROP_CAN_PASTE_RICH_TEXT,
+                                  g_param_spec_boolean ("can_paste_rich_text",
+                                                        P_("Can paste rich text"),
+                                                        P_("Whether it should be possible to paste rich text to the buffer"),
+                                                        FALSE, G_PARAM_READWRITE));
+  g_object_class_install_property (object_class,
+                                  PROP_RICH_TEXT_FORMAT,
+                                  g_param_spec_string ("rich_text_format",
+                                                       P_("Rich Text Format"),
+                                                       P_("Name of a collection of tags that the text view supports"),
+                                                       NULL, G_PARAM_READWRITE));
 
+  
   signals[INSERT_TEXT] =
     g_signal_new ("insert_text",
                   G_OBJECT_CLASS_TYPE (object_class),
@@ -335,7 +365,9 @@
                   NULL, NULL,
                   _gtk_marshal_VOID__VOID,
                   G_TYPE_NONE,
-                  0);  
+                  0);
+  
+  g_type_class_add_private (object_class, sizeof (GtkTextBufferPrivate));
 }
 
 static void
@@ -385,7 +417,12 @@
     case PROP_TAG_TABLE:
       set_table (text_buffer, g_value_get_object (value));
       break;
-
+    case PROP_CAN_PASTE_RICH_TEXT:
+      gtk_text_buffer_set_can_paste_rich_text (text_buffer, g_value_get_boolean (value));
+      break;
+    case PROP_RICH_TEXT_FORMAT:
+      gtk_text_buffer_set_rich_text_format (text_buffer, g_value_get_string (value));
+      break;
     default:
       break;
     }
@@ -406,7 +443,14 @@
     case PROP_TAG_TABLE:
       g_value_set_object (value, get_table (text_buffer));
       break;
-
+    case PROP_CAN_PASTE_RICH_TEXT:
+      g_value_set_boolean (value,
+                          gtk_text_buffer_get_can_paste_rich_text (text_buffer));
+      break;
+    case PROP_RICH_TEXT_FORMAT:
+      g_value_set_string (value,
+                         gtk_text_buffer_get_rich_text_format (text_buffer));
+      break;
     default:
       break;
     }
@@ -434,11 +478,14 @@
 gtk_text_buffer_finalize (GObject *object)
 {
   GtkTextBuffer *buffer;
+  GtkTextBufferPrivate *priv;
 
   buffer = GTK_TEXT_BUFFER (object);
 
   remove_all_selection_clipboards (buffer);
 
+  priv = GTK_TEXT_BUFFER_GET_PRIVATE (buffer);
+
   if (buffer->tag_table)
     {
       _gtk_text_tag_table_remove_buffer (buffer->tag_table, buffer);
@@ -456,7 +503,9 @@
     free_log_attr_cache (buffer->log_attr_cache);
 
   buffer->log_attr_cache = NULL;
-  
+
+  g_free (priv->rich_text_format);
+
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
 
@@ -2738,8 +2787,7 @@
 
   if (gtk_text_buffer_get_selection_bounds (buffer, &start, &end))
     {
-      if (selection_data->target ==
-          gdk_atom_intern ("GTK_TEXT_BUFFER_CONTENTS", FALSE))
+      if (info == TARGET_TEXT_BUFFER_CONTENTS)
         {
           /* Provide the address of the buffer; this will only be
            * used within-process
@@ -2750,6 +2798,32 @@
                                   (void*)&buffer,
                                   sizeof (buffer));
         }
+      else if (info == TARGET_TEXT_VIEW_MARKUP)
+       {
+         gchar *str;
+         gint len;
+
+         str = gtk_text_buffer_serialize_rich_text (buffer, &start, &end, &len);
+
+         gtk_selection_data_set (selection_data,
+                                 gdk_atom_intern ("application/x-gtk-text-view-markup", FALSE),
+                                 8, /* bytes */
+                                 str, len);
+         g_free (str);
+       }
+      else if (info == TARGET_TEXT_VIEW_RICH_TEXT_FORMAT)
+	{
+	  gint len;
+	  gchar *format;
+	  
+	  format = g_object_get_data (G_OBJECT (buffer), "gtk-text-buffer-clipboard-format");
+	  len = format ? strlen (format) : -1;
+	  
+	  gtk_selection_data_set (selection_data,
+				  gdk_atom_intern ("application/x-gtk-text-view-rich-text-format", FALSE),
+				  8, /* bytes */
+				  format, len);
+	}
       else
         {
           gchar *str;
@@ -2765,10 +2839,16 @@
 create_clipboard_contents_buffer (GtkTextBuffer *buffer)
 {
   GtkTextBuffer *contents;
+  gchar *format;
 
   contents = gtk_text_buffer_new (gtk_text_buffer_get_tag_table (buffer));
 
+  format = GTK_TEXT_BUFFER_GET_PRIVATE (buffer)->rich_text_format;
+
   g_object_set_data (G_OBJECT (contents), "gtk-text-buffer-clipboard", GINT_TO_POINTER (1));
+
+  g_object_set_data_full (G_OBJECT (contents), "gtk-text-buffer-clipboard-format",
+ 			  format ? g_strdup (format) : NULL, g_free);
   
   return contents;
 }
@@ -2786,8 +2866,7 @@
   
   g_assert (contents); /* This should never be called unless we own the clipboard */
 
-  if (selection_data->target ==
-      gdk_atom_intern ("GTK_TEXT_BUFFER_CONTENTS", FALSE))
+  if (info == TARGET_TEXT_BUFFER_CONTENTS)
     {
       /* Provide the address of the clipboard buffer; this will only
        * be used within-process. OK to supply a NULL value for contents.
@@ -2798,6 +2877,35 @@
                               (void*)&contents,
                               sizeof (contents));
     }
+  else if (info == TARGET_TEXT_VIEW_MARKUP)
+    {
+      gchar *str;
+      gint *len;
+      GtkTextIter start, end;
+      
+      gtk_text_buffer_get_bounds (contents, &start, &end);
+      
+      str = gtk_text_buffer_serialize_rich_text (contents, &start, &end, &len);
+      
+      gtk_selection_data_set (selection_data,
+			      gdk_atom_intern ("application/x-gtk-text-view-markup", FALSE),
+			      8, /* bytes */
+			      str, len);
+      g_free (str);
+    }
+  else if (info == TARGET_TEXT_VIEW_RICH_TEXT_FORMAT)
+    {
+      gint len;
+      gchar *format;
+
+      format = g_object_get_data (G_OBJECT (contents), "gtk-text-buffer-clipboard-format");
+      len = format ? strlen (format) : -1;
+
+      gtk_selection_data_set (selection_data,
+                             gdk_atom_intern ("application/x-gtk-text-view-rich-text-format", FALSE),
+                             8, /* bytes */
+                             format, len);
+    }
   else
     {
       gchar *str;
@@ -2992,6 +3100,56 @@
 #endif
 
 static void
+clipboard_text_view_markup_received (GtkClipboard     *clipboard,
+                                    GtkSelectionData *selection_data,
+                                    gpointer          data)
+{
+  ClipboardRequest *request_data = data;
+  GtkTextIter insert_point;
+  gboolean retval = TRUE;
+  GError *error = NULL;
+  GtkTextBufferPrivate *priv;
+
+  priv = GTK_TEXT_BUFFER_GET_PRIVATE (request_data->buffer);
+
+  /* The length is negative if the request failed. */
+  if (selection_data->length > 0 && selection_data->target ==
+      gdk_atom_intern ("application/x-gtk-text-view-markup", FALSE))
+    {
+      pre_paste_prep (request_data, &insert_point);
+
+      if (request_data->interactive)
+       gtk_text_buffer_begin_user_action (request_data->buffer);
+
+      if (!request_data->interactive ||
+         gtk_text_iter_can_insert (&insert_point, request_data->default_editable))
+       retval = gtk_text_buffer_deserialize_rich_text (request_data->buffer,
+                                                       &insert_point,
+                                                       selection_data->data, selection_data->length,
+                                                       priv->rich_text_format == NULL, &error);
+
+      if (!retval)
+       {
+         g_warning ("error pasting: %s\n", error->message);
+	 g_clear_error (&error);
+       }
+
+      if (request_data->interactive)
+       gtk_text_buffer_end_user_action (request_data->buffer);
+
+      if (retval) {
+       post_paste_cleanup (request_data);
+       return;
+      }
+    }
+
+  /* Request the text selection instead */
+  gtk_clipboard_request_text (clipboard,
+                             clipboard_text_received,
+                             data);
+}
+
+static void
 paste_from_buffer (ClipboardRequest    *request_data,
                    GtkTextBuffer       *src_buffer,
                    const GtkTextIter   *start,
@@ -3029,6 +3187,38 @@
   g_free (request_data);
 }
 
+static gboolean
+formats_match (GtkClipboard *clipboard, const gchar *format)
+{
+  GtkSelectionData *data;
+  gchar *tmp;
+  gboolean retval;
+
+  if (!format)
+    return TRUE;
+
+  data = gtk_clipboard_wait_for_contents (clipboard,
+					  gdk_atom_intern ("application/x-gtk-text-view-rich-text-format", FALSE));
+
+  if (!data)
+    return FALSE;
+
+  if (data->length <= 0)
+    retval = FALSE;
+  else
+    {
+      tmp = g_strndup (data->data, data->length);
+
+      retval = (strcmp (tmp, format) == 0);
+
+      g_free (tmp);
+    }
+
+  gtk_selection_data_free (data);
+
+  return retval;
+}
+      
 static void
 clipboard_clipboard_buffer_received (GtkClipboard     *clipboard,
                                      GtkSelectionData *selection_data,
@@ -3036,6 +3226,7 @@
 {
   ClipboardRequest *request_data = data;
   GtkTextBuffer *src_buffer;
+  GtkTextBufferPrivate *priv;
   
   src_buffer = selection_data_get_buffer (selection_data, request_data); 
 
@@ -3059,10 +3250,19 @@
     }
   else
     {
-      /* Request the text selection instead */
-      gtk_clipboard_request_text (clipboard,
-                                  clipboard_text_received,
-                                  data);
+      priv = GTK_TEXT_BUFFER_GET_PRIVATE (request_data->buffer);
+
+      if (priv->can_paste_rich_text &&
+         formats_match (clipboard, priv->rich_text_format))
+       /* Request markup */
+       gtk_clipboard_request_contents (clipboard,
+                                       gdk_atom_intern ("application/x-gtk-text-view-markup", FALSE),
+                                       clipboard_text_view_markup_received, data);
+      else
+       /* Request the text selection instead */
+       gtk_clipboard_request_text (clipboard,
+                                   clipboard_text_received,
+                                   data);
     }
 }
 
@@ -3071,6 +3271,8 @@
   { "TEXT",   0, TARGET_TEXT },
   { "COMPOUND_TEXT", 0, TARGET_COMPOUND_TEXT },
   { "UTF8_STRING", 0, TARGET_UTF8_STRING },
+  { "application/x-gtk-text-view-markup", 0, TARGET_TEXT_VIEW_MARKUP },
+  { "application/x-gtk-text-view-rich-text-format", 0, TARGET_TEXT_VIEW_RICH_TEXT_FORMAT },
   { "GTK_TEXT_BUFFER_CONTENTS", 0, TARGET_TEXT_BUFFER_CONTENTS }
 };
 
@@ -3591,6 +3793,68 @@
     }
 }
 
+void
+gtk_text_buffer_set_can_paste_rich_text (GtkTextBuffer *buffer,
+                                        gboolean       can_paste_rich_text)
+{
+  GtkTextBufferPrivate *priv;
+
+  g_return_if_fail (GTK_IS_TEXT_BUFFER (buffer));
+
+  priv = GTK_TEXT_BUFFER_GET_PRIVATE (buffer);
+
+  can_paste_rich_text = (can_paste_rich_text != FALSE);
+
+  if (priv->can_paste_rich_text != can_paste_rich_text)
+    {
+      priv->can_paste_rich_text = can_paste_rich_text;
+
+      g_object_notify (G_OBJECT (buffer), "can_paste_rich_text");
+    }
+}
+
+gboolean
+gtk_text_buffer_get_can_paste_rich_text (GtkTextBuffer *buffer)
+{
+  GtkTextBufferPrivate *priv;
+
+  g_return_val_if_fail (GTK_IS_TEXT_BUFFER (buffer), FALSE);
+
+  priv = GTK_TEXT_BUFFER_GET_PRIVATE (buffer);
+
+  return priv->can_paste_rich_text;
+}
+
+void
+gtk_text_buffer_set_rich_text_format (GtkTextBuffer *buffer,
+                                     const gchar   *format)
+{
+  gchar *new_format;
+  GtkTextBufferPrivate *priv;
+
+  g_return_if_fail (GTK_IS_TEXT_BUFFER (buffer));
+
+  priv = GTK_TEXT_BUFFER_GET_PRIVATE (buffer);
+
+  new_format = g_strdup (format);
+  g_free (priv->rich_text_format);
+
+  priv->rich_text_format = new_format;
+  g_object_notify (G_OBJECT (buffer), "rich_text_format");
+}
+
+G_CONST_RETURN gchar *
+gtk_text_buffer_get_rich_text_format (GtkTextBuffer *buffer)
+{
+  GtkTextBufferPrivate *priv;
+
+  g_return_val_if_fail (GTK_IS_TEXT_BUFFER (buffer), NULL);
+
+  priv = GTK_TEXT_BUFFER_GET_PRIVATE (buffer);
+
+  return priv->rich_text_format;
+}
+
 /*
  * Logical attribute cache
  */
--- gtk+/gtk/gtkcellview.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkcellview.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -67,6 +67,7 @@
 
 void              gtk_cell_view_set_background_color    (GtkCellView     *cell_view,
                                                          const GdkColor  *color);
+void              gtk_cell_view_set_cell_data           (GtkCellView     *cellview);
 GList            *gtk_cell_view_get_cell_renderers      (GtkCellView     *cell_view);
 
 G_END_DECLS
--- gtk+/gtk/gtkiconfactory.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkiconfactory.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -813,7 +813,7 @@
 {
   if (icon_sizes == NULL)
     {
-#define NUM_BUILTIN_SIZES 7
+#define NUM_BUILTIN_SIZES 11
       gint i;
 
       icon_aliases = g_hash_table_new (g_str_hash, g_str_equal);
@@ -863,7 +863,27 @@
       icon_sizes[GTK_ICON_SIZE_DIALOG].width = 48;
       icon_sizes[GTK_ICON_SIZE_DIALOG].height = 48;
 
-      g_assert ((GTK_ICON_SIZE_DIALOG + 1) == NUM_BUILTIN_SIZES);
+      icon_sizes[HILDON_ICON_SIZE_26].size = HILDON_ICON_SIZE_26;
+      icon_sizes[HILDON_ICON_SIZE_26].name = "hildon-26";
+      icon_sizes[HILDON_ICON_SIZE_26].width = 26;
+      icon_sizes[HILDON_ICON_SIZE_26].height = 26;
+
+      icon_sizes[HILDON_ICON_SIZE_40].size = HILDON_ICON_SIZE_40;
+      icon_sizes[HILDON_ICON_SIZE_40].name = "hildon-40";
+      icon_sizes[HILDON_ICON_SIZE_40].width = 40;
+      icon_sizes[HILDON_ICON_SIZE_40].height = 40;
+
+      icon_sizes[HILDON_ICON_SIZE_50].size = HILDON_ICON_SIZE_50;
+      icon_sizes[HILDON_ICON_SIZE_50].name = "hildon-50";
+      icon_sizes[HILDON_ICON_SIZE_50].width = 50;
+      icon_sizes[HILDON_ICON_SIZE_50].height = 50;
+
+      icon_sizes[HILDON_ICON_SIZE_64].size = HILDON_ICON_SIZE_64;
+      icon_sizes[HILDON_ICON_SIZE_64].name = "hildon-64";
+      icon_sizes[HILDON_ICON_SIZE_64].width = 54;
+      icon_sizes[HILDON_ICON_SIZE_64].height = 64;
+
+      g_assert ((HILDON_ICON_SIZE_64 + 1) == NUM_BUILTIN_SIZES);
 
       /* Alias everything to itself. */
       i = 1; /* skip invalid size */
@@ -1658,7 +1678,7 @@
   gint width, height, pixel_size;
   gint *sizes, *s, dist;
   GError *error = NULL;
-  
+
   if (widget && gtk_widget_has_screen (widget))
     screen = gtk_widget_get_screen (widget);
   else if (style && style->colormap)
@@ -1734,8 +1754,10 @@
   tmp_source.type = GTK_ICON_SOURCE_PIXBUF;
   tmp_source.source.pixbuf = tmp_pixbuf;
 
+  /* Hildon: no scaling allowed for Hildon icons */
   pixbuf = gtk_style_render_icon (style, &tmp_source,
-				  direction, state, -1,
+				  direction, state,
+				  (size < HILDON_ICON_SIZE_26) ? -1 : size,
 				  widget, detail);
 
   if (!pixbuf)
@@ -1818,7 +1840,6 @@
 {
   /* This icon can be used for any direction/state/size */
   static GtkIconSource fallback_source = GTK_ICON_SOURCE_INIT (TRUE, TRUE, TRUE);
-
   if (fallback_source.type == GTK_ICON_SOURCE_EMPTY)
     {
       GdkPixbuf *pixbuf = gdk_pixbuf_new_from_inline (-1, stock_missing_image_24, FALSE, NULL);
--- gtk+/gtk/Makefile.am	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/Makefile.am	(.../2.6.4-1.osso62)	(revision 904)
@@ -246,6 +246,7 @@
 	gtktearoffmenuitem.h    \
 	gtktext.h		\
 	gtktextbuffer.h		\
+	gtktextbufferserialize.h\
 	gtktextchild.h		\
 	gtktextdisplay.h	\
 	gtktextiter.h		\
@@ -387,6 +388,8 @@
 	gtkframe.c		\
 	gtkgamma.c		\
 	gtkgc.c			\
+	gtkhashtable.c		\
+	gtkhashtable.h		\
 	gtkhandlebox.c		\
 	gtkhbbox.c		\
 	gtkhbox.c		\
@@ -470,6 +473,7 @@
 	gtktext.c		\
 	gtktextbtree.c		\
 	gtktextbuffer.c		\
+	gtktextbufferserialize.c\
 	gtktextchild.c		\
 	gtktextdisplay.c	\
 	gtktextiter.c		\
@@ -707,7 +711,7 @@
 #
 # Installed tools
 #
-bin_PROGRAMS = gtk-query-immodules-2.0 gtk-update-icon-cache
+bin_PROGRAMS = gtk-query-immodules-2.0 gtk-update-icon-cache maemo-gtk-im-switch
 
 gtk_query_immodules_2_0_DEPENDENCIES = $(DEPS)
 gtk_query_immodules_2_0_LDADD = $(LDADDS)
@@ -720,6 +724,11 @@
 
 gtk_update_icon_cache_SOURCES = updateiconcache.c
 
+
+maemo_gtk_im_switch_LDADD = $(LDADDS)
+
+maemo_gtk_im_switch_SOURCES = maemo-gtk-im-switch.c
+
 .PHONY: files test test-debug
 
 files:
--- gtk+/gtk/gtktextbuffer.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtktextbuffer.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -365,6 +365,14 @@
 void            gtk_text_buffer_begin_user_action       (GtkTextBuffer *buffer);
 void            gtk_text_buffer_end_user_action         (GtkTextBuffer *buffer);
 
+void            gtk_text_buffer_set_can_paste_rich_text (GtkTextBuffer *buffer,
+							 gboolean       can_paste_rich_text);
+gboolean        gtk_text_buffer_get_can_paste_rich_text (GtkTextBuffer *buffer);
+
+void                  gtk_text_buffer_set_rich_text_format (GtkTextBuffer *buffer,
+							    const gchar   *format);
+G_CONST_RETURN gchar *gtk_text_buffer_get_rich_text_format (GtkTextBuffer *buffer);
+
 /* INTERNAL private stuff */
 void            _gtk_text_buffer_spew                  (GtkTextBuffer      *buffer);
 
--- gtk+/gtk/gtkscrolledwindow.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkscrolledwindow.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -289,6 +289,13 @@
 							     DEFAULT_SCROLLBAR_SPACING,
 							     G_PARAM_READABLE));
 
+  gtk_widget_class_install_style_property (widget_class,
+					   g_param_spec_boolean ("scrollbar_dislocation",
+    								 P_("Scrollbar dislocation"),
+    								 P_("Flag for having scrollbar at the outer border or container padding instead of at the inner border"),
+    								 FALSE,
+    								 G_PARAM_READABLE));
+
   signals[SCROLL_CHILD] =
     g_signal_new ("scroll_child",
                   G_TYPE_FROM_CLASS (object_class),
@@ -1062,6 +1069,79 @@
     }
 }
 
+static gdouble
+gtk_scrolled_window_get_focus_movement (GtkScrolledWindow *scrolled_window)
+{
+  GtkWidget *focus_child;
+  GtkRange *range;
+  GtkAdjustment *adj;
+  gdouble value, new_value;
+  gint x, y;
+  gint border_width;
+
+  focus_child = GTK_CONTAINER (scrolled_window)->focus_child;
+  if (focus_child == NULL)
+     return 0;
+
+  while (GTK_IS_CONTAINER (focus_child) &&
+	 GTK_CONTAINER (focus_child)->focus_child)
+    {
+      focus_child = GTK_CONTAINER (focus_child)->focus_child;
+    }
+
+  range = GTK_RANGE (scrolled_window->vscrollbar);
+  adj = range->adjustment;
+  value = gtk_adjustment_get_value (adj);
+
+  gtk_widget_translate_coordinates (focus_child->parent,
+				    GTK_WIDGET (scrolled_window),
+				    focus_child->allocation.x,
+				    focus_child->allocation.y, &x, &y);
+
+  border_width = GTK_CONTAINER (scrolled_window)->border_width;
+
+  x -= border_width;
+  y -= border_width;
+
+  if (y < 0)
+    {
+      /* scroll up */
+      new_value = value + y;
+      if (new_value < adj->lower)
+	new_value = adj->lower;
+    }
+  else if (y + focus_child->allocation.height > adj->page_size)
+    {
+      /* scroll down */
+      new_value = value + y + focus_child->allocation.height - adj->page_size;
+      if (new_value > adj->upper - adj->page_size)
+        new_value = adj->upper - adj->page_size;
+    }
+  else
+    {
+      new_value = value;
+    }
+
+  return new_value - value;
+}
+
+static void
+gtk_scrolled_window_scroll_to_focus (GtkScrolledWindow *scrolled_window)
+{
+  GtkAdjustment *adj;
+  gdouble diff;
+
+  diff = gtk_scrolled_window_get_focus_movement (scrolled_window);
+  if (diff != 0)
+    {
+      adj = GTK_RANGE (scrolled_window->vscrollbar)->adjustment;
+
+      gtk_adjustment_set_value (adj, gtk_adjustment_get_value (adj) + diff);
+      gtk_scrolled_window_set_vadjustment (scrolled_window,
+					   GTK_ADJUSTMENT (adj));
+    }
+}
+
 static void
 gtk_scrolled_window_size_allocate (GtkWidget     *widget,
 				   GtkAllocation *allocation)
@@ -1071,17 +1151,32 @@
   GtkAllocation relative_allocation;
   GtkAllocation child_allocation;
   gint scrollbar_spacing;
-  
+  gboolean is_focus_visible, dislocate;
+  gint dislocation;
+
   g_return_if_fail (GTK_IS_SCROLLED_WINDOW (widget));
   g_return_if_fail (allocation != NULL);
 
   scrolled_window = GTK_SCROLLED_WINDOW (widget);
   bin = GTK_BIN (scrolled_window);
 
+  is_focus_visible =
+    gtk_scrolled_window_get_focus_movement (scrolled_window) == 0;
+
   scrollbar_spacing = _gtk_scrolled_window_get_scrollbar_spacing (scrolled_window);
 
   widget->allocation = *allocation;
 
+  /* See how much scrollbar needs be "dislocated" (to get it to the other
+   * edge of the border). Does not apply to all occasions. */
+  gtk_widget_style_get (GTK_WIDGET (scrolled_window),
+			"scrollbar_dislocation", &dislocate,
+			NULL);
+  if (dislocate)
+    dislocation = GTK_CONTAINER (scrolled_window)->border_width;
+  else
+    dislocation = 0;
+
   if (scrolled_window->hscrollbar_policy == GTK_POLICY_ALWAYS)
     scrolled_window->hscrollbar_visible = TRUE;
   else if (scrolled_window->hscrollbar_policy == GTK_POLICY_NEVER)
@@ -1150,10 +1245,12 @@
 	child_allocation.y = (relative_allocation.y +
 			      relative_allocation.height +
 			      scrollbar_spacing +
+			      dislocation +
 			      (scrolled_window->shadow_type == GTK_SHADOW_NONE ?
 			       0 : widget->style->ythickness));
       else
-	child_allocation.y = GTK_CONTAINER (scrolled_window)->border_width;
+	child_allocation.y = GTK_CONTAINER (scrolled_window)->border_width -
+	  dislocation;
 
       child_allocation.width = relative_allocation.width;
       child_allocation.height = hscrollbar_requisition.height;
@@ -1189,10 +1286,12 @@
 	child_allocation.x = (relative_allocation.x +
 			      relative_allocation.width +
 			      scrollbar_spacing +
+			      dislocation +
 			      (scrolled_window->shadow_type == GTK_SHADOW_NONE ?
 			       0 : widget->style->xthickness));
       else
-	child_allocation.x = GTK_CONTAINER (scrolled_window)->border_width;
+	child_allocation.x = GTK_CONTAINER (scrolled_window)->border_width -
+	  dislocation;
 
       child_allocation.y = relative_allocation.y;
       child_allocation.width = vscrollbar_requisition.width;
@@ -1207,6 +1306,9 @@
 	}
 
       gtk_widget_size_allocate (scrolled_window->vscrollbar, &child_allocation);
+
+      if (is_focus_visible)
+	gtk_scrolled_window_scroll_to_focus (scrolled_window);
     }
   else if (GTK_WIDGET_VISIBLE (scrolled_window->vscrollbar))
     gtk_widget_hide (scrolled_window->vscrollbar);
--- gtk+/gtk/gtkdialog.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkdialog.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -24,6 +24,9 @@
  * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
  */
 
+/* Modified by Nokia Corporation - 2005.
+ * 
+ */
 #include <config.h>
 #include "gtkalias.h"
 #include "gtkbutton.h"
@@ -37,11 +40,14 @@
 #include "gtkmain.h"
 #include "gtkintl.h"
 #include "gtkbindings.h"
+#include "gtkalignment.h"
 
 #define GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GTK_TYPE_DIALOG, GtkDialogPrivate))
 
 typedef struct {
   guint ignore_separator : 1;
+  GtkWidget *first;
+  GtkWidget *last;
 } GtkDialogPrivate;
 
 typedef struct _ResponseData ResponseData;
@@ -77,8 +83,14 @@
 static void gtk_dialog_close             (GtkDialog        *dialog);
 
 static ResponseData* get_response_data   (GtkWidget        *widget,
-					  gboolean          create);
+                                          gboolean          create);
 
+static gboolean gtk_dialog_handle_focus (GtkWidget *widget,
+                                         GtkDirectionType dir,
+                                         gpointer user_data);
+
+static gboolean gtk_dialog_move_to_next_active_button (GList *iter,
+                                                       gboolean forward);
 enum {
   PROP_0,
   PROP_HAS_SEPARATOR
@@ -178,6 +190,14 @@
                                                              2,
                                                              G_PARAM_READABLE));
   gtk_widget_class_install_style_property (widget_class,
+					   g_param_spec_int ("content_area_spacing",
+                                                             P_("Content area spacing"),
+                                                             P_("Spacing between elements of the main dialog area"),
+                                                             0,
+                                                             G_MAXINT,
+                                                             0,
+                                                             G_PARAM_READABLE));
+  gtk_widget_class_install_style_property (widget_class,
                                            g_param_spec_int ("button_spacing",
                                                              P_("Button spacing"),
                                                              P_("Spacing between buttons"),
@@ -195,6 +215,23 @@
                                                              5,
                                                              G_PARAM_READABLE));
 
+  gtk_widget_class_install_style_property (widget_class,
+                                           g_param_spec_int ("extended_left_border",
+                                                             _("Content area extra left border"),
+                                                             _("Width of extra left border around the main dialog area"),
+                                                             0,
+                                                             G_MAXINT,
+                                                             0,
+                                                             G_PARAM_READABLE));
+  gtk_widget_class_install_style_property (widget_class,
+                                           g_param_spec_int ("extended_right_border",
+                                                             _("Content area extra right border"),
+                                                             _("Width of extra right border around the main dialog area"),
+                                                             0,
+                                                             G_MAXINT,
+                                                             0,
+                                                             G_PARAM_READABLE));
+
   binding_set = gtk_binding_set_by_class (class);
   
   gtk_binding_entry_add_signal (binding_set, GDK_Escape, 0,
@@ -205,33 +242,72 @@
 update_spacings (GtkDialog *dialog)
 {
   GtkWidget *widget;
+  GtkWidget *hbox;
+  GtkWidget *left_padding;
+  GtkWidget *right_padding;
   gint content_area_border;
+  gint content_area_spacing;
   gint button_spacing;
   gint action_area_border;
+
+	gint extended_left_border;
+  gint extended_right_border;
   
   widget = GTK_WIDGET (dialog);
 
   gtk_widget_style_get (widget,
                         "content_area_border",
                         &content_area_border,
+                        "content_area_spacing",
+                        &content_area_spacing,
                         "button_spacing",
                         &button_spacing,
                         "action_area_border",
                         &action_area_border,
+	"extended_left_border",
+	&extended_left_border,
+	"extended_right_border",
+	&extended_right_border,
                         NULL);
 
+  gtk_box_set_spacing (GTK_BOX (dialog->vbox),
+                       content_area_spacing);
   gtk_container_set_border_width (GTK_CONTAINER (dialog->vbox),
                                   content_area_border);
   gtk_box_set_spacing (GTK_BOX (dialog->action_area),
                        button_spacing);
   gtk_container_set_border_width (GTK_CONTAINER (dialog->action_area),
                                   action_area_border);
+
+  if ((extended_left_border == 0) && (extended_right_border == 0))
+    /* no extended borders, so we are done */
+    return;
+
+  /* extended borders are in use, so reconstruct dialog */
+  hbox = gtk_hbox_new(FALSE, 0);
+  left_padding = gtk_alignment_new(0.0, 0.0, 0.0, 0.0);
+  right_padding = gtk_alignment_new(0.0, 0.0, 0.0, 0.0);
+  gtk_widget_set_size_request(left_padding, extended_left_border, 0);
+  gtk_widget_set_size_request(right_padding, extended_right_border, 0);
+
+  gtk_widget_ref(dialog->vbox);
+  gtk_container_remove(GTK_CONTAINER(dialog), dialog->vbox);
+  gtk_container_add(GTK_CONTAINER(hbox), left_padding);
+  gtk_container_add(GTK_CONTAINER(hbox), dialog->vbox);
+  gtk_container_add(GTK_CONTAINER(hbox), right_padding);
+  gtk_container_add(GTK_CONTAINER(dialog), hbox);
+  gtk_widget_unref(dialog->vbox);
+
+  gtk_widget_show(left_padding);
+  gtk_widget_show(right_padding);
+  gtk_widget_show(hbox);
 }
 
 static void
 gtk_dialog_init (GtkDialog *dialog)
 {
   GtkDialogPrivate *priv;
+  GtkWidget *alignment;
 
   priv = GET_PRIVATE (dialog);
   priv->ignore_separator = FALSE;
@@ -250,14 +326,23 @@
   gtk_container_add (GTK_CONTAINER (dialog), dialog->vbox);
   gtk_widget_show (dialog->vbox);
 
+  /* Hildon : Here we add an alignment widget to gtk because
+   * we want that the dialog buttons are all centered. */
+  alignment = gtk_alignment_new (0.5, 0.5, 0, 0);
+  gtk_box_pack_end (GTK_BOX (dialog->vbox), alignment, FALSE, TRUE, 0);
+
   dialog->action_area = gtk_hbutton_box_new ();
 
   gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog->action_area),
                              GTK_BUTTONBOX_END);  
 
-  gtk_box_pack_end (GTK_BOX (dialog->vbox), dialog->action_area,
-                    FALSE, TRUE, 0);
+  /* we need add-signal to allocate correct area for childs */ 
+  gtk_container_add (GTK_CONTAINER (alignment), dialog->action_area);
+  /* gtk_box_pack_end (GTK_BOX (dialog->vbox), dialog->action_area,
+     FALSE, TRUE, 0); */
+  
   gtk_widget_show (dialog->action_area);
+  gtk_widget_show (alignment);
 
   dialog->separator = gtk_hseparator_new ();
   gtk_box_pack_end (GTK_BOX (dialog->vbox), dialog->separator, FALSE, TRUE, 0);
@@ -364,10 +449,10 @@
 	{
 	  GtkWidget *child = tmp_list->data;
 
-	  if (window->focus_widget == NULL ||
-	      (child == window->focus_widget && 
+	  if ((window->focus_widget == NULL ||
+	       child == window->focus_widget) && 
 	       child != window->default_widget && 
-	       window->default_widget))
+	       window->default_widget)
 	    {
 	      gtk_widget_grab_focus (window->default_widget);
 	      break;
@@ -616,9 +701,10 @@
   else
     g_warning ("Only 'activatable' widgets can be packed into the action area of a GtkDialog");
 
-  gtk_box_pack_end (GTK_BOX (dialog->action_area),
-                    child,
-                    FALSE, TRUE, 0);
+  gtk_container_add(GTK_CONTAINER(dialog->action_area), child);
+
+  g_signal_connect (child, "focus", 
+                    (GCallback)gtk_dialog_handle_focus, (gpointer)dialog);
   
   if (response_id == GTK_RESPONSE_HELP)
     gtk_button_box_set_child_secondary (GTK_BUTTON_BOX (dialog->action_area), child, TRUE);
@@ -637,7 +723,7 @@
  * you don't need it.
  *
  * Return value: the button widget that was added
- **/
+ **/ 
 GtkWidget*
 gtk_dialog_add_button (GtkDialog   *dialog,
                        const gchar *button_text,
@@ -653,7 +739,7 @@
   GTK_WIDGET_SET_FLAGS (button, GTK_CAN_DEFAULT);
   
   gtk_widget_show (button);
-  
+
   gtk_dialog_add_action_widget (dialog,
                                 button,
                                 response_id);
@@ -1001,7 +1087,7 @@
 
   if (!GTK_WIDGET_VISIBLE (dialog))
     gtk_widget_show (GTK_WIDGET (dialog));
-  
+
   response_handler =
     g_signal_connect (dialog,
                       "response",
@@ -1227,13 +1313,116 @@
 
   screen = gtk_widget_get_screen (GTK_WIDGET (dialog));
   if (!gtk_alternative_dialog_button_order (screen))
-      return;
+    return;
 
   for (position = 0; position < n_params; position++)
   {
-      /* reorder child with response_id to position */
-      child = dialog_find_button (dialog, new_order[position]);
-      gtk_box_reorder_child (GTK_BOX (dialog->action_area), child, position);
+    /* reorder child with response_id to position */
+    child = dialog_find_button (dialog, new_order[position]);
+    gtk_box_reorder_child (GTK_BOX (dialog->action_area), child, position);
+  }
+}
+
+static gboolean
+gtk_dialog_handle_focus (GtkWidget *widget,
+                          GtkDirectionType dir,
+                          gpointer user_data)
+{
+  GtkDialog *dialog = NULL;
+  GList *list = NULL;
+  GList *iter = NULL;
+  gint i = 0;
+  gint list_length = 0;
+  gboolean ret_val = FALSE;
+  GtkDialogPrivate *priv;
+
+  dialog = GTK_DIALOG(user_data);
+  list = gtk_container_get_children (GTK_CONTAINER(
+                                      GTK_DIALOG(user_data)->action_area));
+  iter = list;
+  priv = GET_PRIVATE (dialog);
+
+  if (GTK_WIDGET_HAS_FOCUS (widget))
+  {
+    list_length =  g_list_length(list);
+    while (iter != NULL)
+    {
+      ++i;
+      if (iter->data == widget)
+      {
+        switch (dir) {
+          case GTK_DIR_UP:
+          case GTK_DIR_LEFT:
+
+                /* If not in the first button, but in the first active
+                 * button, the default should do, else handle movement
+                 * by yourself
+                 */
+             ret_val = gtk_dialog_move_to_next_active_button (
+                        g_list_previous (iter),
+                        FALSE);
+            
+             if (!ret_val)
+                {
+                  g_signal_emit_by_name (dialog, "move-focus",
+                            GTK_DIR_TAB_BACKWARD);
+                  ret_val = TRUE;
+                }
+             break;
+
+          /* If in the last item:jump to top, else select previous button */
+          case GTK_DIR_DOWN:
+          case GTK_DIR_RIGHT:
+            ret_val = gtk_dialog_move_to_next_active_button (
+                                            g_list_next (iter),
+                                            TRUE);
+            
+            if (!ret_val)
+              {
+                g_signal_emit_by_name (dialog, "move-focus", 
+                        GTK_DIR_TAB_FORWARD);
+                ret_val = TRUE;
+              }
+            break;
+
+          case GTK_DIR_TAB_BACKWARD:
+          case GTK_DIR_TAB_FORWARD:
+          default:
+            break;
+        }
+        break;
+      }
+      iter = g_list_next(iter);
     }
+  }
+
+  g_list_free (list);
+
+  return ret_val;
+}
+
+static gboolean
+gtk_dialog_move_to_next_active_button (GList *iter, gboolean forward)
+{
+    gboolean active;
+    gboolean visible;
+
+    while (iter)
+    {
+        g_object_get (G_OBJECT (iter->data), "sensitive", &active, NULL);
+        g_object_get (G_OBJECT (iter->data), "visible", &visible, NULL);
+        if (active && visible)
+        {
+            gtk_widget_grab_focus (GTK_WIDGET (iter->data));
+            return TRUE;
+        }
+
+        if (forward)
+            iter = g_list_next (iter);
+        else
+            iter = g_list_previous (iter);
+    }
+
+    return FALSE;
 }
 
--- gtk+/gtk/gtkspinbutton.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkspinbutton.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -1041,15 +1041,21 @@
 		GtkArrowType   click_child,
 		gdouble        step)
 {
+  GtkSettings *settings;
+  guint timeout;
+
   g_return_if_fail (click_child == GTK_ARROW_UP || click_child == GTK_ARROW_DOWN);
-  
+
+  settings = gtk_settings_get_default ();
+  g_object_get (settings, "gtk-initial-timeout", &timeout, NULL); 
+
   spin->click_child = click_child;
   
   if (!spin->timer)
     {
       spin->timer_step = step;
       spin->need_timer = TRUE;
-      spin->timer = g_timeout_add (SPIN_BUTTON_INITIAL_TIMER_DELAY, 
+      spin->timer = g_timeout_add (/*SPIN_BUTTON_INITIAL_TIMER_DELAY*/timeout, 
 				   (GSourceFunc) gtk_spin_button_timer, 
 				   (gpointer) spin);
     }
@@ -1188,9 +1194,14 @@
 gtk_spin_button_timer (GtkSpinButton *spin_button)
 {
   gboolean retval = FALSE;
+  GtkSettings *settings;
+  guint timeout;
   
   GDK_THREADS_ENTER ();
 
+  settings = gtk_settings_get_default ();
+  g_object_get (settings, "gtk-update-timeout", &timeout, NULL);
+
   if (spin_button->timer)
     {
       if (spin_button->click_child == GTK_ARROW_UP)
@@ -1201,7 +1212,7 @@
       if (spin_button->need_timer)
 	{
 	  spin_button->need_timer = FALSE;
-	  spin_button->timer = g_timeout_add (SPIN_BUTTON_TIMER_DELAY, 
+	  spin_button->timer = g_timeout_add (/*SPIN_BUTTON_TIMER_DELAY*/timeout, 
 					      (GSourceFunc) gtk_spin_button_timer, 
 					      (gpointer) spin_button);
 	}
--- gtk+/gtk/gtkhseparator.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkhseparator.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -91,13 +91,29 @@
 gtk_hseparator_expose (GtkWidget      *widget,
 		       GdkEventExpose *event)
 {
-  if (GTK_WIDGET_DRAWABLE (widget))
-    gtk_paint_hline (widget->style, widget->window, GTK_WIDGET_STATE (widget),
-		     &event->area, widget, "hseparator",
-		     widget->allocation.x,
-		     widget->allocation.x + widget->allocation.width - 1,
-		     widget->allocation.y + (widget->allocation.height -
-					     widget->style->ythickness) / 2);
+   gboolean hildonlike_drawing = FALSE;
+   gtk_widget_style_get ( widget, "hildonlike-drawing", &hildonlike_drawing, NULL );
 
-  return FALSE;
+   if (GTK_WIDGET_DRAWABLE (widget))
+   {
+	   if(hildonlike_drawing)
+		   gtk_paint_box   (widget->style, widget->window, GTK_STATE_NORMAL,
+				   GTK_SHADOW_NONE, &event->area, widget, "hseparator",
+				   widget->allocation.x,
+				   widget->allocation.y + (widget->allocation.height -
+					   widget->style->ythickness) / 2,
+				   widget->allocation.width - 1,
+				   widget->style->ythickness);
+	   else
+		   gtk_paint_hline (widget->style, widget->window, GTK_STATE_NORMAL,
+				   &event->area, widget, "hseparator",
+				   widget->allocation.x,
+				   widget->allocation.x + widget->allocation.width - 1,
+				   widget->allocation.y + (widget->allocation.height -
+					   widget->style->ythickness) / 2);
+   }
+
+
+
+   return FALSE;
 }
--- gtk+/gtk/gtklabel.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtklabel.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -23,6 +23,11 @@
  * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
  */
 
+
+/* Modified by Nokia Corporation - 2005.
+ * 
+ */
+
 #include <config.h>
 #include <math.h>
 #include <string.h>
@@ -52,6 +57,7 @@
   guint single_line_mode : 1;
   guint have_transform : 1;
   gdouble angle;
+  gboolean request_full_width;
 }
 GtkLabelPrivate;
 
@@ -75,6 +81,9 @@
   LAST_SIGNAL
 };
 
+/* Hildon mod.
+   A property PROP_TRANSLATABLE has been added here. If new Gtk+
+   versions add items here, the compability will break. */
 enum {
   PROP_0,
   PROP_LABEL,
@@ -89,6 +98,7 @@
   PROP_MNEMONIC_WIDGET,
   PROP_CURSOR_POSITION,
   PROP_SELECTION_BOUND,
+  PROP_TRANSLATABLE,
   PROP_ELLIPSIZE,
   PROP_WIDTH_CHARS,
   PROP_SINGLE_LINE_MODE,
@@ -96,6 +106,12 @@
   PROP_MAX_WIDTH_CHARS
 };
 
+/* Hildon mod. A few keys. These are used to store data for label
+ * without changing the private structures. */
+#define LABEL_KEY_TRANSLATABLE "label_translatable"
+#define LABEL_KEY_TRANSLATABLETEXT "label_translatabletext"
+#define LABEL_KEY_ORIGINAL_LAYOUT "label_original_layout"
+
 static guint signals[LAST_SIGNAL] = { 0 };
 
 static void gtk_label_class_init        (GtkLabelClass    *klass);
@@ -149,7 +165,7 @@
 static void gtk_label_set_uline_text_internal    (GtkLabel      *label,
 						  const gchar   *str);
 static void gtk_label_set_pattern_internal       (GtkLabel      *label,
-				                  const gchar   *pattern);
+                                                  const gchar   *pattern);
 static void set_markup                           (GtkLabel      *label,
 						  const gchar   *str,
 						  gboolean       with_uline);
@@ -516,6 +532,24 @@
                                                      G_MAXINT,
                                                      -1,
                                                      G_PARAM_READWRITE));
+ /* Hildon mod. Add property for a widget - whether it supports run-time
+  +    locale change. Please note that this functionality is not yet
+  +    completed and may change. */
+  g_object_class_install_property (gobject_class,
+                                   PROP_TRANSLATABLE,
+                                   g_param_spec_boolean ("translatable",
+                                                         _("Is translatable"),
+	                                                 _("Whether label should be translatable."),
+	                                                 FALSE,
+	                                                 G_PARAM_READWRITE));
+
+ /* Hildonlike class property */
+ gtk_widget_class_install_style_property (widget_class,
+	                                  g_param_spec_boolean ("hildonlike",
+		                                  _("hildonlike looks"),
+		                                  _("Changes wrapping etc behaviour, 1/0"),
+		                                  FALSE,
+		                                  G_PARAM_READABLE));
   /*
    * Key bindings
    */
@@ -650,6 +684,10 @@
     case PROP_MAX_WIDTH_CHARS:
       gtk_label_set_max_width_chars (label, g_value_get_int (value));
       break;
+/* Hildon add. */
+    case PROP_TRANSLATABLE:
+      gtk_label_set_translatable (label, g_value_get_boolean (value));
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -730,6 +768,10 @@
     case PROP_MAX_WIDTH_CHARS:
       g_value_set_int (value, gtk_label_get_max_width_chars (label));
       break;
+/* Hildon mod. */
+    case PROP_TRANSLATABLE:
+      g_value_set_boolean (value, gtk_label_get_translatable (label));
+      break;
 
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
@@ -748,6 +790,7 @@
   priv->width_chars = -1;
   priv->angle = 0.0;
   priv->max_width_chars = -1;
+  priv->request_full_width = FALSE;
   label->label = NULL;
 
   label->jtype = GTK_JUSTIFY_LEFT;
@@ -766,6 +809,15 @@
   label->mnemonic_window = NULL;
   
   gtk_label_set_text (label, "");
+   
+/* Hildon Addition. */
+   
+  g_object_set_data (G_OBJECT (label), LABEL_KEY_TRANSLATABLE, FALSE);
+  g_object_set_data (G_OBJECT (label), LABEL_KEY_TRANSLATABLETEXT, NULL);
+  g_object_set_data (G_OBJECT (label), LABEL_KEY_ORIGINAL_LAYOUT, NULL);
+   
+/* /Hildon Addition. */
+   
 }
 
 /**
@@ -822,7 +874,7 @@
 
   if (str && *str)
     gtk_label_set_text_with_mnemonic (label, str);
-  
+
   return GTK_WIDGET (label);
 }
 
@@ -1257,7 +1309,7 @@
   GError *error = NULL;
   PangoAttrList *attrs = NULL;
   gunichar accel_char = 0;
-
+ 
   if (!pango_parse_markup (str,
                            -1,
                            with_uline ? '_' : 0,
@@ -1340,12 +1392,14 @@
   g_return_if_fail (GTK_IS_LABEL (label));
 
   last_keyval = label->mnemonic_keyval;
+
   gtk_label_set_label_internal (label, g_strdup (str ? str : ""));
   gtk_label_set_use_markup_internal (label, TRUE);
   gtk_label_set_use_underline_internal (label, TRUE);
-  
   gtk_label_recalculate (label);
+ 
   gtk_label_setup_mnemonic (label, last_keyval);
+
 }
 
 /**
@@ -1409,7 +1463,7 @@
 
 static void
 gtk_label_set_pattern_internal (GtkLabel    *label,
-				const gchar *pattern)
+                                const gchar *pattern)
 {
   PangoAttrList *attrs;
   g_return_if_fail (GTK_IS_LABEL (label));
@@ -1421,7 +1475,16 @@
 
   if (label->effective_attrs)
     pango_attr_list_unref (label->effective_attrs);
+/* Following will disable undercores from
+   keyboard shortcuts if DISABLE_KEYBOARD_SHORTCUTS
+   is enabled during compile time
+ */
+#ifndef DISABLE_KEYBOARD_SHORTCUTS
   label->effective_attrs = attrs;
+#else
+  pango_attr_list_unref (attrs);
+#endif /* DISABLE_KEYBOARD_SHORTCUTS */
+
 }
 
 void
@@ -1742,8 +1805,13 @@
 {
   PangoLayout *layout;
   GtkStyle *style = GTK_WIDGET (label)->style;
-
+  
+  gboolean hildonlike;
   LabelWrapWidth *wrap_width = g_object_get_data (G_OBJECT (style), "gtk-label-wrap-width");
+
+  /* Hildon: get hildonlike property */
+  gtk_widget_style_get (GTK_WIDGET (label), "hildonlike", &hildonlike, NULL);
+
   if (!wrap_width)
     {
       wrap_width = g_new0 (LabelWrapWidth, 1);
@@ -1763,19 +1831,28 @@
 					   "This long string gives a good enough length for any line to have.");
   pango_layout_get_size (layout, &wrap_width->width, NULL);
   g_object_unref (layout);
-
+  /* A hildon mod for "fixing line wrapping". Remember to remove this
+   when GtkLabel will implement width for height size negotiation.*/
+  if (hildonlike)
+    {
+      wrap_width->width = wrap_width->width  * 1.25;
+    }
   return wrap_width->width;
 }
 
 static void
-gtk_label_ensure_layout (GtkLabel *label)
+gtk_label_ensure_layout_full (GtkLabel *label, gboolean have_allocation)
 {
   GtkWidget *widget;
   PangoRectangle logical_rect;
   gint rwidth, rheight;
   gboolean rtl;
+  gboolean hildonlike;
 
   widget = GTK_WIDGET (label);
+ 
+  /* Hildon: get hildonlike property */
+  gtk_widget_style_get (widget, "hildonlike", &hildonlike, NULL);
 
   rtl = gtk_widget_get_direction(widget) == GTK_TEXT_DIR_RTL;
   rwidth = label->misc.xpad * 2;
@@ -1864,8 +1941,18 @@
 
 	      wrap_width = get_label_wrap_width (label);
 	      width = MIN (width, wrap_width);
-	      width = MIN (width,
+ 
+              if (!hildonlike)
+                {
+	         width = MIN (width,
 			   PANGO_SCALE * (gdk_screen_get_width (screen) + 1) / 2);
+	        }
+              else 
+                {
+                 width = MIN (width,
+                           PANGO_SCALE * (gdk_screen_get_width (screen) + 1));
+               }
+            
 	      
 	      pango_layout_set_width (label->layout, width);
 	      pango_layout_get_extents (label->layout, NULL, &logical_rect);
@@ -1904,6 +1991,14 @@
 			}
 		    }
 		}
+
+              /* If we already know our allocation size, make sure we don't
+               * try to set the width to more than we have
+               */
+              if (width > widget->allocation.width * PANGO_SCALE &&
+                  have_allocation)
+                width = widget->allocation.width * PANGO_SCALE;
+
 	      pango_layout_set_width (label->layout, width);
 	    }
 	}
@@ -1912,6 +2007,12 @@
     }
 }
 
+static void
+gtk_label_ensure_layout (GtkLabel *label)
+{
+  gtk_label_ensure_layout_full (label, TRUE);
+}
+
 /* Gets the bounds of a layout in device coordinates. Note cut-and-paste
  * between here and gdkpango.c */
 static void
@@ -1993,7 +2094,7 @@
   if (label->wrap)
     gtk_label_clear_layout (label);
 
-  gtk_label_ensure_layout (label);
+  gtk_label_ensure_layout_full (label, FALSE);
 
   width = label->misc.xpad * 2;
   height = label->misc.ypad * 2;
@@ -2017,7 +2118,8 @@
        priv->width_chars > 0 || priv->max_width_chars > 0) && 
       aux_info && aux_info->width > 0)
     width += aux_info->width;
-  else if (label->ellipsize || priv->width_chars > 0 || priv->max_width_chars > 0)
+  else if ((label->ellipsize || priv->width_chars > 0 || priv->max_width_chars > 0) &&
+             !priv->request_full_width)
     {
       PangoContext *context;
       PangoFontMetrics *metrics;
@@ -2081,15 +2183,28 @@
                          GtkAllocation *allocation)
 {
   GtkLabel *label;
+  GtkRequisition req;
+  GtkLabelPrivate *priv;
 
   label = GTK_LABEL (widget);
+  priv = GTK_LABEL_GET_PRIVATE (label);
 
   (* GTK_WIDGET_CLASS (parent_class)->size_allocate) (widget, allocation);
 
-  if (label->ellipsize)
+  gtk_widget_get_child_requisition (widget, &req);
+
+  if (allocation->width < req.width && !label->wrap)
+    {
+      gtk_label_set_ellipsize (label, PANGO_ELLIPSIZE_END);
+      priv->request_full_width = TRUE;
+    }
+  else
+    priv->request_full_width = FALSE;
+
+  if (label->ellipsize || label->wrap)
     {
       if (label->layout)
-	pango_layout_set_width (label->layout, allocation->width * PANGO_SCALE);
+        pango_layout_set_width (label->layout, allocation->width * PANGO_SCALE);
     }
 
   if (label->select_info && label->select_info->window)
@@ -2151,7 +2266,7 @@
   GtkMisc *misc;
   GtkWidget *widget;
   gfloat xalign;
-  gint req_width, x, y;
+  gint req_width, req_height, x, y;
   
   misc = GTK_MISC (label);
   widget = GTK_WIDGET (label);
@@ -2161,6 +2276,24 @@
   else
     xalign = 1.0 - misc->xalign;
 
+  /* get label's actual width and height so alignment calculations will work
+   * correctly (assuming our allocation has enough width/height).
+   */
+  if (label->wrap)
+    {
+      gint height, width;
+
+      pango_layout_get_size (label->layout, &width, &height);
+      req_width = width / PANGO_SCALE + label->misc.xpad * 2;
+      req_height = height / PANGO_SCALE + label->misc.ypad * 2;
+    }
+  else
+    {
+      /* no wrapping, the requisition width/height is correct already */
+      req_width = widget->requisition.width;
+      req_height = widget->requisition.height;
+    }
+
   if (label->ellipsize)
     {
       PangoRectangle ink_rect;
@@ -2169,8 +2302,6 @@
 
       req_width = PANGO_PIXELS (ink_rect.width);
     }
-  else
-    req_width = widget->requisition.width;
 
   x = floor (widget->allocation.x + (gint)misc->xpad +
 	      xalign * (widget->allocation.width - req_width)
@@ -2184,7 +2315,7 @@
 	     req_width - misc->xpad);
 
   y = floor (widget->allocation.y + (gint)misc->ypad 
-             + MAX (((widget->allocation.height - widget->requisition.height) * misc->yalign)
+             + MAX (((widget->allocation.height - req_height) * misc->yalign)
 		    + 0.5, 0));
 
   if (xp)
@@ -2479,7 +2610,7 @@
     }
   *dest = 0;
   *pattern_dest = 0;
-  
+
   gtk_label_set_text_internal (label, new_str);
   gtk_label_set_pattern_internal (label, pattern);
   
@@ -2541,13 +2672,11 @@
   last_keyval = label->mnemonic_keyval;
 
   g_object_freeze_notify (G_OBJECT (label));
-
   gtk_label_set_label_internal (label, g_strdup (str ? str : ""));
   gtk_label_set_use_markup_internal (label, FALSE);
   gtk_label_set_use_underline_internal (label, TRUE);
-  
-  gtk_label_recalculate (label);
 
+  gtk_label_recalculate (label);
   gtk_label_setup_mnemonic (label, last_keyval);
 
   g_object_thaw_notify (G_OBJECT (label));
@@ -3948,3 +4077,67 @@
                     popup_position_func, label,
                     0, gtk_get_current_event_time ());
 }
+
+/* Hildon mod.
+ * Functions for run-time locale changing. Beware though that this
+   functionality is not yet completed. Therefore it's suggested
+   that these functions shouldn't be used yet outside testing.  */
+   
+void     gtk_label_set_translatable       (GtkLabel *label, gboolean newstatus)
+{
+  if (newstatus == gtk_label_get_translatable (label)) return;
+   
+  if (newstatus == TRUE)
+    {
+      if (g_object_get_data (G_OBJECT (label), LABEL_KEY_TRANSLATABLETEXT) != NULL)
+        g_free (g_object_get_data (G_OBJECT (label), LABEL_KEY_TRANSLATABLETEXT));
+      g_object_set_data (G_OBJECT (label), LABEL_KEY_TRANSLATABLETEXT, g_strdup (label->label));
+      g_object_set_data (G_OBJECT (label), LABEL_KEY_TRANSLATABLE, (void*) TRUE);
+      if (label->text != NULL)
+        g_free (label->text);
+      if (label->label != NULL)
+        g_free (label->label);
+      label->text = g_strdup(_(g_object_get_data (G_OBJECT (label), LABEL_KEY_TRANSLATABLETEXT)));
+      label->label = g_strdup(_(g_object_get_data (G_OBJECT (label), LABEL_KEY_TRANSLATABLETEXT)));
+    }
+  else
+    {
+      if (label->text != NULL)
+        g_free (label->text);
+      if (label->label != NULL)
+        g_free (label->label);
+      label->text = g_strdup (g_object_get_data (G_OBJECT (label), LABEL_KEY_TRANSLATABLETEXT));
+      label->label = g_strdup (g_object_get_data (G_OBJECT (label), LABEL_KEY_TRANSLATABLETEXT));
+      g_object_set_data (G_OBJECT (label), LABEL_KEY_TRANSLATABLE, FALSE);
+      if (g_object_get_data (G_OBJECT (label), LABEL_KEY_TRANSLATABLETEXT) != NULL)
+        g_free (g_object_get_data (G_OBJECT (label), LABEL_KEY_TRANSLATABLETEXT));
+      g_object_set_data (G_OBJECT (label), LABEL_KEY_TRANSLATABLETEXT, NULL);
+    }
+  gtk_label_recalculate (label);
+}
+
+gboolean gtk_label_get_translatable       (GtkLabel *label)
+{
+  return (gboolean) (g_object_get_data (G_OBJECT (label), LABEL_KEY_TRANSLATABLE));
+}
+
+   
+void     gtk_label_retranslate            (GtkLabel *label)
+{
+  g_object_freeze_notify (G_OBJECT (label));
+  if (gtk_label_get_translatable (label) == TRUE)
+    {
+      if (label->label != NULL)
+        g_free (label->label);
+      label->label = g_strdup(gettext(g_object_get_data (G_OBJECT (label), LABEL_KEY_TRANSLATABLETEXT)));
+    }
+  if (g_object_get_data (G_OBJECT (label), LABEL_KEY_ORIGINAL_LAYOUT)) g_object_unref (g_object_get_data (G_OBJECT (label), LABEL_KEY_ORIGINAL_LAYOUT));
+  g_object_set_data (G_OBJECT (label), LABEL_KEY_ORIGINAL_LAYOUT, NULL);
+  g_object_notify (G_OBJECT (label), "label");
+  gtk_label_recalculate (label);
+  g_object_thaw_notify (G_OBJECT (label));
+  gtk_label_set_text (label, label->label);
+}
+
+/* End of hildon mods for run-time locale change. */
+
--- gtk+/gtk/gtkcellrendererpixbuf.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkcellrendererpixbuf.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -22,6 +22,7 @@
 #include "gtkalias.h"
 #include "gtkcellrendererpixbuf.h"
 #include "gtkiconfactory.h"
+#include "gtkicontheme.h"
 #include "gtkintl.h"
 
 static void gtk_cell_renderer_pixbuf_get_property  (GObject                    *object,
@@ -37,6 +38,8 @@
 static void gtk_cell_renderer_pixbuf_finalize   (GObject                    *object);
 static void gtk_cell_renderer_pixbuf_create_stock_pixbuf (GtkCellRendererPixbuf *cellpixbuf,
 							  GtkWidget             *widget);
+static void gtk_cell_renderer_pixbuf_create_named_icon_pixbuf (GtkCellRendererPixbuf *cellpixbuf,
+                                                               GtkWidget             *widget);
 static void gtk_cell_renderer_pixbuf_get_size   (GtkCellRenderer            *cell,
 						 GtkWidget                  *widget,
 						 GdkRectangle               *rectangle,
@@ -60,7 +63,8 @@
 	PROP_PIXBUF_EXPANDER_CLOSED,
 	PROP_STOCK_ID,
 	PROP_STOCK_SIZE,
-	PROP_STOCK_DETAIL
+	PROP_STOCK_DETAIL,
+        PROP_ICON_NAME
 };
 
 static gpointer parent_class;
@@ -74,6 +78,8 @@
   gchar *stock_id;
   GtkIconSize stock_size;
   gchar *stock_detail;
+
+  gchar *icon_name;
 };
 
 
@@ -183,6 +189,14 @@
 							NULL,
 							G_PARAM_READWRITE));
 
+  g_object_class_install_property (object_class, 
+                                   PROP_ICON_NAME,
+                                   g_param_spec_string ("icon-name",
+                                                        P_("Icon Name"),
+                                                        P_("The name of the icon from the icon theme"),
+                                                        NULL,
+                                                        G_PARAM_READWRITE));
+
   g_type_class_add_private (object_class, sizeof (GtkCellRendererPixbufPrivate));
 }
 
@@ -197,11 +211,9 @@
   if (cellpixbuf->pixbuf)
     g_object_unref (cellpixbuf->pixbuf);
 
-  if (priv->stock_id)
-    g_free (priv->stock_id);
-
-  if (priv->stock_detail)
-    g_free (priv->stock_detail);
+  g_free (priv->stock_id);
+  g_free (priv->stock_detail);
+  g_free (priv->icon_name);
 
   (* G_OBJECT_CLASS (parent_class)->finalize) (object);
 }
@@ -240,6 +252,9 @@
     case PROP_STOCK_DETAIL:
       g_value_set_string (value, priv->stock_detail);
       break;
+    case PROP_ICON_NAME:
+      g_value_set_string (value, priv->icon_name);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, param_id, pspec);
       break;
@@ -294,6 +309,8 @@
               cellpixbuf->pixbuf = NULL;
             }
           g_free (priv->stock_id);
+          g_free (priv->icon_name);
+          priv->icon_name = NULL;
         }
       priv->stock_id = g_strdup (g_value_get_string (value));
       break;
@@ -305,6 +322,19 @@
         g_free (priv->stock_detail);
       priv->stock_detail = g_strdup (g_value_get_string (value));
       break;
+    case PROP_ICON_NAME:
+      if (priv->icon_name)
+        {
+          if (cellpixbuf->pixbuf)
+            {
+              g_object_unref (cellpixbuf->pixbuf);
+              cellpixbuf->pixbuf = NULL;
+            }
+          g_free (priv->stock_id);
+          g_free (priv->icon_name);
+        }
+      priv->icon_name = g_strdup (g_value_get_string (value));
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, param_id, pspec);
       break;
@@ -353,6 +383,45 @@
                                                priv->stock_detail);
 }
 
+static void 
+gtk_cell_renderer_pixbuf_create_named_icon_pixbuf (GtkCellRendererPixbuf *cellpixbuf,
+                                                   GtkWidget             *widget)
+{
+  GtkCellRendererPixbufPrivate *priv;
+  GdkScreen *screen;
+  GtkIconTheme *icon_theme;
+  GtkSettings *settings;
+  gint width, height;
+  GError *error = NULL;
+
+  priv = GTK_CELL_RENDERER_PIXBUF_GET_PRIVATE (cellpixbuf);
+
+  if (cellpixbuf->pixbuf)
+    g_object_unref (cellpixbuf->pixbuf);
+
+  screen = gtk_widget_get_screen (GTK_WIDGET (widget));
+  icon_theme = gtk_icon_theme_get_for_screen (screen);
+  settings = gtk_settings_get_for_screen (screen);
+
+  if (!gtk_icon_size_lookup_for_settings (settings,
+                                          priv->stock_size,
+                                          &width, &height))
+    {
+      g_warning ("Invalid icon size %d\n", priv->stock_size);
+      width = height = 24;
+    }
+
+  cellpixbuf->pixbuf =
+    gtk_icon_theme_load_icon (icon_theme,
+                              priv->icon_name,
+                              MIN (width, height), 0, &error);
+  if (!cellpixbuf->pixbuf) 
+    {
+      g_warning ("could not load image: %s\n", error->message);
+      g_error_free (error);
+    }
+}
+
 static void
 gtk_cell_renderer_pixbuf_get_size (GtkCellRenderer *cell,
 				   GtkWidget       *widget,
@@ -371,8 +440,13 @@
 
   priv = GTK_CELL_RENDERER_PIXBUF_GET_PRIVATE (cell);
 
-  if (!cellpixbuf->pixbuf && priv->stock_id)
-    gtk_cell_renderer_pixbuf_create_stock_pixbuf (cellpixbuf, widget);
+  if (!cellpixbuf->pixbuf)
+    {
+      if (priv->stock_id)
+        gtk_cell_renderer_pixbuf_create_stock_pixbuf (cellpixbuf, widget);
+      else if (priv->icon_name)
+        gtk_cell_renderer_pixbuf_create_named_icon_pixbuf (cellpixbuf, widget);
+    }
 
   if (cellpixbuf->pixbuf)
     {
--- gtk+/gtk/gtklabel.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtklabel.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -23,6 +23,10 @@
  * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
  */
 
+/* Modified by Nokia Corporation - 2005.
+ * 
+ */
+
 #ifndef __GTK_LABEL_H__
 #define __GTK_LABEL_H__
 
@@ -165,6 +169,15 @@
                                               gboolean single_line_mode);
 gboolean     gtk_label_get_single_line_mode  (GtkLabel *label);
 
+/* Additional Hildon functions for run-time locale change */
+
+void     gtk_label_set_translatable       (GtkLabel *label, gboolean newstatus);
+gboolean gtk_label_get_translatable       (GtkLabel *label);
+
+void     gtk_label_retranslate            (GtkLabel *label);
+
+/* ----- */
+
 #ifndef GTK_DISABLE_DEPRECATED
 
 #define  gtk_label_set           gtk_label_set_text
--- gtk+/gtk/gtkmarshalers.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkmarshalers.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -48,7 +48,7 @@
 #endif /* !G_ENABLE_DEBUG */
 
 
-/* BOOLEAN:BOXED (./gtkmarshalers.list:24) */
+
 void
 _gtk_marshal_BOOLEAN__BOXED (GClosure     *closure,
                              GValue       *return_value,
@@ -87,7 +87,7 @@
   g_value_set_boolean (return_value, v_return);
 }
 
-/* BOOLEAN:BOXED,BOXED (./gtkmarshalers.list:25) */
+
 void
 _gtk_marshal_BOOLEAN__BOXED_BOXED (GClosure     *closure,
                                    GValue       *return_value,
@@ -128,7 +128,7 @@
   g_value_set_boolean (return_value, v_return);
 }
 
-/* BOOLEAN:ENUM (./gtkmarshalers.list:26) */
+
 void
 _gtk_marshal_BOOLEAN__ENUM (GClosure     *closure,
                             GValue       *return_value,
@@ -167,7 +167,7 @@
   g_value_set_boolean (return_value, v_return);
 }
 
-/* BOOLEAN:ENUM,DOUBLE (./gtkmarshalers.list:27) */
+
 void
 _gtk_marshal_BOOLEAN__ENUM_DOUBLE (GClosure     *closure,
                                    GValue       *return_value,
@@ -208,7 +208,7 @@
   g_value_set_boolean (return_value, v_return);
 }
 
-/* BOOLEAN:ENUM,INT (./gtkmarshalers.list:28) */
+
 void
 _gtk_marshal_BOOLEAN__ENUM_INT (GClosure     *closure,
                                 GValue       *return_value,
@@ -249,7 +249,7 @@
   g_value_set_boolean (return_value, v_return);
 }
 
-/* BOOLEAN:OBJECT,UINT,FLAGS (./gtkmarshalers.list:29) */
+
 void
 _gtk_marshal_BOOLEAN__OBJECT_UINT_FLAGS (GClosure     *closure,
                                          GValue       *return_value,
@@ -292,7 +292,7 @@
   g_value_set_boolean (return_value, v_return);
 }
 
-/* BOOLEAN:OBJECT,INT,INT,UINT (./gtkmarshalers.list:30) */
+
 void
 _gtk_marshal_BOOLEAN__OBJECT_INT_INT_UINT (GClosure     *closure,
                                            GValue       *return_value,
@@ -337,7 +337,7 @@
   g_value_set_boolean (return_value, v_return);
 }
 
-/* BOOLEAN:OBJECT,STRING,STRING,BOXED (./gtkmarshalers.list:31) */
+
 void
 _gtk_marshal_BOOLEAN__OBJECT_STRING_STRING_BOXED (GClosure     *closure,
                                                   GValue       *return_value,
@@ -382,7 +382,7 @@
   g_value_set_boolean (return_value, v_return);
 }
 
-/* BOOLEAN:OBJECT,BOXED (./gtkmarshalers.list:32) */
+
 void
 _gtk_marshal_BOOLEAN__OBJECT_BOXED (GClosure     *closure,
                                     GValue       *return_value,
@@ -423,7 +423,7 @@
   g_value_set_boolean (return_value, v_return);
 }
 
-/* BOOLEAN:OBJECT,BOXED,BOXED (./gtkmarshalers.list:33) */
+
 void
 _gtk_marshal_BOOLEAN__OBJECT_BOXED_BOXED (GClosure     *closure,
                                           GValue       *return_value,
@@ -466,7 +466,7 @@
   g_value_set_boolean (return_value, v_return);
 }
 
-/* BOOLEAN:OBJECT,STRING,STRING (./gtkmarshalers.list:34) */
+
 void
 _gtk_marshal_BOOLEAN__OBJECT_STRING_STRING (GClosure     *closure,
                                             GValue       *return_value,
@@ -509,7 +509,7 @@
   g_value_set_boolean (return_value, v_return);
 }
 
-/* BOOLEAN:INT,INT (./gtkmarshalers.list:35) */
+
 void
 _gtk_marshal_BOOLEAN__INT_INT (GClosure     *closure,
                                GValue       *return_value,
@@ -550,7 +550,7 @@
   g_value_set_boolean (return_value, v_return);
 }
 
-/* BOOLEAN:INT,INT,INT (./gtkmarshalers.list:36) */
+
 void
 _gtk_marshal_BOOLEAN__INT_INT_INT (GClosure     *closure,
                                    GValue       *return_value,
@@ -593,7 +593,7 @@
   g_value_set_boolean (return_value, v_return);
 }
 
-/* BOOLEAN:UINT (./gtkmarshalers.list:37) */
+
 void
 _gtk_marshal_BOOLEAN__UINT (GClosure     *closure,
                             GValue       *return_value,
@@ -632,7 +632,7 @@
   g_value_set_boolean (return_value, v_return);
 }
 
-/* BOOLEAN:VOID (./gtkmarshalers.list:38) */
+
 void
 _gtk_marshal_BOOLEAN__VOID (GClosure     *closure,
                             GValue       *return_value,
@@ -669,7 +669,7 @@
   g_value_set_boolean (return_value, v_return);
 }
 
-/* BOOLEAN:BOOLEAN (./gtkmarshalers.list:39) */
+
 void
 _gtk_marshal_BOOLEAN__BOOLEAN (GClosure     *closure,
                                GValue       *return_value,
@@ -708,9 +708,7 @@
   g_value_set_boolean (return_value, v_return);
 }
 
-/* BOOLEAN:NONE (./gtkmarshalers.list:40) */
 
-/* BOOLEAN:BOOLEAN,BOOLEAN,BOOLEAN (./gtkmarshalers.list:41) */
 void
 _gtk_marshal_BOOLEAN__BOOLEAN_BOOLEAN_BOOLEAN (GClosure     *closure,
                                                GValue       *return_value,
@@ -753,7 +751,7 @@
   g_value_set_boolean (return_value, v_return);
 }
 
-/* BOOLEAN:STRING (./gtkmarshalers.list:42) */
+
 void
 _gtk_marshal_BOOLEAN__STRING (GClosure     *closure,
                               GValue       *return_value,
@@ -792,7 +790,7 @@
   g_value_set_boolean (return_value, v_return);
 }
 
-/* ENUM:ENUM (./gtkmarshalers.list:43) */
+
 void
 _gtk_marshal_ENUM__ENUM (GClosure     *closure,
                          GValue       *return_value,
@@ -831,7 +829,7 @@
   g_value_set_enum (return_value, v_return);
 }
 
-/* INT:POINTER (./gtkmarshalers.list:44) */
+
 void
 _gtk_marshal_INT__POINTER (GClosure     *closure,
                            GValue       *return_value,
@@ -870,13 +868,7 @@
   g_value_set_int (return_value, v_return);
 }
 
-/* NONE:BOOLEAN (./gtkmarshalers.list:45) */
-
-/* NONE:ENUM (./gtkmarshalers.list:46) */
-
-/* NONE:INT (./gtkmarshalers.list:47) */
 
-/* NONE:INT,BOOL (./gtkmarshalers.list:48) */
 void
 _gtk_marshal_VOID__INT_BOOLEAN (GClosure     *closure,
                                 GValue       *return_value,
@@ -913,7 +905,7 @@
             data2);
 }
 
-/* NONE:INT,INT (./gtkmarshalers.list:49) */
+
 void
 _gtk_marshal_VOID__INT_INT (GClosure     *closure,
                             GValue       *return_value,
@@ -950,9 +942,7 @@
             data2);
 }
 
-/* NONE:NONE (./gtkmarshalers.list:50) */
 
-/* NONE:STRING,INT,POINTER (./gtkmarshalers.list:51) */
 void
 _gtk_marshal_VOID__STRING_INT_POINTER (GClosure     *closure,
                                        GValue       *return_value,
@@ -991,7 +981,7 @@
             data2);
 }
 
-/* STRING:DOUBLE (./gtkmarshalers.list:52) */
+
 void
 _gtk_marshal_STRING__DOUBLE (GClosure     *closure,
                              GValue       *return_value,
@@ -1030,11 +1020,7 @@
   g_value_take_string (return_value, v_return);
 }
 
-/* VOID:DOUBLE (./gtkmarshalers.list:53) */
 
-/* VOID:BOOLEAN (./gtkmarshalers.list:54) */
-
-/* VOID:BOOLEAN,BOOLEAN,BOOLEAN (./gtkmarshalers.list:55) */
 void
 _gtk_marshal_VOID__BOOLEAN_BOOLEAN_BOOLEAN (GClosure     *closure,
                                             GValue       *return_value,
@@ -1073,9 +1059,7 @@
             data2);
 }
 
-/* VOID:BOXED (./gtkmarshalers.list:56) */
 
-/* VOID:BOXED,BOXED (./gtkmarshalers.list:57) */
 void
 _gtk_marshal_VOID__BOXED_BOXED (GClosure     *closure,
                                 GValue       *return_value,
@@ -1112,7 +1096,7 @@
             data2);
 }
 
-/* VOID:BOXED,BOXED,POINTER (./gtkmarshalers.list:58) */
+
 void
 _gtk_marshal_VOID__BOXED_BOXED_POINTER (GClosure     *closure,
                                         GValue       *return_value,
@@ -1151,7 +1135,7 @@
             data2);
 }
 
-/* VOID:BOXED,OBJECT (./gtkmarshalers.list:59) */
+
 void
 _gtk_marshal_VOID__BOXED_OBJECT (GClosure     *closure,
                                  GValue       *return_value,
@@ -1188,7 +1172,7 @@
             data2);
 }
 
-/* VOID:BOXED,STRING,INT (./gtkmarshalers.list:60) */
+
 void
 _gtk_marshal_VOID__BOXED_STRING_INT (GClosure     *closure,
                                      GValue       *return_value,
@@ -1227,7 +1211,7 @@
             data2);
 }
 
-/* VOID:BOXED,UINT (./gtkmarshalers.list:61) */
+
 void
 _gtk_marshal_VOID__BOXED_UINT (GClosure     *closure,
                                GValue       *return_value,
@@ -1264,7 +1248,7 @@
             data2);
 }
 
-/* VOID:BOXED,UINT,FLAGS (./gtkmarshalers.list:62) */
+
 void
 _gtk_marshal_VOID__BOXED_UINT_FLAGS (GClosure     *closure,
                                      GValue       *return_value,
@@ -1303,7 +1287,7 @@
             data2);
 }
 
-/* VOID:BOXED,UINT,UINT (./gtkmarshalers.list:63) */
+
 void
 _gtk_marshal_VOID__BOXED_UINT_UINT (GClosure     *closure,
                                     GValue       *return_value,
@@ -1342,9 +1326,7 @@
             data2);
 }
 
-/* VOID:ENUM (./gtkmarshalers.list:64) */
 
-/* VOID:ENUM,BOOLEAN (./gtkmarshalers.list:65) */
 void
 _gtk_marshal_VOID__ENUM_BOOLEAN (GClosure     *closure,
                                  GValue       *return_value,
@@ -1381,7 +1363,7 @@
             data2);
 }
 
-/* VOID:ENUM,ENUM (./gtkmarshalers.list:66) */
+
 void
 _gtk_marshal_VOID__ENUM_ENUM (GClosure     *closure,
                               GValue       *return_value,
@@ -1418,7 +1400,7 @@
             data2);
 }
 
-/* VOID:ENUM,FLOAT (./gtkmarshalers.list:67) */
+
 void
 _gtk_marshal_VOID__ENUM_FLOAT (GClosure     *closure,
                                GValue       *return_value,
@@ -1455,7 +1437,7 @@
             data2);
 }
 
-/* VOID:ENUM,FLOAT,BOOLEAN (./gtkmarshalers.list:68) */
+
 void
 _gtk_marshal_VOID__ENUM_FLOAT_BOOLEAN (GClosure     *closure,
                                        GValue       *return_value,
@@ -1494,7 +1476,7 @@
             data2);
 }
 
-/* VOID:ENUM,INT (./gtkmarshalers.list:69) */
+
 void
 _gtk_marshal_VOID__ENUM_INT (GClosure     *closure,
                              GValue       *return_value,
@@ -1531,7 +1513,7 @@
             data2);
 }
 
-/* VOID:ENUM,INT,BOOLEAN (./gtkmarshalers.list:70) */
+
 void
 _gtk_marshal_VOID__ENUM_INT_BOOLEAN (GClosure     *closure,
                                      GValue       *return_value,
@@ -1570,11 +1552,7 @@
             data2);
 }
 
-/* VOID:INT (./gtkmarshalers.list:71) */
 
-/* VOID:INT,INT (./gtkmarshalers.list:72) */
-
-/* VOID:INT,INT,BOXED (./gtkmarshalers.list:73) */
 void
 _gtk_marshal_VOID__INT_INT_BOXED (GClosure     *closure,
                                   GValue       *return_value,
@@ -1613,7 +1591,7 @@
             data2);
 }
 
-/* VOID:INT,INT,INT (./gtkmarshalers.list:74) */
+
 void
 _gtk_marshal_VOID__INT_INT_INT (GClosure     *closure,
                                 GValue       *return_value,
@@ -1652,9 +1630,7 @@
             data2);
 }
 
-/* VOID:OBJECT (./gtkmarshalers.list:75) */
 
-/* VOID:OBJECT,BOOLEAN (./gtkmarshalers.list:76) */
 void
 _gtk_marshal_VOID__OBJECT_BOOLEAN (GClosure     *closure,
                                    GValue       *return_value,
@@ -1691,7 +1667,7 @@
             data2);
 }
 
-/* VOID:OBJECT,BOXED,BOXED (./gtkmarshalers.list:77) */
+
 void
 _gtk_marshal_VOID__OBJECT_BOXED_BOXED (GClosure     *closure,
                                        GValue       *return_value,
@@ -1730,7 +1706,7 @@
             data2);
 }
 
-/* VOID:OBJECT,BOXED,UINT,UINT (./gtkmarshalers.list:78) */
+
 void
 _gtk_marshal_VOID__OBJECT_BOXED_UINT_UINT (GClosure     *closure,
                                            GValue       *return_value,
@@ -1771,7 +1747,7 @@
             data2);
 }
 
-/* VOID:OBJECT,INT,INT (./gtkmarshalers.list:79) */
+
 void
 _gtk_marshal_VOID__OBJECT_INT_INT (GClosure     *closure,
                                    GValue       *return_value,
@@ -1810,7 +1786,7 @@
             data2);
 }
 
-/* VOID:OBJECT,INT,INT,BOXED,UINT,UINT (./gtkmarshalers.list:80) */
+
 void
 _gtk_marshal_VOID__OBJECT_INT_INT_BOXED_UINT_UINT (GClosure     *closure,
                                                    GValue       *return_value,
@@ -1855,7 +1831,7 @@
             data2);
 }
 
-/* VOID:OBJECT,OBJECT (./gtkmarshalers.list:81) */
+
 void
 _gtk_marshal_VOID__OBJECT_OBJECT (GClosure     *closure,
                                   GValue       *return_value,
@@ -1892,7 +1868,7 @@
             data2);
 }
 
-/* VOID:OBJECT,STRING (./gtkmarshalers.list:82) */
+
 void
 _gtk_marshal_VOID__OBJECT_STRING (GClosure     *closure,
                                   GValue       *return_value,
@@ -1929,7 +1905,7 @@
             data2);
 }
 
-/* VOID:OBJECT,STRING,STRING (./gtkmarshalers.list:83) */
+
 void
 _gtk_marshal_VOID__OBJECT_STRING_STRING (GClosure     *closure,
                                          GValue       *return_value,
@@ -1968,7 +1944,7 @@
             data2);
 }
 
-/* VOID:OBJECT,UINT (./gtkmarshalers.list:84) */
+
 void
 _gtk_marshal_VOID__OBJECT_UINT (GClosure     *closure,
                                 GValue       *return_value,
@@ -2005,7 +1981,7 @@
             data2);
 }
 
-/* VOID:OBJECT,UINT,FLAGS (./gtkmarshalers.list:85) */
+
 void
 _gtk_marshal_VOID__OBJECT_UINT_FLAGS (GClosure     *closure,
                                       GValue       *return_value,
@@ -2044,11 +2020,7 @@
             data2);
 }
 
-/* VOID:OBJECT,STRING (./gtkmarshalers.list:86) */
 
-/* VOID:POINTER (./gtkmarshalers.list:87) */
-
-/* VOID:POINTER,INT (./gtkmarshalers.list:88) */
 void
 _gtk_marshal_VOID__POINTER_INT (GClosure     *closure,
                                 GValue       *return_value,
@@ -2085,7 +2057,7 @@
             data2);
 }
 
-/* VOID:POINTER,BOOLEAN (./gtkmarshalers.list:89) */
+
 void
 _gtk_marshal_VOID__POINTER_BOOLEAN (GClosure     *closure,
                                     GValue       *return_value,
@@ -2122,7 +2094,7 @@
             data2);
 }
 
-/* VOID:POINTER,POINTER,POINTER (./gtkmarshalers.list:90) */
+
 void
 _gtk_marshal_VOID__POINTER_POINTER_POINTER (GClosure     *closure,
                                             GValue       *return_value,
@@ -2161,7 +2133,7 @@
             data2);
 }
 
-/* VOID:POINTER,UINT (./gtkmarshalers.list:91) */
+
 void
 _gtk_marshal_VOID__POINTER_UINT (GClosure     *closure,
                                  GValue       *return_value,
@@ -2198,9 +2170,7 @@
             data2);
 }
 
-/* VOID:STRING (./gtkmarshalers.list:92) */
 
-/* VOID:STRING,STRING (./gtkmarshalers.list:93) */
 void
 _gtk_marshal_VOID__STRING_STRING (GClosure     *closure,
                                   GValue       *return_value,
@@ -2237,9 +2207,7 @@
             data2);
 }
 
-/* VOID:STRING,INT,POINTER (./gtkmarshalers.list:94) */
 
-/* VOID:STRING,UINT,FLAGS (./gtkmarshalers.list:95) */
 void
 _gtk_marshal_VOID__STRING_UINT_FLAGS (GClosure     *closure,
                                       GValue       *return_value,
@@ -2278,7 +2246,7 @@
             data2);
 }
 
-/* VOID:UINT,FLAGS,BOXED (./gtkmarshalers.list:96) */
+
 void
 _gtk_marshal_VOID__UINT_FLAGS_BOXED (GClosure     *closure,
                                      GValue       *return_value,
@@ -2317,7 +2285,7 @@
             data2);
 }
 
-/* VOID:UINT,UINT (./gtkmarshalers.list:97) */
+
 void
 _gtk_marshal_VOID__UINT_UINT (GClosure     *closure,
                               GValue       *return_value,
@@ -2354,7 +2322,7 @@
             data2);
 }
 
-/* VOID:UINT,STRING (./gtkmarshalers.list:98) */
+
 void
 _gtk_marshal_VOID__UINT_STRING (GClosure     *closure,
                                 GValue       *return_value,
@@ -2391,7 +2359,7 @@
             data2);
 }
 
-/* VOID:UINT,BOXED,UINT,FLAGS,FLAGS (./gtkmarshalers.list:99) */
+
 void
 _gtk_marshal_VOID__UINT_BOXED_UINT_FLAGS_FLAGS (GClosure     *closure,
                                                 GValue       *return_value,
@@ -2434,7 +2402,7 @@
             data2);
 }
 
-/* VOID:UINT,OBJECT,UINT,FLAGS,FLAGS (./gtkmarshalers.list:100) */
+
 void
 _gtk_marshal_VOID__UINT_OBJECT_UINT_FLAGS_FLAGS (GClosure     *closure,
                                                  GValue       *return_value,
@@ -2477,5 +2445,5 @@
             data2);
 }
 
-/* VOID:VOID (./gtkmarshalers.list:101) */
+
 
--- gtk+/gtk/gtkmarshalers.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkmarshalers.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -6,7 +6,7 @@
 
 G_BEGIN_DECLS
 
-/* BOOLEAN:BOXED (./gtkmarshalers.list:24) */
+
 extern void _gtk_marshal_BOOLEAN__BOXED (GClosure     *closure,
                                          GValue       *return_value,
                                          guint         n_param_values,
@@ -14,7 +14,7 @@
                                          gpointer      invocation_hint,
                                          gpointer      marshal_data);
 
-/* BOOLEAN:BOXED,BOXED (./gtkmarshalers.list:25) */
+
 extern void _gtk_marshal_BOOLEAN__BOXED_BOXED (GClosure     *closure,
                                                GValue       *return_value,
                                                guint         n_param_values,
@@ -22,7 +22,7 @@
                                                gpointer      invocation_hint,
                                                gpointer      marshal_data);
 
-/* BOOLEAN:ENUM (./gtkmarshalers.list:26) */
+
 extern void _gtk_marshal_BOOLEAN__ENUM (GClosure     *closure,
                                         GValue       *return_value,
                                         guint         n_param_values,
@@ -30,7 +30,7 @@
                                         gpointer      invocation_hint,
                                         gpointer      marshal_data);
 
-/* BOOLEAN:ENUM,DOUBLE (./gtkmarshalers.list:27) */
+
 extern void _gtk_marshal_BOOLEAN__ENUM_DOUBLE (GClosure     *closure,
                                                GValue       *return_value,
                                                guint         n_param_values,
@@ -38,7 +38,7 @@
                                                gpointer      invocation_hint,
                                                gpointer      marshal_data);
 
-/* BOOLEAN:ENUM,INT (./gtkmarshalers.list:28) */
+
 extern void _gtk_marshal_BOOLEAN__ENUM_INT (GClosure     *closure,
                                             GValue       *return_value,
                                             guint         n_param_values,
@@ -46,7 +46,7 @@
                                             gpointer      invocation_hint,
                                             gpointer      marshal_data);
 
-/* BOOLEAN:OBJECT,UINT,FLAGS (./gtkmarshalers.list:29) */
+
 extern void _gtk_marshal_BOOLEAN__OBJECT_UINT_FLAGS (GClosure     *closure,
                                                      GValue       *return_value,
                                                      guint         n_param_values,
@@ -54,7 +54,7 @@
                                                      gpointer      invocation_hint,
                                                      gpointer      marshal_data);
 
-/* BOOLEAN:OBJECT,INT,INT,UINT (./gtkmarshalers.list:30) */
+
 extern void _gtk_marshal_BOOLEAN__OBJECT_INT_INT_UINT (GClosure     *closure,
                                                        GValue       *return_value,
                                                        guint         n_param_values,
@@ -62,7 +62,7 @@
                                                        gpointer      invocation_hint,
                                                        gpointer      marshal_data);
 
-/* BOOLEAN:OBJECT,STRING,STRING,BOXED (./gtkmarshalers.list:31) */
+
 extern void _gtk_marshal_BOOLEAN__OBJECT_STRING_STRING_BOXED (GClosure     *closure,
                                                               GValue       *return_value,
                                                               guint         n_param_values,
@@ -70,7 +70,7 @@
                                                               gpointer      invocation_hint,
                                                               gpointer      marshal_data);
 
-/* BOOLEAN:OBJECT,BOXED (./gtkmarshalers.list:32) */
+
 extern void _gtk_marshal_BOOLEAN__OBJECT_BOXED (GClosure     *closure,
                                                 GValue       *return_value,
                                                 guint         n_param_values,
@@ -78,7 +78,7 @@
                                                 gpointer      invocation_hint,
                                                 gpointer      marshal_data);
 
-/* BOOLEAN:OBJECT,BOXED,BOXED (./gtkmarshalers.list:33) */
+
 extern void _gtk_marshal_BOOLEAN__OBJECT_BOXED_BOXED (GClosure     *closure,
                                                       GValue       *return_value,
                                                       guint         n_param_values,
@@ -86,7 +86,7 @@
                                                       gpointer      invocation_hint,
                                                       gpointer      marshal_data);
 
-/* BOOLEAN:OBJECT,STRING,STRING (./gtkmarshalers.list:34) */
+
 extern void _gtk_marshal_BOOLEAN__OBJECT_STRING_STRING (GClosure     *closure,
                                                         GValue       *return_value,
                                                         guint         n_param_values,
@@ -94,7 +94,7 @@
                                                         gpointer      invocation_hint,
                                                         gpointer      marshal_data);
 
-/* BOOLEAN:INT,INT (./gtkmarshalers.list:35) */
+
 extern void _gtk_marshal_BOOLEAN__INT_INT (GClosure     *closure,
                                            GValue       *return_value,
                                            guint         n_param_values,
@@ -102,7 +102,7 @@
                                            gpointer      invocation_hint,
                                            gpointer      marshal_data);
 
-/* BOOLEAN:INT,INT,INT (./gtkmarshalers.list:36) */
+
 extern void _gtk_marshal_BOOLEAN__INT_INT_INT (GClosure     *closure,
                                                GValue       *return_value,
                                                guint         n_param_values,
@@ -110,7 +110,7 @@
                                                gpointer      invocation_hint,
                                                gpointer      marshal_data);
 
-/* BOOLEAN:UINT (./gtkmarshalers.list:37) */
+
 extern void _gtk_marshal_BOOLEAN__UINT (GClosure     *closure,
                                         GValue       *return_value,
                                         guint         n_param_values,
@@ -118,7 +118,7 @@
                                         gpointer      invocation_hint,
                                         gpointer      marshal_data);
 
-/* BOOLEAN:VOID (./gtkmarshalers.list:38) */
+
 extern void _gtk_marshal_BOOLEAN__VOID (GClosure     *closure,
                                         GValue       *return_value,
                                         guint         n_param_values,
@@ -126,7 +126,7 @@
                                         gpointer      invocation_hint,
                                         gpointer      marshal_data);
 
-/* BOOLEAN:BOOLEAN (./gtkmarshalers.list:39) */
+
 extern void _gtk_marshal_BOOLEAN__BOOLEAN (GClosure     *closure,
                                            GValue       *return_value,
                                            guint         n_param_values,
@@ -134,10 +134,10 @@
                                            gpointer      invocation_hint,
                                            gpointer      marshal_data);
 
-/* BOOLEAN:NONE (./gtkmarshalers.list:40) */
+
 #define _gtk_marshal_BOOLEAN__NONE	_gtk_marshal_BOOLEAN__VOID
 
-/* BOOLEAN:BOOLEAN,BOOLEAN,BOOLEAN (./gtkmarshalers.list:41) */
+
 extern void _gtk_marshal_BOOLEAN__BOOLEAN_BOOLEAN_BOOLEAN (GClosure     *closure,
                                                            GValue       *return_value,
                                                            guint         n_param_values,
@@ -145,7 +145,7 @@
                                                            gpointer      invocation_hint,
                                                            gpointer      marshal_data);
 
-/* BOOLEAN:STRING (./gtkmarshalers.list:42) */
+
 extern void _gtk_marshal_BOOLEAN__STRING (GClosure     *closure,
                                           GValue       *return_value,
                                           guint         n_param_values,
@@ -153,7 +153,7 @@
                                           gpointer      invocation_hint,
                                           gpointer      marshal_data);
 
-/* ENUM:ENUM (./gtkmarshalers.list:43) */
+
 extern void _gtk_marshal_ENUM__ENUM (GClosure     *closure,
                                      GValue       *return_value,
                                      guint         n_param_values,
@@ -161,7 +161,7 @@
                                      gpointer      invocation_hint,
                                      gpointer      marshal_data);
 
-/* INT:POINTER (./gtkmarshalers.list:44) */
+
 extern void _gtk_marshal_INT__POINTER (GClosure     *closure,
                                        GValue       *return_value,
                                        guint         n_param_values,
@@ -169,19 +169,19 @@
                                        gpointer      invocation_hint,
                                        gpointer      marshal_data);
 
-/* NONE:BOOLEAN (./gtkmarshalers.list:45) */
+
 #define _gtk_marshal_VOID__BOOLEAN	g_cclosure_marshal_VOID__BOOLEAN
 #define _gtk_marshal_NONE__BOOLEAN	_gtk_marshal_VOID__BOOLEAN
 
-/* NONE:ENUM (./gtkmarshalers.list:46) */
+
 #define _gtk_marshal_VOID__ENUM	g_cclosure_marshal_VOID__ENUM
 #define _gtk_marshal_NONE__ENUM	_gtk_marshal_VOID__ENUM
 
-/* NONE:INT (./gtkmarshalers.list:47) */
+
 #define _gtk_marshal_VOID__INT	g_cclosure_marshal_VOID__INT
 #define _gtk_marshal_NONE__INT	_gtk_marshal_VOID__INT
 
-/* NONE:INT,BOOL (./gtkmarshalers.list:48) */
+
 extern void _gtk_marshal_VOID__INT_BOOLEAN (GClosure     *closure,
                                             GValue       *return_value,
                                             guint         n_param_values,
@@ -190,7 +190,7 @@
                                             gpointer      marshal_data);
 #define _gtk_marshal_NONE__INT_BOOL	_gtk_marshal_VOID__INT_BOOLEAN
 
-/* NONE:INT,INT (./gtkmarshalers.list:49) */
+
 extern void _gtk_marshal_VOID__INT_INT (GClosure     *closure,
                                         GValue       *return_value,
                                         guint         n_param_values,
@@ -199,11 +199,11 @@
                                         gpointer      marshal_data);
 #define _gtk_marshal_NONE__INT_INT	_gtk_marshal_VOID__INT_INT
 
-/* NONE:NONE (./gtkmarshalers.list:50) */
+
 #define _gtk_marshal_VOID__VOID	g_cclosure_marshal_VOID__VOID
 #define _gtk_marshal_NONE__NONE	_gtk_marshal_VOID__VOID
 
-/* NONE:STRING,INT,POINTER (./gtkmarshalers.list:51) */
+
 extern void _gtk_marshal_VOID__STRING_INT_POINTER (GClosure     *closure,
                                                    GValue       *return_value,
                                                    guint         n_param_values,
@@ -212,7 +212,7 @@
                                                    gpointer      marshal_data);
 #define _gtk_marshal_NONE__STRING_INT_POINTER	_gtk_marshal_VOID__STRING_INT_POINTER
 
-/* STRING:DOUBLE (./gtkmarshalers.list:52) */
+
 extern void _gtk_marshal_STRING__DOUBLE (GClosure     *closure,
                                          GValue       *return_value,
                                          guint         n_param_values,
@@ -220,12 +220,12 @@
                                          gpointer      invocation_hint,
                                          gpointer      marshal_data);
 
-/* VOID:DOUBLE (./gtkmarshalers.list:53) */
+
 #define _gtk_marshal_VOID__DOUBLE	g_cclosure_marshal_VOID__DOUBLE
 
-/* VOID:BOOLEAN (./gtkmarshalers.list:54) */
 
-/* VOID:BOOLEAN,BOOLEAN,BOOLEAN (./gtkmarshalers.list:55) */
+
+
 extern void _gtk_marshal_VOID__BOOLEAN_BOOLEAN_BOOLEAN (GClosure     *closure,
                                                         GValue       *return_value,
                                                         guint         n_param_values,
@@ -233,10 +233,10 @@
                                                         gpointer      invocation_hint,
                                                         gpointer      marshal_data);
 
-/* VOID:BOXED (./gtkmarshalers.list:56) */
+
 #define _gtk_marshal_VOID__BOXED	g_cclosure_marshal_VOID__BOXED
 
-/* VOID:BOXED,BOXED (./gtkmarshalers.list:57) */
+
 extern void _gtk_marshal_VOID__BOXED_BOXED (GClosure     *closure,
                                             GValue       *return_value,
                                             guint         n_param_values,
@@ -244,7 +244,7 @@
                                             gpointer      invocation_hint,
                                             gpointer      marshal_data);
 
-/* VOID:BOXED,BOXED,POINTER (./gtkmarshalers.list:58) */
+
 extern void _gtk_marshal_VOID__BOXED_BOXED_POINTER (GClosure     *closure,
                                                     GValue       *return_value,
                                                     guint         n_param_values,
@@ -252,7 +252,7 @@
                                                     gpointer      invocation_hint,
                                                     gpointer      marshal_data);
 
-/* VOID:BOXED,OBJECT (./gtkmarshalers.list:59) */
+
 extern void _gtk_marshal_VOID__BOXED_OBJECT (GClosure     *closure,
                                              GValue       *return_value,
                                              guint         n_param_values,
@@ -260,7 +260,7 @@
                                              gpointer      invocation_hint,
                                              gpointer      marshal_data);
 
-/* VOID:BOXED,STRING,INT (./gtkmarshalers.list:60) */
+
 extern void _gtk_marshal_VOID__BOXED_STRING_INT (GClosure     *closure,
                                                  GValue       *return_value,
                                                  guint         n_param_values,
@@ -268,7 +268,7 @@
                                                  gpointer      invocation_hint,
                                                  gpointer      marshal_data);
 
-/* VOID:BOXED,UINT (./gtkmarshalers.list:61) */
+
 extern void _gtk_marshal_VOID__BOXED_UINT (GClosure     *closure,
                                            GValue       *return_value,
                                            guint         n_param_values,
@@ -276,7 +276,7 @@
                                            gpointer      invocation_hint,
                                            gpointer      marshal_data);
 
-/* VOID:BOXED,UINT,FLAGS (./gtkmarshalers.list:62) */
+
 extern void _gtk_marshal_VOID__BOXED_UINT_FLAGS (GClosure     *closure,
                                                  GValue       *return_value,
                                                  guint         n_param_values,
@@ -284,7 +284,7 @@
                                                  gpointer      invocation_hint,
                                                  gpointer      marshal_data);
 
-/* VOID:BOXED,UINT,UINT (./gtkmarshalers.list:63) */
+
 extern void _gtk_marshal_VOID__BOXED_UINT_UINT (GClosure     *closure,
                                                 GValue       *return_value,
                                                 guint         n_param_values,
@@ -292,9 +292,8 @@
                                                 gpointer      invocation_hint,
                                                 gpointer      marshal_data);
 
-/* VOID:ENUM (./gtkmarshalers.list:64) */
 
-/* VOID:ENUM,BOOLEAN (./gtkmarshalers.list:65) */
+
 extern void _gtk_marshal_VOID__ENUM_BOOLEAN (GClosure     *closure,
                                              GValue       *return_value,
                                              guint         n_param_values,
@@ -302,7 +301,7 @@
                                              gpointer      invocation_hint,
                                              gpointer      marshal_data);
 
-/* VOID:ENUM,ENUM (./gtkmarshalers.list:66) */
+
 extern void _gtk_marshal_VOID__ENUM_ENUM (GClosure     *closure,
                                           GValue       *return_value,
                                           guint         n_param_values,
@@ -310,7 +309,7 @@
                                           gpointer      invocation_hint,
                                           gpointer      marshal_data);
 
-/* VOID:ENUM,FLOAT (./gtkmarshalers.list:67) */
+
 extern void _gtk_marshal_VOID__ENUM_FLOAT (GClosure     *closure,
                                            GValue       *return_value,
                                            guint         n_param_values,
@@ -318,7 +317,7 @@
                                            gpointer      invocation_hint,
                                            gpointer      marshal_data);
 
-/* VOID:ENUM,FLOAT,BOOLEAN (./gtkmarshalers.list:68) */
+
 extern void _gtk_marshal_VOID__ENUM_FLOAT_BOOLEAN (GClosure     *closure,
                                                    GValue       *return_value,
                                                    guint         n_param_values,
@@ -326,7 +325,7 @@
                                                    gpointer      invocation_hint,
                                                    gpointer      marshal_data);
 
-/* VOID:ENUM,INT (./gtkmarshalers.list:69) */
+
 extern void _gtk_marshal_VOID__ENUM_INT (GClosure     *closure,
                                          GValue       *return_value,
                                          guint         n_param_values,
@@ -334,7 +333,7 @@
                                          gpointer      invocation_hint,
                                          gpointer      marshal_data);
 
-/* VOID:ENUM,INT,BOOLEAN (./gtkmarshalers.list:70) */
+
 extern void _gtk_marshal_VOID__ENUM_INT_BOOLEAN (GClosure     *closure,
                                                  GValue       *return_value,
                                                  guint         n_param_values,
@@ -342,11 +341,6 @@
                                                  gpointer      invocation_hint,
                                                  gpointer      marshal_data);
 
-/* VOID:INT (./gtkmarshalers.list:71) */
-
-/* VOID:INT,INT (./gtkmarshalers.list:72) */
-
-/* VOID:INT,INT,BOXED (./gtkmarshalers.list:73) */
 extern void _gtk_marshal_VOID__INT_INT_BOXED (GClosure     *closure,
                                               GValue       *return_value,
                                               guint         n_param_values,
@@ -354,7 +348,7 @@
                                               gpointer      invocation_hint,
                                               gpointer      marshal_data);
 
-/* VOID:INT,INT,INT (./gtkmarshalers.list:74) */
+
 extern void _gtk_marshal_VOID__INT_INT_INT (GClosure     *closure,
                                             GValue       *return_value,
                                             guint         n_param_values,
@@ -362,10 +356,10 @@
                                             gpointer      invocation_hint,
                                             gpointer      marshal_data);
 
-/* VOID:OBJECT (./gtkmarshalers.list:75) */
+
 #define _gtk_marshal_VOID__OBJECT	g_cclosure_marshal_VOID__OBJECT
 
-/* VOID:OBJECT,BOOLEAN (./gtkmarshalers.list:76) */
+
 extern void _gtk_marshal_VOID__OBJECT_BOOLEAN (GClosure     *closure,
                                                GValue       *return_value,
                                                guint         n_param_values,
@@ -373,7 +367,7 @@
                                                gpointer      invocation_hint,
                                                gpointer      marshal_data);
 
-/* VOID:OBJECT,BOXED,BOXED (./gtkmarshalers.list:77) */
+
 extern void _gtk_marshal_VOID__OBJECT_BOXED_BOXED (GClosure     *closure,
                                                    GValue       *return_value,
                                                    guint         n_param_values,
@@ -381,7 +375,7 @@
                                                    gpointer      invocation_hint,
                                                    gpointer      marshal_data);
 
-/* VOID:OBJECT,BOXED,UINT,UINT (./gtkmarshalers.list:78) */
+
 extern void _gtk_marshal_VOID__OBJECT_BOXED_UINT_UINT (GClosure     *closure,
                                                        GValue       *return_value,
                                                        guint         n_param_values,
@@ -389,7 +383,7 @@
                                                        gpointer      invocation_hint,
                                                        gpointer      marshal_data);
 
-/* VOID:OBJECT,INT,INT (./gtkmarshalers.list:79) */
+
 extern void _gtk_marshal_VOID__OBJECT_INT_INT (GClosure     *closure,
                                                GValue       *return_value,
                                                guint         n_param_values,
@@ -397,7 +391,7 @@
                                                gpointer      invocation_hint,
                                                gpointer      marshal_data);
 
-/* VOID:OBJECT,INT,INT,BOXED,UINT,UINT (./gtkmarshalers.list:80) */
+
 extern void _gtk_marshal_VOID__OBJECT_INT_INT_BOXED_UINT_UINT (GClosure     *closure,
                                                                GValue       *return_value,
                                                                guint         n_param_values,
@@ -405,7 +399,7 @@
                                                                gpointer      invocation_hint,
                                                                gpointer      marshal_data);
 
-/* VOID:OBJECT,OBJECT (./gtkmarshalers.list:81) */
+
 extern void _gtk_marshal_VOID__OBJECT_OBJECT (GClosure     *closure,
                                               GValue       *return_value,
                                               guint         n_param_values,
@@ -413,7 +407,7 @@
                                               gpointer      invocation_hint,
                                               gpointer      marshal_data);
 
-/* VOID:OBJECT,STRING (./gtkmarshalers.list:82) */
+
 extern void _gtk_marshal_VOID__OBJECT_STRING (GClosure     *closure,
                                               GValue       *return_value,
                                               guint         n_param_values,
@@ -421,7 +415,7 @@
                                               gpointer      invocation_hint,
                                               gpointer      marshal_data);
 
-/* VOID:OBJECT,STRING,STRING (./gtkmarshalers.list:83) */
+
 extern void _gtk_marshal_VOID__OBJECT_STRING_STRING (GClosure     *closure,
                                                      GValue       *return_value,
                                                      guint         n_param_values,
@@ -429,7 +423,7 @@
                                                      gpointer      invocation_hint,
                                                      gpointer      marshal_data);
 
-/* VOID:OBJECT,UINT (./gtkmarshalers.list:84) */
+
 extern void _gtk_marshal_VOID__OBJECT_UINT (GClosure     *closure,
                                             GValue       *return_value,
                                             guint         n_param_values,
@@ -437,7 +431,7 @@
                                             gpointer      invocation_hint,
                                             gpointer      marshal_data);
 
-/* VOID:OBJECT,UINT,FLAGS (./gtkmarshalers.list:85) */
+
 extern void _gtk_marshal_VOID__OBJECT_UINT_FLAGS (GClosure     *closure,
                                                   GValue       *return_value,
                                                   guint         n_param_values,
@@ -445,12 +439,10 @@
                                                   gpointer      invocation_hint,
                                                   gpointer      marshal_data);
 
-/* VOID:OBJECT,STRING (./gtkmarshalers.list:86) */
 
-/* VOID:POINTER (./gtkmarshalers.list:87) */
 #define _gtk_marshal_VOID__POINTER	g_cclosure_marshal_VOID__POINTER
 
-/* VOID:POINTER,INT (./gtkmarshalers.list:88) */
+
 extern void _gtk_marshal_VOID__POINTER_INT (GClosure     *closure,
                                             GValue       *return_value,
                                             guint         n_param_values,
@@ -458,7 +450,7 @@
                                             gpointer      invocation_hint,
                                             gpointer      marshal_data);
 
-/* VOID:POINTER,BOOLEAN (./gtkmarshalers.list:89) */
+
 extern void _gtk_marshal_VOID__POINTER_BOOLEAN (GClosure     *closure,
                                                 GValue       *return_value,
                                                 guint         n_param_values,
@@ -466,7 +458,7 @@
                                                 gpointer      invocation_hint,
                                                 gpointer      marshal_data);
 
-/* VOID:POINTER,POINTER,POINTER (./gtkmarshalers.list:90) */
+
 extern void _gtk_marshal_VOID__POINTER_POINTER_POINTER (GClosure     *closure,
                                                         GValue       *return_value,
                                                         guint         n_param_values,
@@ -474,7 +466,7 @@
                                                         gpointer      invocation_hint,
                                                         gpointer      marshal_data);
 
-/* VOID:POINTER,UINT (./gtkmarshalers.list:91) */
+
 extern void _gtk_marshal_VOID__POINTER_UINT (GClosure     *closure,
                                              GValue       *return_value,
                                              guint         n_param_values,
@@ -482,10 +474,10 @@
                                              gpointer      invocation_hint,
                                              gpointer      marshal_data);
 
-/* VOID:STRING (./gtkmarshalers.list:92) */
+
 #define _gtk_marshal_VOID__STRING	g_cclosure_marshal_VOID__STRING
 
-/* VOID:STRING,STRING (./gtkmarshalers.list:93) */
+
 extern void _gtk_marshal_VOID__STRING_STRING (GClosure     *closure,
                                               GValue       *return_value,
                                               guint         n_param_values,
@@ -493,9 +485,9 @@
                                               gpointer      invocation_hint,
                                               gpointer      marshal_data);
 
-/* VOID:STRING,INT,POINTER (./gtkmarshalers.list:94) */
 
-/* VOID:STRING,UINT,FLAGS (./gtkmarshalers.list:95) */
+
+
 extern void _gtk_marshal_VOID__STRING_UINT_FLAGS (GClosure     *closure,
                                                   GValue       *return_value,
                                                   guint         n_param_values,
@@ -503,7 +495,7 @@
                                                   gpointer      invocation_hint,
                                                   gpointer      marshal_data);
 
-/* VOID:UINT,FLAGS,BOXED (./gtkmarshalers.list:96) */
+
 extern void _gtk_marshal_VOID__UINT_FLAGS_BOXED (GClosure     *closure,
                                                  GValue       *return_value,
                                                  guint         n_param_values,
@@ -511,7 +503,7 @@
                                                  gpointer      invocation_hint,
                                                  gpointer      marshal_data);
 
-/* VOID:UINT,UINT (./gtkmarshalers.list:97) */
+
 extern void _gtk_marshal_VOID__UINT_UINT (GClosure     *closure,
                                           GValue       *return_value,
                                           guint         n_param_values,
@@ -519,7 +511,7 @@
                                           gpointer      invocation_hint,
                                           gpointer      marshal_data);
 
-/* VOID:UINT,STRING (./gtkmarshalers.list:98) */
+
 extern void _gtk_marshal_VOID__UINT_STRING (GClosure     *closure,
                                             GValue       *return_value,
                                             guint         n_param_values,
@@ -527,7 +519,7 @@
                                             gpointer      invocation_hint,
                                             gpointer      marshal_data);
 
-/* VOID:UINT,BOXED,UINT,FLAGS,FLAGS (./gtkmarshalers.list:99) */
+
 extern void _gtk_marshal_VOID__UINT_BOXED_UINT_FLAGS_FLAGS (GClosure     *closure,
                                                             GValue       *return_value,
                                                             guint         n_param_values,
@@ -535,7 +527,7 @@
                                                             gpointer      invocation_hint,
                                                             gpointer      marshal_data);
 
-/* VOID:UINT,OBJECT,UINT,FLAGS,FLAGS (./gtkmarshalers.list:100) */
+
 extern void _gtk_marshal_VOID__UINT_OBJECT_UINT_FLAGS_FLAGS (GClosure     *closure,
                                                              GValue       *return_value,
                                                              guint         n_param_values,
@@ -543,7 +535,7 @@
                                                              gpointer      invocation_hint,
                                                              gpointer      marshal_data);
 
-/* VOID:VOID (./gtkmarshalers.list:101) */
+
 
 G_END_DECLS
 
--- gtk+/gtk/gtkentry.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkentry.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -24,6 +24,10 @@
  * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
  */
 
+/* Modified by Nokia Corporation - 2005.
+ * 
+ */
+
 #include <config.h>
 #include <string.h>
 
@@ -56,10 +60,13 @@
 
 #define GTK_ENTRY_COMPLETION_KEY "gtk-entry-completion-key"
 
-#define MIN_ENTRY_WIDTH  150
-#define DRAW_TIMEOUT     20
-#define INNER_BORDER     2
+#define MIN_ENTRY_WIDTH   150
+#define DRAW_TIMEOUT      20
+#define INNER_BORDER      2
+#define CARET_CURSOR_SIZE 1
 #define COMPLETION_TIMEOUT 300
+#define HILDON_EDITED_CHARACTER_MAX 8
+#define HILDON_EDITED_CHARACTER_MS 600  /* 0.6 seconds */
 
 /* Initial size of buffer, in bytes */
 #define MIN_SIZE 16
@@ -75,6 +82,18 @@
 {
   gfloat xalign;
   gint insert_pos;
+  /* Hildon additions:
+   * following variables are needed
+   * for Hildon password 'preview'
+   * functionality; last inputted character
+   * is showed for defined period, before it is
+   * rendered to '*'
+   */
+  gchar hildon_edited_character[HILDON_EDITED_CHARACTER_MAX];
+  gboolean  hildon_edited_character_timeout;
+  gint  hildon_edited_character_length;
+  gboolean keep_focus;
+  gboolean menu_popped; 
 };
 
 enum {
@@ -88,6 +107,7 @@
   COPY_CLIPBOARD,
   PASTE_CLIPBOARD,
   TOGGLE_OVERWRITE,
+  INVALID_INPUT,
   LAST_SIGNAL
 };
 
@@ -104,7 +124,9 @@
   PROP_WIDTH_CHARS,
   PROP_SCROLL_OFFSET,
   PROP_TEXT,
-  PROP_XALIGN
+  PROP_XALIGN,
+  PROP_AUTOCAP,
+  PROP_INPUT_MODE
 };
 
 static guint signals[LAST_SIGNAL] = { 0 };
@@ -165,6 +187,7 @@
 					      GtkStateType      previous_state);
 static void   gtk_entry_screen_changed       (GtkWidget        *widget,
 					      GdkScreen        *old_screen);
+static void   gtk_entry_unmap                (GtkWidget        *widget);
 
 static gboolean gtk_entry_drag_drop          (GtkWidget        *widget,
                                               GdkDragContext   *context,
@@ -324,6 +347,22 @@
 							gint           *y,
 							gint           *width,
 							gint           *height);
+static void         gtk_entry_set_autocap              (GtkEntry       *entry,
+                                                        gboolean       autocap);
+static gboolean     gtk_entry_get_autocap              (GtkEntry       *entry);
+static void         gtk_entry_set_input_mode           (GtkEntry       *entry,
+                                                        gboolean       mode);
+static gint         gtk_entry_get_input_mode           (GtkEntry       *entry);
+
+/*Change for Hildon
+ *returns an iterator to the character at position x,y of the
+ *layout
+ *returns NULL if no iterator was found at that position
+ *Caller must call pango_layout_free_iter on the returned iterator
+ */
+static PangoLayoutIter *get_char_at_pos( PangoLayout *layout, gint x, gint y );
+
+static gboolean hildon_remove_visible_character( gpointer data );
 
 /* Completion */
 static gint         gtk_entry_completion_timeout       (gpointer            data);
@@ -464,6 +503,7 @@
   widget_class->drag_data_received = gtk_entry_drag_data_received;
   widget_class->drag_data_get = gtk_entry_drag_data_get;
   widget_class->drag_data_delete = gtk_entry_drag_data_delete;
+  widget_class->unmap = gtk_entry_unmap; 
 
   widget_class->popup_menu = gtk_entry_popup_menu;
 
@@ -523,7 +563,25 @@
 							 P_("FALSE displays the \"invisible char\" instead of the actual text (password mode)"),
                                                          TRUE,
 							 G_PARAM_READABLE | G_PARAM_WRITABLE));
-
+  
+  g_object_class_install_property (gobject_class,
+                                   PROP_AUTOCAP,
+                                   g_param_spec_boolean ("autocap",
+                                                         P_("auto capitalization"),
+                                                         P_("Enable autocap support"),
+                                                         TRUE,
+                                                         G_PARAM_READABLE | G_PARAM_WRITABLE)); 
+  
+  g_object_class_install_property (gobject_class,
+                                   PROP_INPUT_MODE,
+                                   g_param_spec_int ("input_mode",
+                                                     P_("input mode"),
+                                                     P_("Define widget's input mode"),
+                                                     0,
+                                                     9, /* keep me updated */
+                                                     0,
+                                                     G_PARAM_READABLE | G_PARAM_WRITABLE)); 
+  
   g_object_class_install_property (gobject_class,
                                    PROP_HAS_FRAME,
                                    g_param_spec_boolean ("has_frame",
@@ -593,6 +651,40 @@
 						       0.0,
 						       G_PARAM_READABLE | G_PARAM_WRITABLE));
   
+ gtk_widget_class_install_style_property (widget_class,
+                                          g_param_spec_int ("horizontal-border",
+							      P_("Horizontal borders for entry"),
+							      P_("Set left/right borders"),
+     							      0,
+							      G_MAXINT,
+ 							      INNER_BORDER,
+							      G_PARAM_READWRITE));
+
+  gtk_widget_class_install_style_property (widget_class,
+                                          g_param_spec_int ("vertical-border",
+							      P_("Vertical borders for entry"),
+							      P_("Set top/bottom borders"),
+							      0,
+  							      G_MAXINT,
+              						      INNER_BORDER,
+							      G_PARAM_READWRITE));
+
+  gtk_widget_class_install_style_property (widget_class,
+                                          g_param_spec_int ("icon-width",
+							      P_("Icon Width"),
+							      P_("Size of the purpose icon."),
+							      0,
+  							      G_MAXINT,
+              						      0,
+							      G_PARAM_READWRITE));
+  
+  gtk_widget_class_install_style_property (widget_class,
+                                          g_param_spec_boolean ("show-last-char",
+							      P_("Show last char in invisible mode for a while"),
+							      P_("Last char is shown before it is rendered to asterisk"),
+							      FALSE,
+							      G_PARAM_READABLE | G_PARAM_WRITABLE));
+
   signals[POPULATE_POPUP] =
     g_signal_new ("populate_popup",
 		  G_OBJECT_CLASS_TYPE (gobject_class),
@@ -693,6 +785,16 @@
 		  _gtk_marshal_VOID__VOID,
 		  G_TYPE_NONE, 0);
 
+  signals[INVALID_INPUT] =
+    g_signal_new ("invalid_input",
+		  G_OBJECT_CLASS_TYPE (gobject_class),
+		  G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+		  G_STRUCT_OFFSET (GtkEntryClass, invalid_input),
+		  NULL, NULL,
+		  _gtk_marshal_VOID__ENUM,
+		  G_TYPE_NONE, 1,
+                  GTK_TYPE_INVALID_INPUT_TYPE);
+
   /*
    * Key bindings
    */
@@ -853,6 +955,22 @@
   iface->start_editing = gtk_entry_start_editing;
 }
 
+/* HILDON: Timed function to hide the most recently inputted character in password mode
+*/
+static gboolean
+ hildon_remove_visible_character( gpointer data )
+{
+    g_return_val_if_fail (GTK_IS_WIDGET (data), FALSE);
+
+    GtkEntry * entry = GTK_ENTRY( data );
+                                                                                        
+    /* Force the string to redrawn, but now without a visible character */
+    gtk_entry_recompute( entry );
+                                                                                        
+    /* Return false so this timeout is not called again and destroyed */
+    return FALSE;
+}
+
 static void
 gtk_entry_set_property (GObject         *object,
                         guint            prop_id,
@@ -869,7 +987,7 @@
 
       	if (new_value != entry->editable)
 	  {
-	    if (!new_value)
+            if (!new_value)
 	      {
 		gtk_entry_reset_im_context (entry);
 		if (GTK_WIDGET_HAS_FOCUS (entry))
@@ -880,6 +998,7 @@
 	      }
 
 	    entry->editable = new_value;
+            gtk_widget_set_sensitive( GTK_WIDGET( entry ), entry->editable );
 
 	    if (new_value && GTK_WIDGET_HAS_FOCUS (entry))
 	      gtk_im_context_focus_in (entry->im_context);
@@ -896,6 +1015,14 @@
     case PROP_VISIBILITY:
       gtk_entry_set_visibility (entry, g_value_get_boolean (value));
       break;
+      
+    case PROP_AUTOCAP:
+      gtk_entry_set_autocap (entry, g_value_get_boolean (value));
+      break;
+
+    case PROP_INPUT_MODE:
+      gtk_entry_set_input_mode (entry, g_value_get_int (value));
+      break;
 
     case PROP_HAS_FRAME:
       gtk_entry_set_has_frame (entry, g_value_get_boolean (value));
@@ -954,6 +1081,12 @@
     case PROP_VISIBILITY:
       g_value_set_boolean (value, entry->visible);
       break;
+    case PROP_AUTOCAP:
+      g_value_set_boolean (value, gtk_entry_get_autocap (entry));
+      break;
+    case PROP_INPUT_MODE:
+	g_value_set_int (value, gtk_entry_get_input_mode (entry));
+      break;
     case PROP_HAS_FRAME:
       g_value_set_boolean (value, entry->has_frame);
       break;
@@ -1000,7 +1133,20 @@
   entry->width_chars = -1;
   entry->is_cell_renderer = FALSE;
   entry->editing_canceled = FALSE;
-  entry->has_frame = TRUE;
+#ifdef HILDON_SINGLE_LINE_EDITOR
+  entry->has_frame = FALSE;
+#else
+    entry->has_frame = TRUE;
+#endif
+
+  /* Hildon */
+  memset( &priv->hildon_edited_character, 0x00, HILDON_EDITED_CHARACTER_MAX );
+  priv->hildon_edited_character_length = 0;
+  priv->hildon_edited_character_timeout = FALSE;
+  
+  priv->keep_focus = FALSE;
+  priv->menu_popped = FALSE;
+  
   priv->xalign = 0.0;
 
   gtk_drag_dest_set (GTK_WIDGET (entry),
@@ -1013,6 +1159,10 @@
    * to it; so we create it here and destroy it in finalize().
    */
   entry->im_context = gtk_im_multicontext_new ();
+  /* Set default stuff. */
+  gtk_entry_set_autocap (entry, TRUE);
+  gtk_entry_set_input_mode (entry, 0); /* alpha-numeric-special */
+  g_object_set (G_OBJECT (entry->im_context), "use-show-hide", TRUE, NULL);
   
   g_signal_connect (entry->im_context, "commit",
 		    G_CALLBACK (gtk_entry_commit_cb), entry);
@@ -1058,7 +1208,8 @@
 gtk_entry_finalize (GObject *object)
 {
   GtkEntry *entry = GTK_ENTRY (object);
-
+  GtkEntryPrivate *priv = GTK_ENTRY_GET_PRIVATE (GTK_WIDGET (entry));
+ 
   gtk_entry_set_completion (entry, NULL);
 
   if (entry->cached_layout)
@@ -1072,6 +1223,9 @@
   if (entry->recompute_idle)
     g_source_remove (entry->recompute_idle);
 
+  if (priv->hildon_edited_character_timeout)
+    g_source_remove (priv->hildon_edited_character_timeout);
+
   entry->text_size = 0;
 
   if (entry->text)
@@ -1213,7 +1367,14 @@
   PangoFontMetrics *metrics;
   gint xborder, yborder;
   PangoContext *context;
-  
+  gint border_x, border_y;
+  gint icon_width;
+
+  gtk_widget_style_get (widget,
+                        "horizontal-border", &border_x,
+                        "vertical-border", &border_y,
+                        "icon-width", &icon_width, NULL);
+
   gtk_widget_ensure_style (widget);
   context = gtk_widget_get_pango_context (widget);
   metrics = pango_context_get_metrics (context,
@@ -1225,21 +1386,22 @@
   
   _gtk_entry_get_borders (entry, &xborder, &yborder);
   
-  xborder += INNER_BORDER;
-  yborder += INNER_BORDER;
+  xborder += border_x<<1;
+  yborder += border_y<<1;
   
   if (entry->width_chars < 0)
-    requisition->width = MIN_ENTRY_WIDTH + xborder * 2;
+    requisition->width = MIN_ENTRY_WIDTH + xborder;
   else
     {
       gint char_width = pango_font_metrics_get_approximate_char_width (metrics);
       gint digit_width = pango_font_metrics_get_approximate_digit_width (metrics);
       gint char_pixels = (MAX (char_width, digit_width) + PANGO_SCALE - 1) / PANGO_SCALE;
       
-      requisition->width = char_pixels * entry->width_chars + xborder * 2;
+      requisition->width = char_pixels * entry->width_chars + xborder;
     }
-    
-  requisition->height = PANGO_PIXELS (entry->ascent + entry->descent) + yborder * 2;
+  
+  requisition->width += icon_width;  
+  requisition->height = PANGO_PIXELS (entry->ascent + entry->descent) + yborder;
 
   pango_font_metrics_unref (metrics);
 }
@@ -1253,23 +1415,39 @@
 {
   gint xborder, yborder;
   GtkRequisition requisition;
+  gint icon_width;
   GtkWidget *widget = GTK_WIDGET (entry);
 
+  gtk_widget_style_get (widget, "icon-width", &icon_width, NULL);
+  
   gtk_widget_get_child_requisition (widget, &requisition);
 
   _gtk_entry_get_borders (entry, &xborder, &yborder);
 
   if (x)
-    *x = xborder;
+    *x = xborder + icon_width;
 
   if (y)
+  {
     *y = yborder;
+    if( widget->allocation.height < requisition.height )
+      *y += ((widget->allocation.height - requisition.height) / 2);
+    if( *y < yborder )
+      *y = yborder;
+  }
   
-  if (width)
-    *width = GTK_WIDGET (entry)->allocation.width - xborder * 2;
+  if (width) 
+    *width = GTK_WIDGET (entry)->allocation.width - xborder * 2 - icon_width + CARET_CURSOR_SIZE;
 
   if (height)
-    *height = requisition.height - yborder * 2;
+  {
+    if( widget->allocation.height < requisition.height )
+      *height = widget->allocation.height - yborder * 2;
+    else
+      *height = widget->requisition.height - yborder * 2;
+    if( *height <=0 )
+      *height = 1;
+  }
 }
 
 static void
@@ -1289,10 +1467,9 @@
 
   if (y)
     {
-      if (entry->is_cell_renderer)
-	*y = widget->allocation.y;
-      else
-	*y = widget->allocation.y + (widget->allocation.height - requisition.height) / 2;
+    	*y = widget->allocation.y;
+      if( widget->allocation.height > requisition.height )
+      	*y += ((widget->allocation.height - requisition.height) / 2);
     }
 
   if (width)
@@ -1300,10 +1477,10 @@
 
   if (height)
     {
-      if (entry->is_cell_renderer)
-	*height = widget->allocation.height;
-      else
+      if( widget->allocation.height > requisition.height )
 	*height = requisition.height;
+      else
+	*height = widget->allocation.height;
     }
 }
 
@@ -1383,20 +1560,19 @@
 		  GdkEventExpose *event)
 {
   GtkEntry *entry = GTK_ENTRY (widget);
+  gint area_width, area_height;
+  
+  get_widget_window_size (entry, NULL, NULL, &area_width, &area_height);
 
   if (widget->window == event->window)
-    gtk_entry_draw_frame (widget);
+    {
+      gtk_paint_box (widget->style, widget->window,
+                     GTK_WIDGET_STATE (widget), GTK_SHADOW_NONE,
+                     NULL, widget, "entry_frame",
+                     0, 0, area_width, area_height);
+    }
   else if (entry->text_area == event->window)
     {
-      gint area_width, area_height;
-
-      get_text_area_size (entry, NULL, NULL, &area_width, &area_height);
-
-      gtk_paint_flat_box (widget->style, entry->text_area, 
-			  GTK_WIDGET_STATE(widget), GTK_SHADOW_NONE,
-			  NULL, widget, "entry_bg", 
-			  0, 0, area_width, area_height);
-      
       if ((entry->visible || entry->invisible_char != 0) &&
 	  GTK_WIDGET_HAS_FOCUS (widget) &&
 	  entry->selection_bound == entry->current_pos && entry->cursor_visible)
@@ -1490,16 +1666,19 @@
     return FALSE;
 
   entry->button = event->button;
-  
+
   if (!GTK_WIDGET_HAS_FOCUS (widget))
     {
       entry->in_click = TRUE;
       gtk_widget_grab_focus (widget);
       entry->in_click = FALSE;
     }
-  
+
+  /* Hildon: we need to reset IM context so pre-edit string can be committed */
+  gtk_entry_reset_im_context (entry);
+
   tmp_pos = gtk_entry_find_position (entry, event->x + entry->scroll_offset);
-    
+  
   if (event->button == 1)
     {
       gboolean have_selection = gtk_editable_get_selection_bounds (editable, &sel_start, &sel_end);
@@ -1509,8 +1688,6 @@
 
       if (event->state & GDK_SHIFT_MASK)
 	{
-	  gtk_entry_reset_im_context (entry);
-	  
 	  if (!have_selection) /* select from the current position to the clicked position */
 	    sel_start = sel_end = entry->current_pos;
 	  
@@ -1573,11 +1750,13 @@
 	       */
 	      entry->in_drag = TRUE;
 	      entry->drag_start_x = event->x + entry->scroll_offset;
-	      entry->drag_start_y = event->y + entry->scroll_offset;
+	      entry->drag_start_y = event->y;
 	    }
-	  else
+	  else {
 	    gtk_editable_set_position (editable, tmp_pos);
-	  break;
+	  }
+
+          break;
  
 	case GDK_2BUTTON_PRESS:
 	  /* We ALWAYS receive a GDK_BUTTON_PRESS immediately before 
@@ -1614,8 +1793,16 @@
     }
   else if (event->button == 3 && event->type == GDK_BUTTON_PRESS)
     {
+      /* Hildon: if we are in password mode selection and Cut & Copy should
+         be disabled. */
+      if (!entry->visible)
+        {
+           gtk_editable_set_position (GTK_EDITABLE(entry), 0);
+        }
+
       gtk_entry_do_popup (entry, event);
       entry->button = 0;	/* Don't wait for release, since the menu will gtk_grab_add */
+      priv->keep_focus = TRUE;
 
       return TRUE;
     }
@@ -1632,12 +1819,14 @@
   if (event->window != entry->text_area || entry->button != event->button)
     return FALSE;
 
+  if (entry->editable)
+    gtk_im_context_show (entry->im_context);
+
   if (entry->in_drag)
     {
       gint tmp_pos = gtk_entry_find_position (entry, entry->drag_start_x);
 
       gtk_editable_set_position (GTK_EDITABLE (entry), tmp_pos);
-
       entry->in_drag = 0;
     }
   
@@ -1768,7 +1957,7 @@
   empty_bitmap = gdk_bitmap_create_from_data (window,
 					      invisible_cursor_bits,
 					      1, 1);
-  
+
   cursor = gdk_cursor_new_from_pixmap (empty_bitmap,
 				       empty_bitmap,
 				       &useless,
@@ -1822,6 +2011,13 @@
         }
     }
 
+  if (event->keyval == GDK_Return)
+    return FALSE;	
+  if (event->keyval == GDK_KP_Enter)	 	
+    g_signal_emit_by_name (G_OBJECT(gtk_widget_get_ancestor (widget,	 	
+                            GTK_TYPE_WINDOW)), "move-focus",	 	
+                           GTK_DIR_TAB_FORWARD);	 	
+
   if (GTK_WIDGET_CLASS (parent_class)->key_press_event (widget, event))
     /* Activate key bindings
      */
@@ -1835,7 +2031,7 @@
 		       GdkEventKey *event)
 {
   GtkEntry *entry = GTK_ENTRY (widget);
-
+  
   if (entry->editable)
     {
       if (gtk_im_context_filter_keypress (entry->im_context, event))
@@ -1853,7 +2049,35 @@
 		    GdkEventFocus *event)
 {
   GtkEntry *entry = GTK_ENTRY (widget);
-  
+  GtkEntryPrivate *priv;
+
+  priv = GTK_ENTRY_GET_PRIVATE (widget);
+  /* Hildon : If the text doesn't fit the entry, upon focusing
+   * to an text field, move the caret to the end of the entry. 
+   * Force the entry to recompute, otherwise it doesn't update
+   * if the cursor is currently at the end*/
+  /* hildon : If the text has no selection and focus returned with
+     other means than pointer click, set cursor before first
+      character of the text, otherwise behave normally */
+
+  if (!entry->in_click)
+    {
+      /*gboolean has_selection;
+      has_selection = gtk_editable_get_selection_bounds (GTK_EDITABLE (entry), NULL, NULL);
+      if (!has_selection)
+        {
+         gtk_editable_set_position (GTK_EDITABLE (entry), -1);
+        }*//*FIXME need a better hack here*/
+      /* Hildon: If in SecretEditor mode highlight selection if entry got focus
+       * otherways than mouse/stylus */
+      if (!entry->visible && priv->keep_focus)
+        {
+          gtk_editable_select_region (GTK_EDITABLE (entry), 0, -1);
+        }
+    }
+
+  gtk_entry_recompute (GTK_ENTRY (entry));
+
   gtk_widget_queue_draw (widget);
   
   if (entry->editable)
@@ -1877,8 +2101,6 @@
 {
   GtkEntry *entry = GTK_ENTRY (widget);
   GtkEntryCompletion *completion;
-  
-  gtk_widget_queue_draw (widget);
 
   if (entry->editable)
     {
@@ -1886,6 +2108,8 @@
       gtk_im_context_focus_out (entry->im_context);
     }
 
+  gtk_widget_queue_draw(widget);
+  
   gtk_entry_check_cursor_blink (entry);
   
   g_signal_handlers_disconnect_by_func (gdk_keymap_get_for_display (gtk_widget_get_display (widget)),
@@ -1902,7 +2126,6 @@
 static void
 gtk_entry_grab_focus (GtkWidget        *widget)
 {
-  GtkEntry *entry = GTK_ENTRY (widget);
   gboolean select_on_focus;
   
   GTK_WIDGET_CLASS (parent_class)->grab_focus (widget);
@@ -1912,8 +2135,8 @@
 		&select_on_focus,
 		NULL);
   
-  if (select_on_focus && entry->editable && !entry->in_click)
-    gtk_editable_select_region (GTK_EDITABLE (widget), 0, -1);
+/* Hildon : When focusing to an entry, it shouldn't become
+ * highlighted. */
 }
 
 static void 
@@ -1987,7 +2210,6 @@
 
   if (new_text_length > 63)
     g_free (text);
-
   g_object_unref (editable);
 }
 
@@ -2074,7 +2296,7 @@
   if (end < 0)
     end = entry->text_length;
   
-  gtk_entry_reset_im_context (entry);
+  /*gtk_entry_reset_im_context (entry);*//*FIXME tmp kludge, might break something*/
 
   gtk_entry_set_positions (entry,
 			   MIN (end, entry->text_length),
@@ -2158,6 +2380,121 @@
 		    G_CALLBACK (gtk_cell_editable_key_press_event), NULL);
 }
 
+static gboolean g_unichar_notalpha (gunichar c)
+{
+  return !g_unichar_isalpha (c);
+}
+
+static gboolean g_unichar_notdigit (gunichar c)
+{
+  return !g_unichar_isdigit (c);
+}
+
+static gboolean g_unichar_isalpspace (gunichar c)
+{
+  return g_unichar_isalpha (c) || g_unichar_isspace (c);
+}
+
+static gboolean g_unichar_isdigitminus (gunichar c)
+{
+  return g_unichar_isdigit (c) || c == '-';
+}
+
+static gboolean g_unichar_isalnumspa (gunichar c)
+{
+  return g_unichar_isdigitminus (c) ||
+         g_unichar_isalpha (c) ||
+         g_unichar_isspace (c);
+}
+
+static gboolean g_unichar_isxdigitspecial (gunichar c)
+{
+  return g_unichar_isxdigit (c) || !g_unichar_isalnum (c);
+}
+
+static gboolean g_unichar_istelephone (gunichar c)
+{
+  return g_unichar_isdigitminus (c) ||
+         c == 'P' || c == 'W' || c == 'p' || c == 'w' ||
+         c == '/' || c == '(' || c == ')' || c == '.' ||
+         c == '+' || c == '*' || c == '#' || c == '?' ||
+         c == ',';
+}
+
+static gboolean g_unichar_istelephonespecial (gunichar c)
+{
+  return g_unichar_istelephone (c) || !g_unichar_isalnum (c);
+}
+
+static gboolean
+gtk_entry_filter_text (GtkEntry *entry, const gchar *str,
+		       gint length)
+{
+  gboolean (*filter_func) (gunichar) = NULL;
+
+  g_assert (GTK_IS_ENTRY (entry));
+
+  if (!length || !str)
+    return FALSE;
+
+  if (!g_utf8_validate (str, -1, NULL))
+    return FALSE;
+
+  /*Input modes are nokia 770 specific - check hildon-input-mode-hint.h*/
+  switch (gtk_entry_get_input_mode (entry))
+    {
+    case 1:
+      filter_func = g_unichar_isdigitminus;
+      break;
+
+    case 2:
+      filter_func = g_unichar_isalpspace;
+      break;
+
+    case 3:
+      filter_func = g_unichar_notalpha;
+      break;
+
+    case 4:
+      filter_func = g_unichar_notdigit;
+      break;
+
+    case 5:
+      filter_func = g_unichar_isalnumspa;
+      break;
+
+    case 6:
+      filter_func = g_unichar_isxdigit;
+      break;
+
+    case 7:
+      filter_func = g_unichar_isxdigitspecial;
+      break;
+
+    case 8:
+      filter_func = g_unichar_istelephone;
+      break;
+
+    case 9:
+      filter_func = g_unichar_istelephonespecial;
+      break;
+
+    default:
+      return TRUE;
+      break;
+    }
+
+  while(length)
+    {
+      if (!filter_func (g_utf8_get_char (str)))
+	return FALSE;
+      str = g_utf8_next_char (str);
+      length--;
+    }
+
+  return TRUE;
+}
+
 /* Default signal handlers
  */
 static void
@@ -2168,16 +2505,36 @@
 {
   gint index;
   gint n_chars;
+  gboolean show_last_char = FALSE;
 
   GtkEntry *entry = GTK_ENTRY (editable);
-
+  GtkEntryPrivate *priv = GTK_ENTRY_GET_PRIVATE (GTK_WIDGET (entry));
   if (new_text_length < 0)
     new_text_length = strlen (new_text);
 
   n_chars = g_utf8_strlen (new_text, new_text_length);
+
+  if (g_object_class_find_property (G_OBJECT_GET_CLASS (entry->im_context),
+				    "input_mode"))
+  if (!gtk_entry_filter_text (entry, new_text, n_chars))
+    {
+      g_signal_emit (entry,
+		     signals[INVALID_INPUT],
+		     0,
+		     GTK_INVALID_INPUT_MODE_RESTRICTION);
+      return;
+    }
+
+  gtk_widget_style_get (GTK_WIDGET (entry), "show-last-char",
+                        &show_last_char, NULL);
+
   if (entry->text_max_length > 0 && n_chars + entry->text_length > entry->text_max_length)
     {
-      gdk_display_beep (gtk_widget_get_display (GTK_WIDGET (entry)));
+      g_signal_emit (entry,
+                     signals[INVALID_INPUT],
+                     0,
+                     GTK_INVALID_INPUT_MAX_CHARS_REACHED);
+
       n_chars = entry->text_max_length - entry->text_length;
       new_text_length = g_utf8_offset_to_pointer (new_text, n_chars) - new_text;
     }
@@ -2238,6 +2595,14 @@
   
   if (entry->selection_bound > *position)
     entry->selection_bound += n_chars;
+  
+  /* Hildon: store this addition IF it was only 1 char (user inputted) and we are currently in secret mode (invisible) */
+                          
+  if (show_last_char && n_chars == 1 && !entry->visible && (new_text_length < HILDON_EDITED_CHARACTER_MAX)) {
+        memset( &priv->hildon_edited_character, 0x00, HILDON_EDITED_CHARACTER_MAX );
+        priv->hildon_edited_character_length = new_text_length;
+        memcpy( &priv->hildon_edited_character, new_text, new_text_length );  /* Guaranteed to be < total length */
+  }
 
   *position += n_chars;
 
@@ -2339,6 +2704,11 @@
 
   gtk_entry_reset_im_context (entry);
 
+  /* Hildon, if not visible set the position to the end */
+  /* New SecretEditor specs say that with cursor should move
+   * With left/right arrows
+   */
+  
   if (entry->current_pos != entry->selection_bound && !extend_selection)
     {
       /* If we have a current selection and aren't extending it, move to the
@@ -2445,7 +2815,7 @@
   gint start_pos = entry->current_pos;
   gint end_pos = entry->current_pos;
   
-  gtk_entry_reset_im_context (entry);
+  /* Hildon: code removed - backspace should not clear the word completion */
 
   if (!entry->editable)
     return;
@@ -2515,7 +2885,8 @@
   GtkEditable *editable = GTK_EDITABLE (entry);
   gint prev_pos;
 
-  gtk_entry_reset_im_context (entry);
+/*  gtk_entry_reset_im_context (entry); */ /*backspace should not clear
+                                             the word completion*/
 
   if (!entry->editable || !entry->text)
     return;
@@ -2883,21 +3254,28 @@
       ++i;
     }
 }
-     
+
+#define HILDON_EDITED_CHARACTER_MS 600  /* 0.6 seconds */
+
 static PangoLayout *
 gtk_entry_create_layout (GtkEntry *entry,
 			 gboolean  include_preedit)
 {
   GtkWidget *widget = GTK_WIDGET (entry);
+  GtkEntryPrivate *priv = GTK_ENTRY_GET_PRIVATE (entry);
   PangoLayout *layout = gtk_widget_create_pango_layout (widget, NULL);
   PangoAttrList *tmp_attrs = pango_attr_list_new ();
   
   gchar *preedit_string = NULL;
   gint preedit_length = 0;
   PangoAttrList *preedit_attrs = NULL;
+  gboolean show_last_char = FALSE;
 
   pango_layout_set_single_paragraph_mode (layout, TRUE);
   
+  gtk_widget_style_get (widget, "show-last-char",
+                        &show_last_char, NULL);
+
   if (include_preedit)
     {
       gtk_im_context_get_preedit_string (entry->im_context,
@@ -3003,7 +3381,54 @@
           else
             invisible_char = ' '; /* just pick a char */
           
-          append_char (str, invisible_char, entry->text_length);
+          if (!show_last_char)
+            append_char (str, invisible_char, entry->text_length);
+          else if (show_last_char)
+            {
+              /* Hildon */
+              if (priv->hildon_edited_character_length > 0)
+                {
+                                                                                                                          
+                  /* If we have an outstanding timeout, remove it, because the character it is set to hide
+                   * is already hidden now. We do this first to prevent possible race conditions if the timout
+                   * were to trigger while in here
+                   */
+                                                                                                                          
+                  if (priv->hildon_edited_character_timeout)
+                    {
+                      g_source_remove( priv->hildon_edited_character_timeout );
+                      priv->hildon_edited_character_timeout = FALSE;
+                    }
+
+		  /* Draw hidden characters upto just inserted, then the real thing, pad up to full length */
+
+		  if (entry->current_pos > 1) {
+		    append_char (str, invisible_char, entry->current_pos - 1);
+		  }
+		  g_string_append_len (str, (char *)&priv->hildon_edited_character, priv->hildon_edited_character_length);
+		  if (entry->current_pos < entry->text_length) {
+		    append_char (str, invisible_char, entry->text_length - entry->current_pos);
+		  }
+
+		  
+                  /* Now remove this last inputted character, don't need it anymore */
+                                                                                                                          
+                  memset( priv->hildon_edited_character, 0x00, HILDON_EDITED_CHARACTER_MAX );
+                  priv->hildon_edited_character_length = 0;
+                                                                                     
+                  priv->hildon_edited_character_timeout = g_timeout_add( HILDON_EDITED_CHARACTER_MS, (GSourceFunc)
+                                											      hildon_remove_visible_character, entry );
+                                                                                                                          
+                } 
+              else 
+                {
+                  /* No last character known. This could be for example because the application has filled
+                   * in the password already. In that case we of course don't want to view it
+                   */
+                  append_char (str, invisible_char, entry->text_length);
+                }
+            }
+    
           pango_layout_set_text (layout, str->str, str->len);
           g_string_free (str, TRUE);
         }
@@ -3048,12 +3473,17 @@
   gint area_width, area_height;
   gint y_pos;
   PangoLayoutLine *line;
-  
+  gint border_x, border_y;
+
+  gtk_widget_style_get (GTK_WIDGET (entry), "horizontal-border", &border_x,
+					    "vertical-border", &border_y,
+				 	    NULL);
+
   layout = gtk_entry_ensure_layout (entry, TRUE);
 
   get_text_area_size (entry, NULL, NULL, &area_width, &area_height);      
       
-  area_height = PANGO_SCALE * (area_height - 2 * INNER_BORDER);
+  area_height = PANGO_SCALE * (area_height - 2 * border_y);
   
   line = pango_layout_get_lines (layout)->data;
   pango_layout_line_get_extents (line, NULL, &logical_rect);
@@ -3070,10 +3500,10 @@
   else if (y_pos + logical_rect.height > area_height)
     y_pos = area_height - logical_rect.height;
   
-  y_pos = INNER_BORDER + y_pos / PANGO_SCALE;
+  y_pos = border_y + y_pos / PANGO_SCALE;
 
   if (x)
-    *x = INNER_BORDER - entry->scroll_offset;
+    *x = border_x - entry->scroll_offset;
 
   if (y)
     *y = y_pos;
@@ -3083,6 +3513,10 @@
 gtk_entry_draw_text (GtkEntry *entry)
 {
   GtkWidget *widget;
+  gint border_y, border_x;
+
+  gtk_widget_style_get (GTK_WIDGET (entry), "horizontal-border", &border_x,
+		  "vertical-border", &border_y, NULL);
   
   if (!entry->visible && entry->invisible_char == 0)
     return;
@@ -3092,14 +3526,76 @@
       PangoLayout *layout = gtk_entry_ensure_layout (entry, TRUE);
       gint x, y;
       gint start_pos, end_pos;
+      GdkRectangle clip_rect;
       
       widget = GTK_WIDGET (entry);
       
       get_layout_position (entry, &x, &y);
 
+      /* Use a clipping rectangle so that we always get enough empty space around
+       * the text.
+       */
+      clip_rect.x = border_x;
+      clip_rect.y = 0;
+
+      gdk_drawable_get_size (entry->text_area, &clip_rect.width, &clip_rect.height);
+      clip_rect.width -= border_x * 2;
+
+      /*changes for Hildon
+       *Reduce the size of the clip rect, so that only full characters are displayed
+      */
+
+         /* NOTE: Commented out because it does not work with bidi text where
+the indexes are in random
+          * left-right or right-left order. Code causes Pango assert aborts. Because gtkentry itself
+          * is broken with regard to bidi anyway (bug #478) we ignore this requirement of the spec
+          * until gtkentry itself is fixed. (bug #477)
+          */
+
+       /* Better yet, let's enable this only when not in RTL mode */
+
+       /* Note: BUG #857. patched gtkentry crashed when pasting scalable fonts. This is pango problem
+        * and we tested patched gtkentry with pango version 1.3.2 and it appears to be fixed. Section is commented
+        out until we upgrade to new version of pango
+          if (gtk_widget_get_direction( entry ) != GTK_TEXT_DIR_RTL)
+          {
+           PangoRectangle char_rect; // used for getting character's onscreen pos
+           PangoLayoutIter *iter; // used to iterate over the text
+
+           // get the position of the character currently at the clip border
+           iter = get_char_at_pos( layout, (clip_rect.x + clip_rect.width + entry->scroll_offset), 0 );
+           if ( iter )
+           {
+               // get the position of that character on the screen
+               pango_layout_iter_get_char_extents( iter, &char_rect );
+               char_rect.x /= PANGO_SCALE;
+               char_rect.x -= entry->scroll_offset;
+               char_rect.width /= PANGO_SCALE;
+
+               // if the ending position is > the clip rectangle, then the
+               // character is only partially visible, and we should
+               // clip the entire character.
+
+               if ( char_rect.x + char_rect.width > clip_rect.x + clip_rect.width )
+               {
+                   clip_rect.width = char_rect.x;
+               }
+
+               pango_layout_iter_free( iter );
+           }
+
+         }
+			*/
+       /******************************************************************/
+
+      gdk_gc_set_clip_rectangle (widget->style->text_gc [widget->state], &clip_rect);
+
       gdk_draw_layout (entry->text_area, widget->style->text_gc [widget->state],       
                        x, y,
 		       layout);
+
+      gdk_gc_set_clip_rectangle (widget->style->text_gc [widget->state], NULL);
+
       
       if (gtk_editable_get_selection_bounds (GTK_EDITABLE (entry), &start_pos, &end_pos))
 	{
@@ -3128,7 +3624,7 @@
 	    {
 	      GdkRectangle rect;
 
-	      rect.x = INNER_BORDER - entry->scroll_offset + ranges[2 * i];
+	      rect.x = border_x - entry->scroll_offset + ranges[2 * i];
 	      rect.y = y;
 	      rect.width = ranges[2 * i + 1];
 	      rect.height = logical_rect.height;
@@ -3177,14 +3673,18 @@
 {
   GdkKeymap *keymap = gdk_keymap_get_for_display (gtk_widget_get_display (GTK_WIDGET (entry)));
   PangoDirection keymap_direction = gdk_keymap_get_direction (keymap);
+  gint border_x, border_y;
   
+  gtk_widget_style_get (GTK_WIDGET (entry), "horizontal-border", &border_x,
+				            "vertical-border", &border_y,
+				            NULL);
   if (GTK_WIDGET_DRAWABLE (entry))
     {
       GtkWidget *widget = GTK_WIDGET (entry);
       GdkRectangle cursor_location;
       gboolean split_cursor;
 
-      gint xoffset = INNER_BORDER - entry->scroll_offset;
+      gint xoffset = border_x - entry->scroll_offset;
       gint strong_x, weak_x;
       gint text_area_height;
       PangoDirection dir1 = PANGO_DIRECTION_NEUTRAL;
@@ -3221,9 +3721,9 @@
 	}
 
       cursor_location.x = xoffset + x1;
-      cursor_location.y = INNER_BORDER;
+      cursor_location.y = border_y;
       cursor_location.width = 0;
-      cursor_location.height = text_area_height - 2 * INNER_BORDER ;
+      cursor_location.height = text_area_height - 2 * border_y;
 
       draw_insertion_cursor (entry,
 			     &cursor_location, TRUE, dir1,
@@ -3249,11 +3749,8 @@
 static void
 gtk_entry_reset_im_context (GtkEntry *entry)
 {
-  if (entry->need_im_reset)
-    {
-      entry->need_im_reset = 0;
-      gtk_im_context_reset (entry->im_context);
-    }
+  /* Hildon: We want reset to be sent more often */ 
+  gtk_im_context_reset (entry->im_context);
 }
 
 static gint
@@ -3266,8 +3763,12 @@
   gint pos;
   gboolean trailing;
   const gchar *text;
-  gint cursor_index;
-  
+  gint border_x, cursor_index;
+
+  gtk_widget_style_get (GTK_WIDGET (entry), "horizontal-border", &border_x,
+				 	    NULL);
+  x -= border_x;
+
   layout = gtk_entry_ensure_layout (entry, TRUE);
   text = pango_layout_get_text (layout);
   cursor_index = g_utf8_offset_to_pointer (text, entry->current_pos) - text;
@@ -3355,12 +3856,17 @@
   PangoLayout *layout;
   PangoLayoutLine *line;
   PangoRectangle logical_rect;
+  gint border_x, border_y;
+
+  gtk_widget_style_get (GTK_WIDGET (entry), "horizontal-border", &border_x,
+					    "vertical-border", &border_y,
+				 	    NULL);
 
   if (!GTK_WIDGET_REALIZED (entry))
     return;
   
   gdk_drawable_get_size (entry->text_area, &text_area_width, NULL);
-  text_area_width -= 2 * INNER_BORDER;
+  text_area_width -= 2 * border_x;
 
   layout = gtk_entry_ensure_layout (entry, TRUE);
   line = pango_layout_get_lines (layout)->data;
@@ -3390,13 +3896,13 @@
   entry->scroll_offset = CLAMP (entry->scroll_offset, min_offset, max_offset);
 
   /* And make sure cursors are on screen. Note that the cursor is
-   * actually drawn one pixel into the INNER_BORDER space on
+   * actually drawn one pixel into the border_x space on
    * the right, when the scroll is at the utmost right. This
    * looks better to to me than confining the cursor inside the
    * border entirely, though it means that the cursor gets one
    * pixel closer to the edge of the widget on the right than
    * on the left. This might need changing if one changed
-   * INNER_BORDER from 2 to 1, as one would do on a
+   * border_x from 2 to 1, as one would do on a
    * small-screen-real-estate display.
    *
    * We always make sure that the strong cursor is on screen, and
@@ -3430,6 +3936,52 @@
       entry->scroll_offset += weak_xoffset - text_area_width;
     }
 
+  /*Changes for Hildon
+   * now we make it so that if a character is partially visible,
+   * then we also scroll that off the screen.
+   */
+         
+       /* NOTE: Commented out because it does not work with bidi text where the indexes are in random
+          * left-right or right-left order. Code causes Pango assert aborts. Because gtkentry itself
+          * is broken with regard to bidi anyway (bug #478) we ignore this requirement of the spec
+          * until gtkentry itself is fixed. (bug #477)
+          */
+
+       /* Better yet, let's disable this (for now) only when using RTL text */
+  
+/*Note: BUG #857. patched gtkentry crashed when pasting scalable fonts. This is pango problem
+  * and we tested patched gtkentry with pango version 1.3.2 and it appears to be fixed. Section is comment          ed out until we upgrade to new version of pango
+ if (gtk_widget_get_direction( entry ) != GTK_TEXT_DIR_RTL)
+  {
+    PangoLayoutIter *iter = get_char_at_pos( layout, entry->scroll_offset, 0 );
+    // if we found the char we were looking for
+    if ( iter )
+    {
+        PangoRectangle char_rect; // used for getting character's onscreen pos
+
+        // get the position of that character on the screen
+        pango_layout_iter_get_char_extents( iter, &char_rect );
+        char_rect.x /= PANGO_SCALE;
+
+        // if the starting position is < the current scroll offset, then the
+        // character is only partially visible, and we should scroll to the
+        // start of the next character instead
+         
+        if ( char_rect.x < entry->scroll_offset )
+        {
+            if ( pango_layout_iter_next_char( iter ) )
+            {
+                pango_layout_iter_get_char_extents( iter, &char_rect);
+                entry->scroll_offset = char_rect.x / PANGO_SCALE;
+            }
+        }
+
+        pango_layout_iter_free( iter );
+    }
+       
+
+  }*/
+ 
   g_object_notify (G_OBJECT (entry), "scroll_offset");
 }
 
@@ -3553,7 +4105,7 @@
       
       /* Find the next word end */
       new_pos++;
-      while (new_pos < n_attrs && !log_attrs[new_pos].is_word_end)
+      while (new_pos < n_attrs - 1 && !log_attrs[new_pos].is_word_end)
 	new_pos++;
 
       g_free (log_attrs);
@@ -3648,14 +4200,9 @@
   
   if (entry->visible)
     return gtk_editable_get_chars (GTK_EDITABLE (entry), start, end);
-  else if (!entry->invisible_char)
+  /*Hildon: when not visible, no chars are public*/
+  else 
     return g_strdup ("");
-  else
-    {
-      GString *str = g_string_new (NULL);
-      append_char (str, entry->invisible_char, end - start);
-      return g_string_free (str, FALSE);
-    }
 }
 
 static void
@@ -3678,9 +4225,12 @@
       
   if (text)
     {
-      gint pos, start, end;
+      gint pos, start, end, length;
       GtkEntryCompletion *completion = gtk_entry_get_completion (entry);
 
+      /* when pasting multiline text, ignore everything but the first line */
+      for (length = 0; text[length] != 0 && text[length] != '\n'; length++);
+
       if (completion)
 	{
 	  g_signal_handler_block (entry, completion->priv->changed_id);
@@ -3692,7 +4242,7 @@
         gtk_editable_delete_text (editable, start, end);
 
       pos = entry->current_pos;
-      gtk_editable_insert_text (editable, text, -1, &pos);
+      gtk_editable_insert_text (editable, text, length, &pos);
       gtk_editable_set_position (editable, pos);
 
       if (completion)
@@ -3888,8 +4438,13 @@
 {
   g_return_if_fail (GTK_IS_ENTRY (entry));
 
+  g_object_set(G_OBJECT(entry->im_context), "visibility", visible, NULL);
   entry->visible = visible ? TRUE : FALSE;
   g_object_notify (G_OBJECT (entry), "visibility");
+
+  if (gtk_entry_get_autocap (entry) != visible)
+    gtk_entry_set_autocap (entry, visible);
+    
   gtk_entry_recompute (entry);
 }
 
@@ -4569,6 +5124,7 @@
                     GdkEventButton *event)
 {
   PopupInfo *info = g_new (PopupInfo, 1);
+  GtkEntryPrivate *priv;
 
   /* In order to know what entries we should make sensitive, we
    * ask for the current targets of the clipboard, and when
@@ -4576,6 +5132,8 @@
    */
   info->entry = g_object_ref (entry);
   
+  priv = GTK_ENTRY_GET_PRIVATE (entry);
+
   if (event)
     {
       info->button = event->button;
@@ -4591,6 +5149,8 @@
 				  gdk_atom_intern ("TARGETS", FALSE),
 				  popup_targets_received,
 				  info);
+
+  priv->menu_popped = TRUE;
 }
 
 static gboolean
@@ -5389,3 +5949,119 @@
 
   return completion;
 }
+
+static PangoLayoutIter *get_char_at_pos( PangoLayout *layout, gint x, gint y )
+{
+     gint index = 0; /*the index of the first character */
+     gint trailing = 0; /*not used*/
+     PangoLayoutIter *iter; /*used to iterate over the text*/
+     gboolean valid_char = TRUE;
+
+     /*get the position of the character currently at the scroll offset*/
+     pango_layout_xy_to_index( layout, x * PANGO_SCALE, y * PANGO_SCALE, &index, &trailing );
+     iter = pango_layout_get_iter( layout );
+
+     /*iterate until we get to the character at the same index*/
+     while ( valid_char && pango_layout_iter_get_index( iter ) != index )
+     {
+         valid_char = pango_layout_iter_next_char( iter );
+     }
+
+     if ( valid_char == FALSE )
+         iter = NULL;
+
+     return iter;
+}
+
+/*
+ * gtk_entry_set_autocap:
+ * @entry: a #GtkEntry
+ * @autocap: autocap
+ *
+ * Sets autocapitalization of the widget.
+ */
+static void
+gtk_entry_set_autocap (GtkEntry *entry,
+                       gboolean autocap)
+{
+  g_return_if_fail (GTK_IS_ENTRY (entry));
+
+  if (gtk_entry_get_autocap (entry) != autocap)
+  {
+    g_object_set (G_OBJECT (entry->im_context), "autocap", autocap, NULL);
+    g_object_notify (G_OBJECT (entry), "autocap");
+  }
+}
+
+/*
+ * gtk_entry_get_autocap:
+ * @entry: a #GtkEntry
+ *
+ * Gets autocapitalization state of the widget.
+ *
+ * Return value: a state
+ */
+static gboolean
+gtk_entry_get_autocap (GtkEntry *entry)
+{
+  gboolean autocap;
+  g_return_val_if_fail (GTK_IS_ENTRY (entry), FALSE);
+
+  g_object_get (G_OBJECT (entry->im_context), "autocap", &autocap, NULL);
+
+  return autocap;
+}
+
+/*
+ * gtk_entry_set_input_mode:
+ * @entry: a #GtkEntry
+ * @autocap: input mode
+ *
+ * Sets autocapitalization of the widget.
+ */
+static void
+gtk_entry_set_input_mode (GtkEntry *entry,
+                          gint      mode)
+{
+  g_return_if_fail (GTK_IS_ENTRY (entry));
+
+  if (g_object_class_find_property (G_OBJECT_GET_CLASS (entry->im_context),
+				    "input_mode"))
+  if (gtk_entry_get_input_mode (entry) != mode)
+  {
+    g_object_set (G_OBJECT (entry->im_context), "input_mode", mode, NULL);
+    g_object_notify (G_OBJECT (entry), "input_mode");
+  }
+}
+
+/*
+ * gtk_entry_get_input_mode:
+ * @entry: a #GtkEntry
+ *
+ * Gets input mode of the widget.
+ *
+ * Return value: input mode
+ */
+static gint
+gtk_entry_get_input_mode (GtkEntry *entry)
+{
+  gint mode;
+  g_return_val_if_fail (GTK_IS_ENTRY (entry), FALSE);
+
+  if (g_object_class_find_property (G_OBJECT_GET_CLASS (entry->im_context),
+				    "input_mode"))
+    g_object_get (G_OBJECT (entry->im_context), "input_mode", &mode, NULL);
+  else
+    mode = 0;
+
+  return mode;
+}
+
+static void
+gtk_entry_unmap (GtkWidget *widget)
+{
+  gtk_im_context_hide (GTK_ENTRY (widget)->im_context);
+  
+  if (GTK_WIDGET_CLASS (parent_class)->unmap)
+    (* GTK_WIDGET_CLASS (parent_class)->unmap) (widget);
+}
--- gtk+/gtk/gtkprogress.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkprogress.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -371,6 +371,17 @@
 						   widget->allocation.width,
 						   widget->allocation.height,
 						   -1);
+       
+      /* OSSO addition : clear the pixmap first or transparent images
+       * painted on top of it may look stupid when it's blended against
+       * random memory.*/
+      gtk_paint_flat_box (widget->style,
+			  progress->offscreen_pixmap,
+			  GTK_STATE_NORMAL,
+			  GTK_SHADOW_NONE,
+			  NULL, widget, NULL,
+			  0, 0, widget->allocation.width, widget->allocation.height);
+      
       GTK_PROGRESS_GET_CLASS (progress)->paint (progress);
     }
 }
--- gtk+/gtk/gtkentry.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkentry.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -143,10 +143,12 @@
   void (* paste_clipboard)    (GtkEntry       *entry);
   void (* toggle_overwrite)   (GtkEntry       *entry);
 
+  void (* invalid_input) (GtkEntry            *entry,
+                          GtkInvalidInputType  invalid_input_type);
+
   /* Padding for future expansion */
   void (*_gtk_reserved1) (void);
   void (*_gtk_reserved2) (void);
-  void (*_gtk_reserved3) (void);
 };
 
 GType      gtk_entry_get_type       		(void) G_GNUC_CONST;
--- gtk+/gtk/gtkcellrenderertoggle.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkcellrenderertoggle.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -68,10 +68,11 @@
   PROP_ACTIVATABLE,
   PROP_ACTIVE,
   PROP_RADIO,
-  PROP_INCONSISTENT
+  PROP_INCONSISTENT,
+  PROP_CHECKBOX_MODE
 };
 
-#define TOGGLE_WIDTH 12
+#define TOGGLE_WIDTH 26
 
 static guint toggle_cell_signals[LAST_SIGNAL] = { 0 };
 
@@ -81,6 +82,7 @@
 struct _GtkCellRendererTogglePrivate
 {
   guint inconsistent : 1;
+  guint checkbox_mode : 1;       /* is checkbox mode on right now? */
 };
 
 
@@ -115,12 +117,13 @@
 static void
 gtk_cell_renderer_toggle_init (GtkCellRendererToggle *celltoggle)
 {
+  GtkCellRendererTogglePrivate *priv = GTK_CELL_RENDERER_TOGGLE_GET_PRIVATE (celltoggle);
+
+  priv->checkbox_mode = FALSE;
   celltoggle->activatable = TRUE;
   celltoggle->active = FALSE;
   celltoggle->radio = FALSE;
   GTK_CELL_RENDERER (celltoggle)->mode = GTK_CELL_RENDERER_MODE_ACTIVATABLE;
-  GTK_CELL_RENDERER (celltoggle)->xpad = 2;
-  GTK_CELL_RENDERER (celltoggle)->ypad = 2;
 }
 
 static void
@@ -172,6 +175,14 @@
 							 G_PARAM_READABLE |
 							 G_PARAM_WRITABLE));
 
+  g_object_class_install_property (object_class,
+           PROP_CHECKBOX_MODE,
+           g_param_spec_boolean ("checkbox_mode",
+               P_("Checkbox Mode"),
+               P_("Activates the checkbox mode of drawing selection"),
+               FALSE,
+               G_PARAM_READABLE |
+               G_PARAM_WRITABLE));
   
   /**
    * GtkCellRendererToggle::toggled:
@@ -219,6 +230,9 @@
     case PROP_RADIO:
       g_value_set_boolean (value, celltoggle->radio);
       break;
+    case PROP_CHECKBOX_MODE:
+      g_value_set_boolean (value, priv->checkbox_mode);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, param_id, pspec);
       break;
@@ -255,6 +269,10 @@
       celltoggle->radio = g_value_get_boolean (value);
       g_object_notify (G_OBJECT(object), "radio");
       break;
+    case PROP_CHECKBOX_MODE:
+      priv->checkbox_mode = g_value_get_boolean (value);
+      g_object_notify (G_OBJECT(object), "checkbox_mode");
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, param_id, pspec);
       break;
@@ -344,30 +362,89 @@
   if (width <= 0 || height <= 0)
     return;
 
-  if (priv->inconsistent)
-    shadow = GTK_SHADOW_ETCHED_IN;
-  else
-    shadow = celltoggle->active ? GTK_SHADOW_IN : GTK_SHADOW_OUT;
-
-  if (!cell->sensitive)
-    {
-      state = GTK_STATE_INSENSITIVE;
-    }
-  else if ((flags & GTK_CELL_RENDERER_SELECTED) == GTK_CELL_RENDERER_SELECTED)
+  if (priv->checkbox_mode)
     {
-      if (GTK_WIDGET_HAS_FOCUS (widget))
-	state = GTK_STATE_SELECTED;
+      /* Checkbox mode drawing */
+      
+      state = GTK_STATE_NORMAL;
+    
+      if (!cell->sensitive)
+        {
+          state = GTK_STATE_INSENSITIVE;
+        }
+/* FIXME: Enable this after the activatable-issue is cleared up */
+#if 0
+      if (!celltoggle->activatable)
+        {
+          state = GTK_STATE_INSENSITIVE;
+        }
+#endif        
+      if ((flags & GTK_CELL_RENDERER_SELECTED) == GTK_CELL_RENDERER_SELECTED)
+        {
+            shadow = GTK_SHADOW_IN;
+        }
       else
-	state = GTK_STATE_ACTIVE;
+        {
+            shadow = GTK_SHADOW_OUT;
+        }
+        
+      if (priv->inconsistent)
+        {
+            shadow = GTK_SHADOW_ETCHED_IN;
+        }
+        
+      if ((flags & GTK_CELL_RENDERER_FOCUSED) == GTK_CELL_RENDERER_FOCUSED)
+        {
+          /* Don't overlap with the focus border */
+          height -= 2;
+          if (GTK_WIDGET_HAS_FOCUS (widget))
+            {
+              state = GTK_STATE_ACTIVE;
+            }
+          else
+            {
+              state = GTK_STATE_PRELIGHT;
+            }
+        }
+  
     }
   else
     {
-      if (celltoggle->activatable)
-        state = GTK_STATE_NORMAL;
+      /* Normal operation */
+      if (priv->inconsistent)
+        shadow = GTK_SHADOW_ETCHED_IN;
+      else
+        shadow = celltoggle->active ? GTK_SHADOW_IN : GTK_SHADOW_OUT;
+    
+      if (!cell->sensitive)
+        {
+          state = GTK_STATE_INSENSITIVE;
+        }
+      else if ((flags & GTK_CELL_RENDERER_SELECTED) == GTK_CELL_RENDERER_SELECTED)
+        {
+          if (GTK_WIDGET_HAS_FOCUS (widget))
+            {
+              state = GTK_STATE_SELECTED;
+            }
+          else
+            {
+              state = GTK_STATE_ACTIVE;
+            }
+        }
       else
-        state = GTK_STATE_INSENSITIVE;
+        {
+          if (celltoggle->activatable)
+            {
+              state = GTK_STATE_NORMAL;
+            }
+          else
+            {
+              state = GTK_STATE_INSENSITIVE;
+            }
+        }
     }
 
+    
   if (celltoggle->radio)
     {
       gtk_paint_option (widget->style,
--- gtk+/gtk/gtktreeviewcolumn.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtktreeviewcolumn.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -1367,6 +1367,19 @@
   return FALSE;
 }
 
+gboolean
+_gtk_tree_view_column_has_activatable_cell (GtkTreeViewColumn *column)
+{
+  GList *list;
+
+  for (list = column->cell_list; list; list = list->next)
+    if (((GtkTreeViewColumnCellInfo *)list->data)->cell->mode ==
+       GTK_CELL_RENDERER_MODE_ACTIVATABLE)
+      return TRUE;
+
+  return FALSE;
+}
+
 /* gets cell being edited */
 GtkCellRenderer *
 _gtk_tree_view_column_get_edited_cell (GtkTreeViewColumn *column)
@@ -2590,7 +2603,9 @@
   if (width)
     * width = 0;
 
-  gtk_widget_style_get (tree_column->tree_view, "focus-line-width", &focus_line_width, NULL);
+  gtk_widget_style_get (tree_column->tree_view,
+                        "focus-line-width", &focus_line_width,
+                        NULL);
   
   for (list = tree_column->cell_list; list; list = list->next)
     {
@@ -2659,7 +2674,6 @@
   gint min_x, min_y, max_x, max_y;
   gint focus_line_width;
   gint special_cells;
-  gint horizontal_separator;
   gboolean cursor_row = FALSE;
   gboolean rtl;
   /* If we have rtl text, we need to transform our areas */
@@ -2702,7 +2716,6 @@
 
   gtk_widget_style_get (GTK_WIDGET (tree_column->tree_view),
 			"focus-line-width", &focus_line_width,
-			"horizontal-separator", &horizontal_separator,
 			NULL);
 
   real_cell_area = *cell_area;
--- gtk+/gtk/gtkcalendar.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkcalendar.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -14,7 +14,7 @@
  *
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
@@ -37,6 +37,7 @@
 #include <string.h>
 #include <stdlib.h>
 #include <time.h>
+#include <langinfo.h>
 #include <glib/gprintf.h>
 
 #include "gtkalias.h"
@@ -53,13 +54,13 @@
  * them separate in case we want to update them if a newer lib_date comes
  * out with fixes.  */
 
-typedef	 unsigned   int	    N_int;
-typedef	 unsigned   long    N_long;
-typedef	 signed	    long    Z_long;
+typedef  unsigned   int     N_int;
+typedef  unsigned   long    N_long;
+typedef  signed     long    Z_long;
 typedef enum { false = FALSE , true = TRUE } boolean;
 
-#define and	    &&	    /* logical (boolean) operators: lower case */
-#define or	    ||
+#define and         &&      /* logical (boolean) operators: lower case */
+#define or          ||
 
 static const N_int month_length[2][13] =
 {
@@ -76,7 +77,7 @@
 static Z_long  calc_days(N_int year, N_int mm, N_int dd);
 static N_int   day_of_week(N_int year, N_int mm, N_int dd);
 static Z_long  dates_difference(N_int year1, N_int mm1, N_int dd1,
-				N_int year2, N_int mm2, N_int dd2);
+                                N_int year2, N_int mm2, N_int dd2);
 static N_int   weeks_in_year(N_int year);
 
 static boolean 
@@ -121,7 +122,7 @@
   
   first = day_of_week(year,1,1) - 1;
   return( (N_int) ( (dates_difference(year,1,1, year,mm,dd) + first) / 7L ) +
-	  (first < 4) );
+          (first < 4) );
 }
 
 static Z_long 
@@ -149,12 +150,12 @@
     {
       *week = week_number(*year,mm,dd);
       if (*week == 0) 
-	*week = weeks_in_year(--(*year));
+        *week = weeks_in_year(--(*year));
       else if (*week > weeks_in_year(*year))
-	{
-	  *week = 1;
-	  (*year)++;
-	}
+        {
+          *week = 1;
+          (*year)++;
+        }
       return(true);
     }
   return(false);
@@ -162,36 +163,53 @@
 
 static Z_long 
 dates_difference(N_int year1, N_int mm1, N_int dd1,
-		 N_int year2, N_int mm2, N_int dd2)
+                 N_int year2, N_int mm2, N_int dd2)
 {
   return( calc_days(year2, mm2, dd2) - calc_days(year1, mm1, dd1) );
 }
 
 /*** END OF lib_date routines ********************************************/
 
+/* HILDON: Spacings modified */
+
+#define HILDON_ARROW_WIDTH   20
+#define HILDON_ARROW_HEIGHT 27
+#define HILDON_ARROW_SEP        5     /* Space between arrows and data */
+
+#define HILDON_DAY_WIDTH         26
+#define HILDON_DAY_HEIGHT        25 
+
+/* additional widths given to week number and day windows */
+#define HILDON_WEEKS_EXTRA_WIDTH  8
+#define HILDON_DAYS_EXTRA_WIDTH   8
+
 /* Spacing around day/week headers and main area, inside those windows */
-#define CALENDAR_MARGIN		 0
+#define CALENDAR_MARGIN          0
 /* Spacing around day/week headers and main area, outside those windows */
-#define INNER_BORDER		 4
+#define INNER_BORDER             0 /* 4 */
 /* Separation between day headers and main area */
-#define CALENDAR_YSEP		 4
+#define CALENDAR_YSEP            3 /* 4 */
 /* Separation between week headers and main area */
-#define CALENDAR_XSEP		 4
+#define CALENDAR_XSEP            6 /* 4 */
 
-#define DAY_XSEP		 0 /* not really good for small calendar */
-#define DAY_YSEP		 0 /* not really good for small calendar */
+#define DAY_XSEP                 0 /* not really good for small calendar */
+#define DAY_YSEP                 0 /* not really good for small calendar */
 
 /* Color usage */
-#define HEADER_FG_COLOR(widget)		 (& (widget)->style->fg[GTK_WIDGET_STATE (widget)])
-#define HEADER_BG_COLOR(widget)		 (& (widget)->style->bg[GTK_WIDGET_STATE (widget)])
-#define SELECTED_BG_COLOR(widget)	 (& (widget)->style->base[GTK_WIDGET_HAS_FOCUS (widget) ? GTK_STATE_SELECTED : GTK_STATE_ACTIVE])
-#define SELECTED_FG_COLOR(widget)	 (& (widget)->style->text[GTK_WIDGET_HAS_FOCUS (widget) ? GTK_STATE_SELECTED : GTK_STATE_ACTIVE])
-#define NORMAL_DAY_COLOR(widget)	 (& (widget)->style->fg[GTK_WIDGET_STATE (widget)])
-#define PREV_MONTH_COLOR(widget)	 (& (widget)->style->mid[GTK_WIDGET_STATE (widget)])
-#define NEXT_MONTH_COLOR(widget)	 (& (widget)->style->mid[GTK_WIDGET_STATE (widget)])
-#define MARKED_COLOR(widget)		 (& (widget)->style->fg[GTK_WIDGET_STATE (widget)])
-#define BACKGROUND_COLOR(widget)	 (& (widget)->style->base[GTK_WIDGET_STATE (widget)])
-#define HIGHLIGHT_BACK_COLOR(widget)	 (& (widget)->style->mid[GTK_WIDGET_STATE (widget)])
+#define HEADER_FG_COLOR(widget)          (& (widget)->style->fg[GTK_WIDGET_STATE (widget)])
+#define HEADER_BG_COLOR(widget)          (& (widget)->style->bg[GTK_WIDGET_STATE (widget)])
+#define SELECTED_BG_COLOR(widget)        (& (widget)->style->base[GTK_WIDGET_HAS_FOCUS (widget) ? GTK_STATE_SELECTED : GTK_STATE_ACTIVE])
+#define SELECTED_FG_COLOR(widget)        (& (widget)->style->text[GTK_WIDGET_HAS_FOCUS (widget) ? GTK_STATE_SELECTED : GTK_STATE_ACTIVE])
+#define NORMAL_DAY_COLOR(widget)         (& (widget)->style->fg[GTK_WIDGET_STATE (widget)])
+#define PREV_MONTH_COLOR(widget)         (& (widget)->style->mid[GTK_WIDGET_STATE (widget)])
+#define NEXT_MONTH_COLOR(widget)         (& (widget)->style->mid[GTK_WIDGET_STATE (widget)])
+#define MARKED_COLOR(widget)             (& (widget)->style->fg[GTK_WIDGET_STATE (widget)])
+#define BACKGROUND_COLOR(widget)         (& (widget)->style->base[GTK_WIDGET_STATE (widget)])
+#define HIGHLIGHT_BACK_COLOR(widget)     (& (widget)->style->mid[GTK_WIDGET_STATE (widget)])
+
+/* Default Min/Max years for hildon calendar */
+#define HILDON_MIN_YEAR 0
+#define HILDON_MAX_YEAR 2999
 
 enum {
   ARROW_YEAR_LEFT,
@@ -214,6 +232,8 @@
   NEXT_MONTH_SIGNAL,
   PREV_YEAR_SIGNAL,
   NEXT_YEAR_SIGNAL,
+  ERRONEOUS_DATE_SIGNAL,
+  SELECTED_DATE_SIGNAL,
   LAST_SIGNAL
 };
 
@@ -227,6 +247,7 @@
   PROP_SHOW_DAY_NAMES,
   PROP_NO_MONTH_CHANGE,
   PROP_SHOW_WEEK_NUMBERS,
+  PROP_WEEK_START,
   PROP_LAST
 };
 
@@ -238,19 +259,22 @@
 struct _GtkCalendarPrivateData
 {
   GdkWindow *header_win;
+  GdkWindow *footer_win;    /* HILDON: Added below calendar */
   GdkWindow *day_name_win;
   GdkWindow *main_win;
   GdkWindow *week_win;
   GdkWindow *arrow_win[4];
 
+  gint year_before;
   guint header_h;
   guint day_name_h;
   guint main_h;
 
-  guint	     arrow_state[4];
-  guint	     arrow_width;
-  guint	     max_month_width;
-  guint	     max_year_width;
+  guint      arrow_state[4];
+  /* guint           arrow_width;  This is now defined constant. Even normal Gtk don't allow to change this */ 
+  guint      arrow_width;
+  guint      max_month_width;
+  guint      max_year_width;
   
   guint day_width;
   guint week_width;
@@ -271,7 +295,7 @@
   guint dirty_main : 1;
   guint dirty_week : 1;
 
-  guint year_before : 1;
+/*  guint year_before : 1;*/
 
   guint need_timer  : 1;
 
@@ -281,6 +305,27 @@
   guint32 timer;
   gint click_child;
 
+  /* Following variables are for current date */
+  guint current_day;
+  guint current_month;
+  guint current_year;
+
+  /* Keep track of day and month
+   * where mouse button was pressed
+   */
+  guint pressed_day;
+  guint pressed_month;
+
+  /* Boolean value to indicate if
+   * out of bound day was selected
+   */
+  gboolean is_bad_day;
+
+  /* Must check if we are sliding stylus */
+  gboolean slide_stylus;
+  gint prev_row;
+  gint prev_col;
+
   gint week_start;
 
   gint drag_start_x;
@@ -291,97 +336,104 @@
 
 typedef void (*GtkCalendarSignalDate) (GtkObject *object, guint arg1, guint arg2, guint arg3, gpointer data);
 
-static void gtk_calendar_class_init	(GtkCalendarClass *class);
-static void gtk_calendar_init		(GtkCalendar *calendar);
-static void gtk_calendar_finalize	(GObject *calendar);
-static void gtk_calendar_destroy	(GtkObject *calendar);
+static void gtk_calendar_class_init     (GtkCalendarClass *class);
+static void gtk_calendar_init           (GtkCalendar *calendar);
+static void gtk_calendar_finalize       (GObject *calendar);
+static void gtk_calendar_destroy        (GtkObject *calendar);
 static void gtk_calendar_set_property   (GObject      *object,
-				         guint         prop_id,
-				         const GValue *value,
-				         GParamSpec   *pspec);
+                                         guint         prop_id,
+                                         const GValue *value,
+                                         GParamSpec   *pspec);
 static void gtk_calendar_get_property   (GObject      *object,
-					 guint         prop_id,
-					 GValue       *value,
-					 GParamSpec   *pspec);
-static void gtk_calendar_realize	(GtkWidget *widget);
-static void gtk_calendar_unrealize	(GtkWidget *widget);
-static void gtk_calendar_size_request	(GtkWidget *widget,
-					 GtkRequisition *requisition);
-static void gtk_calendar_size_allocate	(GtkWidget *widget,
-					 GtkAllocation *allocation);
-static gint gtk_calendar_expose		(GtkWidget *widget,
-					 GdkEventExpose *event);
-static gint gtk_calendar_button_press	(GtkWidget *widget,
-					 GdkEventButton *event);
-static gint gtk_calendar_button_release	(GtkWidget *widget,
-					 GdkEventButton *event);
-static void gtk_calendar_main_button	(GtkWidget *widget,
-					 GdkEventButton *event);
-static gint gtk_calendar_motion_notify	(GtkWidget *widget,
-					 GdkEventMotion *event);
-static gint gtk_calendar_enter_notify	(GtkWidget *widget,
-					 GdkEventCrossing *event);
-static gint gtk_calendar_leave_notify	(GtkWidget *widget,
-					 GdkEventCrossing *event);
-static gint gtk_calendar_key_press	(GtkWidget	   *widget,
-					 GdkEventKey	   *event);
+                                         guint         prop_id,
+                                         GValue       *value,
+                                         GParamSpec   *pspec);
+static void gtk_calendar_realize        (GtkWidget *widget);
+static void gtk_calendar_unrealize      (GtkWidget *widget);
+static void gtk_calendar_size_request   (GtkWidget *widget,
+                                         GtkRequisition *requisition);
+static void gtk_calendar_size_allocate  (GtkWidget *widget,
+                                         GtkAllocation *allocation);
+static gint gtk_calendar_expose         (GtkWidget *widget,
+                                         GdkEventExpose *event);
+static gint gtk_calendar_button_press   (GtkWidget *widget,
+                                         GdkEventButton *event);
+static gint gtk_calendar_button_release (GtkWidget *widget,
+                                         GdkEventButton *event);
+static void gtk_calendar_main_button    (GtkWidget *widget,
+                                         GdkEventButton *event);
+static gint gtk_calendar_motion_notify  (GtkWidget *widget,
+                                         GdkEventMotion *event);
+static gint gtk_calendar_enter_notify   (GtkWidget *widget,
+                                         GdkEventCrossing *event);
+static gint gtk_calendar_leave_notify   (GtkWidget *widget,
+                                         GdkEventCrossing *event);
+static gint gtk_calendar_key_press      (GtkWidget         *widget,
+                                         GdkEventKey       *event);
 static gint gtk_calendar_scroll         (GtkWidget         *widget,
-					 GdkEventScroll    *event);
+                                         GdkEventScroll    *event);
 static void gtk_calendar_grab_notify    (GtkWidget          *widget,
-			 	         gboolean            was_grabbed);
+                                         gboolean            was_grabbed);
 static gboolean gtk_calendar_focus_out  (GtkWidget          *widget,
-			 	         GdkEventFocus      *event);
-static void gtk_calendar_state_changed	(GtkWidget *widget,
-					 GtkStateType previous_state);
-static void gtk_calendar_style_set	(GtkWidget *widget,
-					 GtkStyle  *previous_style);
-static void gtk_calendar_paint_header	    (GtkWidget *widget);
+                                         GdkEventFocus      *event);
+static void gtk_calendar_state_changed  (GtkWidget *widget,
+                                         GtkStateType previous_state);
+static void gtk_calendar_style_set      (GtkWidget *widget,
+                                         GtkStyle  *previous_style);
+static void gtk_calendar_paint_header       (GtkWidget *widget);
+static void gtk_calendar_paint_footer (GtkWidget *widget);
 static void gtk_calendar_paint_day_names    (GtkWidget *widget);
 static void gtk_calendar_paint_week_numbers (GtkWidget *widget);
-static void gtk_calendar_paint_main	    (GtkWidget *widget);
+static void gtk_calendar_paint_main         (GtkWidget *widget);
 
 static void gtk_calendar_select_and_focus_day (GtkCalendar *calendar,
-					       guint        day);
+                                               guint        day);
 
-static void gtk_calendar_paint_arrow	(GtkWidget    *widget,
-					 guint	       arrow);
-static void gtk_calendar_paint_day_num	(GtkWidget    *widget,
-					 gint	       day);
-static void gtk_calendar_paint_day	(GtkWidget    *widget,
-					 gint	       row,
-					 gint	       col);
-static void gtk_calendar_compute_days	(GtkCalendar  *calendar);
-static gint left_x_for_column		(GtkCalendar  *calendar,
-					 gint	       column);
-static gint top_y_for_row		(GtkCalendar  *calendar,
-					 gint	       row);
+static void gtk_calendar_paint_arrow    (GtkWidget    *widget,
+                                         guint         arrow);
+static void gtk_calendar_paint_day_num  (GtkWidget    *widget,
+                                         gint          day);
+static void gtk_calendar_paint_day      (GtkWidget    *widget,
+                                         gint          row,
+                                         gint          col);
+static void gtk_calendar_compute_days   (GtkCalendar  *calendar);
+static gint left_x_for_column           (GtkCalendar  *calendar,
+                                         gint          column);
+static gint top_y_for_row               (GtkCalendar  *calendar,
+                                         gint          row);
 
 static void gtk_calendar_drag_data_get      (GtkWidget        *widget,
-					     GdkDragContext   *context,
-					     GtkSelectionData *selection_data,
-					     guint             info,
-					     guint             time);
+                                             GdkDragContext   *context,
+                                             GtkSelectionData *selection_data,
+                                             guint             info,
+                                             guint             time);
 static void gtk_calendar_drag_data_received (GtkWidget        *widget,
-					     GdkDragContext   *context,
-					     gint              x,
-					     gint              y,
-					     GtkSelectionData *selection_data,
-					     guint             info,
-					     guint             time);
+                                             GdkDragContext   *context,
+                                             gint              x,
+                                             gint              y,
+                                             GtkSelectionData *selection_data,
+                                             guint             info,
+                                             guint             time);
 static gboolean gtk_calendar_drag_motion    (GtkWidget        *widget,
-					     GdkDragContext   *context,
-					     gint              x,
-					     gint              y,
-					     guint             time);
+                                             GdkDragContext   *context,
+                                             gint              x,
+                                             gint              y,
+                                             guint             time);
 static void gtk_calendar_drag_leave         (GtkWidget        *widget,
-				             GdkDragContext   *context,
-				             guint             time);
+                                             GdkDragContext   *context,
+                                             guint             time);
 static gboolean gtk_calendar_drag_drop      (GtkWidget        *widget,
-					     GdkDragContext   *context,
-					     gint              x,
-					     gint              y,
-					     guint             time);
-     
+                                             GdkDragContext   *context,
+                                             gint              x,
+                                             gint              y,
+                                             guint             time);
+
+/* This function was added because we need to mark current day according to
+ * specifications
+ */
+static void
+gtk_calendar_check_current_date (GtkCalendar *calendar, gint x, gint y);
+
 static char    *default_abbreviated_dayname[7];
 static char    *default_monthname[12];
 
@@ -394,19 +446,19 @@
     {
       static const GTypeInfo calendar_info =
       {
-	sizeof (GtkCalendarClass),
-	NULL,		/* base_init */
-	NULL,		/* base_finalize */
-	(GClassInitFunc) gtk_calendar_class_init,
-	NULL,		/* class_finalize */
-	NULL,		/* class_data */
-	sizeof (GtkCalendar),
-	0,		/* n_preallocs */
-	(GInstanceInitFunc) gtk_calendar_init,
+        sizeof (GtkCalendarClass),
+        NULL,           /* base_init */
+        NULL,           /* base_finalize */
+        (GClassInitFunc) gtk_calendar_class_init,
+        NULL,           /* class_finalize */
+        NULL,           /* class_data */
+        sizeof (GtkCalendar),
+        0,              /* n_preallocs */
+        (GInstanceInitFunc) gtk_calendar_init,
       };
 
       calendar_type = g_type_register_static (GTK_TYPE_WIDGET, "GtkCalendar",
-					      &calendar_info, 0);
+                                              &calendar_info, 0);
     }
   
   return calendar_type;
@@ -461,28 +513,30 @@
   class->next_month = NULL;
   class->prev_year = NULL;
   class->next_year = NULL;
+  class->erroneous_date = NULL;
+  class->selected_date = NULL;
 
   g_object_class_install_property (gobject_class,
                                    PROP_YEAR,
                                    g_param_spec_int ("year",
-						     P_("Year"),
-						     P_("The selected year"),
-						     0, G_MAXINT, 0,
-						     G_PARAM_READWRITE));
+                                                     P_("Year"),
+                                                     P_("The selected year"),
+                                                     0, G_MAXINT, 0,
+                                                     G_PARAM_READWRITE));
   g_object_class_install_property (gobject_class,
                                    PROP_MONTH,
                                    g_param_spec_int ("month",
-						     P_("Month"),
-						     P_("The selected month (as a number between 0 and 11)"),
-						     0, 11, 0,
-						     G_PARAM_READWRITE));
+                                                     P_("Month"),
+                                                     P_("The selected month (as a number between 0 and 11)"),
+                                                     0, 11, 0,
+                                                     G_PARAM_READWRITE));
   g_object_class_install_property (gobject_class,
                                    PROP_DAY,
                                    g_param_spec_int ("day",
-						     P_("Day"),
-						     P_("The selected day (as a number between 1 and 31, or 0 to unselect the currently selected day)"),
-						     0, 31, 0,
-						     G_PARAM_READWRITE));
+                                                     P_("Day"),
+                                                     P_("The selected day (as a number between 1 and 31, or 0 to unselect the currently selected day)"),
+                                                     0, 31, 0,
+                                                     G_PARAM_READWRITE));
 
 /**
  * GtkCalendar:show-heading:
@@ -494,10 +548,10 @@
   g_object_class_install_property (gobject_class,
                                    PROP_SHOW_HEADING,
                                    g_param_spec_boolean ("show_heading",
-							 P_("Show Heading"),
-							 P_("If TRUE, a heading is displayed"),
-							 TRUE,
-							 G_PARAM_READWRITE));
+                                                         P_("Show Heading"),
+                                                         P_("If TRUE, a heading is displayed"),
+                                                         TRUE,
+                                                         G_PARAM_READWRITE));
 
 /**
  * GtkCalendar:show-day-names:
@@ -509,10 +563,10 @@
   g_object_class_install_property (gobject_class,
                                    PROP_SHOW_DAY_NAMES,
                                    g_param_spec_boolean ("show_day_names",
-							 P_("Show Day Names"),
-							 P_("If TRUE, day names are displayed"),
-							 TRUE,
-							 G_PARAM_READWRITE));
+                                                         P_("Show Day Names"),
+                                                         P_("If TRUE, day names are displayed"),
+                                                         TRUE,
+                                                         G_PARAM_READWRITE));
 /**
  * GtkCalendar:no-month-change:
  *
@@ -523,10 +577,10 @@
   g_object_class_install_property (gobject_class,
                                    PROP_NO_MONTH_CHANGE,
                                    g_param_spec_boolean ("no_month_change",
-							 P_("No Month Change"),
-							 P_("If TRUE, the selected month cannot be changed"),
-							 FALSE,
-							 G_PARAM_READWRITE));
+                                                         P_("No Month Change"),
+                                                         P_("If TRUE, the selected month cannot be changed"),
+                                                         FALSE,
+                                                         G_PARAM_READWRITE));
 
 /**
  * GtkCalendar:show-week-numbers:
@@ -538,67 +592,123 @@
   g_object_class_install_property (gobject_class,
                                    PROP_SHOW_WEEK_NUMBERS,
                                    g_param_spec_boolean ("show_week_numbers",
-							 P_("Show Week Numbers"),
-							 P_("If TRUE, week numbers are displayed"),
-							 FALSE,
-							 G_PARAM_READWRITE));
+                                                         P_("Show Week Numbers"),
+                                                         P_("If TRUE, week numbers are displayed"),
+                                                         FALSE,
+                                                         G_PARAM_READWRITE));
+
+/**
+ * GtkCalendar:week-start:
+ *
+ * Determines the start day of the week (0 for Sunday, 1 for Monday etc.)
+ *
+ * Since: OSSO addition
+ */
+  g_object_class_install_property (gobject_class,
+                                   PROP_WEEK_START,
+                                   g_param_spec_int ("week_start",
+                                                     P_("Week start day"),
+                                                     P_("First day of the week; 0 for Sunday, 1 for Monday etc."),
+                                                     0, 6, 0,
+                                                     G_PARAM_READWRITE));
+
+  gtk_widget_class_install_style_property (widget_class,
+                                          g_param_spec_int ("min-year",
+                                                              P_("Minimum year for calendar"),
+                                                              P_("Set minimum year calendar accepts"),
+                                                              0,
+                                                              G_MAXINT,
+                                                              HILDON_MIN_YEAR,
+                                                              G_PARAM_READWRITE));
+
+  gtk_widget_class_install_style_property (widget_class,
+                                          g_param_spec_int ("max-year",
+                                                              P_("Maximum year for calendar"),
+                                                              P_("Set max year that calendar accepts"),
+                                                              0,
+                                                              G_MAXINT,
+                                                              HILDON_MAX_YEAR,
+                                                              G_PARAM_READWRITE));
+
+  gtk_widget_class_install_style_property (widget_class,
+                                  g_param_spec_boolean ("hildonlike",
+                                  _("Size request"),
+                                  _("Size allocate"),
+                                  FALSE,
+                                  G_PARAM_READABLE));
 
   gtk_calendar_signals[MONTH_CHANGED_SIGNAL] =
     g_signal_new ("month_changed",
-		  G_OBJECT_CLASS_TYPE (gobject_class),
-		  G_SIGNAL_RUN_FIRST,
-		  G_STRUCT_OFFSET (GtkCalendarClass, month_changed),
-		  NULL, NULL,
-		  _gtk_marshal_VOID__VOID,
-		  G_TYPE_NONE, 0);
+                  G_OBJECT_CLASS_TYPE (gobject_class),
+                  G_SIGNAL_RUN_FIRST,
+                  G_STRUCT_OFFSET (GtkCalendarClass, month_changed),
+                  NULL, NULL,
+                  _gtk_marshal_VOID__VOID,
+                  G_TYPE_NONE, 0);
   gtk_calendar_signals[DAY_SELECTED_SIGNAL] =
     g_signal_new ("day_selected",
-		  G_OBJECT_CLASS_TYPE (gobject_class),
-		  G_SIGNAL_RUN_FIRST,
-		  G_STRUCT_OFFSET (GtkCalendarClass, day_selected),
-		  NULL, NULL,
-		  _gtk_marshal_VOID__VOID,
-		  G_TYPE_NONE, 0);
+                  G_OBJECT_CLASS_TYPE (gobject_class),
+                  G_SIGNAL_RUN_FIRST,
+                  G_STRUCT_OFFSET (GtkCalendarClass, day_selected),
+                  NULL, NULL,
+                  _gtk_marshal_VOID__VOID,
+                  G_TYPE_NONE, 0);
   gtk_calendar_signals[DAY_SELECTED_DOUBLE_CLICK_SIGNAL] =
     g_signal_new ("day_selected_double_click",
-		  G_OBJECT_CLASS_TYPE (gobject_class),
-		  G_SIGNAL_RUN_FIRST,
-		  G_STRUCT_OFFSET (GtkCalendarClass, day_selected_double_click),
-		  NULL, NULL,
-		  _gtk_marshal_VOID__VOID,
-		  G_TYPE_NONE, 0);
+                  G_OBJECT_CLASS_TYPE (gobject_class),
+                  G_SIGNAL_RUN_FIRST,
+                  G_STRUCT_OFFSET (GtkCalendarClass, day_selected_double_click),
+                  NULL, NULL,
+                  _gtk_marshal_VOID__VOID,
+                  G_TYPE_NONE, 0);
   gtk_calendar_signals[PREV_MONTH_SIGNAL] =
     g_signal_new ("prev_month",
-		  G_OBJECT_CLASS_TYPE (gobject_class),
-		  G_SIGNAL_RUN_FIRST,
-		  G_STRUCT_OFFSET (GtkCalendarClass, prev_month),
-		  NULL, NULL,
-		  _gtk_marshal_VOID__VOID,
-		  G_TYPE_NONE, 0);
+                  G_OBJECT_CLASS_TYPE (gobject_class),
+                  G_SIGNAL_RUN_FIRST,
+                  G_STRUCT_OFFSET (GtkCalendarClass, prev_month),
+                  NULL, NULL,
+                  _gtk_marshal_VOID__VOID,
+                  G_TYPE_NONE, 0);
   gtk_calendar_signals[NEXT_MONTH_SIGNAL] =
     g_signal_new ("next_month",
-		  G_OBJECT_CLASS_TYPE (gobject_class),
-		  G_SIGNAL_RUN_FIRST,
-		  G_STRUCT_OFFSET (GtkCalendarClass, next_month),
-		  NULL, NULL,
-		  _gtk_marshal_VOID__VOID,
-		  G_TYPE_NONE, 0);
+                  G_OBJECT_CLASS_TYPE (gobject_class),
+                  G_SIGNAL_RUN_FIRST,
+                  G_STRUCT_OFFSET (GtkCalendarClass, next_month),
+                  NULL, NULL,
+                  _gtk_marshal_VOID__VOID,
+                  G_TYPE_NONE, 0);
   gtk_calendar_signals[PREV_YEAR_SIGNAL] =
     g_signal_new ("prev_year",
-		  G_OBJECT_CLASS_TYPE (gobject_class),
-		  G_SIGNAL_RUN_FIRST,
-		  G_STRUCT_OFFSET (GtkCalendarClass, prev_year),
-		  NULL, NULL,
-		  _gtk_marshal_VOID__VOID,
-		  G_TYPE_NONE, 0);
+                  G_OBJECT_CLASS_TYPE (gobject_class),
+                  G_SIGNAL_RUN_FIRST,
+                  G_STRUCT_OFFSET (GtkCalendarClass, prev_year),
+                  NULL, NULL,
+                  _gtk_marshal_VOID__VOID,
+                  G_TYPE_NONE, 0);
   gtk_calendar_signals[NEXT_YEAR_SIGNAL] =
     g_signal_new ("next_year",
-		  G_OBJECT_CLASS_TYPE (gobject_class),
-		  G_SIGNAL_RUN_FIRST,
-		  G_STRUCT_OFFSET (GtkCalendarClass, next_year),
-		  NULL, NULL,
-		  _gtk_marshal_VOID__VOID,
-		  G_TYPE_NONE, 0);
+                  G_OBJECT_CLASS_TYPE (gobject_class),
+                  G_SIGNAL_RUN_FIRST,
+                  G_STRUCT_OFFSET (GtkCalendarClass, next_year),
+                  NULL, NULL,
+                  _gtk_marshal_VOID__VOID,
+                  G_TYPE_NONE, 0);
+   gtk_calendar_signals[ERRONEOUS_DATE_SIGNAL] =
+     g_signal_new ("erroneous_date",
+                   G_OBJECT_CLASS_TYPE(gobject_class),
+                   G_SIGNAL_RUN_FIRST,
+                   G_STRUCT_OFFSET (GtkCalendarClass, erroneous_date),
+                   NULL, NULL,
+                   _gtk_marshal_VOID__VOID,
+                   G_TYPE_NONE, 0);
+   gtk_calendar_signals[SELECTED_DATE_SIGNAL] =
+     g_signal_new ("selected_date",
+                   G_OBJECT_CLASS_TYPE(gobject_class),
+                   G_SIGNAL_RUN_FIRST,
+                   G_STRUCT_OFFSET (GtkCalendarClass, selected_date),
+                   NULL, NULL,
+                   _gtk_marshal_VOID__VOID,
+                   G_TYPE_NONE, 0);
 }
 
 static void
@@ -607,12 +717,14 @@
   time_t secs;
   struct tm *tm;
   gint i;
-  char buffer[255];
-  time_t tmp_time;
+/*  char buffer[255];*/
+/*  time_t tmp_time;*/
   GtkWidget *widget;
   GtkCalendarPrivateData *private_data;
-  gchar *year_before;
-  gchar *week_start;
+/*  gchar *year_before;*/
+/*  gint row;
+  gint col; */
+  guint32 week_1stday;
   
   widget = GTK_WIDGET (calendar);
   GTK_WIDGET_SET_FLAGS (widget, GTK_CAN_FOCUS);
@@ -620,22 +732,6 @@
   calendar->private_data = g_malloc (sizeof (GtkCalendarPrivateData));
   private_data = GTK_CALENDAR_PRIVATE_DATA (calendar);
 
-  if (!default_abbreviated_dayname[0])
-    for (i=0; i<7; i++)
-      {
-	tmp_time= (i+3)*86400;
-	strftime ( buffer, sizeof (buffer), "%a", gmtime (&tmp_time));
-	default_abbreviated_dayname[i] = g_locale_to_utf8 (buffer, -1, NULL, NULL, NULL);
-      }
-  
-  if (!default_monthname[0])
-    for (i=0; i<12; i++)
-      {
-	tmp_time=i*2764800;
-	strftime ( buffer, sizeof (buffer), "%B", gmtime (&tmp_time));
-	default_monthname[i] = g_locale_to_utf8 (buffer, -1, NULL, NULL, NULL);
-      }
-  
   /* Set defaults */
   secs = time (NULL);
   tm = localtime (&secs);
@@ -645,16 +741,29 @@
   for (i=0;i<31;i++)
     calendar->marked_date[i] = FALSE;
   calendar->num_marked_dates = 0;
-  calendar->selected_day = tm->tm_mday;
-  
+  calendar->selected_day = tm->tm_mday; 
+     
   calendar->display_flags = ( GTK_CALENDAR_SHOW_HEADING | 
-			      GTK_CALENDAR_SHOW_DAY_NAMES );
+                              GTK_CALENDAR_SHOW_DAY_NAMES );
   
+  /* Hildon: we should mark current day  and we need to store current date */
+  private_data->current_day  = tm->tm_mday;
+  private_data->current_month = tm->tm_mon;
+  private_data->current_year = tm->tm_year + 1900;
+
+  /* Hildon: following lines are for stylus sliding */   
+  private_data->slide_stylus = FALSE;
+  private_data->prev_row = -1;
+  private_data->prev_col = -1;
+
+  /* Hildon: is_bad_day indicate if day was selected out of legal range */
+  private_data->is_bad_day = FALSE;
+
   calendar->highlight_row = -1;
-  calendar->highlight_col = -1;
+  calendar->highlight_col = -1; 
   
   calendar->focus_row = -1;
-  calendar->focus_col = -1;
+  calendar->focus_col = -1; 
   calendar->xor_gc = NULL;
 
   private_data->max_year_width = 0;
@@ -667,7 +776,7 @@
   private_data->max_label_char_ascent = 0;
   private_data->max_label_char_descent = 0;
 
-  private_data->arrow_width = 10;
+/*  private_data->arrow_width = 10;*/
 
   private_data->freeze_count = 0;
   
@@ -686,6 +795,46 @@
   gtk_drag_dest_set (widget, 0, NULL, 0, GDK_ACTION_COPY);
   gtk_drag_dest_add_text_targets (widget);
 
+  default_abbreviated_dayname[0] = g_locale_to_utf8(nl_langinfo(ABDAY_1),
+                                                    -1, NULL, NULL, NULL);
+  default_abbreviated_dayname[1] = g_locale_to_utf8(nl_langinfo(ABDAY_2),
+                                                    -1, NULL, NULL, NULL);
+  default_abbreviated_dayname[2] = g_locale_to_utf8(nl_langinfo(ABDAY_3),
+                                                    -1, NULL, NULL, NULL);
+  default_abbreviated_dayname[3] = g_locale_to_utf8(nl_langinfo(ABDAY_4),
+                                                    -1, NULL, NULL, NULL);
+  default_abbreviated_dayname[4] = g_locale_to_utf8(nl_langinfo(ABDAY_5),
+                                                    -1, NULL, NULL, NULL);
+  default_abbreviated_dayname[5] = g_locale_to_utf8(nl_langinfo(ABDAY_6),
+                                                    -1, NULL, NULL, NULL);
+  default_abbreviated_dayname[6] = g_locale_to_utf8(nl_langinfo(ABDAY_7),
+                                                    -1, NULL, NULL, NULL);
+  default_monthname[0] = g_locale_to_utf8(nl_langinfo(MON_1),
+                                          -1, NULL, NULL, NULL);
+  default_monthname[1] = g_locale_to_utf8(nl_langinfo(MON_2),
+                                          -1, NULL, NULL, NULL);
+  default_monthname[2] = g_locale_to_utf8(nl_langinfo(MON_3),
+                                          -1, NULL, NULL, NULL);
+  default_monthname[3] = g_locale_to_utf8(nl_langinfo(MON_4),
+                                          -1, NULL, NULL, NULL);
+  default_monthname[4] = g_locale_to_utf8(nl_langinfo(MON_5),
+                                          -1, NULL, NULL, NULL);
+  default_monthname[5] = g_locale_to_utf8(nl_langinfo(MON_6),
+                                          -1, NULL, NULL, NULL);
+  default_monthname[6] = g_locale_to_utf8(nl_langinfo(MON_7),
+                                          -1, NULL, NULL, NULL);
+  default_monthname[7] = g_locale_to_utf8(nl_langinfo(MON_8),
+                                          -1, NULL, NULL, NULL);
+  default_monthname[8] = g_locale_to_utf8(nl_langinfo(MON_9),
+                                          -1, NULL, NULL, NULL);
+  default_monthname[9] = g_locale_to_utf8(nl_langinfo(MON_10),
+                                          -1, NULL, NULL, NULL);
+  default_monthname[10] = g_locale_to_utf8(nl_langinfo(MON_11),
+                                           -1, NULL, NULL, NULL);
+  default_monthname[11] = g_locale_to_utf8(nl_langinfo(MON_12),
+                                           -1, NULL, NULL, NULL);
+
+#if 0
   private_data->year_before = 0;
 
   /* Translate to calendar:YM if you want years to be displayed
@@ -702,21 +851,24 @@
     private_data->year_before = 1;
   else if (strcmp (year_before, "calendar:MY") != 0)
     g_warning ("Whoever translated calendar:MY did so wrongly.\n");
+#endif
 
-  /* Translate to calendar:week_start:0 if you want Sunday to be the
-   * first day of the week to calendar:week_start:1 if you want Monday
-   * to be the first day of the week, and so on.
-   */  
-  week_start = _("calendar:week_start:0");
+  /* Use nl_langinfo to obtain the first day of the week */
+  week_1stday = nl_langinfo (_NL_TIME_WEEK_1STDAY);
 
-  if (strncmp (week_start, "calendar:week_start:", 20) == 0)
-    private_data->week_start = *(week_start + 20) - '0';
-  else 
-    private_data->week_start = -1;
-  
-  if (private_data->week_start < 0 || private_data->week_start > 6)
+  if (g_date_valid_dmy (week_1stday % 100,
+                        week_1stday % 10000 / 100,
+                        week_1stday / 10000))
+    {
+      GDate *start_day = g_date_new_dmy (week_1stday % 100,
+                                         week_1stday % 10000 / 100,
+                                         week_1stday / 10000);
+      private_data->week_start = g_date_get_weekday (start_day) % 7;
+      g_date_free (start_day);
+    }
+  else
     {
-      g_warning ("Whoever translated calendar:week_start:0 did so wrongly.\n");
+      g_warning ("nl_langinfo(_NL_TIME_WEEK_1STDAY) returns invalid date");
       private_data->week_start = 0;
     }
 }
@@ -731,7 +883,7 @@
  * x pixel of the xwindow is in */
 static gint
 column_from_x (GtkCalendar *calendar,
-	       gint	    event_x)
+               gint         event_x)
 {
   gint c, column;
   gint x_left, x_right;
@@ -744,47 +896,46 @@
       x_right = x_left + GTK_CALENDAR_PRIVATE_DATA (calendar)->day_width;
       
       if (event_x >= x_left && event_x < x_right)
-	{
-	  column = c;
-	  break;
-	}
+        {
+          column = c;
+          break;
+        }
     }
   
   return column;
 }
-
+#if 0
 static gint
 row_height (GtkCalendar *calendar)
 {
   return (GTK_CALENDAR_PRIVATE_DATA (calendar)->main_h - CALENDAR_MARGIN
-	  - ((calendar->display_flags & GTK_CALENDAR_SHOW_DAY_NAMES)
-	     ? CALENDAR_YSEP : CALENDAR_MARGIN)) / 6;
+          - ((calendar->display_flags & GTK_CALENDAR_SHOW_DAY_NAMES)
+             ? CALENDAR_YSEP : CALENDAR_MARGIN)) / 6;
 }
-
+#endif
 
 /* row_from_y: returns the row 0-5 that the
  * y pixel of the xwindow is in */
 static gint
 row_from_y (GtkCalendar *calendar,
-	    gint	 event_y)
+            gint         event_y)
 {
   gint r, row;
-  gint height;
+  /*gint height;*/
   gint y_top, y_bottom;
   
-  height = row_height (calendar);
   row = -1;
   
   for (r = 0; r < 6; r++)
     {
       y_top = top_y_for_row (calendar, r);
-      y_bottom = y_top + height;
+      y_bottom = y_top + HILDON_DAY_HEIGHT /*height*/;
       
       if (event_y >= y_top && event_y < y_bottom)
-	{
-	  row = r;
-	  break;
-	}
+        {
+          row = r;
+          break;
+        }
     }
   
   return row;
@@ -792,20 +943,20 @@
  * for the left of the column */
 static gint
 left_x_for_column (GtkCalendar *calendar,
-		   gint		column)
+                   gint         column)
 {
   gint width;
   gint x_left;
-  
+   
   if (gtk_widget_get_direction (GTK_WIDGET (calendar)) == GTK_TEXT_DIR_RTL)
     column = 6 - column;
-
+ 
   width = GTK_CALENDAR_PRIVATE_DATA (calendar)->day_width;
   if (calendar->display_flags & GTK_CALENDAR_SHOW_WEEK_NUMBERS)
     x_left = CALENDAR_XSEP + (width + DAY_XSEP) * column;
   else
     x_left = CALENDAR_MARGIN + (width + DAY_XSEP) * column;
-  
+   
   return x_left;
 }
 
@@ -813,41 +964,57 @@
  * for the top of the row */
 static gint
 top_y_for_row (GtkCalendar *calendar,
-	       gint	    row)
+               gint         row)
 {
   
   return (GTK_CALENDAR_PRIVATE_DATA (calendar)->main_h 
-	  - (CALENDAR_MARGIN + (6 - row)
-	     * row_height (calendar)));
+          - (CALENDAR_MARGIN + (6 - row)
+             * HILDON_DAY_HEIGHT));
 }
 
 static void
 gtk_calendar_set_month_prev (GtkCalendar *calendar)
 {
   gint month_len;
-  
+  gint min_year;
+  gboolean hildonlike;
+
+  gtk_widget_style_get (GTK_WIDGET (calendar), "hildonlike", &hildonlike,
+                        "min-year", &min_year, NULL);
+
   if (calendar->display_flags & GTK_CALENDAR_NO_MONTH_CHANGE)
     return;
   
   if (calendar->month == 0)
-    {
-      calendar->month = 11;
-      calendar->year--;
-    } 
-  else 
-    calendar->month--;
-  
+     {
+       if (hildonlike)
+         {
+            if (calendar->year > min_year) 
+              {
+                 calendar->month = 11;
+                 calendar->year--;
+              }
+         }
+       else
+         {
+           calendar->month = 11;
+           calendar->year--;
+         }
+      }
+  else
+     calendar->month--;
+
   month_len = month_length[leap (calendar->year)][calendar->month + 1];
   
   gtk_calendar_freeze (calendar);
   gtk_calendar_compute_days (calendar);
   
   g_signal_emit (calendar,
-		 gtk_calendar_signals[PREV_MONTH_SIGNAL],
-		 0);
+                 gtk_calendar_signals[PREV_MONTH_SIGNAL],
+                 0);
   g_signal_emit (calendar,
-		 gtk_calendar_signals[MONTH_CHANGED_SIGNAL],
-		 0);
+                 gtk_calendar_signals[MONTH_CHANGED_SIGNAL],
+                 0);
   
   if (month_len < calendar->selected_day)
     {
@@ -857,7 +1024,7 @@
   else
     {
       if (calendar->selected_day < 0)
-	calendar->selected_day = calendar->selected_day + 1 + month_length[leap (calendar->year)][calendar->month + 1];
+        calendar->selected_day = calendar->selected_day + 1 + month_length[leap (calendar->year)][calendar->month + 1];
       gtk_calendar_select_day (calendar, calendar->selected_day);
     }
 
@@ -870,17 +1037,32 @@
 gtk_calendar_set_month_next (GtkCalendar *calendar)
 {
   gint month_len;
+  gint max_year;
+  gboolean hildonlike;
   
   g_return_if_fail (GTK_IS_WIDGET (calendar));
   
+  gtk_widget_style_get (GTK_WIDGET (calendar), "hildonlike", &hildonlike,
+                        "max-year", &max_year, NULL);
+
   if (calendar->display_flags & GTK_CALENDAR_NO_MONTH_CHANGE)
     return;
   
-  
   if (calendar->month == 11)
     {
-      calendar->month = 0;
-      calendar->year++;
+      if (hildonlike)
+        {
+          if (calendar->year < max_year)
+            {
+              calendar->month = 0;
+              calendar->year++;
+            }
+        }
+      else
+        {
+          calendar->month = 0;
+          calendar->year++;
+        }
     } 
   else 
     calendar->month++;
@@ -888,11 +1070,11 @@
   gtk_calendar_freeze (calendar);
   gtk_calendar_compute_days (calendar);
   g_signal_emit (calendar,
-		 gtk_calendar_signals[NEXT_MONTH_SIGNAL],
-		 0);
+                 gtk_calendar_signals[NEXT_MONTH_SIGNAL],
+                 0);
   g_signal_emit (calendar,
-		 gtk_calendar_signals[MONTH_CHANGED_SIGNAL],
-		 0);
+                 gtk_calendar_signals[MONTH_CHANGED_SIGNAL],
+                 0);
   
   month_len = month_length[leap (calendar->year)][calendar->month + 1];
   
@@ -912,18 +1094,30 @@
 gtk_calendar_set_year_prev (GtkCalendar *calendar)
 {
   gint month_len;
-  
+  gint min_year;
+  gboolean hildonlike;
+
   g_return_if_fail (GTK_IS_WIDGET (calendar));
   
-  calendar->year--;
+  gtk_widget_style_get (GTK_WIDGET (calendar), "hildonlike", &hildonlike,
+                        "min-year", &min_year, NULL);
+  
+  if (hildonlike)
+  {
+      if (calendar->year > min_year)
+         calendar->year--;
+  }
+  else 
+      calendar->year--;
+
   gtk_calendar_freeze (calendar);
   gtk_calendar_compute_days (calendar);
   g_signal_emit (calendar,
-		 gtk_calendar_signals[PREV_YEAR_SIGNAL],
-		 0);
+                 gtk_calendar_signals[PREV_YEAR_SIGNAL],
+                 0);
   g_signal_emit (calendar,
-		 gtk_calendar_signals[MONTH_CHANGED_SIGNAL],
-		 0);
+                 gtk_calendar_signals[MONTH_CHANGED_SIGNAL],
+                 0);
   
   month_len = month_length[leap (calendar->year)][calendar->month + 1];
   
@@ -944,21 +1138,33 @@
 {
   gint month_len;
   GtkWidget *widget;
+  gint max_year;
+  gboolean hildonlike;
   
   g_return_if_fail (GTK_IS_WIDGET (calendar));
   
   widget = GTK_WIDGET (calendar);
+
+  gtk_widget_style_get(widget, "hildonlike", &hildonlike, 
+                       "max-year", &max_year, NULL);
   
   gtk_calendar_freeze (calendar);
   
-  calendar->year++;
+  if (hildonlike)
+  {
+     if (calendar->year < max_year)
+       calendar->year++;
+  }
+  else
+      calendar->year++;
+
   gtk_calendar_compute_days (calendar);
   g_signal_emit (calendar,
-		 gtk_calendar_signals[NEXT_YEAR_SIGNAL],
-		 0);
+                 gtk_calendar_signals[NEXT_YEAR_SIGNAL],
+                 0);
   g_signal_emit (calendar,
-		 gtk_calendar_signals[MONTH_CHANGED_SIGNAL],
-		 0);
+                 gtk_calendar_signals[MONTH_CHANGED_SIGNAL],
+                 0);
   
   month_len = month_length[leap (calendar->year)][calendar->month + 1];
   
@@ -969,14 +1175,13 @@
     }
   else
     gtk_calendar_select_day (calendar, calendar->selected_day);
-  
   gtk_widget_queue_draw (GTK_WIDGET (calendar));
   gtk_calendar_thaw (calendar);
 }
 
 static void
-gtk_calendar_main_button (GtkWidget	 *widget,
-			  GdkEventButton *event)
+gtk_calendar_main_button (GtkWidget      *widget,
+                          GdkEventButton *event)
 {
   GtkCalendar *calendar;
   GtkCalendarPrivateData *private_data;
@@ -984,6 +1189,8 @@
   gint row, col;
   gint day_month;
   gint day;
+  gint max_year, min_year;
+  gboolean hildonlike;
   
   calendar = GTK_CALENDAR (widget);
   private_data = GTK_CALENDAR_PRIVATE_DATA (widget);
@@ -997,37 +1204,53 @@
   /* If row or column isn't found, just return. */
   if (row == -1 || col == -1)
     return;
-  
-  day_month = calendar->day_month[row][col];
 
-  if (event->type == GDK_BUTTON_PRESS)
+  gtk_widget_style_get (GTK_WIDGET (calendar), "hildonlike", &hildonlike,
+                        "max-year", &max_year, "min-year", &min_year, NULL);
+  day_month = calendar->day_month[row][col];
+  
+  if (hildonlike) 
+    {
+      if ((calendar->year == min_year && calendar->month == 0 && day_month == MONTH_PREV)
+          || (calendar->year == max_year && calendar->month == 11 && day_month == MONTH_NEXT)) 
+        {
+          private_data->is_bad_day = TRUE;
+          g_signal_emit (calendar, gtk_calendar_signals[ERRONEOUS_DATE_SIGNAL], 0);
+          return;
+        }
+    }
+  if (event->type == (hildonlike ? GDK_BUTTON_RELEASE : GDK_BUTTON_PRESS))
     {
       day = calendar->day[row][col];
       
       if (day_month == MONTH_PREV)
-	gtk_calendar_set_month_prev (calendar);
+        {  
+          gtk_calendar_set_month_prev (calendar);
+        }
       else if (day_month == MONTH_NEXT)
-	gtk_calendar_set_month_next (calendar);
+        {
+          gtk_calendar_set_month_next (calendar);
+        }
       
       if (!GTK_WIDGET_HAS_FOCUS (widget))
-	gtk_widget_grab_focus (widget);
-	  
+              gtk_widget_grab_focus (widget);
+          
       if (event->button == 1) 
-	{
-	  private_data->in_drag = 1;
-	  private_data->drag_start_x = x;
-	  private_data->drag_start_y = y;
-	}
+        {
+          private_data->in_drag = 1;
+          private_data->drag_start_x = x;
+          private_data->drag_start_y = y;
+        }
 
       gtk_calendar_select_and_focus_day (calendar, day);
     }
   else if (event->type == GDK_2BUTTON_PRESS)
     {
       private_data->in_drag = 0;
+      private_data->slide_stylus = FALSE;
       if (day_month == MONTH_CURRENT)
-	g_signal_emit (calendar,
-		       gtk_calendar_signals[DAY_SELECTED_DOUBLE_CLICK_SIGNAL],
-		       0);
+              g_signal_emit (calendar,
+                       gtk_calendar_signals[DAY_SELECTED_DOUBLE_CLICK_SIGNAL], 0);
     }
 }
 
@@ -1039,18 +1262,18 @@
   GdkWindowAttr attributes;
   gint attributes_mask;
   gint i;
-  gboolean year_left;
+  /*gboolean year_left;*/
   
   g_return_if_fail (GTK_IS_CALENDAR (widget));
   
   calendar = GTK_CALENDAR (widget);
   private_data = GTK_CALENDAR_PRIVATE_DATA (widget);
-
+/*
   if (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_LTR) 
     year_left = private_data->year_before;
   else
     year_left = !private_data->year_before;
-    
+*/    
   /* Arrow windows ------------------------------------- */
   if (! (calendar->display_flags & GTK_CALENDAR_NO_MONTH_CHANGE)
       && (calendar->display_flags & GTK_CALENDAR_SHOW_HEADING))
@@ -1060,66 +1283,85 @@
       attributes.visual = gtk_widget_get_visual (widget);
       attributes.colormap = gtk_widget_get_colormap (widget);
       attributes.event_mask = (gtk_widget_get_events (widget) | GDK_EXPOSURE_MASK
-			       | GDK_BUTTON_PRESS_MASK	| GDK_BUTTON_RELEASE_MASK
-			       | GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK);
+                               | GDK_BUTTON_PRESS_MASK  | GDK_BUTTON_RELEASE_MASK
+                               | GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK);
       attributes_mask = GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL | GDK_WA_COLORMAP;
-      attributes.y = 3;
-      attributes.width = private_data->arrow_width;
-      attributes.height = private_data->header_h - 7;
-      for (i = 0; i < 4; i++)
-	{
-	  switch (i)
-	    {
-	    case ARROW_MONTH_LEFT:
-	      if (year_left) 
-		attributes.x = (widget->allocation.width - 2 * widget->style->xthickness
-				- (3 + 2*private_data->arrow_width 
-				   + private_data->max_month_width));
-	      else
-	      attributes.x = 3;
-	      break;
-	    case ARROW_MONTH_RIGHT:
-	      if (year_left) 
-		attributes.x = (widget->allocation.width - 2 * widget->style->xthickness 
-				- 3 - private_data->arrow_width);
-	      else
-	      attributes.x = (private_data->arrow_width 
-			      + private_data->max_month_width);
-	      break;
-	    case ARROW_YEAR_LEFT:
-	      if (year_left) 
-		attributes.x = 3;
-	      else
-	      attributes.x = (widget->allocation.width - 2 * widget->style->xthickness
-			      - (3 + 2*private_data->arrow_width 
-				 + private_data->max_year_width));
-	      break;
-	    case ARROW_YEAR_RIGHT:
-	      if (year_left) 
-		attributes.x = (private_data->arrow_width 
-				+ private_data->max_year_width);
-	      else
-	      attributes.x = (widget->allocation.width - 2 * widget->style->xthickness 
-			      - 3 - private_data->arrow_width);
-	      break;
-	    }
-	  private_data->arrow_win[i] = gdk_window_new (private_data->header_win,
-						       &attributes, 
-						       attributes_mask);
-	  if (GTK_WIDGET_IS_SENSITIVE (widget))
-	    private_data->arrow_state[i] = GTK_STATE_NORMAL;
-	  else 
-	    private_data->arrow_state[i] = GTK_STATE_INSENSITIVE;
-	  gdk_window_set_background (private_data->arrow_win[i],
-				     HEADER_BG_COLOR (GTK_WIDGET (calendar)));
-	  gdk_window_show (private_data->arrow_win[i]);
-	  gdk_window_set_user_data (private_data->arrow_win[i], widget);
-	}
+      attributes.y = 0;
+      attributes.width = HILDON_ARROW_WIDTH;
+      attributes.height = HILDON_ARROW_HEIGHT;
+      
+      attributes.x = (widget->allocation.width - private_data->max_year_width) / 2 - HILDON_ARROW_WIDTH - HILDON_ARROW_SEP;    
+            private_data->arrow_win[ARROW_YEAR_LEFT] = gdk_window_new (private_data->header_win,
+                                                       &attributes, attributes_mask);
+      
+      attributes.x = (widget->allocation.width + private_data->max_year_width) / 2 + HILDON_ARROW_SEP;
+            private_data->arrow_win[ARROW_YEAR_RIGHT] = gdk_window_new (private_data->header_win,
+                                                       &attributes, attributes_mask);
+      attributes.x = (widget->allocation.width - private_data->max_month_width) / 2 - HILDON_ARROW_WIDTH - HILDON_ARROW_SEP;
+            private_data->arrow_win[ARROW_MONTH_LEFT] = gdk_window_new (private_data->footer_win,
+                                                       &attributes, attributes_mask);
+      attributes.x = (widget->allocation.width + private_data->max_month_width) / 2 + HILDON_ARROW_SEP;
+            private_data->arrow_win[ARROW_MONTH_RIGHT] = gdk_window_new (private_data->footer_win,
+                                                       &attributes, attributes_mask);
+
+/*
+for (i = 0; i < 4; i++)
+        {
+          switch (i)
+            {
+            case ARROW_MONTH_LEFT:
+              if (year_left) 
+                attributes.x = (widget->allocation.width - 2 * widget->style->xthickness
+                                - (3 + 2*private_data->arrow_width 
+                                   + private_data->max_month_width));
+              else
+              attributes.x = 3;
+              break;
+            case ARROW_MONTH_RIGHT:
+              if (year_left) 
+                attributes.x = (widget->allocation.width - 2 * widget->style->xthickness 
+                                - 3 - private_data->arrow_width);
+              else
+              attributes.x = (private_data->arrow_width 
+                              + private_data->max_month_width);
+              break;
+            case ARROW_YEAR_LEFT:
+              if (year_left) 
+                attributes.x = 3;
+              else
+              attributes.x = (widget->allocation.width - 2 * widget->style->xthickness
+                              - (3 + 2*private_data->arrow_width 
+                                 + private_data->max_year_width));
+              break;
+            case ARROW_YEAR_RIGHT:
+              if (year_left) 
+                attributes.x = (private_data->arrow_width 
+                                + private_data->max_year_width);
+              else
+              attributes.x = (widget->allocation.width - 2 * widget->style->xthickness 
+                              - 3 - private_data->arrow_width);
+              break;
+            }
+          private_data->arrow_win[i] = gdk_window_new (private_data->header_win,
+                                                       &attributes, 
+                                                       attributes_mask);*/
+
+    for (i = 0; i < 4; i++)
+  {
+          if (GTK_WIDGET_IS_SENSITIVE (widget))
+            private_data->arrow_state[i] = GTK_STATE_NORMAL;
+          else 
+            private_data->arrow_state[i] = GTK_STATE_INSENSITIVE;
+          gdk_window_set_background (private_data->arrow_win[i],
+                                     HEADER_BG_COLOR (GTK_WIDGET (calendar)));
+          gdk_window_show (private_data->arrow_win[i]);
+          gdk_window_set_user_data (private_data->arrow_win[i], widget);
+        }
     }
   else
     {
       for (i = 0; i < 4; i++)
-	private_data->arrow_win[i] = NULL;
+        private_data->arrow_win[i] = NULL;
     }
 }
 
@@ -1145,23 +1387,33 @@
       attributes.colormap = gtk_widget_get_colormap (widget);
       attributes.event_mask = gtk_widget_get_events (widget) | GDK_EXPOSURE_MASK;
       attributes_mask = GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL | GDK_WA_COLORMAP;
-      attributes.x = widget->style->xthickness;
-      attributes.y = widget->style->ythickness;
-      attributes.width = widget->allocation.width - 2 * attributes.x;
-      attributes.height = private_data->header_h - 2 * attributes.y;
+      attributes.x = 0 /*widget->style->xthickness*/;
+      attributes.y = 0 /*widget->style->ythickness*/;
+      attributes.width = widget->allocation.width; /* - 2 * attributes.x */;
+      attributes.height = HILDON_ARROW_HEIGHT /*private_data->header_h - 2 * attributes.y*/;
       private_data->header_win = gdk_window_new (widget->window,
-					     &attributes, attributes_mask);
-      
+                                                 &attributes, attributes_mask);
+
+      attributes.y = HILDON_ARROW_HEIGHT + 2 * CALENDAR_YSEP + private_data->main_h + private_data->day_name_h;
+
+      private_data->footer_win = gdk_window_new(widget->window, 
+                                                &attributes, attributes_mask);
+
       gdk_window_set_background (private_data->header_win,
-				 HEADER_BG_COLOR (GTK_WIDGET (calendar)));
+                                 HEADER_BG_COLOR (widget));
+      gdk_window_set_background (private_data->footer_win,
+         HEADER_BG_COLOR (widget));
+  
       gdk_window_show (private_data->header_win);
+      gdk_window_show (private_data->footer_win);
       gdk_window_set_user_data (private_data->header_win, widget);
-      
+      gdk_window_set_user_data (private_data->footer_win, widget);
     }
   else
     {
       private_data->header_win = NULL;
-    }
+      private_data->footer_win = NULL;
+  }
   gtk_calendar_realize_arrows (widget);
 }
 
@@ -1172,13 +1424,13 @@
   GtkCalendarPrivateData *private_data;
   GdkWindowAttr attributes;
   gint attributes_mask;
-  
+
   g_return_if_fail (GTK_IS_CALENDAR (widget));
   
   calendar = GTK_CALENDAR (widget);
   private_data = GTK_CALENDAR_PRIVATE_DATA (widget);
 
-  /* Day names	window --------------------------------- */
+  /* Day names  window --------------------------------- */
   if ( calendar->display_flags & GTK_CALENDAR_SHOW_DAY_NAMES)
     {
       attributes.wclass = GDK_INPUT_OUTPUT;
@@ -1187,18 +1439,16 @@
       attributes.colormap = gtk_widget_get_colormap (widget);
       attributes.event_mask = gtk_widget_get_events (widget) | GDK_EXPOSURE_MASK;
       attributes_mask = GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL | GDK_WA_COLORMAP;
-      attributes.x = (widget->style->xthickness + INNER_BORDER);
-      attributes.y = private_data->header_h + (widget->style->ythickness 
-					   + INNER_BORDER);
-      attributes.width = (widget->allocation.width 
-			  - (widget->style->xthickness + INNER_BORDER) 
-			  * 2);
+      attributes.x = HILDON_DAY_WIDTH + HILDON_WEEKS_EXTRA_WIDTH/*(widget->style->xthickness + INNER_BORDER)*/;
+      attributes.y = private_data->header_h;
+      attributes.width = widget->allocation.width - attributes.x;
       attributes.height = private_data->day_name_h;
       private_data->day_name_win = gdk_window_new (widget->window,
-						   &attributes, 
-						   attributes_mask);
+                                                   &attributes, 
+                                                   attributes_mask);
       gdk_window_set_background (private_data->day_name_win, 
-				 BACKGROUND_COLOR ( GTK_WIDGET ( calendar)));
+                                BACKGROUND_COLOR ( GTK_WIDGET (calendar)));
+                                 
       gdk_window_show (private_data->day_name_win);
       gdk_window_set_user_data (private_data->day_name_win, widget);
     }
@@ -1215,7 +1465,7 @@
   GtkCalendarPrivateData *private_data;
   GdkWindowAttr attributes;
   gint attributes_mask;
-  
+
   g_return_if_fail (GTK_IS_CALENDAR (widget));
   
   calendar = GTK_CALENDAR (widget);
@@ -1231,15 +1481,15 @@
       attributes.event_mask = gtk_widget_get_events (widget) | GDK_EXPOSURE_MASK;
       
       attributes_mask = GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL | GDK_WA_COLORMAP;
-      attributes.x = widget->style->xthickness + INNER_BORDER;
-      attributes.y = (private_data->header_h + private_data->day_name_h 
-		      + (widget->style->ythickness + INNER_BORDER));
-      attributes.width = private_data->week_width;
-      attributes.height = private_data->main_h;
+      attributes.x = 0 /*widget->style->xthickness + INNER_BORDER*/;
+      attributes.y = private_data->header_h; 
+                      /*+ (widget->style->ythickness + INNER_BORDER))*/;
+      attributes.width = HILDON_DAY_WIDTH + HILDON_WEEKS_EXTRA_WIDTH;
+      attributes.height = private_data->main_h + private_data->day_name_h;
       private_data->week_win = gdk_window_new (widget->window,
-					       &attributes, attributes_mask);
+                                               &attributes, attributes_mask);
       gdk_window_set_background (private_data->week_win,  
-				 BACKGROUND_COLOR (GTK_WIDGET (calendar)));
+                                 BACKGROUND_COLOR (GTK_WIDGET (calendar)));
       gdk_window_show (private_data->week_win);
       gdk_window_set_user_data (private_data->week_win, widget);
     } 
@@ -1271,37 +1521,37 @@
   attributes.wclass = GDK_INPUT_OUTPUT;
   attributes.window_type = GDK_WINDOW_CHILD;
   attributes.event_mask =  (gtk_widget_get_events (widget) 
-			    | GDK_EXPOSURE_MASK |GDK_KEY_PRESS_MASK | GDK_SCROLL_MASK);
+                            | GDK_EXPOSURE_MASK |GDK_KEY_PRESS_MASK | GDK_SCROLL_MASK);
   attributes.visual = gtk_widget_get_visual (widget);
   attributes.colormap = gtk_widget_get_colormap (widget);
   
   attributes_mask = GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL | GDK_WA_COLORMAP;
   widget->window = gdk_window_new (widget->parent->window,
-				   &attributes, attributes_mask);
+                                   &attributes, attributes_mask);
   
   widget->style = gtk_style_attach (widget->style, widget->window);
   
   /* Header window ------------------------------------- */
   gtk_calendar_realize_header (widget);
-  /* Day names	window --------------------------------- */
+  /* Day names  window --------------------------------- */
   gtk_calendar_realize_day_names (widget);
   /* Week number window -------------------------------- */
   gtk_calendar_realize_week_numbers (widget);
-  /* Main Window --------------------------------------	 */
+  /* Main Window --------------------------------------  */
   attributes.event_mask =  (gtk_widget_get_events (widget) | GDK_EXPOSURE_MASK
-			    | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK
-			    | GDK_POINTER_MOTION_MASK | GDK_LEAVE_NOTIFY_MASK);
+                            | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK
+                            | GDK_POINTER_MOTION_MASK | GDK_LEAVE_NOTIFY_MASK);
   
-  attributes.x = private_data->week_width + (widget->style->ythickness + INNER_BORDER);
+  attributes.x = HILDON_DAY_WIDTH + HILDON_WEEKS_EXTRA_WIDTH /*private_data->week_width + (widget->style->ythickness + INNER_BORDER)*/;
   attributes.y = (private_data->header_h + private_data->day_name_h 
-		  + (widget->style->ythickness + INNER_BORDER));
+                  + (widget->style->ythickness + INNER_BORDER));
   attributes.width = (widget->allocation.width - attributes.x 
-		      - (widget->style->xthickness + INNER_BORDER));
+                      /*- (widget->style->xthickness + INNER_BORDER)*/);
   attributes.height = private_data->main_h;
   private_data->main_win = gdk_window_new (widget->window,
-					   &attributes, attributes_mask);
+                                           &attributes, attributes_mask);
   gdk_window_set_background (private_data->main_win, 
-			     BACKGROUND_COLOR ( GTK_WIDGET ( calendar)));
+                             BACKGROUND_COLOR ( GTK_WIDGET ( calendar)));
   gdk_window_show (private_data->main_win);
   gdk_window_set_user_data (private_data->main_win, widget);
   gdk_window_set_background (widget->window, BACKGROUND_COLOR (widget));
@@ -1314,11 +1564,10 @@
   values.foreground = widget->style->white;
   values.function = GDK_XOR;
   calendar->xor_gc = gdk_gc_new_with_values (widget->window,
-					     &values,
-					     GDK_GC_FOREGROUND |
-					     GDK_GC_FUNCTION);
+                                             &values,
+                                             GDK_GC_FOREGROUND |
+                                             GDK_GC_FUNCTION);
 }
-
 static void
 gtk_calendar_unrealize (GtkWidget *widget)
 {
@@ -1332,18 +1581,21 @@
   if (private_data->header_win)
     {
       for (i = 0; i < 4; i++)
-	{
-	  if (private_data->arrow_win[i])
-	    {
-	      gdk_window_set_user_data (private_data->arrow_win[i], NULL);
-	      gdk_window_destroy (private_data->arrow_win[i]);
-	      private_data->arrow_win[i] = NULL;
-	    }
-	}
+        {
+          if (private_data->arrow_win[i])
+            {
+              gdk_window_set_user_data (private_data->arrow_win[i], NULL);
+              gdk_window_destroy (private_data->arrow_win[i]);
+              private_data->arrow_win[i] = NULL;
+            }
+        }
       gdk_window_set_user_data (private_data->header_win, NULL);
       gdk_window_destroy (private_data->header_win);
       private_data->header_win = NULL;
-    }
+      gdk_window_set_user_data (private_data->footer_win, NULL);
+      gdk_window_destroy (private_data->footer_win);
+      private_data->footer_win = NULL;  
+  }
   
   if (private_data->week_win)
     {
@@ -1374,18 +1626,18 @@
 }
 
 static void
-gtk_calendar_size_request (GtkWidget	  *widget,
-			   GtkRequisition *requisition)
+gtk_calendar_size_request (GtkWidget      *widget,
+                           GtkRequisition *requisition)
 {
   GtkCalendar *calendar;
   GtkCalendarPrivateData *private_data;
   PangoLayout *layout;
   PangoRectangle logical_rect;
 
-  gint height;
+  /*gint height;*/
   gint i;
   gchar buffer[255];
-  gint calendar_margin = CALENDAR_MARGIN;
+  /*gint calendar_margin = CALENDAR_MARGIN;*/
   gint header_width, main_width;
   gint max_header_height = 0;
   gint focus_width;
@@ -1394,14 +1646,14 @@
   calendar = GTK_CALENDAR (widget);
   private_data = GTK_CALENDAR_PRIVATE_DATA (widget);
   gtk_widget_style_get (GTK_WIDGET (widget),
-			"focus-line-width", &focus_width,
-			"focus-padding", &focus_padding,
-			NULL);
+                        "focus-line-width", &focus_width,
+                        "focus-padding", &focus_padding,
+                        NULL);
 
   layout = gtk_widget_create_pango_layout (widget, NULL);
   
   /*
-   * Calculate the requisition	width for the widget.
+   * Calculate the requisition width for the widget.
    */
   
   /* Header width */
@@ -1410,38 +1662,38 @@
     {
       private_data->max_month_width = 0;
       for (i = 0; i < 12; i++)
-	{
-	  pango_layout_set_text (layout, default_monthname[i], -1);
-	  pango_layout_get_pixel_extents (layout, NULL, &logical_rect);
-	  private_data->max_month_width = MAX (private_data->max_month_width,
-					       logical_rect.width + 8);
-	  max_header_height = MAX (max_header_height, logical_rect.height); 
-	}
+        {
+          pango_layout_set_text (layout, default_monthname[i], -1);
+          pango_layout_get_pixel_extents (layout, NULL, &logical_rect);
+          private_data->max_month_width = MAX (private_data->max_month_width,
+                                               logical_rect.width + 8);
+          max_header_height = MAX (max_header_height, logical_rect.height); 
+        }
       private_data->max_year_width = 0;
       for (i=0; i<10; i++)
-	{
-	  g_snprintf (buffer, sizeof (buffer), "%d%d%d%d", i,i,i,i);
-	  pango_layout_set_text (layout, buffer, -1);	  
-	  pango_layout_get_pixel_extents (layout, NULL, &logical_rect);
-	  private_data->max_year_width = MAX (private_data->max_year_width,
-					      logical_rect.width + 8);
-	  max_header_height = MAX (max_header_height, logical_rect.height); 
-	}
-    } 
+        {
+          g_snprintf (buffer, sizeof (buffer), "%d%d%d%d", i,i,i,i);
+          pango_layout_set_text (layout, buffer, -1);     
+          pango_layout_get_pixel_extents (layout, NULL, &logical_rect);
+          private_data->max_year_width = MAX (private_data->max_year_width,
+                                              logical_rect.width + 8);
+          max_header_height = MAX (max_header_height, logical_rect.height); 
+        }
+    }
   else 
     {
       private_data->max_month_width = 0;
       private_data->max_year_width = 0;
     }
-  
+
   if (calendar->display_flags & GTK_CALENDAR_NO_MONTH_CHANGE)
     header_width = (private_data->max_month_width 
-		    + private_data->max_year_width
-		    + 3 * 3);
+                    + private_data->max_year_width
+                    + 3 * 3);
   else
     header_width = (private_data->max_month_width 
-		    + private_data->max_year_width
-		    + 4 * private_data->arrow_width + 3 * 3);
+                    + private_data->max_year_width
+                    + 4 * private_data->arrow_width + 3 * 3);
 
   /* Mainwindow labels width */
   
@@ -1453,15 +1705,15 @@
   for (i = 0; i < 9; i++)
     {
       g_snprintf (buffer, sizeof (buffer), "%d%d", i, i);
-      pango_layout_set_text (layout, buffer, -1);	  
+      pango_layout_set_text (layout, buffer, -1);         
       pango_layout_get_pixel_extents (layout, NULL, &logical_rect);
       private_data->min_day_width = MAX (private_data->min_day_width,
-					 logical_rect.width);
+                                         logical_rect.width);
 
       private_data->max_day_char_ascent = MAX (private_data->max_label_char_ascent,
-					       PANGO_ASCENT (logical_rect));
+                                               PANGO_ASCENT (logical_rect));
       private_data->max_day_char_descent = MAX (private_data->max_label_char_descent, 
-						PANGO_DESCENT (logical_rect));
+                                                PANGO_DESCENT (logical_rect));
     }
   /* We add one to max_day_char_width to be able to make the marked day "bold" */
   private_data->max_day_char_width = private_data->min_day_width / 2 + 1;
@@ -1469,82 +1721,69 @@
   if (calendar->display_flags & GTK_CALENDAR_SHOW_DAY_NAMES)
     for (i = 0; i < 7; i++)
       {
-	pango_layout_set_text (layout, default_abbreviated_dayname[i], -1);
-	pango_layout_line_get_pixel_extents (pango_layout_get_lines (layout)->data, NULL, &logical_rect);
+        pango_layout_set_text (layout, default_abbreviated_dayname[i], -1);
+        pango_layout_line_get_pixel_extents (pango_layout_get_lines (layout)->data, NULL, &logical_rect);
 
-	private_data->min_day_width = MAX (private_data->min_day_width, logical_rect.width);
-	private_data->max_label_char_ascent = MAX (private_data->max_label_char_ascent,
-						   PANGO_ASCENT (logical_rect));
-	private_data->max_label_char_descent = MAX (private_data->max_label_char_descent, 
-						    PANGO_DESCENT (logical_rect));
+        /* Hildon: add 4 so that passive focus wouldn't overlap day names */
+        private_data->min_day_width = MAX (private_data->min_day_width, logical_rect.width + 4);
+        private_data->max_label_char_ascent = MAX (private_data->max_label_char_ascent,
+                                                   PANGO_ASCENT (logical_rect));
+        private_data->max_label_char_descent = MAX (private_data->max_label_char_descent, 
+                                                    PANGO_DESCENT (logical_rect));
       }
   
   private_data->max_week_char_width = 0;
   if (calendar->display_flags & GTK_CALENDAR_SHOW_WEEK_NUMBERS)
     for (i = 0; i < 9; i++)
       {
-	g_snprintf (buffer, sizeof (buffer), "%d%d", i, i);
-	pango_layout_set_text (layout, buffer, -1);	  
-	pango_layout_get_pixel_extents (layout, NULL, &logical_rect);
-	private_data->max_week_char_width = MAX (private_data->max_week_char_width,
-						 logical_rect.width / 2);
+        g_snprintf (buffer, sizeof (buffer), "%d%d", i, i);
+        pango_layout_set_text (layout, buffer, -1);       
+        pango_layout_get_pixel_extents (layout, NULL, &logical_rect);
+        private_data->max_week_char_width = MAX (private_data->max_week_char_width,
+                                                 logical_rect.width / 2);
       }
   
   main_width = (7 * (private_data->min_day_width + (focus_padding + focus_width) * 2) + (DAY_XSEP * 6) + CALENDAR_MARGIN * 2
-		+ (private_data->max_week_char_width
-		   ? private_data->max_week_char_width * 2 + (focus_padding + focus_width) * 2 + CALENDAR_XSEP * 2
-		   : 0));
-  
-  
+                + (private_data->max_week_char_width
+                   ? private_data->max_week_char_width * 2 + (focus_padding + focus_width) * 2 + CALENDAR_XSEP * 2
+                   : 0));
+
   requisition->width = MAX (header_width, main_width + INNER_BORDER * 2) + widget->style->xthickness * 2;
+
+  /* FIXME: header_width is broken, when Calendar is themed ! 
+   *  Next line is workaround for this bug
+   */
+  requisition->width = (main_width + INNER_BORDER * 2) + widget->style->xthickness * 2 + HILDON_WEEKS_EXTRA_WIDTH + HILDON_DAYS_EXTRA_WIDTH;
   
   /*
    * Calculate the requisition height for the widget.
+   * This is Hildon calculation
    */
-  
+
   if (calendar->display_flags & GTK_CALENDAR_SHOW_HEADING)
-    {
-      private_data->header_h = (max_header_height + CALENDAR_YSEP * 2);
-    }
+      private_data->header_h = HILDON_ARROW_HEIGHT + CALENDAR_YSEP;
   else
-    {
       private_data->header_h = 0;
-    }
-  
+ 
   if (calendar->display_flags & GTK_CALENDAR_SHOW_DAY_NAMES)
-    {
-      private_data->day_name_h = (private_data->max_label_char_ascent
-				  + private_data->max_label_char_descent
-				  + 2 * (focus_padding + focus_width) + calendar_margin);
-      calendar_margin = CALENDAR_YSEP;
-    } 
+      private_data->day_name_h = HILDON_DAY_HEIGHT;
   else
-    {
       private_data->day_name_h = 0;
-    }
 
-  private_data->main_h = (CALENDAR_MARGIN + calendar_margin
-			  + 6 * (private_data->max_day_char_ascent
-				 + private_data->max_day_char_descent 
-				 + 2 * (focus_padding + focus_width))
-			  + DAY_YSEP * 5);
-  
-  height = (private_data->header_h + private_data->day_name_h 
-	    + private_data->main_h);
-  
-  requisition->height = height + (widget->style->ythickness + INNER_BORDER) * 2;
+  private_data->main_h = 6 * HILDON_DAY_HEIGHT;
+  requisition->height = 2 * private_data->header_h + private_data->day_name_h + private_data->main_h;
 
   g_object_unref (layout);
 }
 
 static void
-gtk_calendar_size_allocate (GtkWidget	  *widget,
-			    GtkAllocation *allocation)
+gtk_calendar_size_allocate (GtkWidget     *widget,
+                            GtkAllocation *allocation)
 {
   GtkCalendar *calendar;
   GtkCalendarPrivateData *private_data;
   gint xthickness = widget->style->xthickness;
-  gint ythickness = widget->style->xthickness;
+  /*gint ythickness = widget->style->xthickness;*/
   gboolean year_left;
   
   widget->allocation = *allocation;
@@ -1559,148 +1798,175 @@
   
   if (calendar->display_flags & GTK_CALENDAR_SHOW_WEEK_NUMBERS)
     {
+      /* this variable is introduced to avoid breaking week_width because
+         of HILDON_WEEKS_EXTRA_WIDTH and HILDON_DAYS_EXTRA_WIDTH appearing
+         in calculation of day_width */
+      int real_day_width = (private_data->min_day_width
+                            * ((allocation->width
+                                - (xthickness + INNER_BORDER) * 2
+                                - (CALENDAR_MARGIN * 2) -  (DAY_XSEP * 6) - CALENDAR_XSEP * 2))
+                            / (7 * private_data->min_day_width + private_data->max_week_char_width * 2));
+
       private_data->day_width = (private_data->min_day_width
-			     * ((allocation->width - (xthickness + INNER_BORDER) * 2
-				 - (CALENDAR_MARGIN * 2) -  (DAY_XSEP * 6) - CALENDAR_XSEP * 2))
-			     / (7 * private_data->min_day_width + private_data->max_week_char_width * 2));
+                             * ((allocation->width
+                                 - (HILDON_WEEKS_EXTRA_WIDTH + HILDON_DAYS_EXTRA_WIDTH)
+                                 - (xthickness + INNER_BORDER) * 2
+                                 - (CALENDAR_MARGIN * 2) -  (DAY_XSEP * 6) - CALENDAR_XSEP * 2))
+                             / (7 * private_data->min_day_width + private_data->max_week_char_width * 2));
       private_data->week_width = ((allocation->width - (xthickness + INNER_BORDER) * 2
-			       - (CALENDAR_MARGIN * 2) - (DAY_XSEP * 6) - CALENDAR_XSEP * 2 )
-			      - private_data->day_width * 7 + CALENDAR_MARGIN + CALENDAR_XSEP);
-    } 
+                                   - (CALENDAR_MARGIN * 2) - (DAY_XSEP * 6) - CALENDAR_XSEP * 2 )
+                                  - real_day_width * 7 + CALENDAR_MARGIN + CALENDAR_XSEP);
+    }
   else 
     {
       private_data->day_width = (allocation->width
-			     - (xthickness + INNER_BORDER) * 2
-			     - (CALENDAR_MARGIN * 2)
-			     - (DAY_XSEP * 6))/7;
+                             - (xthickness + INNER_BORDER) * 2
+                             - (CALENDAR_MARGIN * 2)
+                             - (DAY_XSEP * 6))/7;
       private_data->week_width = 0;
     }
-  
+
   if (GTK_WIDGET_REALIZED (widget))
     {
       gdk_window_move_resize (widget->window,
-			      allocation->x, allocation->y,
-			      allocation->width, allocation->height);
+                              allocation->x, allocation->y,
+                              allocation->width, allocation->height);
       if (private_data->header_win)
-	gdk_window_move_resize (private_data->header_win,
-				xthickness, ythickness,
-				allocation->width - 2 * xthickness, private_data->header_h);
-      if (private_data->arrow_win[ARROW_MONTH_LEFT])
-	{
-	  if (year_left)
-	    gdk_window_move_resize (private_data->arrow_win[ARROW_MONTH_LEFT],
-				    (allocation->width - 2 * xthickness
-				     - (3 + 2*private_data->arrow_width 
-					+ private_data->max_month_width)),
-				    3,
-				    private_data->arrow_width,
-				    private_data->header_h - 7);
-	  else
-	    gdk_window_move_resize (private_data->arrow_win[ARROW_MONTH_LEFT],
-				    3, 3,
-				    private_data->arrow_width,
-				    private_data->header_h - 7);
-	}
-      if (private_data->arrow_win[ARROW_MONTH_RIGHT])
-	{
-	  if (year_left)
-	    gdk_window_move_resize (private_data->arrow_win[ARROW_MONTH_RIGHT],
-				    (allocation->width - 2 * xthickness 
-				     - 3 - private_data->arrow_width), 
-				    3,
-				    private_data->arrow_width,
-				    private_data->header_h - 7);
-	  else
-	    gdk_window_move_resize (private_data->arrow_win[ARROW_MONTH_RIGHT],
-				    (private_data->arrow_width 
-				     + private_data->max_month_width), 
-				    3,
-				    private_data->arrow_width,
-				    private_data->header_h - 7);
-	}
+        gdk_window_move_resize (private_data->header_win,
+                                0, 0, widget->allocation.width, HILDON_ARROW_HEIGHT);
       if (private_data->arrow_win[ARROW_YEAR_LEFT])
-	{
-	  if (year_left)
-	    gdk_window_move_resize (private_data->arrow_win[ARROW_YEAR_LEFT],
-				    3, 3,
-				    private_data->arrow_width,
-				    private_data->header_h - 7);
-	  else
-	    gdk_window_move_resize (private_data->arrow_win[ARROW_YEAR_LEFT],
-				    (allocation->width - 2 * xthickness
-				     - (3 + 2*private_data->arrow_width 
-					+ private_data->max_year_width)),
-				    3,
-				    private_data->arrow_width,
-				    private_data->header_h - 7);
-	}
+        {
+         /* if (year_left)
+            gdk_window_move_resize (private_data->arrow_win[ARROW_YEAR_LEFT],
+                                    3, 3,
+                                    private_data->arrow_width,
+                                    private_data->header_h - 7);
+          else
+            gdk_window_move_resize (private_data->arrow_win[ARROW_YEAR_LEFT],
+                                    (allocation->width - 2 * xthickness
+                                     - (3 + 2*private_data->arrow_width 
+                                        + private_data->max_year_width)),
+                                    3,
+                                    private_data->arrow_width,
+                                    private_data->header_h - 7);*/
+
+            gdk_window_move (private_data->arrow_win[ARROW_YEAR_LEFT],
+                                    (widget->allocation.width - private_data->max_year_width) / 2 - HILDON_ARROW_WIDTH - HILDON_ARROW_SEP, 0);
+        }
       if (private_data->arrow_win[ARROW_YEAR_RIGHT])
-	{
-	  if (year_left)
-	    gdk_window_move_resize (private_data->arrow_win[ARROW_YEAR_RIGHT],
-				    (private_data->arrow_width 
-				     + private_data->max_year_width), 
-				    3,
-				    private_data->arrow_width,
-				    private_data->header_h - 7);
-	  else
-	    gdk_window_move_resize (private_data->arrow_win[ARROW_YEAR_RIGHT],
-				    (allocation->width - 2 * xthickness 
-				     - 3 - private_data->arrow_width), 
-				    3,
-				    private_data->arrow_width,
-				    private_data->header_h - 7);
-	}
+        {
+/*        if (year_left)
+            gdk_window_move_resize (private_data->arrow_win[ARROW_YEAR_RIGHT],
+                                    (private_data->arrow_width 
+                                     + private_data->max_year_width), 
+                                    3,
+                                    private_data->arrow_width,
+                                    private_data->header_h - 7);
+          else
+            gdk_window_move_resize (private_data->arrow_win[ARROW_YEAR_RIGHT],
+                                    (allocation->width - 2 * xthickness 
+                                     - 3 - private_data->arrow_width), 
+                                    3,
+                                    private_data->arrow_width,
+                                    private_data->header_h - 7);*/
+            gdk_window_move (private_data->arrow_win[ARROW_YEAR_RIGHT],
+                                    (widget->allocation.width + private_data->max_year_width) / 2 + HILDON_ARROW_SEP,  0);
+        }
+      if (private_data->footer_win)
+        gdk_window_move_resize (private_data->footer_win,
+                                    0, private_data->header_h + private_data->day_name_h +  private_data->main_h + CALENDAR_YSEP,
+                                    widget->allocation.width, HILDON_ARROW_HEIGHT);
+
+      if (private_data->arrow_win[ARROW_MONTH_LEFT])
+        {
+/*        if (year_left)
+            gdk_window_move_resize (private_data->arrow_win[ARROW_MONTH_LEFT],
+                                    (allocation->width - 2 * xthickness
+                                     - (3 + 2*private_data->arrow_width 
+                                        + private_data->max_month_width)),
+                                    3,
+                                    private_data->arrow_width,
+                                    private_data->header_h - 7);
+          else
+            gdk_window_move_resize (private_data->arrow_win[ARROW_MONTH_LEFT],
+                                    3, 3,
+                                    private_data->arrow_width,
+                                    private_data->header_h - 7);
+*/
+
+            gdk_window_move (private_data->arrow_win[ARROW_MONTH_LEFT],
+                                    (widget->allocation.width - private_data->max_month_width) / 2 - HILDON_ARROW_WIDTH - HILDON_ARROW_SEP, 0);
+  }
+      if (private_data->arrow_win[ARROW_MONTH_RIGHT])
+        {
+/*        if (year_left)
+            gdk_window_move_resize (private_data->arrow_win[ARROW_MONTH_RIGHT],
+                                    (allocation->width - 2 * xthickness 
+                                     - 3 - private_data->arrow_width), 
+                                    3,
+                                    private_data->arrow_width,
+                                    private_data->header_h - 7);
+          else
+            gdk_window_move_resize (private_data->arrow_win[ARROW_MONTH_RIGHT],
+                                    (private_data->arrow_width 
+                                     + private_data->max_month_width), 
+                                    3,
+                                    private_data->arrow_width,
+                                    private_data->header_h - 7);*/
+            gdk_window_move (private_data->arrow_win[ARROW_MONTH_RIGHT],
+                                    (widget->allocation.width + private_data->max_month_width) / 2 + HILDON_ARROW_SEP, 0); 
+        }
+
+
       if (private_data->day_name_win)
-	gdk_window_move_resize (private_data->day_name_win,
-				xthickness + INNER_BORDER,
-				private_data->header_h + (widget->style->ythickness + INNER_BORDER),
-				allocation->width - (xthickness + INNER_BORDER) * 2,
-				private_data->day_name_h);
+        gdk_window_move_resize (private_data->day_name_win,
+                                private_data->week_width, /*xthickness + INNER_BORDER*/
+                                private_data->header_h /*+ (widget->style->ythickness + INNER_BORDER)*/,
+                                widget->allocation.width - private_data->week_width /*- (xthickness + INNER_BORDER) * 2*/,
+                                private_data->day_name_h);
       if (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_LTR) 
-	{
-	  if (private_data->week_win)
-	    gdk_window_move_resize (private_data->week_win,
-				    (xthickness + INNER_BORDER),
-				    private_data->header_h + private_data->day_name_h
-				    + (widget->style->ythickness + INNER_BORDER),
-				    private_data->week_width,
-				    private_data->main_h);
-	  gdk_window_move_resize (private_data->main_win,
-				  private_data->week_width + (xthickness + INNER_BORDER),
-				  private_data->header_h + private_data->day_name_h
-				  + (widget->style->ythickness + INNER_BORDER),
-				  allocation->width 
-				  - private_data->week_width 
-				  - (xthickness + INNER_BORDER) * 2,
-				  private_data->main_h);
-	}
+        {
+          if (private_data->week_win)
+            gdk_window_move_resize (private_data->week_win,
+                                    0 /*(xthickness + INNER_BORDER)*/,
+                                    private_data->header_h   /*+ (widget->style->ythickness + INNER_BORDER)*/,
+                                    HILDON_DAY_WIDTH,
+                                    private_data->main_h + private_data->day_name_h);
+          gdk_window_move_resize (private_data->main_win,
+                                  private_data->week_width /* + (xthickness + INNER_BORDER)*/,
+                                  private_data->header_h + private_data->day_name_h
+                                  /*+ (widget->style->ythickness + INNER_BORDER)*/,
+                                  widget->allocation.width - private_data->week_width 
+                                  /*- (xthickness + INNER_BORDER) * 2*/,
+                                  private_data->main_h);
+        }
       else 
-	{
-	  gdk_window_move_resize (private_data->main_win,
-				  (xthickness + INNER_BORDER),
-				  private_data->header_h + private_data->day_name_h
-				  + (widget->style->ythickness + INNER_BORDER),
-				  allocation->width 
-				  - private_data->week_width 
-				  - (xthickness + INNER_BORDER) * 2,
-				  private_data->main_h);
-	  if (private_data->week_win)
-	    gdk_window_move_resize (private_data->week_win,
-				    allocation->width 
-				    - private_data->week_width 
-				    - (xthickness + INNER_BORDER),
-				    private_data->header_h + private_data->day_name_h
-				    + (widget->style->ythickness + INNER_BORDER),
-				    private_data->week_width,
-				    private_data->main_h);
-	}
+        {
+          gdk_window_move_resize (private_data->main_win,
+                                  0 /*(xthickness + INNER_BORDER)*/,
+                                  private_data->header_h + private_data->day_name_h
+                                  /*+ (widget->style->ythickness + INNER_BORDER)*/,
+                                  widget->allocation.width 
+                                  - private_data->week_width 
+                                  /*- (xthickness + INNER_BORDER) * 2*/,
+                                  private_data->main_h);
+          if (private_data->week_win)
+            gdk_window_move_resize (private_data->week_win,
+                                    widget->allocation.width 
+                                    - private_data->week_width 
+                                    /*- (xthickness + INNER_BORDER)*/,
+                                    private_data->header_h + private_data->day_name_h
+                                    /*+ (widget->style->ythickness + INNER_BORDER)*/,
+                                    private_data->week_width,
+                                    private_data->main_h);
+        }
     }
 }
 
+
 static gboolean
-gtk_calendar_expose (GtkWidget	    *widget,
-		     GdkEventExpose *event)
+gtk_calendar_expose (GtkWidget      *widget,
+                     GdkEventExpose *event)
 {
   GtkCalendar *calendar;
   GtkCalendarPrivateData *private_data;
@@ -1711,22 +1977,18 @@
   if (GTK_WIDGET_DRAWABLE (widget))
     {
       if (event->window == private_data->main_win)
-	gtk_calendar_paint_main (widget);
-      
+        gtk_calendar_paint_main (widget);
+
       if (event->window == private_data->header_win)
-	gtk_calendar_paint_header (widget);
-      
-      if (event->window == private_data->day_name_win)
-	gtk_calendar_paint_day_names (widget);
+        gtk_calendar_paint_header (widget);
+      if (event->window == private_data->footer_win)
+        gtk_calendar_paint_footer(widget);
+
+      if (event->window == private_data->day_name_win) 
+        gtk_calendar_paint_day_names (widget);
       
-      if (event->window == private_data->week_win)
-	gtk_calendar_paint_week_numbers (widget);
-      if (event->window == widget->window)
-	{
-	  gtk_paint_shadow (widget->style, widget->window, GTK_WIDGET_STATE (widget),
-			    GTK_SHADOW_IN, NULL, widget, "calendar",
-			    0, 0, widget->allocation.width, widget->allocation.height);
-	}
+      if (event->window == private_data->week_win) 
+        gtk_calendar_paint_week_numbers (widget);
     }
   
   return FALSE;
@@ -1740,12 +2002,9 @@
   char buffer[255];
   int x, y;
   gint header_width, cal_height;
-  gint max_month_width;
-  gint max_year_width;
   GtkCalendarPrivateData *private_data;
   PangoLayout *layout;
   PangoRectangle logical_rect;
-  gboolean year_left;
 
   calendar = GTK_CALENDAR (widget);
   private_data = GTK_CALENDAR_PRIVATE_DATA (widget);
@@ -1756,84 +2015,77 @@
       return;
     }
 
-  if (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_LTR) 
-    year_left = private_data->year_before;
-  else
-    year_left = !private_data->year_before;
-
   private_data->dirty_header = 0;
   gc = calendar->gc;
   
   /* Clear window */
   gdk_window_clear (private_data->header_win);
   
-  header_width = widget->allocation.width - 2 * widget->style->xthickness;
+  header_width = widget->allocation.width /*- 2 * widget->style->xthickness*/;
   cal_height = widget->allocation.height;
   
-  max_month_width = private_data->max_month_width;
-  max_year_width = private_data->max_year_width;
-  
-  gdk_gc_set_foreground (gc, BACKGROUND_COLOR (GTK_WIDGET (calendar)));
-  gtk_paint_shadow (widget->style, private_data->header_win,
-		    GTK_STATE_NORMAL, GTK_SHADOW_OUT,
-		    NULL, widget, "calendar",
-		    0, 0, header_width, private_data->header_h);
-  
-  
   g_snprintf (buffer, sizeof (buffer), "%d", calendar->year);
   layout = gtk_widget_create_pango_layout (widget, buffer);
   pango_layout_get_pixel_extents (layout, NULL, &logical_rect);
   
-  /* Draw title */
-  y = (private_data->header_h - logical_rect.height) / 2;
-  
+  y = (HILDON_ARROW_HEIGHT - logical_rect.height) / 2;
+  x = (widget->allocation.width - logical_rect.width) / 2;
+
   /* Draw year and its arrows */
+  gdk_gc_set_foreground (gc, HEADER_FG_COLOR (GTK_WIDGET (calendar)));
+  gdk_draw_layout (private_data->header_win, gc, x, y, layout);  
   
-  if (calendar->display_flags & GTK_CALENDAR_NO_MONTH_CHANGE)
-    if (year_left)
-      x = 3 + (max_year_width - logical_rect.width)/2;
-    else
-      x = header_width - (3 + max_year_width
-			  - (max_year_width - logical_rect.width)/2);
-  else
-    if (year_left)
-      x = 3 + private_data->arrow_width + (max_year_width - logical_rect.width)/2;
-    else
-      x = header_width - (3 + private_data->arrow_width + max_year_width
-			  - (max_year_width - logical_rect.width)/2);
+  gtk_calendar_paint_arrow (widget, ARROW_YEAR_LEFT);
+  gtk_calendar_paint_arrow (widget, ARROW_YEAR_RIGHT);
+
+  g_object_unref (layout);
+}
+
+static void
+gtk_calendar_paint_footer (GtkWidget *widget)
+{
+GtkCalendar *calendar;
+  GdkGC *gc;
+  char buffer[255];
+  int x, y;
+  gint header_width, cal_height;
+  GtkCalendarPrivateData *private_data;
+  PangoLayout *layout;
+  PangoRectangle logical_rect;
+
+  calendar = GTK_CALENDAR (widget);
+  private_data = GTK_CALENDAR_PRIVATE_DATA (widget);
+
+  if (private_data->freeze_count)
+    {
+      private_data->dirty_header = 1;
+      return;
+    }
+
+  private_data->dirty_header = 0;
+  gc = calendar->gc;
   
+  /* Clear window */
+  gdk_window_clear (private_data->footer_win);
   
-  gdk_gc_set_foreground (gc, HEADER_FG_COLOR (GTK_WIDGET (calendar)));
-  gdk_draw_layout (private_data->header_win, gc, x, y, layout);
+  header_width = widget->allocation.width - 2 * widget->style->xthickness;
+  cal_height = widget->allocation.height;
   
-  /* Draw month */
+  /* Draw month and its arrows */
   g_snprintf (buffer, sizeof (buffer), "%s", default_monthname[calendar->month]);
-  pango_layout_set_text (layout, buffer, -1);
+  layout = gtk_widget_create_pango_layout (widget, buffer);
   pango_layout_get_pixel_extents (layout, NULL, &logical_rect);
 
-  if (calendar->display_flags & GTK_CALENDAR_NO_MONTH_CHANGE)
-    if (year_left)
-      x = header_width - (3 + max_month_width
-			  - (max_month_width - logical_rect.width)/2);      
-    else
-    x = 3 + (max_month_width - logical_rect.width) / 2;
-  else
-    if (year_left)
-      x = header_width - (3 + private_data->arrow_width + max_month_width
-			  - (max_month_width - logical_rect.width)/2);
-    else
-    x = 3 + private_data->arrow_width + (max_month_width - logical_rect.width)/2;
+  x = (widget->allocation.width - logical_rect.width) / 2;
+  y = (HILDON_ARROW_HEIGHT - logical_rect.height) / 2;
+
+  gdk_gc_set_foreground (gc, HEADER_FG_COLOR(GTK_WIDGET (calendar)));
+  gdk_draw_layout (private_data->footer_win, gc, x, y, layout);
 
-  gdk_draw_layout (private_data->header_win, gc, x, y, layout);
-  
-  gdk_gc_set_foreground (gc, BACKGROUND_COLOR (GTK_WIDGET (calendar)));
-  
   gtk_calendar_paint_arrow (widget, ARROW_MONTH_LEFT);
   gtk_calendar_paint_arrow (widget, ARROW_MONTH_RIGHT);
-  gtk_calendar_paint_arrow (widget, ARROW_YEAR_LEFT);
-  gtk_calendar_paint_arrow (widget, ARROW_YEAR_RIGHT);
 
-  g_object_unref (layout);
+  g_object_unref(layout);
 }
 
 static void
@@ -1851,16 +2103,18 @@
   GtkCalendarPrivateData *private_data;
   gint focus_padding;
   gint focus_width;
+  gboolean hildonlike;
   
   g_return_if_fail (GTK_IS_CALENDAR (widget));
   calendar = GTK_CALENDAR (widget);
   private_data = GTK_CALENDAR_PRIVATE_DATA (widget);
   gc = calendar->gc;
-  
+
   gtk_widget_style_get (GTK_WIDGET (widget),
-			"focus-line-width", &focus_width,
-			"focus-padding", &focus_padding,
-			NULL);
+                        "focus-line-width", &focus_width,
+                        "focus-padding", &focus_padding,
+                        "hildonlike", &hildonlike,
+                        NULL);
   /*
    * Handle freeze/thaw functionality
    */
@@ -1887,18 +2141,22 @@
    * Draw rectangles as inverted background for the labels.
    */
   
-  gdk_gc_set_foreground (gc, SELECTED_BG_COLOR (widget));
-  gdk_draw_rectangle (private_data->day_name_win, gc, TRUE,
-		      CALENDAR_MARGIN, CALENDAR_MARGIN,
-		      cal_width-CALENDAR_MARGIN * 2,
-		      private_data->day_name_h - CALENDAR_MARGIN);
-  
-  if (calendar->display_flags & GTK_CALENDAR_SHOW_WEEK_NUMBERS)
-    gdk_draw_rectangle (private_data->day_name_win, gc, TRUE,
-			CALENDAR_MARGIN,
-			private_data->day_name_h - CALENDAR_YSEP,
-			private_data->week_width - CALENDAR_YSEP - CALENDAR_MARGIN,
-			CALENDAR_YSEP);
+  /* Hildon: don't paint dayname window */
+  if (!hildonlike)
+    {
+      gdk_gc_set_foreground (gc, SELECTED_BG_COLOR (widget));
+      gdk_draw_rectangle (private_data->day_name_win, gc, TRUE,
+                         CALENDAR_MARGIN, CALENDAR_MARGIN,
+                         cal_width-CALENDAR_MARGIN * 2,
+                         private_data->day_name_h - CALENDAR_MARGIN);
+    
+    if (calendar->display_flags & GTK_CALENDAR_SHOW_WEEK_NUMBERS)
+      gdk_draw_rectangle (private_data->day_name_win, gc, TRUE,
+                        CALENDAR_MARGIN,
+                        private_data->day_name_h - CALENDAR_YSEP,
+                        private_data->week_width - CALENDAR_YSEP - CALENDAR_MARGIN,
+                        CALENDAR_YSEP);
+     }
   
   /*
    * Write the labels
@@ -1908,28 +2166,36 @@
   
   gdk_gc_set_foreground (gc, SELECTED_FG_COLOR (widget));
   for (i = 0; i < 7; i++)
-    {
+    { 
+      guint x = left_x_for_column (calendar, i);
+
       if (gtk_widget_get_direction (GTK_WIDGET (calendar)) == GTK_TEXT_DIR_RTL)
-	day = 6 - i;
+        day = 6 - i;
       else
-	day = i;
+        day = i;
       day = (day + private_data->week_start) % 7;
       g_snprintf (buffer, sizeof (buffer), "%s", default_abbreviated_dayname[day]);
-
+  
       pango_layout_set_text (layout, buffer, -1);
       pango_layout_get_pixel_extents (layout, NULL, &logical_rect);
 
-      gdk_draw_layout (private_data->day_name_win, gc, 
-		       (CALENDAR_MARGIN +
-			+ (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_LTR ?
-			   (private_data->week_width + (private_data->week_width ? CALENDAR_XSEP : 0))
-			   : 0)
-			+ day_wid_sep * i
-			+ (day_width - logical_rect.width)/2),
-		       CALENDAR_MARGIN + focus_width + focus_padding + logical_rect.y,
-		       layout);
+      /* Hildon: draw passive focus for day name */
+      if (hildonlike && calendar->focus_col == i)
+        gtk_paint_box(GTK_WIDGET (calendar)->style,
+                      private_data->day_name_win,
+                      GTK_STATE_NORMAL,
+                      GTK_SHADOW_OUT, NULL,
+                      GTK_WIDGET (calendar), "passive-focus",
+                      x,
+                      0,
+                      logical_rect.width + 4,
+                      HILDON_DAY_HEIGHT);
+
+      gdk_draw_layout (private_data->day_name_win, gc,
+                       x + 2,
+                       CALENDAR_MARGIN + focus_width + focus_padding + logical_rect.y,
+                       layout);
     }
-  
   g_object_unref (layout);
 }
 
@@ -1937,17 +2203,18 @@
 gtk_calendar_paint_week_numbers (GtkWidget *widget)
 {
   GtkCalendar *calendar;
-  GdkGC *gc;
+  GdkGC *gc; 
   gint row, week = 0, year;
   gint x_loc;
-  char buffer[3];
-  gint y_loc, day_height;
+  char buffer[10];
+  gint y_loc;
   GtkCalendarPrivateData *private_data;
   PangoLayout *layout;
   PangoRectangle logical_rect;
   gint focus_padding;
   gint focus_width;
-  
+  gboolean hildonlike;
+
   g_return_if_fail (GTK_IS_CALENDAR (widget));
   g_return_if_fail (widget->window != NULL);
   calendar = GTK_CALENDAR (widget);
@@ -1966,10 +2233,11 @@
   private_data->dirty_week = 0;
   
   gtk_widget_style_get (GTK_WIDGET (widget),
-			"focus-line-width", &focus_width,
-			"focus-padding", &focus_padding,
-			NULL);
-  
+                        "focus-line-width", &focus_width,
+                        "focus-padding", &focus_padding,
+                        "hildonlike", &hildonlike,
+                        NULL);
+
   /*
    * Clear the window
    */
@@ -1979,20 +2247,25 @@
   /*
    * Draw a rectangle as inverted background for the labels.
    */
-  
+
   gdk_gc_set_foreground (gc, SELECTED_BG_COLOR (widget));
-  if (private_data->day_name_win)
-    gdk_draw_rectangle (private_data->week_win, gc, TRUE,
-			CALENDAR_MARGIN,
-			0,
-			private_data->week_width - CALENDAR_MARGIN,
-			private_data->main_h - CALENDAR_MARGIN);
-  else
-    gdk_draw_rectangle (private_data->week_win, gc, TRUE,
-			CALENDAR_MARGIN,
-			CALENDAR_MARGIN,
-			private_data->week_width - CALENDAR_MARGIN,
-			private_data->main_h - 2 * CALENDAR_MARGIN);
+
+  /* Hildon: don't paint background for weekday window */
+  if (!hildonlike)
+    {
+      if (private_data->day_name_win)
+        gdk_draw_rectangle (private_data->week_win, gc, TRUE,
+                          CALENDAR_MARGIN,
+                          0,
+                          private_data->week_width - CALENDAR_MARGIN,
+                          private_data->main_h + private_data->day_name_h - CALENDAR_MARGIN);
+      else
+        gdk_draw_rectangle (private_data->week_win, gc, TRUE,
+                            CALENDAR_MARGIN,
+                            CALENDAR_MARGIN,
+                            private_data->week_width - CALENDAR_MARGIN,
+                            private_data->main_h - 2 * CALENDAR_MARGIN);
+     }
   
   /*
    * Write the labels
@@ -2001,26 +2274,43 @@
   layout = gtk_widget_create_pango_layout (widget, NULL);
   
   gdk_gc_set_foreground (gc, SELECTED_FG_COLOR (widget));
-  day_height = row_height (calendar);
+  gdk_draw_line(private_data->week_win, gc, 
+                HILDON_DAY_WIDTH + 7,
+                0,
+                HILDON_DAY_WIDTH + 7,
+                private_data->main_h + private_data->day_name_h);
+
   for (row = 0; row < 6; row++)
     {
-      year = calendar->year;
+       year = calendar->year;
       if (calendar->day[row][6] < 15 && row > 3 && calendar->month == 11)
-	year++;
-
-      g_return_if_fail (week_of_year (&week, &year,		
-				      ((calendar->day[row][6] < 15 && row > 3 ? 1 : 0)
-				       + calendar->month) % 12 + 1, calendar->day[row][6]));
-
-      g_snprintf (buffer, sizeof (buffer), "%d", week);
-      pango_layout_set_text (layout, buffer, -1);
-      pango_layout_get_pixel_extents (layout, NULL, &logical_rect);
+        year++;
 
-      y_loc = top_y_for_row (calendar, row) + (day_height - logical_rect.height) / 2;
-
-      x_loc = (private_data->week_width
-	       - logical_rect.width
-	       - CALENDAR_XSEP - focus_padding - focus_width);
+      g_return_if_fail (week_of_year (&week, &year,             
+                                      ((calendar->day[row][6] < 15 && row > 3 ? 1 : 0)
+                                       + calendar->month) % 12 + 1, calendar->day[row][6]));
+
+       g_snprintf (buffer, sizeof (buffer), "%d", week);
+       pango_layout_set_text (layout, buffer, -1); 
+       pango_layout_get_pixel_extents (layout, NULL, &logical_rect);
+
+       /* Hildon: draw passive focus for week */
+       if (hildonlike && calendar->focus_row == row) 
+         {
+           guint y = top_y_for_row (calendar, calendar->focus_row + 1);
+  
+           gtk_paint_box(GTK_WIDGET (calendar)->style,
+                         private_data->week_win,
+                         GTK_STATE_NORMAL,
+                         GTK_SHADOW_OUT, NULL,
+                         GTK_WIDGET (calendar), "passive-focus",
+                         0, y,
+                         private_data->week_width/* - 4*/,
+                         HILDON_DAY_HEIGHT);
+         }
+      
+      y_loc = private_data->day_name_h + top_y_for_row (calendar, row) + (HILDON_DAY_HEIGHT - logical_rect.height) / 2;
+      x_loc = (HILDON_DAY_WIDTH - logical_rect.width) / 2;
 
       gdk_draw_layout (private_data->week_win, gc, x_loc, y_loc, layout);
     }
@@ -2030,48 +2320,50 @@
 
 static void
 gtk_calendar_paint_day_num (GtkWidget *widget,
-			    gint       day)
+                            gint       day)
 {
   GtkCalendar *calendar;
   gint r, c, row, col;
-  
+  GtkCalendarPrivateData *private_data;  
   g_return_if_fail (GTK_IS_CALENDAR (widget));
   
   calendar = GTK_CALENDAR (widget);
-  
+
+  private_data = GTK_CALENDAR_PRIVATE_DATA (widget);
+
   row = -1;
   col = -1;
   for (r = 0; r < 6; r++)
     for (c = 0; c < 7; c++)
       if (calendar->day_month[r][c] == MONTH_CURRENT &&
-	  calendar->day[r][c] == day)
-	{
-	  row = r;
-	  col = c;
-	}
+          calendar->day[r][c] == day)
+        {
+          row = r;
+          col = c;
+        }
   
   g_return_if_fail (row != -1);
   g_return_if_fail (col != -1);
   
   gtk_calendar_paint_day (widget, row, col);
+
 }
 
 static void
 gtk_calendar_paint_day (GtkWidget *widget,
-			gint	   row,
-			gint	   col)
+                        gint       row,
+                        gint       col)
 {
   GtkCalendar *calendar;
   GdkGC *gc;
   gchar buffer[255];
   gint day;
-  gint day_height;
   gint x_left;
   gint x_loc;
   gint y_top;
   gint y_loc;
-  gint day_xspace;
   gint focus_width;
+  gboolean hildonlike;
 
   GtkCalendarPrivateData *private_data;
   PangoLayout *layout;
@@ -2083,6 +2375,8 @@
   calendar = GTK_CALENDAR (widget);
   private_data = GTK_CALENDAR_PRIVATE_DATA (widget);
 
+  if (private_data->main_win == NULL) return;
+   
   /*
    * Handle freeze/thaw functionality
    */
@@ -2092,25 +2386,19 @@
       private_data->dirty_main = 1;
       return;
     }
-  
-  gtk_widget_style_get (widget, "focus-line-width", &focus_width, NULL);
 
-  day_height = row_height (calendar);
-  
-  day_xspace = private_data->day_width - private_data->max_day_char_width*2;
-  
+  gtk_widget_style_get (widget, "focus-line-width", &focus_width,
+                        "hildonlike", &hildonlike, NULL);
+
   day = calendar->day[row][col];
-  
   x_left = left_x_for_column (calendar, col);
-  x_loc = x_left + private_data->day_width / 2 + private_data->max_day_char_width;
-  
   y_top = top_y_for_row (calendar, row);
   
   gdk_window_clear_area (private_data->main_win, x_left, y_top,
-			 private_data->day_width, day_height);
+                         HILDON_DAY_WIDTH, HILDON_DAY_HEIGHT);
   
   gc = calendar->gc;
-  
+
   if (calendar->day_month[row][col] == MONTH_PREV)
     {
       gdk_gc_set_foreground (gc, PREV_MONTH_COLOR (GTK_WIDGET (calendar)));
@@ -2121,67 +2409,77 @@
     } 
   else 
     {
-      /*
-      if (calendar->highlight_row == row && calendar->highlight_col == col)
-	{
-	  gdk_gc_set_foreground (gc, HIGHLIGHT_BACK_COLOR (GTK_WIDGET (calendar)));
-	  gdk_draw_rectangle (private_data->main_win, gc, TRUE, x_left, y_top,
-			      private_data->day_width, day_height);
-	}
-      */
       if (calendar->selected_day == day)
-	{
-	  gdk_gc_set_foreground (gc, SELECTED_BG_COLOR (GTK_WIDGET (calendar)));
-	  gdk_draw_rectangle (private_data->main_win, gc, TRUE, x_left, y_top,
-			      private_data->day_width, day_height);
-	}
-      
+        {
+          /* Hildon: use custom graphics */
+          if (hildonlike)
+            {
+              gtk_paint_box(GTK_WIDGET (calendar)->style,
+                            private_data->main_win,
+                            GTK_STATE_NORMAL,
+                            GTK_SHADOW_NONE, NULL,
+                            GTK_WIDGET (calendar), "active-day",
+                            x_left, y_top,
+                            HILDON_DAY_WIDTH,
+                            HILDON_DAY_HEIGHT);
+            }
+          else
+            {
+              gdk_gc_set_foreground (gc, SELECTED_BG_COLOR (GTK_WIDGET (calendar)));
+              gdk_draw_rectangle (private_data->main_win, gc, TRUE, x_left, y_top,
+                                  HILDON_DAY_WIDTH, HILDON_DAY_HEIGHT);
+            }
+        } 
       if (calendar->marked_date[day-1])
-	gdk_gc_set_foreground (gc, MARKED_COLOR	 (GTK_WIDGET (calendar)));
+        gdk_gc_set_foreground (gc, MARKED_COLOR    (GTK_WIDGET (calendar)));
       else
-	gdk_gc_set_foreground (gc, NORMAL_DAY_COLOR (GTK_WIDGET (calendar)));
-  
+        gdk_gc_set_foreground (gc, NORMAL_DAY_COLOR (GTK_WIDGET (calendar)));
       if (calendar->selected_day == day)
-	gdk_gc_set_foreground (gc, SELECTED_FG_COLOR (GTK_WIDGET (calendar)));
+        gdk_gc_set_foreground (gc, SELECTED_FG_COLOR (GTK_WIDGET (calendar)));
       else
-	gdk_gc_set_foreground (gc, & (GTK_WIDGET (calendar)->style->fg[GTK_WIDGET_STATE (calendar)]));
+        gdk_gc_set_foreground (gc, & (GTK_WIDGET (calendar)->style->fg[GTK_WIDGET_STATE (calendar)]));
     }
-    
-
-  g_snprintf (buffer, sizeof (buffer), "%d", day);
-  layout = gtk_widget_create_pango_layout (widget, buffer);
-  pango_layout_get_pixel_extents (layout, NULL, &logical_rect);
-  
-  x_loc -= logical_rect.width;
 
-  y_loc = y_top + (day_height - logical_rect.height) / 2;
-  gdk_draw_layout (private_data->main_win, gc,
-		   x_loc, y_loc, layout);
-  if (calendar->marked_date[day-1]
-      && calendar->day_month[row][col] == MONTH_CURRENT)
-    gdk_draw_layout (private_data->main_win, gc,
-		     x_loc-1, y_loc, layout);
-
-  if (GTK_WIDGET_HAS_FOCUS (calendar) 
-      && calendar->focus_row == row && calendar->focus_col == col)
+  if (GTK_WIDGET_HAS_FOCUS (calendar) &&
+      calendar->focus_row == row &&
+      calendar->focus_col == col)
     {
       GtkStateType state;
 
       if (calendar->selected_day == day)
-	state = GTK_WIDGET_HAS_FOCUS (widget) ? GTK_STATE_SELECTED : GTK_STATE_ACTIVE;
+        state = GTK_WIDGET_HAS_FOCUS (widget) ? GTK_STATE_SELECTED : GTK_STATE_ACTIVE;
       else
-	state = GTK_STATE_NORMAL;
-      
+        state = GTK_STATE_NORMAL;
+
       gtk_paint_focus (widget->style, 
-		       private_data->main_win,
-		       (calendar->selected_day == day) 
-		          ? GTK_STATE_SELECTED : GTK_STATE_NORMAL, 
-		       NULL, widget, "calendar-day",
-		       x_left, y_top, 
-		       private_data->day_width, 
-		       day_height);
+                       private_data->main_win,
+                       (calendar->selected_day == day) 
+                       ? GTK_STATE_SELECTED : GTK_STATE_NORMAL, 
+                       NULL, widget, "calendar-day",
+                       x_left, y_top, 
+                       HILDON_DAY_WIDTH, 
+                       HILDON_DAY_HEIGHT);
     }
 
+  /* Hildon: paint green indicator for current day */
+  if (hildonlike && (day == private_data->current_day && calendar->selected_day !=
+                     private_data->current_day) && (calendar->day_month[row][col] == MONTH_CURRENT))
+    gtk_calendar_check_current_date (calendar, x_left, y_top);
+
+  g_snprintf (buffer, sizeof (buffer), "%d", day);
+  layout = gtk_widget_create_pango_layout (widget, buffer);
+  pango_layout_get_pixel_extents (layout, NULL, &logical_rect);
+
+  x_loc = x_left + (HILDON_DAY_WIDTH - logical_rect.width) / 2;
+  y_loc = y_top + (HILDON_DAY_HEIGHT - logical_rect.height) / 2;
+
+  gdk_draw_layout (private_data->main_win, gc,
+                   x_loc, y_loc, layout);
+  if (calendar->marked_date[day-1] &&
+      calendar->day_month[row][col] == MONTH_CURRENT)
+    gdk_draw_layout (private_data->main_win, gc,
+                     x_loc-1, y_loc, layout);
+
   g_object_unref (layout);
 }
 
@@ -2195,7 +2493,7 @@
   
   g_return_if_fail (GTK_IS_CALENDAR (widget));
   g_return_if_fail (widget->window != NULL);
-  
+
   calendar = GTK_CALENDAR (widget);
   private_data = GTK_CALENDAR_PRIVATE_DATA (widget);
 
@@ -2207,8 +2505,6 @@
   private_data->dirty_main = 0;
   gdk_window_clear (private_data->main_win);
   
-  /* gtk_calendar_compute_days (calendar); */ /* REMOVE later */
-  
   for (col = 0; col < 7; col++)
     for (row = 0; row < 6; row++)
       gtk_calendar_paint_day (widget, row, col);
@@ -2250,11 +2546,11 @@
   if (first_day > 0)
     {
       for (col = 0; col < first_day; col++)
-	{
-	  calendar->day[row][col] = day;
-	  calendar->day_month[row][col] = MONTH_PREV;
-	  day++;
-	}
+        {
+          calendar->day[row][col] = day;
+          calendar->day_month[row][col] = MONTH_PREV;
+          day++;
+        }
     }
   
   /* Compute days of current month */
@@ -2266,10 +2562,10 @@
       
       col++;
       if (col == 7)
-	{
-	  row++;
-	  col = 0;
-	}
+        {
+          row++;
+          col = 0;
+        }
     }
   
   /* Compute days of next month */
@@ -2277,18 +2573,18 @@
   for (; row <= 5; row++)
     {
       for (; col <= 6; col++)
-	{
-	  calendar->day[row][col] = day;
-	  calendar->day_month[row][col] = MONTH_NEXT;
-	  day++;
-	}
+        {
+          calendar->day[row][col] = day;
+          calendar->day_month[row][col] = MONTH_NEXT;
+          day++;
+        }
       col = 0;
     }
 }
 
 void
-gtk_calendar_display_options (GtkCalendar	       *calendar,
-			      GtkCalendarDisplayOptions flags)
+gtk_calendar_display_options (GtkCalendar              *calendar,
+                              GtkCalendarDisplayOptions flags)
 {
   gtk_calendar_set_display_options (calendar, flags);
 }
@@ -2322,8 +2618,8 @@
  * Since: 2.4
  **/
 void
-gtk_calendar_set_display_options (GtkCalendar	       *calendar,
-				  GtkCalendarDisplayOptions flags)
+gtk_calendar_set_display_options (GtkCalendar          *calendar,
+                                  GtkCalendarDisplayOptions flags)
 {
   GtkCalendarPrivateData *private_data;
   gint resize = 0;
@@ -2340,97 +2636,97 @@
   if (GTK_WIDGET_REALIZED (widget))
     {
       if ((flags ^ calendar->display_flags) & GTK_CALENDAR_NO_MONTH_CHANGE)
-	{
-	  resize ++;
-	  if (! (flags & GTK_CALENDAR_NO_MONTH_CHANGE)
-	      && (private_data->header_win))
-	    {
-	      calendar->display_flags &= ~GTK_CALENDAR_NO_MONTH_CHANGE;
-	      gtk_calendar_realize_arrows (widget);
-	    }
-	  else
-	    {
-	      for (i = 0; i < 4; i++)
-		{
-		  if (private_data->arrow_win[i])
-		    {
-		      gdk_window_set_user_data (private_data->arrow_win[i], 
-						NULL);
-		      gdk_window_destroy (private_data->arrow_win[i]);
-		      private_data->arrow_win[i] = NULL;
-		    }
-		}
-	    }
-	}
+        {
+          resize ++;
+          if (! (flags & GTK_CALENDAR_NO_MONTH_CHANGE)
+              && (private_data->header_win))
+            {
+              calendar->display_flags &= ~GTK_CALENDAR_NO_MONTH_CHANGE;
+              gtk_calendar_realize_arrows (widget);
+            }
+          else
+            {
+              for (i = 0; i < 4; i++)
+                {
+                  if (private_data->arrow_win[i])
+                    {
+                      gdk_window_set_user_data (private_data->arrow_win[i], 
+                                                NULL);
+                      gdk_window_destroy (private_data->arrow_win[i]);
+                      private_data->arrow_win[i] = NULL;
+                    }
+                }
+            }
+        }
       
       if ((flags ^ calendar->display_flags) & GTK_CALENDAR_SHOW_HEADING)
-	{
-	  resize++;
-	  
-	  if (flags & GTK_CALENDAR_SHOW_HEADING)
-	    {
-	      calendar->display_flags |= GTK_CALENDAR_SHOW_HEADING;
-	      gtk_calendar_realize_header (widget);
-	    }
-	  else
-	    {
-	      for (i = 0; i < 4; i++)
-		{
-		  if (private_data->arrow_win[i])
-		    {
-		      gdk_window_set_user_data (private_data->arrow_win[i], 
-						NULL);
-		      gdk_window_destroy (private_data->arrow_win[i]);
-		      private_data->arrow_win[i] = NULL;
-		    }
-		}
-	      gdk_window_set_user_data (private_data->header_win, NULL);
-	      gdk_window_destroy (private_data->header_win);
-	      private_data->header_win = NULL;
-	    }
-	}
+        {
+          resize++;
+          
+          if (flags & GTK_CALENDAR_SHOW_HEADING)
+            {
+              calendar->display_flags |= GTK_CALENDAR_SHOW_HEADING;
+              gtk_calendar_realize_header (widget);
+            }
+          else
+            {
+              for (i = 0; i < 4; i++)
+                {
+                  if (private_data->arrow_win[i])
+                    {
+                      gdk_window_set_user_data (private_data->arrow_win[i], 
+                                                NULL);
+                      gdk_window_destroy (private_data->arrow_win[i]);
+                      private_data->arrow_win[i] = NULL;
+                    }
+                }
+              gdk_window_set_user_data (private_data->header_win, NULL);
+              gdk_window_destroy (private_data->header_win);
+              private_data->header_win = NULL;
+            }
+        }
       
       
       if ((flags ^ calendar->display_flags) & GTK_CALENDAR_SHOW_DAY_NAMES)
-	{
-	  resize++;
-	  
-	  if (flags & GTK_CALENDAR_SHOW_DAY_NAMES)
-	    {
-	      calendar->display_flags |= GTK_CALENDAR_SHOW_DAY_NAMES;
-	      gtk_calendar_realize_day_names (widget);
-	    }
-	  else
-	    {
-	      gdk_window_set_user_data (private_data->day_name_win, NULL);
-	      gdk_window_destroy (private_data->day_name_win);
-	      private_data->day_name_win = NULL;
-	    }
-	}
+        {
+          resize++;
+          
+          if (flags & GTK_CALENDAR_SHOW_DAY_NAMES)
+            {
+              calendar->display_flags |= GTK_CALENDAR_SHOW_DAY_NAMES;
+              gtk_calendar_realize_day_names (widget);
+            }
+          else
+            {
+              gdk_window_set_user_data (private_data->day_name_win, NULL);
+              gdk_window_destroy (private_data->day_name_win);
+              private_data->day_name_win = NULL;
+            }
+        }
       
       if ((flags ^ calendar->display_flags) & GTK_CALENDAR_SHOW_WEEK_NUMBERS)
-	{
-	  resize++;
-	  
-	  if (flags & GTK_CALENDAR_SHOW_WEEK_NUMBERS)
-	    {
-	      calendar->display_flags |= GTK_CALENDAR_SHOW_WEEK_NUMBERS;
-	      gtk_calendar_realize_week_numbers (widget);
-	    }
-	  else
-	    {
-	      gdk_window_set_user_data (private_data->week_win, NULL);
-	      gdk_window_destroy (private_data->week_win);
-	      private_data->week_win = NULL;
-	    }
-	}
+        {
+          resize++;
+          
+          if (flags & GTK_CALENDAR_SHOW_WEEK_NUMBERS)
+            {
+              calendar->display_flags |= GTK_CALENDAR_SHOW_WEEK_NUMBERS;
+              gtk_calendar_realize_week_numbers (widget);
+            }
+          else
+            {
+              gdk_window_set_user_data (private_data->week_win, NULL);
+              gdk_window_destroy (private_data->week_win);
+              private_data->week_win = NULL;
+            }
+        }
 
       if ((flags ^ calendar->display_flags) & GTK_CALENDAR_WEEK_START_MONDAY)
-	g_warning ("GTK_CALENDAR_WEEK_START_MONDAY is ignored; the first day of the week is determined from the locale");
+        g_warning ("GTK_CALENDAR_WEEK_START_MONDAY is ignored; the first day of the week is determined from the locale");
       
       calendar->display_flags = flags;
       if (resize)
-	gtk_widget_queue_resize (GTK_WIDGET (calendar));
+        gtk_widget_queue_resize (GTK_WIDGET (calendar));
       
     } 
   else
@@ -2450,12 +2746,27 @@
 
 gboolean
 gtk_calendar_select_month (GtkCalendar *calendar,
-			   guint	month,
-			   guint	year)
+                           guint        month,
+                           guint        year)
 {
+  gboolean hildonlike;
+  guint min_year, max_year;
+
   g_return_val_if_fail (GTK_IS_CALENDAR (calendar), FALSE);
   g_return_val_if_fail (month <= 11, FALSE);
   
+  gtk_widget_style_get(GTK_WIDGET (calendar), "hildonlike", &hildonlike, 
+                       "max-year", &max_year, "min-year",
+                        &min_year, NULL);
+  
+  if (hildonlike)
+    {
+      if (year >= max_year)
+         year = max_year;
+      else if (year <= min_year)
+         year = min_year;
+    }
+
   calendar->month = month;
   calendar->year  = year;
   
@@ -2469,21 +2780,37 @@
   g_object_thaw_notify (G_OBJECT (calendar));
 
   g_signal_emit (calendar,
-		 gtk_calendar_signals[MONTH_CHANGED_SIGNAL],
-		 0);
+                 gtk_calendar_signals[MONTH_CHANGED_SIGNAL],
+                 0);
   return TRUE;
 }
 
 void
 gtk_calendar_select_day (GtkCalendar *calendar,
-			 guint	      day)
+                         guint        day)
 {
-  g_return_if_fail (GTK_IS_CALENDAR (calendar));
-  g_return_if_fail (day <= 31);
-  
-  /* gtk_calendar_compute_days (calendar); */
-  
-  /* Deselect the old day */
+   gint row, col;
+   GtkCalendarPrivateData *priv;
+   g_return_if_fail (GTK_IS_CALENDAR (calendar));
+   g_return_if_fail (day <= 31);
+   priv = GTK_CALENDAR_PRIVATE_DATA (calendar);
+  
+   for (row = 0; row < 6; row ++)
+     for (col = 0; col < 7; col++)
+       {
+          if (calendar->day_month[row][col] == MONTH_CURRENT
+              && calendar->day[row][col] == day)
+            {
+               calendar->focus_row = row;
+               calendar->focus_col = col;
+            }
+       }
+
+   if (calendar->month != priv->current_month || 
+       calendar->year != priv->current_year)
+     gtk_calendar_unmark_day (calendar, priv->current_day);
+   
+   /* Deselect the old day */
   if (calendar->selected_day > 0)
     {
       gint selected_day;
@@ -2491,28 +2818,33 @@
       selected_day = calendar->selected_day;
       calendar->selected_day = 0;
       if (GTK_WIDGET_DRAWABLE (GTK_WIDGET (calendar)))
-	gtk_calendar_paint_day_num (GTK_WIDGET (calendar), selected_day);
+         {
+            gtk_calendar_paint_day_num (GTK_WIDGET (calendar), selected_day);
+         }
     }
   
   calendar->selected_day = day;
   
+  /*printf("Selected day = %d\n", day);*/
+
   /* Select the new day */
   if (day != 0)
     {
       if (GTK_WIDGET_DRAWABLE (GTK_WIDGET (calendar)))
-	gtk_calendar_paint_day_num (GTK_WIDGET (calendar), day);
+         {
+            gtk_calendar_paint_day_num (GTK_WIDGET (calendar), day);
+         }
     }
-  
+   
   g_object_notify (G_OBJECT (calendar), "day");
-
   g_signal_emit (calendar,
-		 gtk_calendar_signals[DAY_SELECTED_SIGNAL],
-		 0);
+                 gtk_calendar_signals[DAY_SELECTED_SIGNAL],
+                 0);
 }
 
 static void
 gtk_calendar_select_and_focus_day (GtkCalendar *calendar,
-				   guint        day)
+                                   guint        day)
 {
   gint old_focus_row = calendar->focus_row;
   gint old_focus_col = calendar->focus_col;
@@ -2522,12 +2854,12 @@
   for (row = 0; row < 6; row ++)
     for (col = 0; col < 7; col++)
       {
-	if (calendar->day_month[row][col] == MONTH_CURRENT 
-	    && calendar->day[row][col] == day)
-	  {
-	    calendar->focus_row = row;
-	    calendar->focus_col = col;
-	  }
+        if (calendar->day_month[row][col] == MONTH_CURRENT 
+            && calendar->day[row][col] == day)
+          {
+            calendar->focus_row = row;
+            calendar->focus_col = col;
+          }
       }
 
   if (old_focus_row != -1 && old_focus_col != -1)
@@ -2558,26 +2890,25 @@
 
 gboolean
 gtk_calendar_mark_day (GtkCalendar *calendar,
-		       guint	    day)
+                       guint        day)
 {
-  g_return_val_if_fail (GTK_IS_CALENDAR (calendar), FALSE);
-  
-  if (day >= 1 && day <= 31 && calendar->marked_date[day-1] == FALSE)
-    {
-      calendar->marked_date[day - 1] = TRUE;
-      calendar->num_marked_dates++;
-    }
-  if (GTK_WIDGET_DRAWABLE (GTK_WIDGET (calendar)))
-    {
-      gtk_calendar_paint_main (GTK_WIDGET (calendar));
-    }
+   g_return_val_if_fail (GTK_IS_CALENDAR (calendar), FALSE);
+   if (day >= 1 && day <= 31 && calendar->marked_date[day-1] == FALSE)
+     {
+        calendar->marked_date[day - 1] = TRUE;
+        calendar->num_marked_dates++;
+     }
+   if (GTK_WIDGET_DRAWABLE (GTK_WIDGET (calendar)))
+     {
+        gtk_calendar_paint_main (GTK_WIDGET (calendar));
+     }
   
   return TRUE;
 }
 
 gboolean
 gtk_calendar_unmark_day (GtkCalendar *calendar,
-			 guint	      day)
+                         guint        day)
 {
   g_return_val_if_fail (GTK_IS_CALENDAR (calendar), FALSE);
   
@@ -2597,9 +2928,9 @@
 
 void
 gtk_calendar_get_date (GtkCalendar *calendar,
-		       guint	   *year,
-		       guint	   *month,
-		       guint	   *day)
+                       guint       *year,
+                       guint       *month,
+                       guint       *day)
 {
   g_return_if_fail (GTK_IS_CALENDAR (calendar));
   
@@ -2618,7 +2949,7 @@
 
 static void
 arrow_action (GtkCalendar *calendar,
-	      guint        arrow)
+              guint        arrow)
 {
   switch (arrow)
     {
@@ -2629,14 +2960,15 @@
       gtk_calendar_set_year_next (calendar);
       break;
     case ARROW_MONTH_LEFT:
-      gtk_calendar_set_month_prev (calendar);
-      break;
+       gtk_calendar_set_month_prev (calendar);
+       break;
     case ARROW_MONTH_RIGHT:
       gtk_calendar_set_month_next (calendar);
       break;
     default:;
       /* do nothing */
     }
+   gtk_calendar_select_and_focus_day(calendar, calendar->selected_day); 
 }
 
 static gboolean
@@ -2645,6 +2977,11 @@
   GtkCalendar *calendar = data;
   GtkCalendarPrivateData *private_data = GTK_CALENDAR_PRIVATE_DATA (calendar);
   gboolean retval = FALSE;
+  GtkSettings *settings;
+  guint timeout;
+
+  settings = gtk_settings_get_default ();
+  g_object_get (settings, "gtk-update-timeout", &timeout, NULL);
   
   GDK_THREADS_ENTER ();
 
@@ -2653,14 +2990,14 @@
       arrow_action (calendar, private_data->click_child);
 
       if (private_data->need_timer)
-	{
-	  private_data->need_timer = FALSE;
-	  private_data->timer = g_timeout_add (CALENDAR_TIMER_DELAY, 
-					       (GSourceFunc) calendar_timer, 
-					       (gpointer) calendar);
-	}
+        {
+          private_data->need_timer = FALSE;
+          private_data->timer = g_timeout_add (/*CALENDAR_TIMER_DELAY*/timeout, 
+                                               (GSourceFunc) calendar_timer, 
+                                               (gpointer) calendar);
+        }
       else 
-	retval = TRUE;
+        retval = TRUE;
     }
 
   GDK_THREADS_LEAVE ();
@@ -2670,18 +3007,23 @@
 
 static void
 start_spinning (GtkWidget *widget,
-		gint       click_child)
+                gint       click_child)
 {
   GtkCalendarPrivateData *private_data = GTK_CALENDAR_PRIVATE_DATA (widget);
+  GtkSettings *settings;
+  guint timeout;
 
+  settings = gtk_settings_get_default ();
+  g_object_get (settings, "gtk-initial-timeout", &timeout, NULL);
+  
   private_data->click_child = click_child;
   
   if (!private_data->timer)
     {
       private_data->need_timer = TRUE;
-      private_data->timer = g_timeout_add (CALENDAR_INITIAL_TIMER_DELAY, 
-					   calendar_timer,
-					   (gpointer) widget);
+      private_data->timer = g_timeout_add (/*CALENDAR_INITIAL_TIMER_DELAY*/timeout, 
+                                           calendar_timer,
+                                           (gpointer) widget);
     }
 }
 
@@ -2710,7 +3052,7 @@
 
 static void
 gtk_calendar_grab_notify (GtkWidget *widget,
-			  gboolean   was_grabbed)
+                          gboolean   was_grabbed)
 {
   if (!was_grabbed)
     stop_spinning (widget);
@@ -2718,7 +3060,7 @@
 
 static gboolean
 gtk_calendar_focus_out (GtkWidget     *widget,
-			GdkEventFocus *event)
+                        GdkEventFocus *event)
 {
   GtkCalendarPrivateData *private_data;
 
@@ -2732,18 +3074,44 @@
 }
 
 static gboolean
-gtk_calendar_button_press (GtkWidget	  *widget,
-			   GdkEventButton *event)
+gtk_calendar_button_press (GtkWidget      *widget,
+                           GdkEventButton *event)
 {
   GtkCalendar *calendar;
   GtkCalendarPrivateData *private_data;
   gint arrow = -1;
-  
+  gboolean hildonlike;
+  gint min_year, max_year;
+
   calendar = GTK_CALENDAR (widget);
   private_data = GTK_CALENDAR_PRIVATE_DATA (widget);
+ 
+  gtk_widget_style_get(widget, "hildonlike", &hildonlike,
+                       "min-year", &min_year, "max-year", &max_year, NULL);
   
-  if (event->window == private_data->main_win)
-    gtk_calendar_main_button (widget, event);
+  if (!hildonlike || event->type == GDK_2BUTTON_PRESS)
+   {
+    if (event->window == private_data->main_win)
+      gtk_calendar_main_button (widget, event);
+   }
+  else if (hildonlike && (event->window == private_data->main_win))
+   {
+     gint x = (gint) (event->x);
+     gint y = (gint) (event->y);
+     gint row = row_from_y (calendar, y);
+     gint col = column_from_x (calendar, x);
+     private_data->pressed_day = calendar->day[row][col];
+     
+     if ((calendar->year == min_year && calendar->month == 0 && calendar->day_month[row][col] == MONTH_PREV) ||
+         (calendar->year == max_year && calendar->month == 11 && calendar->day_month[row][col] == MONTH_NEXT))
+       {}
+     else if (calendar->day_month[row][col] == MONTH_CURRENT)
+       gtk_calendar_select_and_focus_day (calendar, private_data->pressed_day);
+     
+     /* Remember month where button was pressed */
+     private_data->pressed_month = calendar->month;
+     private_data->slide_stylus = TRUE;
+   } 
 
   if (!GTK_WIDGET_HAS_FOCUS (widget))
     gtk_widget_grab_focus (widget);
@@ -2751,119 +3119,176 @@
   for (arrow = ARROW_YEAR_LEFT; arrow <= ARROW_MONTH_RIGHT; arrow++)
     {
       if (event->window == private_data->arrow_win[arrow])
-	{
-	  
-	  /* only call the action on single click, not double */
-	  if (event->type == GDK_BUTTON_PRESS)
-	    {
-	      if (event->button == 1)
-		start_spinning (widget, arrow);
+        {
+          
+          /* only call the action on single click, not double */
+          if (event->type == GDK_BUTTON_PRESS)
+            {
+              if (event->button == 1)
+                start_spinning (widget, arrow);
 
-	      arrow_action (calendar, arrow);	      
-	    }
+              arrow_action (calendar, arrow);         
+            }
 
-	  return TRUE;
-	}
+          return TRUE;
+        }
     }
 
-  return FALSE;
+  return TRUE;
 }
 
 static gboolean
-gtk_calendar_button_release (GtkWidget	  *widget,
-			     GdkEventButton *event)
+gtk_calendar_button_release (GtkWidget    *widget,
+                             GdkEventButton *event)
 {
   GtkCalendar *calendar;
   GtkCalendarPrivateData *private_data;
+  gboolean hildonlike;
 
   calendar = GTK_CALENDAR (widget);
   private_data = GTK_CALENDAR_PRIVATE_DATA (widget);
 
+  gtk_widget_style_get(widget, "hildonlike", &hildonlike,
+                       NULL);
+
+  if (hildonlike && (event->window == private_data->main_win))
+    {
+      gtk_calendar_main_button (widget, event);
+      gint x = (gint) (event->x);
+      gint y = (gint) (event->y);
+      gint row = row_from_y (calendar, y);
+      gint col = column_from_x (calendar, x);
+      private_data->prev_col = -1;
+      private_data->prev_row = -1;
+
+      if ((private_data->pressed_day == calendar->day[row][col]) &&
+          (private_data->pressed_month == calendar->month))
+       {
+        if (!private_data->is_bad_day)
+          {
+            g_signal_emit (calendar, gtk_calendar_signals[SELECTED_DATE_SIGNAL], 0);
+          }
+        else
+          {
+            private_data->is_bad_day = FALSE;
+          }
+       }
+    }
+
   if (event->button == 1) 
     {
       stop_spinning (widget);
 
       if (private_data->in_drag)
-	private_data->in_drag = 0;
+              private_data->in_drag = 0;
     }
 
+  private_data->slide_stylus = FALSE;
   return TRUE;
 }
 
 static gboolean
-gtk_calendar_motion_notify (GtkWidget	   *widget,
-			    GdkEventMotion *event)
+gtk_calendar_motion_notify (GtkWidget      *widget,
+                            GdkEventMotion *event)
 {
   GtkCalendar *calendar;
   GtkCalendarPrivateData *private_data;
   gint event_x, event_y;
   gint row, col;
   gint old_row, old_col;
+  gboolean hildonlike;
   
   calendar = GTK_CALENDAR (widget);
   private_data = GTK_CALENDAR_PRIVATE_DATA (widget);
   event_x = (gint) (event->x);
   event_y = (gint) (event->y);
-  
+
+  gtk_widget_style_get(widget, "hildonlike", &hildonlike,
+                       NULL);
+
   if (event->window == private_data->main_win)
     {
-      
+      if (hildonlike)
+        {
+          /* Hildon: make active day to move, when stylus is slided */
+          if (private_data->slide_stylus)
+            {
+              gint c_row = row_from_y (calendar, event_y);
+              gint c_col = column_from_x (calendar, event_x);
+          
+              if (calendar->day_month[c_row][c_col] == MONTH_PREV ||
+                  calendar->day_month[c_row][c_col] == MONTH_NEXT)
+                { }
+              else if ((private_data->prev_row != c_row || private_data->prev_col != c_col) &&
+                       (calendar->highlight_row != -1 && calendar->highlight_col != -1))
+                {
+                  gtk_calendar_select_and_focus_day (calendar, 
+                                                     calendar->day[c_row][c_col]);
+                  /* Update passive focus indicators work weekday number and name */
+                  gtk_calendar_paint_week_numbers (GTK_WIDGET (calendar));
+                  gtk_calendar_paint_day_names (GTK_WIDGET (calendar));
+                }
+               private_data->prev_col = c_col;
+               private_data->prev_row = c_row;    
+             }
+         }
       if (private_data->in_drag) 
-	{
-	  if (gtk_drag_check_threshold (widget,
-					private_data->drag_start_x, private_data->drag_start_y,
-					event->x, event->y))
-	    {
-	      GdkDragContext *context;
-	      GtkTargetList *target_list = gtk_target_list_new (NULL, 0);
-	      gtk_target_list_add_text_targets (target_list, 0);
-	      context = gtk_drag_begin (widget, target_list, GDK_ACTION_COPY,
-					1, (GdkEvent *)event);
-
-	  
-	      private_data->in_drag = 0;
-	      
-	      gtk_target_list_unref (target_list);
-	      gtk_drag_set_icon_default (context);
-	    }
-	}
+        {
+          if (gtk_drag_check_threshold (widget,
+                                        private_data->drag_start_x, private_data->drag_start_y,
+                                        event->x, event->y))
+            {
+              GdkDragContext *context;
+              GtkTargetList *target_list = gtk_target_list_new (NULL, 0);
+              gtk_target_list_add_text_targets (target_list, 0);
+              context = gtk_drag_begin (widget, target_list, GDK_ACTION_COPY,
+                                        1, (GdkEvent *)event);
+
+          
+              private_data->in_drag = 0;
+              
+              gtk_target_list_unref (target_list);
+              gtk_drag_set_icon_default (context);
+            }
+        }
       else 
-	{
-	  row = row_from_y (calendar, event_y);
-	  col = column_from_x (calendar, event_x);
-	  
-	  if (row != calendar->highlight_row || calendar->highlight_col != col)
-	    {
-	      old_row = calendar->highlight_row;
-	      old_col = calendar->highlight_col;
-	      if (old_row > -1 && old_col > -1)
-		{
-		  calendar->highlight_row = -1;
-		  calendar->highlight_col = -1;
-		  gtk_calendar_paint_day (widget, old_row, old_col);
-		}
-	      
-	      calendar->highlight_row = row;
-	      calendar->highlight_col = col;
-	      
-	      if (row > -1 && col > -1)
-		gtk_calendar_paint_day (widget, row, col);
-	    }
-	}
+        {
+          row = row_from_y (calendar, event_y);
+          col = column_from_x (calendar, event_x);
+          
+          if (row != calendar->highlight_row || calendar->highlight_col != col)
+            {
+              old_row = calendar->highlight_row;
+              old_col = calendar->highlight_col;
+              if (old_row > -1 && old_col > -1)
+                {
+                  calendar->highlight_row = -1;
+                  calendar->highlight_col = -1;
+                  gtk_calendar_paint_day (widget, old_row, old_col);
+                }
+              
+              calendar->highlight_row = row;
+              calendar->highlight_col = col;
+              
+              if (row > -1 && col > -1)
+                      gtk_calendar_paint_day (widget, row, col);
+            }
+        }
     }
+
   return TRUE;
 }
 
 static gboolean
-gtk_calendar_enter_notify (GtkWidget	    *widget,
-			   GdkEventCrossing *event)
+gtk_calendar_enter_notify (GtkWidget        *widget,
+                           GdkEventCrossing *event)
 {
   GtkCalendar *calendar;
   GtkCalendarPrivateData *private_data;
   
   calendar = GTK_CALENDAR (widget);
   private_data = GTK_CALENDAR_PRIVATE_DATA (widget);
-  
+
   if (event->window == private_data->arrow_win[ARROW_MONTH_LEFT])
     {
       private_data->arrow_state[ARROW_MONTH_LEFT] = GTK_STATE_PRELIGHT;
@@ -2892,8 +3317,8 @@
 }
 
 static gboolean
-gtk_calendar_leave_notify (GtkWidget	    *widget,
-			   GdkEventCrossing *event)
+gtk_calendar_leave_notify (GtkWidget        *widget,
+                           GdkEventCrossing *event)
 {
   GtkCalendar *calendar;
   GtkCalendarPrivateData *private_data;
@@ -2902,7 +3327,7 @@
   
   calendar = GTK_CALENDAR (widget);
   private_data = GTK_CALENDAR_PRIVATE_DATA (widget);
-  
+
   if (event->window == private_data->main_win)
     {
       row = calendar->highlight_row;
@@ -2910,7 +3335,7 @@
       calendar->highlight_row = -1;
       calendar->highlight_col = -1;
       if (row > -1 && col > -1)
-	gtk_calendar_paint_day (widget, row, col);
+              gtk_calendar_paint_day (widget, row, col);
     }
   
   if (event->window == private_data->arrow_win[ARROW_MONTH_LEFT])
@@ -2942,17 +3367,21 @@
 
 static void
 gtk_calendar_paint_arrow (GtkWidget *widget,
-			  guint	     arrow)
+                          guint      arrow)
 {
   GtkCalendarPrivateData *private_data;
   GdkWindow *window;
   GdkGC *gc;
   GtkCalendar *calendar;
   gint state;
-  gint width, height;
+  gint max_year, min_year;
+  gboolean hildonlike;
+/*  gint width, height;*/
   
   calendar = GTK_CALENDAR (widget);
   private_data = GTK_CALENDAR_PRIVATE_DATA (widget);
+  gtk_widget_style_get (widget, "hildonlike", &hildonlike, "max-year",
+                        &max_year, "min-year", &min_year, NULL);
 
   if (private_data->freeze_count)
     {
@@ -2965,23 +3394,81 @@
       state = private_data->arrow_state[arrow];
       gc = calendar->gc;
       
-      gdk_window_clear (window);
+/*      gdk_window_clear (window);*/
       gdk_window_set_background (window, &(widget)->style->bg[state]);
-      gdk_drawable_get_size (window, &width, &height);
-      gdk_window_clear_area (window,
-			     0,0,
-			     width,height);
-      if (arrow == ARROW_MONTH_LEFT || arrow == ARROW_YEAR_LEFT)
-	gtk_paint_arrow (widget->style, window, state, 
-			 GTK_SHADOW_OUT, NULL, widget, "calendar",
-			 GTK_ARROW_LEFT, TRUE, 
-			 width/2 - 3, height/2 - 4, 8, 8);
-      else 
-	gtk_paint_arrow (widget->style, window, state, 
-			 GTK_SHADOW_OUT, NULL, widget, "calendar",
-			 GTK_ARROW_RIGHT, TRUE, 
-			 width/2 - 2, height/2 - 4, 8, 8);
-    }
+/*      gdk_drawable_get_size (window, &width, &height);*/
+/*      gdk_window_clear_area (window,
+                             0,0,
+                             width,height);*/
+
+      gdk_window_clear(window);
+
+    /* Hildon: added support for dimmed arrows */
+    if (hildonlike  && (calendar->year <= min_year || calendar->year >= max_year))
+      {
+        if (calendar->year <= min_year)
+          {
+            if (arrow == ARROW_YEAR_LEFT)
+              gtk_paint_arrow (widget->style, window, GTK_STATE_INSENSITIVE,
+                         GTK_SHADOW_OUT, NULL, widget, "calendar",
+                         GTK_ARROW_LEFT, TRUE,
+               0, 0, HILDON_ARROW_WIDTH, HILDON_ARROW_HEIGHT);
+            else if (arrow == ARROW_YEAR_RIGHT || arrow == ARROW_MONTH_RIGHT)
+              gtk_paint_arrow (widget->style, window, state,
+                         GTK_SHADOW_OUT, NULL, widget, "calendar",
+                         GTK_ARROW_RIGHT, TRUE, 
+              0, 0, HILDON_ARROW_WIDTH, HILDON_ARROW_HEIGHT);
+            else if (arrow == ARROW_MONTH_LEFT && calendar->month != 0)
+              gtk_paint_arrow (widget->style, window, state,
+                         GTK_SHADOW_OUT, NULL, widget, "calendar",
+                         GTK_ARROW_LEFT, TRUE,
+              0, 0, HILDON_ARROW_WIDTH, HILDON_ARROW_HEIGHT);
+            else if (arrow == ARROW_MONTH_LEFT && !calendar->month)
+              gtk_paint_arrow (widget->style, window, GTK_STATE_INSENSITIVE,
+                         GTK_SHADOW_OUT, NULL, widget, "calendar",
+                         GTK_ARROW_LEFT, TRUE,
+               0, 0, HILDON_ARROW_WIDTH, HILDON_ARROW_HEIGHT);
+          }
+        else if (calendar->year >= max_year)
+          {
+           if (arrow == ARROW_YEAR_RIGHT)
+             gtk_paint_arrow (widget->style, window, GTK_STATE_INSENSITIVE, 
+                         GTK_SHADOW_OUT, NULL, widget, "calendar",
+                         GTK_ARROW_RIGHT, TRUE, 
+             0, 0, HILDON_ARROW_WIDTH, HILDON_ARROW_HEIGHT);
+           else if (arrow == ARROW_YEAR_LEFT || arrow == ARROW_MONTH_LEFT)
+             gtk_paint_arrow (widget->style, window, state, 
+                         GTK_SHADOW_OUT, NULL, widget, "calendar",
+                         GTK_ARROW_LEFT, TRUE, 
+             0, 0, HILDON_ARROW_WIDTH, HILDON_ARROW_HEIGHT);
+           else if (arrow == ARROW_MONTH_RIGHT && calendar->month != 11)
+             gtk_paint_arrow (widget->style, window, state,
+                         GTK_SHADOW_OUT, NULL, widget, "calendar",
+                         GTK_ARROW_RIGHT, TRUE,
+              0, 0, HILDON_ARROW_WIDTH, HILDON_ARROW_HEIGHT);
+           else if (arrow == ARROW_MONTH_RIGHT && calendar->month == 11)
+             gtk_paint_arrow (widget->style, window, GTK_STATE_INSENSITIVE,
+                         GTK_SHADOW_OUT, NULL, widget, "calendar",
+                         GTK_ARROW_RIGHT, TRUE,
+               0, 0, HILDON_ARROW_WIDTH, HILDON_ARROW_HEIGHT);
+          }
+      }
+    else
+      { 
+        if (arrow == ARROW_MONTH_LEFT || arrow == ARROW_YEAR_LEFT)
+            gtk_paint_arrow (widget->style, window, state, 
+                         GTK_SHADOW_OUT, NULL, widget, "calendar",
+                         GTK_ARROW_LEFT, TRUE, 
+          /*                     width/2 - 3, height/2 - 4, 8, 8);*/
+          0, 0, HILDON_ARROW_WIDTH, HILDON_ARROW_HEIGHT);
+        else 
+            gtk_paint_arrow (widget->style, window, state,
+                         GTK_SHADOW_OUT, NULL, widget, "calendar",
+                         GTK_ARROW_RIGHT, TRUE, 
+          /*                     width/2 - 2, height/2 - 4, 8, 8);*/
+          0, 0, HILDON_ARROW_WIDTH, HILDON_ARROW_HEIGHT);
+     }
+   }
 }
 
 void
@@ -3004,21 +3491,21 @@
   if (private_data->freeze_count)
     if (!(--private_data->freeze_count))
       {
-	if (private_data->dirty_header)
-	  if (GTK_WIDGET_DRAWABLE (calendar))
-	    gtk_calendar_paint_header (GTK_WIDGET (calendar));
-	
-	if (private_data->dirty_day_names)
-	  if (GTK_WIDGET_DRAWABLE (calendar))
-	    gtk_calendar_paint_day_names (GTK_WIDGET (calendar));
-	
-	if (private_data->dirty_week)
-	  if (GTK_WIDGET_DRAWABLE (calendar))
-	    gtk_calendar_paint_week_numbers (GTK_WIDGET (calendar));
-	
-	if (private_data->dirty_main)
-	  if (GTK_WIDGET_DRAWABLE (calendar))
-	    gtk_calendar_paint_main (GTK_WIDGET (calendar));
+        if (private_data->dirty_header)
+          if (GTK_WIDGET_DRAWABLE (calendar))
+            gtk_calendar_paint_header (GTK_WIDGET (calendar));
+        
+        if (private_data->dirty_day_names)
+          if (GTK_WIDGET_DRAWABLE (calendar))
+            gtk_calendar_paint_day_names (GTK_WIDGET (calendar));
+        
+        if (private_data->dirty_week)
+          if (GTK_WIDGET_DRAWABLE (calendar))
+            gtk_calendar_paint_week_numbers (GTK_WIDGET (calendar));
+        
+        if (private_data->dirty_main)
+          if (GTK_WIDGET_DRAWABLE (calendar))
+            gtk_calendar_paint_main (GTK_WIDGET (calendar));
       }
 }
 
@@ -3035,40 +3522,40 @@
   if (GTK_WIDGET_REALIZED (widget))
     {
       for (i = 0; i < 4; i++)
-	{
-	  if (private_data->arrow_win[i])
-	    gdk_window_set_background (private_data->arrow_win[i], 
-				       HEADER_BG_COLOR (widget));
-	}
+        {
+          if (private_data->arrow_win[i])
+            gdk_window_set_background (private_data->arrow_win[i], 
+                                       HEADER_BG_COLOR (widget));
+        }
       if (private_data->header_win)
-	gdk_window_set_background (private_data->header_win, 
-				   HEADER_BG_COLOR (widget));
+        gdk_window_set_background (private_data->header_win, 
+                                   HEADER_BG_COLOR (widget));
       if (private_data->day_name_win)
-	gdk_window_set_background (private_data->day_name_win, 
-				   BACKGROUND_COLOR (widget));
+        gdk_window_set_background (private_data->day_name_win, 
+                                   BACKGROUND_COLOR (widget));
       if (private_data->week_win)
-	gdk_window_set_background (private_data->week_win,
-				   BACKGROUND_COLOR (widget));
+        gdk_window_set_background (private_data->week_win,
+                                   BACKGROUND_COLOR (widget));
       if (private_data->main_win)
-	gdk_window_set_background (private_data->main_win,
-				   BACKGROUND_COLOR (widget));
+        gdk_window_set_background (private_data->main_win,
+                                   BACKGROUND_COLOR (widget));
       if (widget->window)
-	gdk_window_set_background (widget->window,
-				   BACKGROUND_COLOR (widget)); 
+        gdk_window_set_background (widget->window,
+                                   BACKGROUND_COLOR (widget)); 
     }
 }
 
 static void
 gtk_calendar_style_set (GtkWidget *widget,
-			GtkStyle  *previous_style)
+                        GtkStyle  *previous_style)
 {
   if (previous_style && GTK_WIDGET_REALIZED (widget))
     gtk_calendar_set_background(widget);
 }
 
 static void
-gtk_calendar_state_changed (GtkWidget	   *widget,
-			    GtkStateType    previous_state)
+gtk_calendar_state_changed (GtkWidget      *widget,
+                            GtkStateType    previous_state)
 {
   GtkCalendarPrivateData *private_data;
   int i;
@@ -3103,20 +3590,20 @@
 
 static gboolean
 gtk_calendar_scroll (GtkWidget      *widget,
-		     GdkEventScroll *event)
+                     GdkEventScroll *event)
 {
   GtkCalendar *calendar = GTK_CALENDAR (widget);
 
   if (event->direction == GDK_SCROLL_UP) 
     {
       if (!GTK_WIDGET_HAS_FOCUS (widget))
-	gtk_widget_grab_focus (widget);
+        gtk_widget_grab_focus (widget);
       gtk_calendar_set_month_prev (calendar);
     }
   else if (event->direction == GDK_SCROLL_DOWN) 
     {
       if (!GTK_WIDGET_HAS_FOCUS (widget))
-	gtk_widget_grab_focus (widget);
+        gtk_widget_grab_focus (widget);
       gtk_calendar_set_month_next (calendar);
     }
   else
@@ -3127,7 +3614,7 @@
 
 static void 
 move_focus (GtkCalendar *calendar, 
-	    gint direction)
+            gint direction)
 {
   GtkTextDirection text_dir = gtk_widget_get_direction (GTK_WIDGET (calendar));
 
@@ -3135,96 +3622,236 @@
       (text_dir == GTK_TEXT_DIR_RTL && direction == 1)) 
     {
       if (calendar->focus_col > 0)
-	  calendar->focus_col--;
+          calendar->focus_col--;
       else if (calendar->focus_row > 0)
-	{
-	  calendar->focus_col = 6;
-	  calendar->focus_row--;
-	}
+        {
+          calendar->focus_col = 6;
+          calendar->focus_row--;
+        }
     }
   else 
     {
       if (calendar->focus_col < 6)
-	calendar->focus_col++;
+        calendar->focus_col++;
       else if (calendar->focus_row < 5)
-	{
-	  calendar->focus_col = 0;
-	  calendar->focus_row++;
-	}
+        {
+          calendar->focus_col = 0;
+          calendar->focus_row++;
+        }
     }
 }
 
 static gboolean
 gtk_calendar_key_press (GtkWidget   *widget,
-			GdkEventKey *event)
+                        GdkEventKey *event)
 {
   GtkCalendar *calendar;
+  GtkSettings *settings;
   gint return_val;
   gint old_focus_row;
   gint old_focus_col;
   gint row, col, day;
-  
+  gint min_year, max_year;
+  gboolean knav;
+
   calendar = GTK_CALENDAR (widget);
   return_val = FALSE;
   
   old_focus_row = calendar->focus_row;
   old_focus_col = calendar->focus_col;
 
+  gtk_widget_style_get (widget, "max-year", &max_year, 
+                            "min-year", &min_year, NULL);
+
+  settings = gtk_settings_get_default ();
+  g_object_get (settings, "hildon-keyboard-navigation", &knav, NULL);
+
   switch (event->keyval)
     {
     case GDK_KP_Left:
     case GDK_Left:
       return_val = TRUE;
       if (event->state & GDK_CONTROL_MASK)
-	gtk_calendar_set_month_prev (calendar);
+        gtk_calendar_set_month_prev (calendar);
       else
-	{
-	  move_focus (calendar, -1);
-	  gtk_calendar_paint_day (widget, old_focus_row, old_focus_col);
-	  gtk_calendar_paint_day (widget, calendar->focus_row,
-				  calendar->focus_col);
-	}
+        {
+           /* if we are at the first allowed day of the minimum year/month then do nothing */
+           if (calendar->year == min_year && calendar->month == 0 && calendar->day_month[old_focus_row][old_focus_col-1] == MONTH_PREV) 
+             {
+                g_signal_emit (calendar, gtk_calendar_signals[ERRONEOUS_DATE_SIGNAL], 0);
+                return TRUE;
+             }
+           else /* else normal */
+             {
+                move_focus (calendar, -1);
+                if (!knav)
+                  {
+                     gtk_calendar_paint_day (widget, old_focus_row, old_focus_col);
+                     gtk_calendar_paint_day (widget, calendar->focus_row,
+                                             calendar->focus_col);
+                  }
+                else if (knav)
+                  {
+                     gint day_month = calendar->day_month[calendar->focus_row][calendar->focus_col];
+                     if (day_month == MONTH_CURRENT && calendar->selected_day != 1)
+                       {
+                               gtk_calendar_select_day(calendar, calendar->selected_day - 1);
+                       }
+                     else
+                       {
+             if (calendar->month != 0) {
+               calendar->selected_day = month_length[leap (calendar->year)][calendar->month];
+             } else {
+               calendar->selected_day = month_length[leap (calendar->year -1)][12];
+             }
+             gtk_calendar_set_month_prev (calendar);
+                       }
+         gtk_calendar_paint_week_numbers (GTK_WIDGET (calendar));
+         gtk_calendar_paint_day_names (GTK_WIDGET (calendar));
+                  }
+             }
+        }
       break;
     case GDK_KP_Right:
     case GDK_Right:
       return_val = TRUE;
       if (event->state & GDK_CONTROL_MASK)
-	gtk_calendar_set_month_next (calendar);
+        gtk_calendar_set_month_next (calendar);
       else
-	{
-	  move_focus (calendar, 1);
-	  gtk_calendar_paint_day (widget, old_focus_row, old_focus_col);
-	  gtk_calendar_paint_day (widget, calendar->focus_row,
-				  calendar->focus_col);
-	}
+        {
+           if (calendar->year == max_year && calendar->month == 11 && calendar->day_month[old_focus_row][old_focus_col+1] == MONTH_NEXT)
+             {
+                g_signal_emit (calendar, gtk_calendar_signals[ERRONEOUS_DATE_SIGNAL], 0);
+                return TRUE;
+             }
+           else 
+             {
+                move_focus (calendar, 1);
+                if (!knav)
+                  {
+                    gtk_calendar_paint_day (widget, old_focus_row, old_focus_col);
+                    gtk_calendar_paint_day (widget, calendar->focus_row,
+                                             calendar->focus_col);
+                  }
+                else if (knav)
+                  {
+                     gint day_month = calendar->day_month[calendar->focus_row][calendar->focus_col];
+                     if (day_month == MONTH_CURRENT)
+                       {  
+             gtk_calendar_select_day (calendar, calendar->selected_day + 1);
+                       }
+                     else
+                       {
+             calendar->selected_day = 1;
+                               gtk_calendar_set_month_next (calendar);
+                       }
+        gtk_calendar_paint_week_numbers (GTK_WIDGET (calendar));
+        gtk_calendar_paint_day_names (GTK_WIDGET (calendar)); 
+                  } 
+             }
+        }
       break;
     case GDK_KP_Up:
     case GDK_Up:
       return_val = TRUE;
       if (event->state & GDK_CONTROL_MASK)
-	gtk_calendar_set_year_prev (calendar);
+        gtk_calendar_set_year_prev (calendar);
       else
-	{
-	  if (calendar->focus_row > 0)
-	    calendar->focus_row--;
-	  gtk_calendar_paint_day (widget, old_focus_row, old_focus_col);
-	  gtk_calendar_paint_day (widget, calendar->focus_row,
-				  calendar->focus_col);
-	}
+        {
+           if (calendar->year == min_year && calendar->month == 0 && calendar->day_month[old_focus_row-1][old_focus_col] == MONTH_PREV)
+             {
+                g_signal_emit (calendar, gtk_calendar_signals[ERRONEOUS_DATE_SIGNAL], 0);
+                return TRUE;
+             }
+           else 
+             {
+                if (calendar->focus_row > 0)
+                  calendar->focus_row--;
+                if (!knav)
+                  {
+                     gtk_calendar_paint_day (widget, old_focus_row, old_focus_col);
+                     gtk_calendar_paint_day (widget, calendar->focus_row,
+                                             calendar->focus_col);
+                  }
+                else if (knav)
+                  {
+                     gint day_month = calendar->day_month[calendar->focus_row][calendar->focus_col];
+                     if (day_month == MONTH_CURRENT)
+                       {
+                               if ((calendar->selected_day - 7) <= 0)
+                                 {
+                 if (calendar->month != 0)
+                   calendar->selected_day = month_length[leap (calendar->year)][calendar->month];
+                 else
+                   calendar->selected_day = month_length[leap (calendar->year - 1)][12];
+                 gtk_calendar_set_month_prev (calendar); 
+                                 }
+                               else
+                                 {
+                 gtk_calendar_select_day (calendar, calendar->selected_day - 7);
+                                 }
+                       }
+                     else
+                       {
+             calendar->selected_day = calendar->day[calendar->focus_row][calendar->focus_col];
+                               gtk_calendar_set_month_prev (calendar);
+                       }
+        gtk_calendar_paint_week_numbers (GTK_WIDGET (calendar));
+        gtk_calendar_paint_day_names (GTK_WIDGET (calendar)); 
+                  }
+             }
+        }
       break;
     case GDK_KP_Down:
     case GDK_Down:
       return_val = TRUE;
       if (event->state & GDK_CONTROL_MASK)
-	gtk_calendar_set_year_next (calendar);
+        gtk_calendar_set_year_next (calendar);
       else
-	{
-	  if (calendar->focus_row < 5)
-	    calendar->focus_row++;
-	  gtk_calendar_paint_day (widget, old_focus_row, old_focus_col);
-	  gtk_calendar_paint_day (widget, calendar->focus_row,
-				  calendar->focus_col);
-	}
+        {
+           if (calendar->year == max_year && calendar->month == 11 && calendar->day_month[old_focus_row+1][old_focus_col] == MONTH_NEXT)
+             {
+                g_signal_emit (calendar, gtk_calendar_signals[ERRONEOUS_DATE_SIGNAL], 0);
+                return TRUE;
+             }
+           else 
+             {
+                
+                if (calendar->focus_row < 5)
+                  calendar->focus_row++;
+                if (!knav)
+                  {
+                     gtk_calendar_paint_day (widget, old_focus_row, old_focus_col);
+                     gtk_calendar_paint_day (widget, calendar->focus_row,
+                                             calendar->focus_col);
+                  }
+                else if (knav)
+                  {
+                     gint day_month = calendar->day_month[calendar->focus_row][calendar->focus_col];
+                     if (day_month == MONTH_CURRENT)
+                       {
+                             if ((calendar->selected_day + 7) > 
+                                  month_length[leap (calendar->year)][calendar->month + 1])
+                               {
+               calendar->selected_day = 1;
+                                 gtk_calendar_set_month_next (calendar);
+                               }
+                             else
+                              {
+              gtk_calendar_select_day (calendar, calendar->selected_day + 7);
+                              }
+                       }
+                     else
+                       {
+             calendar->selected_day = calendar->day[calendar->focus_row][calendar->focus_col];
+                               gtk_calendar_set_month_next (calendar);
+                       }
+         gtk_calendar_paint_week_numbers (GTK_WIDGET (calendar));
+         gtk_calendar_paint_day_names (GTK_WIDGET (calendar));
+                  } 
+             }
+        }
+           
       break;
     case GDK_KP_Space:
     case GDK_space:
@@ -3233,28 +3860,28 @@
       day = calendar->day[row][col];
       
       if (row > -1 && col > -1)
-	{
-	  return_val = TRUE;
-	  gtk_calendar_freeze (calendar);	  
-
-	  if (calendar->day_month[row][col] == MONTH_PREV)
-	    gtk_calendar_set_month_prev (calendar);
-	  else if (calendar->day_month[row][col] == MONTH_NEXT)
-	    gtk_calendar_set_month_next (calendar);
-
-	  gtk_calendar_select_and_focus_day (calendar, day);
-	  
-	  gtk_calendar_thaw (calendar);	  
-	}
-    }	
+        {
+          return_val = TRUE;
+          gtk_calendar_freeze (calendar);         
+
+          if (calendar->day_month[row][col] == MONTH_PREV)
+            gtk_calendar_set_month_prev (calendar);
+          else if (calendar->day_month[row][col] == MONTH_NEXT)
+            gtk_calendar_set_month_next (calendar);
+
+          gtk_calendar_select_and_focus_day (calendar, day);
+          
+          gtk_calendar_thaw (calendar);   
+        }
+    }   
   
   return return_val;
 }
 
 static void
 gtk_calendar_set_display_option (GtkCalendar              *calendar,
-				 GtkCalendarDisplayOptions flag,
-				 gboolean                  setting)
+                                 GtkCalendarDisplayOptions flag,
+                                 gboolean                  setting)
 {
   GtkCalendarDisplayOptions flags;
   if (setting) 
@@ -3266,7 +3893,7 @@
 
 static gboolean
 gtk_calendar_get_display_option (GtkCalendar              *calendar,
-				 GtkCalendarDisplayOptions flag)
+                                 GtkCalendarDisplayOptions flag)
 {
   return (calendar->display_flags & flag) != 0;
 }
@@ -3274,49 +3901,54 @@
 
 static void 
 gtk_calendar_set_property (GObject      *object,
-			   guint         prop_id,
-			   const GValue *value,
-			   GParamSpec   *pspec)
+                           guint         prop_id,
+                           const GValue *value,
+                           GParamSpec   *pspec)
 {
   GtkCalendar *calendar;
+  GtkCalendarPrivateData *private_data;
 
   calendar = GTK_CALENDAR (object);
+  private_data = GTK_CALENDAR_PRIVATE_DATA (calendar);
 
   switch (prop_id) 
     {
     case PROP_YEAR:
       gtk_calendar_select_month (calendar,
-				 calendar->month,
-				 g_value_get_int (value));
+                                 calendar->month,
+                                 g_value_get_int (value));
       break;
     case PROP_MONTH:
       gtk_calendar_select_month (calendar,
-				 g_value_get_int (value),
-				 calendar->year);
+                                 g_value_get_int (value),
+                                 calendar->year);
       break;
     case PROP_DAY:
       gtk_calendar_select_day (calendar,
-			       g_value_get_int (value));
+                               g_value_get_int (value));
       break;
     case PROP_SHOW_HEADING:
       gtk_calendar_set_display_option (calendar,
-				       GTK_CALENDAR_SHOW_HEADING,
-				       g_value_get_boolean (value));
+                                       GTK_CALENDAR_SHOW_HEADING,
+                                       g_value_get_boolean (value));
       break;
     case PROP_SHOW_DAY_NAMES:
       gtk_calendar_set_display_option (calendar,
-				       GTK_CALENDAR_SHOW_DAY_NAMES,
-				       g_value_get_boolean (value));
+                                       GTK_CALENDAR_SHOW_DAY_NAMES,
+                                       g_value_get_boolean (value));
       break;
     case PROP_NO_MONTH_CHANGE:
       gtk_calendar_set_display_option (calendar,
-				       GTK_CALENDAR_NO_MONTH_CHANGE,
-				       g_value_get_boolean (value));
+                                       GTK_CALENDAR_NO_MONTH_CHANGE,
+                                       g_value_get_boolean (value));
       break;
     case PROP_SHOW_WEEK_NUMBERS:
       gtk_calendar_set_display_option (calendar,
-				       GTK_CALENDAR_SHOW_WEEK_NUMBERS,
-				       g_value_get_boolean (value));
+                                       GTK_CALENDAR_SHOW_WEEK_NUMBERS,
+                                       g_value_get_boolean (value));
+      break;
+    case PROP_WEEK_START:
+      private_data->week_start = g_value_get_int (value);
       break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
@@ -3326,13 +3958,15 @@
 
 static void 
 gtk_calendar_get_property (GObject      *object,
-			   guint         prop_id,
-			   GValue       *value,
-			   GParamSpec   *pspec)
+                           guint         prop_id,
+                           GValue       *value,
+                           GParamSpec   *pspec)
 {
   GtkCalendar *calendar;
+  GtkCalendarPrivateData *private_data;
 
   calendar = GTK_CALENDAR (object);
+  private_data = GTK_CALENDAR_PRIVATE_DATA (calendar);
 
   switch (prop_id) 
     {
@@ -3347,19 +3981,22 @@
       break;
     case PROP_SHOW_HEADING:
       g_value_set_boolean (value, gtk_calendar_get_display_option (calendar,
-								   GTK_CALENDAR_SHOW_HEADING));
+                                                                   GTK_CALENDAR_SHOW_HEADING));
       break;
     case PROP_SHOW_DAY_NAMES:
       g_value_set_boolean (value, gtk_calendar_get_display_option (calendar,
-								   GTK_CALENDAR_SHOW_DAY_NAMES));
+                                                                   GTK_CALENDAR_SHOW_DAY_NAMES));
       break;
     case PROP_NO_MONTH_CHANGE:
       g_value_set_boolean (value, gtk_calendar_get_display_option (calendar,
-								   GTK_CALENDAR_NO_MONTH_CHANGE));
+                                                                   GTK_CALENDAR_NO_MONTH_CHANGE));
       break;
     case PROP_SHOW_WEEK_NUMBERS:
       g_value_set_boolean (value, gtk_calendar_get_display_option (calendar,
-								   GTK_CALENDAR_SHOW_WEEK_NUMBERS));
+                                                                   GTK_CALENDAR_SHOW_WEEK_NUMBERS));
+      break;
+    case PROP_WEEK_START:
+      g_value_set_int (value, private_data->week_start);
       break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
@@ -3370,10 +4007,10 @@
 
 static void
 gtk_calendar_drag_data_get (GtkWidget        *widget,
-			    GdkDragContext   *context,
-			    GtkSelectionData *selection_data,
-			    guint             info,
-			    guint             time)
+                            GdkDragContext   *context,
+                            GtkSelectionData *selection_data,
+                            guint             info,
+                            guint             time)
 {
   GtkCalendar *calendar = GTK_CALENDAR (widget);
   GDate *date;
@@ -3409,8 +4046,8 @@
 
 static void
 gtk_calendar_drag_leave (GtkWidget *widget,
-			 GdkDragContext *context,
-			 guint time)
+                         GdkDragContext *context,
+                         guint time)
 {
   GtkCalendarPrivateData *private_data;
 
@@ -3422,10 +4059,10 @@
 
 static gboolean
 gtk_calendar_drag_motion (GtkWidget *widget,
-			  GdkDragContext *context,
-			  gint x,
-			  gint y,
-			  guint time)
+                          GdkDragContext *context,
+                          gint x,
+                          gint y,
+                          guint time)
 {
   GtkCalendarPrivateData *private_data;
   GdkAtom target;
@@ -3451,10 +4088,10 @@
 
 static gboolean
 gtk_calendar_drag_drop (GtkWidget *widget,
-			GdkDragContext *context,
-			gint x,
-			gint y,
-			guint time)
+                        GdkDragContext *context,
+                        gint x,
+                        gint y,
+                        guint time)
 {
   GdkAtom target;
 
@@ -3462,8 +4099,8 @@
   if (target != GDK_NONE)
     {
       gtk_drag_get_data (widget, context, 
-			 target, 
-			 time);
+                         target, 
+                         time);
       return TRUE;
     }
 
@@ -3472,12 +4109,12 @@
 
 static void
 gtk_calendar_drag_data_received (GtkWidget        *widget,
-				 GdkDragContext   *context,
-				 gint              x,
-				 gint              y,
-				 GtkSelectionData *selection_data,
-				 guint             info,
-				 guint             time)
+                                 GdkDragContext   *context,
+                                 gint              x,
+                                 gint              y,
+                                 GtkSelectionData *selection_data,
+                                 guint             info,
+                                 guint             time)
 {
   GtkCalendar *calendar = GTK_CALENDAR (widget);
   guint day, month, year;
@@ -3498,16 +4135,16 @@
        */
       str = gtk_selection_data_get_text (selection_data);
       if (str) 
-	{
-	  date = g_date_new ();
-	  g_date_set_parse (date, str);
-	  if (!g_date_valid (date)) 
-	      suggested_action = 0;
-	  g_date_free (date);
-	  g_free (str);
-	}
+        {
+          date = g_date_new ();
+          g_date_set_parse (date, str);
+          if (!g_date_valid (date)) 
+              suggested_action = 0;
+          g_date_free (date);
+          g_free (str);
+        }
       else
-	suggested_action = 0;
+        suggested_action = 0;
 
       gdk_drag_status (context, suggested_action, time);
 
@@ -3525,7 +4162,7 @@
   if (!g_date_valid (date)) 
     {
       g_warning ("Received invalid date data\n");
-      g_date_free (date);	
+      g_date_free (date);       
       gtk_drag_finish (context, FALSE, FALSE, time);
       return;
     }
@@ -3533,7 +4170,7 @@
   day = g_date_get_day (date);
   month = g_date_get_month (date);
   year = g_date_get_year (date);
-  g_date_free (date);	
+  g_date_free (date);   
 
   gtk_drag_finish (context, TRUE, FALSE, time);
 
@@ -3545,3 +4182,27 @@
   gtk_calendar_select_day (calendar, day);
   g_object_thaw_notify (G_OBJECT (calendar));  
 }
+
+/* This function return TRUE if we should mark date and FALSE
+ *  otherwise
+ */
+static void
+gtk_calendar_check_current_date (GtkCalendar *calendar, gint x, gint y)
+{
+  GtkCalendarPrivateData *private_data;
+
+  private_data = GTK_CALENDAR_PRIVATE_DATA (calendar);
+  
+  if (calendar->month == private_data->current_month && 
+      calendar->year == private_data->current_year)
+    {
+      gtk_paint_box( GTK_WIDGET (calendar)->style,
+                     private_data->main_win,
+                     GTK_STATE_NORMAL,
+                     GTK_SHADOW_NONE, NULL,
+                     GTK_WIDGET (calendar), "current-day",
+                     x, y,
+                     HILDON_DAY_WIDTH,
+                     HILDON_DAY_HEIGHT);
+    }
+}
--- gtk+/gtk/gtkcalendar.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkcalendar.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -111,6 +111,9 @@
   void (* next_month)			(GtkCalendar *calendar);
   void (* prev_year)			(GtkCalendar *calendar);
   void (* next_year)			(GtkCalendar *calendar);
+  /* Hildon signals */
+  void (* erroneous_date) (GtkCalendar *calendar);
+  void (* selected_date) (GtkCalendar *calendar);
   
 };
 
--- gtk+/gtk/gtktextbufferserialize.c	(.../2.6.4)	(revision 0)
+++ gtk+/gtk/gtktextbufferserialize.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -0,0 +1,1859 @@
+/* gtktextbufferserialize.c
+ *
+ * Copyright (C) 2001 Havoc Pennington
+ * Copyright (C) 2004 Nokia Corporation
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/* FIXME: We should use other error codes for the 
+ * parts that deal with the format errors
+ */
+
+#include <config.h>
+
+#include <stdio.h>
+#include "gdk-pixbuf/gdk-pixdata.h"
+#include "gtktextbufferserialize.h"
+#include "gtkintl.h"
+
+#include <string.h>
+#include <stdlib.h>
+
+typedef struct
+{
+  GString *tag_table_str;
+  GString *text_str;
+  GHashTable *tags;
+  GtkTextIter start, end;
+
+  gint n_pixbufs;
+  GList *pixbufs;
+  gint tag_id;
+  GHashTable *tag_id_tags;
+} SerializationContext;
+
+static gchar *
+serialize_value (GValue *value)
+{
+  if (g_value_type_transformable (value->g_type, G_TYPE_STRING))
+    {
+      GValue text_value = { 0 };
+      gchar *tmp;
+      
+      g_value_init (&text_value, G_TYPE_STRING);
+      g_value_transform (value, &text_value);
+
+      tmp = g_markup_escape_text (g_value_get_string (&text_value), -1);
+      g_value_unset (&text_value);
+
+      return tmp;      
+    }
+  else if (value->g_type == GDK_TYPE_COLOR)
+    {
+      GdkColor *color = g_value_get_boxed (value);
+      
+      return g_strdup_printf ("%x:%x:%x", color->red, color->green, color->blue);
+    }
+  else if (g_type_is_a (value->g_type, GDK_TYPE_DRAWABLE))
+    {
+      /* Don't do anything */
+    }
+  else
+    {
+      g_warning ("Type %s is not serializable\n", g_type_name (value->g_type));
+    }
+
+  return NULL;
+}
+
+static gboolean
+deserialize_value (const gchar *str, GValue *value)
+{
+  if (g_value_type_transformable (G_TYPE_STRING, value->g_type))
+    {
+      GValue text_value = { 0 };
+      gboolean retval;
+      
+      g_value_init (&text_value, G_TYPE_STRING);
+      g_value_set_static_string (&text_value, str);
+      
+      retval = g_value_transform (&text_value, value);
+      g_value_unset (&text_value);
+
+      return retval;
+    }
+  else if (value->g_type == G_TYPE_BOOLEAN)
+    {
+      gboolean v;
+
+      v = strcmp (str, "TRUE") == 0;
+
+      g_value_set_boolean (value, v);
+
+      return TRUE;
+    }
+  else if (value->g_type == G_TYPE_INT)
+    {
+      gchar *tmp;
+      int v;
+      
+      v = strtol (str, &tmp, 10);
+
+      if (tmp == NULL || tmp == str)
+	return FALSE;
+
+      g_value_set_int (value, v);
+
+      return TRUE;
+    }
+  else if (value->g_type == G_TYPE_DOUBLE)
+    {
+      gchar *tmp;
+      gdouble v;
+      
+      v = g_ascii_strtod (str, &tmp);
+
+      if (tmp == NULL || tmp == str)
+	return FALSE;
+
+      g_value_set_double (value, v);
+
+      return TRUE;
+    }
+  else if (value->g_type == GDK_TYPE_COLOR)
+    {
+      GdkColor color;
+      const gchar *old;
+      gchar *tmp;
+
+      old = str;
+      color.red = strtol (old, &tmp, 16);
+
+      if (tmp == NULL || tmp == old)
+	return FALSE;
+
+      old = tmp;
+      if (*old++ != ':')
+	return FALSE;
+
+      color.green = strtol (old, &tmp, 16);
+      if (tmp == NULL || tmp == old)
+	return FALSE;
+
+      old = tmp;
+      if (*old++ != ':')
+	return FALSE;
+
+      color.blue = strtol (old, &tmp, 16);
+
+      if (tmp == NULL || tmp == old || *tmp != '\0')
+	return FALSE;
+
+      g_value_set_boxed (value, &color);
+      
+      return TRUE;
+    }
+  else if (G_VALUE_HOLDS_ENUM (value))
+    {
+      GEnumClass *class = G_ENUM_CLASS (g_type_class_peek (value->g_type));
+      GEnumValue *enum_value;
+
+      enum_value = g_enum_get_value_by_name (class, str);
+
+      if (enum_value)
+	{
+	  g_value_set_enum (value, enum_value->value);
+	  return TRUE;
+	}
+
+      return FALSE;
+    }
+  else
+    {
+      g_warning ("Type %s can not be deserialized\n", g_type_name (value->g_type));
+    }
+  
+  return FALSE;
+}
+
+/* Checks if a param is set, or if it's the default value */
+static gboolean
+is_param_set (GObject *object, GParamSpec *pspec, GValue *value)
+{
+  /* We need to special case some attributes here */
+  if (strcmp (pspec->name, "background-gdk") == 0)
+    {
+      gboolean is_set;
+
+      g_object_get (object, "background-set", &is_set, NULL);
+
+      if (is_set)
+	{
+	  g_value_init (value, G_PARAM_SPEC_VALUE_TYPE (pspec));
+      
+	  g_object_get_property (object, pspec->name, value);
+
+	  return TRUE;
+	}
+
+      return FALSE;
+    }
+  else if (strcmp (pspec->name, "foreground-gdk") == 0)
+    {
+      gboolean is_set;
+
+      g_object_get (object, "foreground-set", &is_set, NULL);
+
+      if (is_set)
+	{
+	  g_value_init (value, G_PARAM_SPEC_VALUE_TYPE (pspec));
+      
+	  g_object_get_property (object, pspec->name, value);
+
+	  return TRUE;
+	}
+
+      return FALSE;
+    }
+  else
+    {
+      gboolean is_set;
+      gchar *is_set_name;
+      
+      is_set_name = g_strdup_printf ("%s-set", pspec->name);
+      
+      if (g_object_class_find_property (G_OBJECT_GET_CLASS (object), is_set_name) == NULL)
+	{
+	  g_free (is_set_name);
+	  return FALSE;
+	}
+      else
+	{
+	  g_object_get (object, is_set_name, &is_set, NULL);
+	  
+	  if (!is_set)
+	    {
+	      g_free (is_set_name);
+	      return FALSE;
+	    }
+	  
+	  g_free (is_set_name);
+
+	  g_value_init (value, G_PARAM_SPEC_VALUE_TYPE (pspec));
+      
+	  g_object_get_property (object, pspec->name, value);
+	  
+	  if (g_param_value_defaults (pspec, value))
+	    {
+	      g_value_unset (value);
+	      
+	      return FALSE;
+	    }
+	}
+      return TRUE;
+    }
+}
+  
+static void
+serialize_tag (gpointer key, gpointer data, gpointer user_data)
+{
+  SerializationContext *context = user_data;
+  GtkTextTag *tag = data;
+  gchar *tag_name;
+  gint tag_id;
+  GParamSpec **pspecs;
+  guint n_pspecs;
+  int i;
+
+  g_string_append (context->tag_table_str, "  <tag ");
+
+  /* Handle anonymous tags */
+  if (tag->name) 
+    {
+      tag_name = g_markup_escape_text (tag->name, -1);
+      g_string_append_printf (context->tag_table_str, "name=\"%s\"", tag_name);
+      g_free (tag_name);
+    }
+  else 
+    {
+      tag_id = GPOINTER_TO_INT (g_hash_table_lookup (context->tag_id_tags, tag));
+
+      g_string_append_printf (context->tag_table_str, "id=\"%d\"", tag_id);
+    }
+  
+  g_string_append_printf (context->tag_table_str, " priority=\"%d\">\n", tag->priority);
+
+  /* Serialize properties */
+  pspecs = g_object_class_list_properties (G_OBJECT_GET_CLASS (tag), &n_pspecs);
+
+  for (i = 0; i < n_pspecs; i++)
+    {
+      GValue value = { 0 };
+      gchar *tmp, *tmp2;
+      
+      if (!(pspecs[i]->flags & G_PARAM_READABLE) ||
+	  !(pspecs[i]->flags & G_PARAM_WRITABLE))
+	continue;
+
+      if (!is_param_set (G_OBJECT (tag), pspecs[i], &value))
+	continue;
+      
+      /* Now serialize the attr */
+      tmp2 = serialize_value (&value);
+
+      if (tmp2) 
+	{
+	  tmp = g_markup_escape_text (pspecs[i]->name, -1);
+	  g_string_append_printf (context->tag_table_str, "   <attr name=\"%s\" ", tmp);
+	  g_free (tmp);
+	  
+	  tmp = g_markup_escape_text (g_type_name (pspecs[i]->value_type), -1);
+	  g_string_append_printf (context->tag_table_str, "type=\"%s\" value=\"%s\" />\n", tmp, tmp2);
+
+	  g_free (tmp);
+	  g_free (tmp2);
+	}
+      
+      g_value_unset (&value);
+    }
+  
+  g_free (pspecs);
+  
+  g_string_append (context->tag_table_str, "  </tag>\n");
+}
+
+static void
+serialize_tags (SerializationContext *context)
+{
+  g_string_append (context->tag_table_str, " <text_view_markup>\n");
+  g_string_append (context->tag_table_str, " <tags>\n");
+  g_hash_table_foreach (context->tags, serialize_tag, context);
+  g_string_append (context->tag_table_str, " </tags>\n");
+}
+
+#if 0
+static void
+dump_tag_list (const gchar *str, GList *list)
+{
+  g_print ("%s: ", str);
+  
+  if (!list)
+    g_print ("(empty)");
+  else
+    {
+      while (list)
+	{
+	  g_print ("%s ", ((GtkTextTag *)list->data)->name);
+	  list = list->next;
+	}
+    }
+
+  g_print ("\n");
+}
+#endif
+
+static void
+find_list_delta (GSList *old_list, GSList *new_list,
+		 GList **added, GList **removed)
+{
+  GSList *tmp;
+  GList *tmp_added, *tmp_removed;
+
+  tmp_added = NULL;
+  tmp_removed = NULL;
+  
+  /* Find added tags */
+  tmp = new_list;
+  while (tmp)
+    {
+      if (!g_slist_find (old_list, tmp->data))
+	tmp_added = g_list_prepend (tmp_added, tmp->data);
+      
+      tmp = tmp->next;
+    }
+
+  *added = tmp_added;
+  
+  /* Find removed tags */
+  tmp = old_list;
+  while (tmp)
+    {
+      if (!g_slist_find (new_list, tmp->data))
+	tmp_removed = g_list_prepend (tmp_removed, tmp->data);
+      
+      tmp = tmp->next;
+    }
+
+  /* We reverse the list here to match the xml semantics */
+  *removed = g_list_reverse (tmp_removed);
+}
+
+static void
+serialize_section_header (GString     *str,
+			  const gchar *name,
+			  gint         length)
+{
+  g_return_if_fail (strlen (name) == 8);
+  
+  g_string_append (str, name);
+
+  g_string_append_c (str, length >> 24);
+
+  g_string_append_c (str, (length >> 16) & 0xff);
+  g_string_append_c (str, (length >> 8) & 0xff);
+  g_string_append_c (str, length & 0xff);
+}
+
+static void
+serialize_text (GtkTextBuffer *buffer, SerializationContext *context)
+{
+  GtkTextIter iter, old_iter;
+  GSList *tag_list, *new_tag_list;
+  GQueue *active_tags;
+  int i;
+  
+  g_string_append (context->text_str, "<text>");
+
+  iter = context->start;
+  tag_list = NULL;
+  active_tags = g_queue_new ();
+  
+  do
+    {
+      GList *added, *removed;
+      GList *tmp;
+      gchar *tmp_text, *escaped_text;
+
+      new_tag_list = gtk_text_iter_get_tags (&iter);
+      find_list_delta (tag_list, new_tag_list, &added, &removed);
+      
+      /* Handle removed tags */
+      tmp = removed;
+      while (tmp)
+	{
+	  GtkTextTag *tag = tmp->data;
+	  
+	  g_string_append (context->text_str, "</apply_tag>");
+
+	  /* We might need to drop some of the tags and re-add them afterwards */
+	  while (g_queue_peek_head (active_tags) != tag &&
+		     !g_queue_is_empty (active_tags))
+	    {
+	      added = g_list_prepend (added, g_queue_pop_head (active_tags));
+	      g_string_append_printf (context->text_str, "</apply_tag>");
+	    }
+	  
+	  g_queue_pop_head (active_tags);
+	  
+	  tmp = tmp->next;
+	}
+      
+      /* Handle added tags */
+      tmp = added;
+      while (tmp)
+	{
+	  GtkTextTag *tag = tmp->data;
+	  gchar *tag_name;
+
+	  /* Add it to the tag hash table */
+	  g_hash_table_insert (context->tags, tag, tag);
+
+	  if (tag->name) 
+	    {
+	      tag_name = g_markup_escape_text (tag->name, -1);
+	      
+	      g_string_append_printf (context->text_str, "<apply_tag name=\"%s\">", tag_name);
+	      g_free (tag_name);
+	    }
+	  else
+	    {
+	      gpointer tag_id;
+
+	      /* We've got an anonymous tag, find out if it's been
+		 used before */
+	      if (!g_hash_table_lookup_extended (context->tag_id_tags, tag, NULL, &tag_id)) 
+		{
+		  tag_id = GINT_TO_POINTER (context->tag_id++);
+
+		  g_hash_table_insert (context->tag_id_tags, tag, tag_id);
+		}
+
+	      g_string_append_printf (context->text_str, "<apply_tag id=\"%d\">", GPOINTER_TO_INT (tag_id));
+	    }
+	  g_queue_push_head (active_tags, tag);
+
+	  tmp = tmp->next;
+	}
+      
+      g_slist_free (tag_list);
+      tag_list = new_tag_list;
+      
+      old_iter = iter;
+      
+      /* Now try to go to either the next tag toggle, or if a pixbuf appears */
+      while (TRUE) 
+	{
+	  gunichar ch = gtk_text_iter_get_char (&iter);
+	  
+	  if (ch == 0xFFFC) 
+	    {
+	      GdkPixbuf *pixbuf = gtk_text_iter_get_pixbuf (&iter);
+	      
+	      if (pixbuf) 
+		{
+		  /* Append the text before the pixbuf */
+		  tmp_text = gtk_text_iter_get_slice (&old_iter, &iter);
+		  escaped_text = g_markup_escape_text (tmp_text, -1);
+		  g_free (tmp_text);
+
+		  /* Forward so we don't get the 0xfffc char */
+		  gtk_text_iter_forward_char (&iter);
+		  old_iter = iter;
+
+		  g_string_append (context->text_str, escaped_text);
+		  g_free (escaped_text);
+
+		  g_string_append_printf (context->text_str, "<pixbuf index=\"%d\" />", context->n_pixbufs);
+
+		  context->n_pixbufs++;
+		  context->pixbufs = g_list_prepend (context->pixbufs, pixbuf);
+		}
+	    }
+          else if (ch == 0)
+            {
+                break;
+            }
+	  else 
+	    gtk_text_iter_forward_char (&iter);
+	  
+	  if (gtk_text_iter_toggles_tag (&iter, NULL))
+	    break;
+	}
+
+      /* We might have moved too far */
+      if (gtk_text_iter_compare (&iter, &context->end) > 0)
+	iter = context->end;
+      
+      /* Append the text */
+      tmp_text = gtk_text_iter_get_slice (&old_iter, &iter);
+      escaped_text = g_markup_escape_text (tmp_text, -1);
+      g_free (tmp_text);
+      
+      g_string_append (context->text_str, escaped_text);
+      g_free (escaped_text);
+    }
+  while (!gtk_text_iter_equal (&iter, &context->end));
+
+  /* Close any open tags */
+  for (i = 0; i < g_queue_get_length (active_tags); i++) {
+    g_string_append (context->text_str, "</apply_tag>");
+  }  
+  g_queue_free (active_tags);
+  g_string_append (context->text_str, "</text>\n</text_view_markup>\n");
+}
+
+static void
+serialize_pixbufs (SerializationContext *context,
+		   GString              *text)
+{
+  GList *list;
+
+  for (list = context->pixbufs; list != NULL; list = list->next) 
+    {
+      GdkPixbuf *pixbuf = list->data;
+      GdkPixdata pixdata;
+      guint8 *tmp;
+      guint len;
+      
+      gdk_pixdata_from_pixbuf (&pixdata, pixbuf, FALSE);
+      tmp = gdk_pixdata_serialize (&pixdata, &len);
+      
+      serialize_section_header (text, "PIXBDATA", len);
+      g_string_append_len (text, tmp, len);
+      g_free (tmp);
+    }
+}
+
+gchar *
+gtk_text_buffer_serialize_rich_text (GtkTextBuffer     *buffer,
+				     const GtkTextIter *start,
+				     const GtkTextIter *end,
+				     gint              *len)
+{
+  SerializationContext context;
+  GString *text;
+
+  context.tags = g_hash_table_new (NULL, NULL);
+  context.text_str = g_string_new (NULL);
+  context.tag_table_str = g_string_new (NULL);
+  context.start = *start;
+  context.end = *end;
+  context.n_pixbufs = 0;
+  context.pixbufs = NULL;
+  context.tag_id = 0;
+  context.tag_id_tags = g_hash_table_new (NULL, NULL);
+
+  /* We need to serialize the text before the tag table so we know
+     what tags are used */
+  serialize_text (buffer, &context);
+  serialize_tags (&context);
+
+  text = g_string_new (NULL);
+  serialize_section_header (text, "RICHTEXT", context.tag_table_str->len + context.text_str->len);
+  
+  g_string_append_len (text, context.tag_table_str->str, context.tag_table_str->len);
+  g_string_append_len (text, context.text_str->str, context.text_str->len);
+
+  context.pixbufs = g_list_reverse (context.pixbufs);
+  serialize_pixbufs (&context, text);
+
+  g_hash_table_destroy (context.tags);
+  g_list_free (context.pixbufs);
+  g_string_free (context.text_str, TRUE);
+  g_string_free (context.tag_table_str, TRUE);
+  g_hash_table_destroy (context.tag_id_tags);
+
+  *len = text->len;
+
+  return g_string_free (text, FALSE);
+}
+
+typedef enum
+{
+  STATE_START,
+  STATE_TEXT_VIEW_MARKUP,
+  STATE_TAGS,
+  STATE_TAG,
+  STATE_ATTR,
+  STATE_TEXT,
+  STATE_APPLY_TAG,
+  STATE_PIXBUF
+} ParseState;
+
+typedef struct
+{
+  gchar *text;
+  GdkPixbuf *pixbuf;
+  GSList *tags;
+} TextSpan;
+
+typedef struct
+{
+  GtkTextTag *tag;
+  gint prio;
+} TextTagPrio;
+
+typedef struct
+{
+  GSList *states;
+
+  GList *headers;
+
+  GtkTextBuffer *buffer;
+
+  /* Tags that are defined in <tag> elements */
+  GHashTable *defined_tags;
+  
+  /* Tags that are anonymous */
+  GHashTable *anonymous_tags;
+
+  /* Tag name substitutions */
+  GHashTable *substitutions;
+
+  /* Current tag */
+  GtkTextTag *current_tag;
+
+  /* Priority of current tag */
+  gint current_tag_prio;
+  
+  /* Id of current tag */
+  gint current_tag_id;
+
+  /* Tags and their priorities */
+  GList *tag_priorities;
+  
+  GSList *tag_stack;
+
+  GList *spans;
+
+  gboolean create_tags;
+  
+  gboolean parsed_text;
+  gboolean parsed_tags;
+} ParseInfo;
+
+static void
+set_error (GError             **err,
+           GMarkupParseContext *context,
+           int                  error_domain,
+           int                  error_code,
+           const char          *format,
+           ...)
+{
+  int line, ch;
+  va_list args;
+  char *str;
+  
+  g_markup_parse_context_get_position (context, &line, &ch);
+
+  va_start (args, format);
+  str = g_strdup_vprintf (format, args);
+  va_end (args);
+
+  g_set_error (err, error_domain, error_code,
+               ("Line %d character %d: %s"),
+               line, ch, str);
+
+  g_free (str);
+}
+
+static void
+push_state (ParseInfo  *info,
+            ParseState  state)
+{
+  info->states = g_slist_prepend (info->states, GINT_TO_POINTER (state));
+}
+
+static void
+pop_state (ParseInfo *info)
+{
+  g_return_if_fail (info->states != NULL);
+  
+  info->states = g_slist_remove (info->states, info->states->data);
+}
+
+static ParseState
+peek_state (ParseInfo *info)
+{
+  g_return_val_if_fail (info->states != NULL, STATE_START);
+
+  return GPOINTER_TO_INT (info->states->data);
+}
+
+#define ELEMENT_IS(name) (strcmp (element_name, (name)) == 0)
+
+
+static gboolean
+check_id_or_name (GMarkupParseContext *context,
+		  const gchar *element_name,
+		  const gchar **attribute_names, 
+		  const gchar **attribute_values, 
+		  gint         *id, 
+		  const gchar **name, 
+		  GError      **error)
+{
+  gboolean has_id = FALSE;
+  gboolean has_name = FALSE;
+  int i;
+
+  *id = 0;
+  *name = NULL;
+
+  for (i = 0; attribute_names[i] != NULL; i++)
+    {
+      if (strcmp (attribute_names[i], "name") == 0) 
+	{
+	  *name = attribute_values[i];
+
+	  if (has_id)
+	    {
+	      set_error (error, context,
+			 G_MARKUP_ERROR,
+			 G_MARKUP_ERROR_PARSE,
+			 _("Both \"id\" and \"name\" were found on the <%s> element"),
+			 element_name);
+	      return FALSE;
+	    }
+
+	  if (has_name)
+	    {
+	      set_error (error, context,
+			 G_MARKUP_ERROR,
+			 G_MARKUP_ERROR_PARSE,
+			 _("The attribute \"name\" were found twice on the <%s> element"),
+			 element_name);
+	      return FALSE;
+	    }
+
+	  has_name = TRUE;
+	}
+      else if (strcmp (attribute_names[i], "id") == 0)
+	{	  
+	  gchar *tmp;
+
+	  if (has_name)
+	    {
+	      set_error (error, context,
+			 G_MARKUP_ERROR,
+			 G_MARKUP_ERROR_PARSE,
+			 _("Both \"id\" and \"name\" were found on the <%s> element"),
+			 element_name);
+	      return FALSE;
+	    }
+
+	  if (has_id)
+	    {
+	      set_error (error, context,
+			 G_MARKUP_ERROR,
+			 G_MARKUP_ERROR_PARSE,
+			 _("The attribute \"id\" were found twice on the <%s> element"),
+			 element_name);
+	      return FALSE;
+	    }
+
+	  has_id = TRUE;
+
+	  /* Try parsing the integer */
+	  *id = strtol (attribute_values[i], &tmp, 10);
+	  
+	  if (tmp == NULL || tmp == attribute_values[i])
+	    {
+	      set_error (error, context,
+			 G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+			 _("<%s> element has invalid id \"%s\""), attribute_values[i]);
+	      return FALSE;
+	    }
+	}
+    }
+
+  if (!has_id && !has_name) 
+    {
+      set_error (error, context,
+		 G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+		 _("<%s> element neither a \"name\" nor an \"id\" element"), element_name);
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+typedef struct
+{
+  const char  *name;
+  const char **retloc;
+} LocateAttr;
+
+static gboolean
+locate_attributes (GMarkupParseContext *context,
+                   const char  *element_name,
+                   const char **attribute_names,
+                   const char **attribute_values,
+		   gboolean     allow_unknown_attrs,
+                   GError     **error,
+                   const char  *first_attribute_name,
+                   const char **first_attribute_retloc,
+                   ...)
+{
+  va_list args;
+  const char *name;
+  const char **retloc;
+  int n_attrs;
+#define MAX_ATTRS 24
+  LocateAttr attrs[MAX_ATTRS];
+  gboolean retval;
+  int i;
+
+  g_return_val_if_fail (first_attribute_name != NULL, FALSE);
+  g_return_val_if_fail (first_attribute_retloc != NULL, FALSE);
+
+  retval = TRUE;
+
+  n_attrs = 1;
+  attrs[0].name = first_attribute_name;
+  attrs[0].retloc = first_attribute_retloc;
+  *first_attribute_retloc = NULL;
+  
+  va_start (args, first_attribute_retloc);
+
+  name = va_arg (args, const char*);
+  retloc = va_arg (args, const char**);
+
+  while (name != NULL)
+    {
+      g_return_val_if_fail (retloc != NULL, FALSE);
+
+      g_assert (n_attrs < MAX_ATTRS);
+      
+      attrs[n_attrs].name = name;
+      attrs[n_attrs].retloc = retloc;
+      n_attrs += 1;
+      *retloc = NULL;      
+
+      name = va_arg (args, const char*);
+      retloc = va_arg (args, const char**);
+    }
+
+  va_end (args);
+
+  if (!retval)
+    return retval;
+
+  i = 0;
+  while (attribute_names[i])
+    {
+      int j;
+      gboolean found;
+
+      found = FALSE;
+      j = 0;
+      while (j < n_attrs)
+        {
+          if (strcmp (attrs[j].name, attribute_names[i]) == 0)
+            {
+              retloc = attrs[j].retloc;
+
+              if (*retloc != NULL)
+                {
+                  set_error (error, context,
+                             G_MARKUP_ERROR,
+                             G_MARKUP_ERROR_PARSE,
+                             _("Attribute \"%s\" repeated twice on the same <%s> element"),
+                             attrs[j].name, element_name);
+                  retval = FALSE;
+                  goto out;
+                }
+
+              *retloc = attribute_values[i];
+              found = TRUE;
+            }
+
+          ++j;
+        }
+
+      if (!found && !allow_unknown_attrs)
+        {
+          set_error (error, context,
+                     G_MARKUP_ERROR,
+                     G_MARKUP_ERROR_PARSE,
+                     _("Attribute \"%s\" is invalid on <%s> element in this context"),
+                     attribute_names[i], element_name);
+          retval = FALSE;
+          goto out;
+        }
+
+      ++i;
+    }
+
+ out:
+  return retval;
+}
+
+static gboolean
+check_no_attributes (GMarkupParseContext *context,
+                     const char  *element_name,
+                     const char **attribute_names,
+                     const char **attribute_values,
+                     GError     **error)
+{
+  if (attribute_names[0] != NULL)
+    {
+      set_error (error, context,
+                 G_MARKUP_ERROR,
+                 G_MARKUP_ERROR_PARSE,
+                 _("Attribute \"%s\" is invalid on <%s> element in this context"),
+                 attribute_names[0], element_name);
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+static GtkTextTag *
+tag_exists (GMarkupParseContext *context,
+	    const gchar         *name,
+	    gint                 id,
+	    ParseInfo           *info,	    
+	    GError             **error)
+{
+  const gchar *real_name;
+  
+  if (info->create_tags)
+    {
+      /* If we have an anonymous tag, just return it directly */
+      if (!name)
+	return g_hash_table_lookup (info->anonymous_tags,
+				    GINT_TO_POINTER (id));
+
+      /* First, try the substitutions */
+      real_name = g_hash_table_lookup (info->substitutions, name);
+
+      if (real_name)
+	return gtk_text_tag_table_lookup (info->buffer->tag_table, real_name);
+
+      /* Next, try the list of defined tags */
+      if (g_hash_table_lookup (info->defined_tags, name) != NULL)
+	return gtk_text_tag_table_lookup (info->buffer->tag_table, name);
+
+      set_error (error, context,
+		 G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+		 _("Tag \"%s\" has not been defined."), name);
+      
+      return NULL;
+    }
+  else
+    {
+      GtkTextTag *tag;
+
+      if (!name)
+	{
+	  set_error (error, context,
+		     G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+		     _("Anonymous tag found and tags can not be created."));
+	  return NULL;
+	}
+
+      tag = gtk_text_tag_table_lookup (info->buffer->tag_table, name);
+      
+      if (tag)
+	return tag;
+      
+      set_error (error, context,
+		 G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+		 _("Tag \"%s\" does not exist in buffer and tags can not be created."), name);
+      
+      return NULL;
+    }
+}
+
+typedef struct
+{
+  const gchar *id;
+  gint length;
+  const gchar *start;
+} Header;
+
+static GdkPixbuf *
+get_pixbuf_from_headers (GList *headers, int id, GError **error)
+{
+  Header *header;
+  GdkPixdata pixdata;
+  GdkPixbuf *pixbuf;
+
+  header = g_list_nth_data (headers, id);
+  
+  if (!header)
+    return NULL;
+
+  if (!gdk_pixdata_deserialize (&pixdata, header->length, header->start, error))
+    return NULL;
+
+  pixbuf = gdk_pixbuf_from_pixdata (&pixdata, TRUE, error);
+  
+  return pixbuf;
+}
+
+static void
+parse_apply_tag_element (GMarkupParseContext  *context,
+			 const gchar          *element_name,
+			 const gchar         **attribute_names,
+			 const gchar         **attribute_values,
+			 ParseInfo            *info,
+			 GError              **error)
+{
+  const gchar *name, *priority;
+  gint id;
+  GtkTextTag *tag;
+
+  g_assert (peek_state (info) == STATE_TEXT ||
+	    peek_state (info) == STATE_APPLY_TAG);
+
+  if (ELEMENT_IS ("apply_tag"))
+    {
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values, TRUE, error,
+			      "priority", &priority, NULL))
+	return;
+      
+      if (!check_id_or_name (context, element_name, attribute_names, attribute_values, 
+			     &id, &name, error))
+	return;
+
+      
+      tag = tag_exists (context, name, id, info, error);
+
+      if (!tag)
+	return;
+      
+      info->tag_stack = g_slist_prepend (info->tag_stack, tag);
+      
+      push_state (info, STATE_APPLY_TAG);
+    }
+  else if (ELEMENT_IS ("pixbuf")) 
+    {
+      int int_id;
+      GdkPixbuf *pixbuf;
+      TextSpan *span;
+      const gchar *pixbuf_id;
+
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values, FALSE, error,
+			      "index", &pixbuf_id, NULL))
+	return;
+      
+      int_id = atoi (pixbuf_id);
+      pixbuf = get_pixbuf_from_headers (info->headers, int_id, error);
+      
+      span = g_new0 (TextSpan, 1);
+      span->pixbuf = pixbuf;
+      span->tags = NULL;
+
+      info->spans = g_list_prepend (info->spans, span);
+
+      if (!pixbuf)
+	return;
+
+      push_state (info, STATE_PIXBUF);
+    }
+  else
+    set_error (error, context,
+	       G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+	       _("Element <%s> is not allowed below <%s>"),
+	       element_name, peek_state(info) == STATE_TEXT ? "text" : "apply_tag");
+}
+
+static void
+parse_attr_element (GMarkupParseContext  *context,
+		    const gchar          *element_name,
+		    const gchar         **attribute_names,
+		    const gchar         **attribute_values,
+		    ParseInfo            *info,
+		    GError              **error)
+{
+  const gchar *name, *type, *value;
+  GType gtype;
+  GValue gvalue = { 0 };
+  GParamSpec *pspec;
+  
+  g_assert (peek_state (info) == STATE_TAG);
+
+  if (ELEMENT_IS ("attr"))
+    {
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values, FALSE, error,
+			      "name", &name, "type", &type, "value", &value, NULL))
+	return;
+
+      gtype = g_type_from_name (type);
+
+      if (gtype == G_TYPE_INVALID)
+	{
+	  set_error (error, context,
+		     G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+		     _("\"%s\" is not a valid attribute type"), type);
+	  return;
+	}
+      
+      if (!(pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (info->current_tag), name)))
+	{
+	  set_error (error, context,
+		     G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+		     _("\"%s\" is not a valid attribute name"), name);
+	  return;
+	}
+      
+      g_value_init (&gvalue, gtype);
+
+      if (!deserialize_value (value, &gvalue))
+	{
+	  set_error (error, context,
+		     G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+		     _("\"%s\" could not be converted to a value of type \"%s\" for attribute \"%s\""),
+		     value, type, name);
+	  return;
+	}
+
+      if (g_param_value_validate (pspec, &gvalue))
+	{
+	  set_error (error, context,
+		     G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+		     _("\"%s\" is not a valid value of for attribute \"%s\""),
+		     value, name);
+	  g_value_unset (&gvalue);
+	  return;
+	}
+      
+      g_object_set_property (G_OBJECT (info->current_tag),
+			     name, &gvalue);
+
+      g_value_unset (&gvalue);
+
+      push_state (info, STATE_ATTR);
+    }
+  else
+    {
+      set_error (error, context,
+                 G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Element <%s> is not allowed below <%s>"),
+                 element_name, "tag");
+    }
+}
+
+
+static gchar *
+get_tag_name (ParseInfo   *info,
+	      const gchar *tag_name)
+{
+  gchar *name;
+  gint i;
+
+  name = g_strdup (tag_name);
+
+  if (!info->create_tags)
+    return name;
+  
+  i = 0;
+  
+  while (gtk_text_tag_table_lookup (info->buffer->tag_table, name) != NULL)
+    {
+      g_free (name);
+      name = g_strdup_printf ("%s-%d", tag_name, ++i);
+    }
+
+  if (i != 0)
+    {
+      g_hash_table_insert (info->substitutions, g_strdup (tag_name), g_strdup (name));
+    }
+
+  return name;
+}
+
+static void
+parse_tag_element (GMarkupParseContext  *context,
+		   const gchar          *element_name,
+		   const gchar         **attribute_names,
+		   const gchar         **attribute_values,
+		   ParseInfo            *info,
+		   GError              **error)
+{
+  const gchar *name, *priority;
+  gchar *tag_name;
+  gint id;
+  gint prio;
+  gchar *tmp;
+  
+  g_assert (peek_state (info) == STATE_TAGS);
+
+  if (ELEMENT_IS ("tag"))
+    {
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values, TRUE, error,
+			      "priority", &priority, NULL))
+	return;
+      
+      if (!check_id_or_name (context, element_name, attribute_names, attribute_values, 
+			     &id, &name, error))
+	return;
+
+      if (name) 
+	{
+	  if (g_hash_table_lookup (info->defined_tags, name) != NULL)
+	    {
+	      set_error (error, context,
+			 G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+			 _("Tag \"%s\" already defined"), name);
+	      return;
+	    }
+	}
+
+      prio = strtol (priority, &tmp, 10);
+
+      if (tmp == NULL || tmp == priority)
+	{
+	  set_error (error, context,
+		     G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+		     _("Tag \"%s\" has invalid priority \"%s\""), name, priority);
+	  return;
+	}
+
+      if (name) 
+	{
+	  tag_name = get_tag_name (info, name);
+	  info->current_tag = gtk_text_tag_new (tag_name);
+	  g_free (tag_name);
+	}
+      else
+	{
+	  info->current_tag = gtk_text_tag_new (NULL);
+	  info->current_tag_id = id;
+	}
+
+      info->current_tag_prio = prio;
+
+      push_state (info, STATE_TAG);
+    }
+  else
+    {
+      set_error (error, context,
+                 G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Element <%s> is not allowed below <%s>"),
+                 element_name, "tags");
+    }
+}
+
+static void
+start_element_handler (GMarkupParseContext  *context,
+		       const gchar          *element_name,
+		       const gchar         **attribute_names,
+		       const gchar         **attribute_values,
+		       gpointer              user_data,
+		       GError              **error)
+{
+  ParseInfo *info = user_data;
+  
+  switch (peek_state (info))
+    {
+    case STATE_START:
+      if (ELEMENT_IS ("text_view_markup"))
+	{
+	  if (!check_no_attributes (context, element_name,
+				    attribute_names, attribute_values, error))
+	    return;
+	  
+	  push_state (info, STATE_TEXT_VIEW_MARKUP);
+	  break;
+	}
+      else
+        set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                   _("Outermost element in text must be <text_view_markup> not <%s>"),
+                   element_name);
+      break;
+    case STATE_TEXT_VIEW_MARKUP:
+      if (ELEMENT_IS ("tags"))
+	{
+	  if (info->parsed_tags)
+	    {
+	      set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+			 _("A <tags> element has already been specified"));
+	      return;
+	    }
+
+	  if (!check_no_attributes (context, element_name,
+				    attribute_names, attribute_values, error))
+	    return;
+	  
+	  push_state (info, STATE_TAGS);
+	  break;
+	}
+      else if (ELEMENT_IS ("text"))
+	{
+	  if (info->parsed_text)
+	    {
+	      set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+			 _("A <text> element has already been specified"));
+	      return;
+	    }
+	  else if (!info->parsed_tags)
+	    {
+	      set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+			 _("A <text> element can't occur before a <tags> element"));
+	      return;
+	    }
+
+	  if (!check_no_attributes (context, element_name,
+				    attribute_names, attribute_values, error))
+	    return;
+	  
+	  push_state (info, STATE_TEXT);
+	  break;
+	}
+      else
+	set_error (error, context,
+		   G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Element <%s> is not allowed below <%s>"),
+		   element_name, "text_view_markup");
+      break;
+    case STATE_TAGS:
+      parse_tag_element (context, element_name,
+			 attribute_names, attribute_values,
+			 info, error);
+      break;
+    case STATE_TAG:
+      parse_attr_element (context, element_name,
+			  attribute_names, attribute_values,
+			  info, error);
+      break;
+    case STATE_TEXT:
+    case STATE_APPLY_TAG:
+      parse_apply_tag_element (context, element_name,
+			       attribute_names, attribute_values,
+			       info, error);
+      break;
+    default:
+      g_assert_not_reached ();
+      break;
+    }
+}
+
+static gint
+sort_tag_prio (TextTagPrio *a,
+	       TextTagPrio *b)
+{
+  if (a->prio < b->prio)
+    return -1;
+  else if (a->prio > b->prio)
+    return 1;
+  else
+    return 0;
+}
+
+static void
+end_element_handler (GMarkupParseContext  *context,
+		     const gchar          *element_name,
+		     gpointer              user_data,
+		     GError              **error)
+{
+  ParseInfo *info = user_data;
+  gchar *tmp;
+  GList *list;
+
+  switch (peek_state (info))
+    {
+    case STATE_TAGS:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_TEXT_VIEW_MARKUP);
+
+      info->parsed_tags = TRUE;
+
+      /* Sort list and add the tags */
+      info->tag_priorities = g_list_sort (info->tag_priorities,
+					  (GCompareFunc)sort_tag_prio);
+      list = info->tag_priorities;
+      while (list)
+	{
+	  TextTagPrio *prio = list->data;
+
+	  if (info->create_tags)
+	    gtk_text_tag_table_add (info->buffer->tag_table, prio->tag);
+
+	  g_object_unref (prio->tag);
+	  prio->tag = NULL;
+	    
+	  list = list->next;
+	}
+      
+      break;
+    case STATE_TAG:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_TAGS);
+
+      if (info->current_tag->name)
+	{
+	  /* Add tag to defined tags hash */
+	  tmp = g_strdup (info->current_tag->name);
+	  g_hash_table_insert (info->defined_tags,
+			       tmp, tmp);
+	}
+      else
+	{
+	  g_hash_table_insert (info->anonymous_tags,
+			       GINT_TO_POINTER (info->current_tag_id),
+			       info->current_tag);
+	}
+
+      if (info->create_tags)
+	{
+	  TextTagPrio *prio;
+	  
+	  /* add the tag to the list */
+	  prio = g_new0 (TextTagPrio, 1);
+	  prio->prio = info->current_tag_prio;
+	  prio->tag = info->current_tag;
+	  
+ 	  info->tag_priorities = g_list_prepend (info->tag_priorities, prio);
+	}
+      
+      info->current_tag = NULL;
+      break;
+    case STATE_ATTR:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_TAG);
+      break;
+    case STATE_APPLY_TAG:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_APPLY_TAG ||
+		peek_state (info) == STATE_TEXT);
+
+      /* Pop tag */
+      info->tag_stack = g_slist_delete_link (info->tag_stack,
+					     info->tag_stack);
+      
+      break;
+    case STATE_TEXT:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_TEXT_VIEW_MARKUP);
+
+      info->spans = g_list_reverse (info->spans);
+      info->parsed_text = TRUE;      
+      break;
+    case STATE_TEXT_VIEW_MARKUP:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_START);
+      break;
+    case STATE_PIXBUF:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_APPLY_TAG ||
+		peek_state (info) == STATE_TEXT);
+      break;
+    default:
+      g_assert_not_reached ();
+      break;
+    }
+}
+
+static gboolean
+all_whitespace (const char *text,
+                int         text_len)
+{
+  const char *p;
+  const char *end;
+  
+  p = text;
+  end = text + text_len;
+  
+  while (p != end)
+    {
+      if (!g_ascii_isspace (*p))
+        return FALSE;
+
+      p = g_utf8_next_char (p);
+    }
+
+  return TRUE;
+}
+
+static void
+text_handler (GMarkupParseContext  *context,
+	      const gchar          *text,
+	      gsize                 text_len,
+	      gpointer              user_data,
+	      GError              **error)
+{
+  ParseInfo *info = user_data;
+  TextSpan *span;
+  
+  if (all_whitespace (text, text_len) &&
+      peek_state (info) != STATE_TEXT &&
+      peek_state (info) != STATE_APPLY_TAG)
+    return;
+      
+  switch (peek_state (info))
+    {
+    case STATE_START:
+      g_assert_not_reached (); /* gmarkup shouldn't do this */
+      break;
+    case STATE_TEXT:
+    case STATE_APPLY_TAG:
+      if (text_len == 0)
+	return;
+
+      span = g_new0 (TextSpan, 1);
+      span->text = g_strndup (text, text_len);
+      span->tags = g_slist_copy (info->tag_stack);
+
+      info->spans = g_list_prepend (info->spans, span);
+      break;
+    default:
+      g_assert_not_reached ();
+      break;
+    }
+}
+
+static void
+parse_info_init (ParseInfo     *info,
+		 GtkTextBuffer *buffer,
+		 gboolean       create_tags,
+		 GList         *headers)
+{
+  info->states = g_slist_prepend (NULL, GINT_TO_POINTER (STATE_START));
+
+  info->create_tags = create_tags;
+  info->headers = headers;
+  info->defined_tags = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
+  info->substitutions = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);  
+  info->anonymous_tags = g_hash_table_new_full (NULL, NULL, NULL, NULL);
+  info->tag_stack = NULL;
+  info->spans = NULL;
+  info->parsed_text = FALSE;
+  info->parsed_tags = FALSE;
+  info->current_tag = NULL;
+  info->current_tag_prio = -1;
+  info->tag_priorities = NULL;
+    
+  info->buffer = buffer;
+}
+
+static void
+text_span_free (TextSpan *span)
+{
+  g_free (span->text);
+  g_slist_free (span->tags);
+  g_free (span);
+}
+
+static void
+parse_info_free (ParseInfo *info)
+{
+  GSList *slist;
+  GList *list;
+  
+  slist = info->tag_stack;
+  while (slist)
+    {
+      g_free (slist->data);
+      
+      slist = slist->next;
+    }
+
+  g_slist_free (info->tag_stack);
+  g_slist_free (info->states);
+
+  g_hash_table_destroy (info->substitutions);
+  g_hash_table_destroy (info->defined_tags);
+
+  if (info->current_tag)
+    g_object_unref (info->current_tag);
+  
+  list = info->spans;
+  while (list)
+    {
+      text_span_free (list->data);
+
+      list = list->next;
+    }
+  g_list_free (info->spans);
+  
+  list = info->tag_priorities;
+  while (list)
+    {
+      TextTagPrio *prio = list->data;
+
+      if (prio->tag)
+	g_object_unref (prio->tag);
+      g_free (prio);
+ 
+      list = list->next;
+    }
+  g_list_free (info->tag_priorities);
+
+}
+
+static void
+insert_text (ParseInfo *info,
+	     GtkTextIter *iter)
+{
+  GtkTextIter start_iter;
+  GtkTextMark *mark;
+  GList *tmp;
+  GSList *tags;
+
+  start_iter = *iter;
+
+  mark = gtk_text_buffer_create_mark (info->buffer, "deserialize_insert_point",
+  				      &start_iter, TRUE);
+  
+  tmp = info->spans;
+  while (tmp)
+    {
+      TextSpan *span = tmp->data;
+
+      if (span->text)
+	gtk_text_buffer_insert (info->buffer, iter, span->text, -1);
+      else
+	{
+	  gtk_text_buffer_insert_pixbuf (info->buffer, iter, span->pixbuf);
+	  g_object_unref (span->pixbuf);
+	}
+      gtk_text_buffer_get_iter_at_mark (info->buffer, &start_iter, mark);
+
+      /* Apply tags */
+      tags = span->tags;
+      while (tags)
+	{
+	  GtkTextTag *tag = tags->data;
+
+	  gtk_text_buffer_apply_tag (info->buffer, tag,
+				     &start_iter, iter);
+
+	  tags = tags->next;
+	}
+
+      gtk_text_buffer_move_mark (info->buffer, mark, iter);
+      
+      tmp = tmp->next;
+    }
+
+  gtk_text_buffer_delete_mark (info->buffer, mark);
+}
+
+
+
+static int
+read_int (const guchar *start)
+{
+  int result;
+
+  result = 
+    start[0] << 24 |
+    start[1] << 16 |
+    start[2] << 8 |
+    start[3];
+
+  return result;
+}
+
+static gboolean
+header_is (Header *header, const gchar *id)
+{
+  return (strncmp (header->id, id, 8) == 0);
+}
+
+static GList *
+read_headers (const gchar *start, 
+	      gint         len,
+	      GError     **error)
+{
+  int i = 0;
+  int section_len;
+  Header *header;
+  GList *headers = NULL;
+
+  while (i < len) 
+    {
+      if (i + 12 >= len) 
+	goto error;
+
+      if (strncmp (start + i, "RICHTEXT", 8) == 0 ||
+	  strncmp (start + i, "PIXBDATA", 8) == 0) 
+	{
+
+	  section_len = read_int (start + i + 8);
+	  
+	  if (i + 12 + section_len > len)
+	    goto error;
+
+	  header = g_new0 (Header, 1);
+	  header->id = start + i;
+	  header->length = section_len;
+	  header->start = start + i + 12;
+	  
+	  i += 12 + section_len;
+	  
+	  headers = g_list_prepend (headers, header);
+	}
+      else
+	break;
+
+    }
+
+  return g_list_reverse (headers);
+
+ error:
+  g_list_foreach (headers, (GFunc) g_free, NULL);
+  g_list_free (headers);
+
+  g_set_error (error,
+	       G_MARKUP_ERROR,
+	       G_MARKUP_ERROR_PARSE,
+	       _("Serialized data is malformed"));
+
+  return NULL;
+}
+ 
+static gboolean
+deserialize_text (GtkTextBuffer *buffer,
+		  GtkTextIter   *iter,
+		  const gchar   *text,
+		  gint           len,
+		  gboolean       create_tags,
+		  GError       **error,
+		  GList         *headers)
+{
+  GMarkupParseContext *context;
+  ParseInfo info;
+  gboolean retval = FALSE;
+
+  
+  static GMarkupParser rich_text_parser = {
+    start_element_handler,
+    end_element_handler,
+    text_handler,
+    NULL,
+    NULL
+  };
+ 
+  parse_info_init (&info, buffer, create_tags, headers);
+  
+  context = g_markup_parse_context_new (&rich_text_parser,
+                                        0, &info, NULL);
+
+  if (!g_markup_parse_context_parse (context,
+                                     text,
+                                     len,
+                                     error))
+    goto out;
+
+  if (!g_markup_parse_context_end_parse (context, error))
+    goto out;
+
+  retval = TRUE;
+
+  /* Now insert the text */
+  insert_text (&info, iter);
+
+ out:
+  parse_info_free (&info);
+  
+  g_markup_parse_context_free (context);
+    
+  return retval;
+}
+
+gboolean
+gtk_text_buffer_deserialize_rich_text (GtkTextBuffer *buffer,
+				       GtkTextIter   *iter,
+				       const gchar   *text,
+				       gint           len,
+				       gboolean       create_tags,
+				       GError       **error)
+{
+  GList *headers;
+  Header *header;
+  gboolean retval;
+
+  headers = read_headers (text, len, error);
+
+  if (!headers)
+    return FALSE;
+  
+  header = headers->data;
+  if (!header_is (header, "RICHTEXT"))
+    {
+      g_set_error (error, 
+		   G_MARKUP_ERROR,
+		   G_MARKUP_ERROR_PARSE,
+		   _("Serialized data is malformed. First section isn't RICHTEXT"));
+      
+      retval = FALSE;
+      goto out;
+    }
+  
+  retval = deserialize_text (buffer, iter, 
+			     header->start, header->length, 
+			     create_tags, error, headers->next);
+
+ out:
+  g_list_foreach (headers, (GFunc)g_free, NULL);
+  g_list_free (headers);
+
+  return retval;
+}
--- gtk+/gtk/gtktreemodelsort.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtktreemodelsort.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -703,6 +703,18 @@
 	  tmppath = gtk_tree_model_get_path (GTK_TREE_MODEL (data), &tmpiter);
 	  if (tmppath)
 	    {
+              GtkTreePath *path;
+              GtkTreeIter iter;
+              gboolean result;
+
+              path = gtk_tree_path_copy (tmppath);
+              gtk_tree_path_down (path);
+
+              result = gtk_tree_model_get_iter (GTK_TREE_MODEL (data), &iter, path);
+              g_assert (result);
+              gtk_tree_model_row_inserted (GTK_TREE_MODEL (data), path, &iter);
+              gtk_tree_path_free (path);
+
 	      gtk_tree_model_row_has_child_toggled (GTK_TREE_MODEL (data),
 						    tmppath,
 						    &tmpiter);
@@ -814,7 +826,11 @@
       gtk_tree_model_sort_increment_stamp (tree_model_sort);
       gtk_tree_path_free (path);
       if (level == tree_model_sort->root)
-	tree_model_sort->root = NULL;
+      {
+        /* Root level is not cleaned up in increment stamp */
+        gtk_tree_model_sort_free_level(tree_model_sort, tree_model_sort->root);
+        tree_model_sort->root = NULL;
+      }
       return;
     }
 
@@ -1244,20 +1260,15 @@
       SortLevel *parent_level = level->parent_level;
       SortElt *parent_elt = level->parent_elt;
       /* We were at zero -- time to decrement the zero_ref_count val */
-      do
-	{
-	  if (parent_elt)
-	    parent_elt->zero_ref_count--;
-	  else
-	    tree_model_sort->zero_ref_count--;
 
-	  if (parent_level)
-	    {
+      while (parent_level && parent_elt)
+      {
+  	    parent_elt->zero_ref_count--;
 	      parent_elt = parent_level->parent_elt;
 	      parent_level = parent_level->parent_level;
-	    }
-	}
-      while (parent_level);
+      }
+
+      tree_model_sort->zero_ref_count--;
     }
 }
 
@@ -1275,10 +1286,11 @@
   g_return_if_fail (GTK_TREE_MODEL_SORT (tree_model)->child_model != NULL);
   g_return_if_fail (GTK_TREE_MODEL_SORT (tree_model)->stamp == iter->stamp);
 
-  GET_CHILD_ITER (tree_model, &child_iter, iter);
-
   if (propagate_unref)
+  {
+    GET_CHILD_ITER (tree_model, &child_iter, iter);
     gtk_tree_model_unref_node (GTK_TREE_MODEL_SORT (tree_model)->child_model, &child_iter);
+  }
 
   level = iter->user_data;
   elt = iter->user_data2;
@@ -2296,8 +2308,8 @@
       parent_elt = parent_level->parent_elt;
       parent_level = parent_level->parent_level;
     }
-  if (new_level != tree_model_sort->root)
-    tree_model_sort->zero_ref_count++;
+
+  tree_model_sort->zero_ref_count++;
 
   for (i = 0; i < length; i++)
     {
@@ -2333,32 +2345,26 @@
 
   g_assert (sort_level);
 
+  for (i = 0; i < sort_level->array->len; i++)
+    {
+      if (g_array_index (sort_level->array, SortElt, i).children)
+	gtk_tree_model_sort_free_level (tree_model_sort, 
+					SORT_LEVEL(g_array_index (sort_level->array, SortElt, i).children));
+    }
+
   if (sort_level->ref_count == 0)
     {
       SortLevel *parent_level = sort_level->parent_level;
       SortElt *parent_elt = sort_level->parent_elt;
 
-      do
-	{
-	  if (parent_elt)
-	    parent_elt->zero_ref_count--;
-	  else
-	    tree_model_sort->zero_ref_count--;
-
-	  if (parent_level)
-	    {
+      while (parent_level && parent_elt)
+      {
+  	    parent_elt->zero_ref_count--;
 	      parent_elt = parent_level->parent_elt;
 	      parent_level = parent_level->parent_level;
 	    }
-	}
-      while (parent_level);
-    }
 
-  for (i = 0; i < sort_level->array->len; i++)
-    {
-      if (g_array_index (sort_level->array, SortElt, i).children)
-	gtk_tree_model_sort_free_level (tree_model_sort, 
-					SORT_LEVEL(g_array_index (sort_level->array, SortElt, i).children));
+	    tree_model_sort->zero_ref_count--;
     }
 
   if (sort_level->parent_elt)
--- gtk+/gtk/gtktextbufferserialize.h	(.../2.6.4)	(revision 0)
+++ gtk+/gtk/gtktextbufferserialize.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -0,0 +1,37 @@
+/* gtktextbufferserialize.h
+ *
+ * Copyright (C) 2004 Nokia Corporation.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+#ifndef GTK_TEXT_BUFFER_SERIALIZE_H
+
+#include <gtk/gtktextbuffer.h>
+
+gchar *gtk_text_buffer_serialize_rich_text (GtkTextBuffer     *buffer,
+					    const GtkTextIter *start,
+					    const GtkTextIter *end,
+					    gint              *len);
+
+gboolean gtk_text_buffer_deserialize_rich_text (GtkTextBuffer *buffer,
+						GtkTextIter   *iter,
+						const gchar   *text,
+						gint           len,
+						gboolean       create_tags,
+						GError       **error);
+
+
+#endif /* GTK_TEXT_BUFFER_SERIALIZE_H */
--- gtk+/gtk/gtktypebuiltins.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtktypebuiltins.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -25,6 +25,26 @@
 }
 
 
+/* enumerations from "gtkbutton.h" */
+GType
+osso_gtk_button_attach_flags_get_type (void)
+{
+  static GType etype = 0;
+  if (etype == 0) {
+    static const GFlagsValue values[] = {
+      { OSSO_GTK_BUTTON_ATTACH_NORTH, "OSSO_GTK_BUTTON_ATTACH_NORTH", "north" },
+      { OSSO_GTK_BUTTON_ATTACH_EAST, "OSSO_GTK_BUTTON_ATTACH_EAST", "east" },
+      { OSSO_GTK_BUTTON_ATTACH_SOUTH, "OSSO_GTK_BUTTON_ATTACH_SOUTH", "south" },
+      { OSSO_GTK_BUTTON_ATTACH_WEST, "OSSO_GTK_BUTTON_ATTACH_WEST", "west" },
+      { OSSO_GTK_BUTTON_ATTACH_ENUM_END, "OSSO_GTK_BUTTON_ATTACH_ENUM_END", "enum-end" },
+      { 0, NULL, NULL }
+    };
+    etype = g_flags_register_static ("OssoGtkButtonAttachFlags", values);
+  }
+  return etype;
+}
+
+
 /* enumerations from "gtkcalendar.h" */
 GType
 gtk_calendar_display_options_get_type (void)
@@ -468,13 +488,17 @@
   static GType etype = 0;
   if (etype == 0) {
     static const GEnumValue values[] = {
-      { GTK_ICON_SIZE_INVALID, "GTK_ICON_SIZE_INVALID", "invalid" },
-      { GTK_ICON_SIZE_MENU, "GTK_ICON_SIZE_MENU", "menu" },
-      { GTK_ICON_SIZE_SMALL_TOOLBAR, "GTK_ICON_SIZE_SMALL_TOOLBAR", "small-toolbar" },
-      { GTK_ICON_SIZE_LARGE_TOOLBAR, "GTK_ICON_SIZE_LARGE_TOOLBAR", "large-toolbar" },
-      { GTK_ICON_SIZE_BUTTON, "GTK_ICON_SIZE_BUTTON", "button" },
-      { GTK_ICON_SIZE_DND, "GTK_ICON_SIZE_DND", "dnd" },
-      { GTK_ICON_SIZE_DIALOG, "GTK_ICON_SIZE_DIALOG", "dialog" },
+      { GTK_ICON_SIZE_INVALID, "GTK_ICON_SIZE_INVALID", "gtk-icon-size-invalid" },
+      { GTK_ICON_SIZE_MENU, "GTK_ICON_SIZE_MENU", "gtk-icon-size-menu" },
+      { GTK_ICON_SIZE_SMALL_TOOLBAR, "GTK_ICON_SIZE_SMALL_TOOLBAR", "gtk-icon-size-small-toolbar" },
+      { GTK_ICON_SIZE_LARGE_TOOLBAR, "GTK_ICON_SIZE_LARGE_TOOLBAR", "gtk-icon-size-large-toolbar" },
+      { GTK_ICON_SIZE_BUTTON, "GTK_ICON_SIZE_BUTTON", "gtk-icon-size-button" },
+      { GTK_ICON_SIZE_DND, "GTK_ICON_SIZE_DND", "gtk-icon-size-dnd" },
+      { GTK_ICON_SIZE_DIALOG, "GTK_ICON_SIZE_DIALOG", "gtk-icon-size-dialog" },
+      { HILDON_ICON_SIZE_26, "HILDON_ICON_SIZE_26", "hildon-icon-size-26" },
+      { HILDON_ICON_SIZE_40, "HILDON_ICON_SIZE_40", "hildon-icon-size-40" },
+      { HILDON_ICON_SIZE_50, "HILDON_ICON_SIZE_50", "hildon-icon-size-50" },
+      { HILDON_ICON_SIZE_64, "HILDON_ICON_SIZE_64", "hildon-icon-size-64" },
       { 0, NULL, NULL }
     };
     etype = g_enum_register_static ("GtkIconSize", values);
@@ -1066,6 +1090,21 @@
   return etype;
 }
 
+GType
+gtk_invalid_input_type_get_type (void)
+{
+  static GType etype = 0;
+  if (etype == 0) {
+    static const GEnumValue values[] = {
+      { GTK_INVALID_INPUT_MAX_CHARS_REACHED, "GTK_INVALID_INPUT_MAX_CHARS_REACHED", "max-chars-reached" },
+      { GTK_INVALID_INPUT_MODE_RESTRICTION, "GTK_INVALID_INPUT_MODE_RESTRICTION", "mode-restriction" },
+      { 0, NULL, NULL }
+    };
+    etype = g_enum_register_static ("GtkInvalidInputType", values);
+  }
+  return etype;
+}
+
 
 /* enumerations from "gtkfilechooser.h" */
 GType
@@ -1390,6 +1429,7 @@
       { GTK_RC_TOKEN_STOCK, "GTK_RC_TOKEN_STOCK", "stock" },
       { GTK_RC_TOKEN_LTR, "GTK_RC_TOKEN_LTR", "ltr" },
       { GTK_RC_TOKEN_RTL, "GTK_RC_TOKEN_RTL", "rtl" },
+      { GTK_RC_TOKEN_LOGICAL_COLOR, "GTK_RC_TOKEN_LOGICAL_COLOR", "logical-color" },
       { GTK_RC_TOKEN_LAST, "GTK_RC_TOKEN_LAST", "last" },
       { 0, NULL, NULL }
     };
@@ -1673,6 +1713,23 @@
   return etype;
 }
 
+GType
+gtk_widget_tap_and_hold_flags_get_type (void)
+{
+  static GType etype = 0;
+  if (etype == 0) {
+    static const GFlagsValue values[] = {
+      { GTK_TAP_AND_HOLD_NONE, "GTK_TAP_AND_HOLD_NONE", "none" },
+      { GTK_TAP_AND_HOLD_PASS_PRESS, "GTK_TAP_AND_HOLD_PASS_PRESS", "pass-press" },
+      { GTK_TAP_AND_HOLD_NO_SIGNALS, "GTK_TAP_AND_HOLD_NO_SIGNALS", "no-signals" },
+      { GTK_TAP_AND_HOLD_NO_INTERNALS, "GTK_TAP_AND_HOLD_NO_INTERNALS", "no-internals" },
+      { 0, NULL, NULL }
+    };
+    etype = g_flags_register_static ("GtkWidgetTapAndHoldFlags", values);
+  }
+  return etype;
+}
+
 
 /* Generated data ends here */
 
--- gtk+/gtk/gtktypebuiltins.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtktypebuiltins.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -13,6 +13,11 @@
 GType gtk_accel_flags_get_type (void) G_GNUC_CONST;
 #define GTK_TYPE_ACCEL_FLAGS (gtk_accel_flags_get_type())
 
+/* enumerations from "gtkbutton.h" */
+
+GType osso_gtk_button_attach_flags_get_type (void) G_GNUC_CONST;
+#define GTK_TYPE_GTK_BUTTON_ATTACH_FLAGS (osso_gtk_button_attach_flags_get_type())
+
 /* enumerations from "gtkcalendar.h" */
 
 GType gtk_calendar_display_options_get_type (void) G_GNUC_CONST;
@@ -203,6 +208,9 @@
 GType gtk_im_status_style_get_type (void) G_GNUC_CONST;
 #define GTK_TYPE_IM_STATUS_STYLE (gtk_im_status_style_get_type())
 
+GType gtk_invalid_input_type_get_type (void) G_GNUC_CONST;
+#define GTK_TYPE_INVALID_INPUT_TYPE (gtk_invalid_input_type_get_type())
+
 /* enumerations from "gtkfilechooser.h" */
 
 GType gtk_file_chooser_action_get_type (void) G_GNUC_CONST;
@@ -335,6 +343,9 @@
 GType gtk_widget_help_type_get_type (void) G_GNUC_CONST;
 #define GTK_TYPE_WIDGET_HELP_TYPE (gtk_widget_help_type_get_type())
 
+GType gtk_widget_tap_and_hold_flags_get_type (void) G_GNUC_CONST;
+#define GTK_TYPE_WIDGET_TAP_AND_HOLD_FLAGS (gtk_widget_tap_and_hold_flags_get_type())
+
 G_END_DECLS
 
 #endif /* __GTK_TYPE_BUILTINS_H__ */
--- gtk+/gtk/gtkcomboboxentry.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkcomboboxentry.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -55,6 +55,8 @@
                                                   gpointer               user_data);
 static gboolean gtk_combo_box_entry_mnemonic_activate (GtkWidget        *entry,
 						       gboolean          group_cycling);
+/*static void gtk_grab_combo_box_entry_focus       (GtkComboBoxEntry *entry_box);*/
+
 static void has_frame_changed                    (GtkComboBoxEntry      *entry_box,
 						  GParamSpec            *pspec,
 						  gpointer               data);
@@ -136,6 +138,10 @@
   gtk_widget_show (entry_box->priv->entry);
 
   entry_box->priv->text_renderer = gtk_cell_renderer_text_new ();
+
+  g_object_set (entry_box->priv->text_renderer,
+                "ellipsize", PANGO_ELLIPSIZE_END, NULL);
+
   gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (entry_box),
                               entry_box->priv->text_renderer, TRUE);
 
@@ -382,3 +388,12 @@
 
   return entry_box;
 }
+
+/* Hildon: this is added because we need to grab focus from caption control
+ * to ComboBox entry.
+ */
+void
+gtk_grab_combo_box_entry_focus (GtkComboBoxEntry *entry_box)
+{
+  gtk_widget_grab_focus (entry_box->priv->entry);
+}
--- gtk+/gtk/gtkalias.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkalias.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -5782,6 +5782,14 @@
 extern __typeof (gtk_menu_shell_select_item) gtk_menu_shell_select_item __attribute((alias("IA__gtk_menu_shell_select_item"), visibility("default")));
 #define gtk_menu_shell_select_item IA__gtk_menu_shell_select_item
 
+extern __typeof (gtk_menu_shell_set_take_focus) IA__gtk_menu_shell_set_take_focus __attribute((visibility("hidden")));
+extern __typeof (gtk_menu_shell_set_take_focus) gtk_menu_shell_set_take_focus __attribute((alias("IA__gtk_menu_shell_set_take_focus"), visibility("default")));
+#define gtk_menu_shell_set_take_focus IA__gtk_menu_shell_set_take_focus
+
+extern __typeof (gtk_menu_shell_get_take_focus) IA__gtk_menu_shell_get_take_focus __attribute((visibility("hidden")));
+extern __typeof (gtk_menu_shell_get_take_focus) gtk_menu_shell_get_take_focus __attribute((alias("IA__gtk_menu_shell_get_take_focus"), visibility("default")));
+#define gtk_menu_shell_get_take_focus IA__gtk_menu_shell_get_take_focus
+
 extern __typeof (gtk_menu_tool_button_get_menu) IA__gtk_menu_tool_button_get_menu __attribute((visibility("hidden")));
 extern __typeof (gtk_menu_tool_button_get_menu) gtk_menu_tool_button_get_menu __attribute((alias("IA__gtk_menu_tool_button_get_menu"), visibility("default")));
 #define gtk_menu_tool_button_get_menu IA__gtk_menu_tool_button_get_menu
--- gtk+/gtk/gtkhbbox.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkhbbox.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -24,10 +24,20 @@
  * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
  */
 
+/* Modified by Nokia Corporation - 2005.
+ * 
+ */
+
+/* Hildon : Button spacing according to the spec. */
+#define HILDON_BUTTON_SPACING 5
+/* Selecting hetefogenous mode for a childlayout */
+#define GTK_BUTTONBOX_HETEROGENOUS 6
+
 #include <config.h>
 #include "gtkalias.h"
 #include "gtkhbbox.h"
-
+/* Hildon : We need this to deal with buttons graphics. */
+#include "gtkbutton.h"
 
 static void gtk_hbutton_box_class_init    (GtkHButtonBoxClass   *klass);
 static void gtk_hbutton_box_init          (GtkHButtonBox        *box);
@@ -36,6 +46,15 @@
 static void gtk_hbutton_box_size_allocate (GtkWidget      *widget,
 					   GtkAllocation  *allocation);
 
+static void osso_gtk_hbutton_child_showhide_handler (GtkWidget *widget,
+						     gpointer user_data);
+static void osso_gtk_hbutton_box_remove_child_signal_handlers (GtkHButtonBox *hbbox,
+							       GtkWidget *removed_widget,
+							       gpointer data);
+static void osso_gtk_hbutton_box_find_button_detail (GtkHButtonBox *hbbox,
+					      GtkWidget *addremovewidget,
+					      gpointer data);
+
 static gint default_spacing = 30;
 static gint default_layout_style = GTK_BUTTONBOX_EDGE;
 
@@ -76,12 +95,23 @@
 
   widget_class->size_request = gtk_hbutton_box_size_request;
   widget_class->size_allocate = gtk_hbutton_box_size_allocate;
+
+  /* HILDON:
+   * Name buttons only if hildon like style property is set
+   */
+  gtk_widget_class_install_style_property (widget_class,
+					   g_param_spec_boolean 
+					   ( "hildonlike",
+					     "hildonlike looks",
+					     "Name buttons, 1/0",
+					     FALSE,
+					     G_PARAM_READABLE) );
 }
 
 static void
 gtk_hbutton_box_init (GtkHButtonBox *hbutton_box)
 {
-	/* button_box_init has done everything allready */
+  /* button_box_init has done everything allready */
 }
 
 GtkWidget*
@@ -91,6 +121,24 @@
 
   hbutton_box = g_object_new (GTK_TYPE_HBUTTON_BOX, NULL);
 
+  /* Attach signal handler for 'hildonizing' buttons.
+   * gtk_hbutton_box_hildonize_buttons will check the name
+   * and if it is something we're interested in i.e.
+   *
+   *   hildon_dialogbuttons
+   *   hildon_viewbuttons
+   *
+   * it will do the hildonizing
+   */
+  g_signal_connect_after (G_OBJECT (hbutton_box), "remove",
+		    G_CALLBACK (osso_gtk_hbutton_box_remove_child_signal_handlers),
+		    NULL);
+  g_signal_connect_after( G_OBJECT( hbutton_box ), "add",
+		  G_CALLBACK( osso_gtk_hbutton_box_find_button_detail ),
+		  NULL );
+  g_signal_connect_after( G_OBJECT( hbutton_box ), "remove",
+		  G_CALLBACK( osso_gtk_hbutton_box_find_button_detail ),
+		  NULL );
   return GTK_WIDGET (hbutton_box);
 }
 
@@ -145,6 +193,11 @@
   gint child_height;
   gint spacing;
   GtkButtonBoxStyle layout;
+  gint child_xpad=0;
+  GtkBoxChild *child_req;
+  GList *children_req;
+  GtkRequisition treq;
+
   
   box = GTK_BOX (widget);
   bbox = GTK_BUTTON_BOX (widget);
@@ -159,6 +212,12 @@
                                      &child_width,
                                      &child_height);
 
+  /* should GTK_BUTTONBOX_HETEROGENOUS add into the GtkButtonBoxStyle 
+     enum struct 
+  */ 
+   if( !box->homogeneous )
+     layout = GTK_BUTTONBOX_HETEROGENOUS; 
+
   if (nvis_children == 0)
   {
     requisition->width = 0; 
@@ -177,11 +236,36 @@
     case GTK_BUTTONBOX_END:
       requisition->width = nvis_children*child_width + ((nvis_children-1)*spacing);
       break;
+    case GTK_BUTTONBOX_HETEROGENOUS:
+      children_req = GTK_BOX (box)->children;
+      child_req = children_req->data;
+      requisition->width = 0; 
+
+      while (children_req)
+	{ 
+	  child_req = children_req->data;
+	  children_req = children_req->next;
+
+	  if (GTK_WIDGET_VISIBLE (child_req->widget))
+	    {
+	      gtk_widget_get_child_requisition( child_req->widget, 
+						&(treq) );   	      
+	      requisition->width += treq.width;
+	 
+              gtk_widget_style_get(widget, 
+				   "child-internal-pad-x", 
+				   &(child_xpad), NULL);
+	      requisition->width  += (child_xpad*2);	      
+	    }
+      	}
+      requisition->width += ((nvis_children-1)*spacing);
+
+      break; 
     default:
       g_assert_not_reached();
       break;
     }
-	  
+    
     requisition->height = child_height;
   }
 	  
@@ -227,6 +311,10 @@
                                      &child_height);
   widget->allocation = *allocation;
   width = allocation->width - GTK_CONTAINER (box)->border_width*2;
+
+  if( !base_box->homogeneous )
+     layout = GTK_BUTTONBOX_HETEROGENOUS;
+
   switch (layout)
   {
   case GTK_BUTTONBOX_SPREAD:
@@ -264,6 +352,36 @@
       - GTK_CONTAINER (box)->border_width;
     secondary_x = allocation->x + GTK_CONTAINER (box)->border_width;
     break;
+  case GTK_BUTTONBOX_HETEROGENOUS:
+    {
+      gint sumwidth = 0;
+      GtkBoxChild *child_h;
+      GList *children_h = GTK_BOX (box)->children;
+        /* heterogenous sized childs onto center */
+      childspacing = spacing;
+
+      while (children_h )
+	{
+	  child_h = children_h->data;
+	  children_h = children_h->next;
+
+	  if (GTK_WIDGET_VISIBLE (child_h->widget))
+	    {
+	      gint child_xpad = 0;
+	      GtkRequisition treq;
+	      gtk_widget_get_child_requisition( child_h->widget, &(treq) );  
+	      sumwidth += treq.width;
+
+	      gtk_widget_style_get(widget, 
+				   "child-internal-pad-x", 
+				   &(child_xpad), NULL); 
+	      sumwidth += (child_xpad*2);
+	    }
+	}
+      x = secondary_x = allocation->x + 
+       ( (allocation->width - sumwidth - (spacing * (nvis_children - 1)))/2 );
+      break; 
+    }
   default:
     g_assert_not_reached();
     break;
@@ -282,10 +400,33 @@
 
       if (GTK_WIDGET_VISIBLE (child->widget))
 	{
-	  child_allocation.width = child_width;
 	  child_allocation.height = child_height;
 	  child_allocation.y = y;
 	  
+	  if(layout != GTK_BUTTONBOX_HETEROGENOUS)
+	    {
+	      child_allocation.width = child_width; 
+	    }
+	  else /* if layout will be hetergenous */
+	    {
+	      gint child_hwidth = 0;
+	      GtkRequisition treq;
+	      gint child_xpad = 0;
+
+	      gtk_widget_get_child_requisition( child->widget, &(treq) );
+	      child_hwidth += treq.width;      
+
+	      gtk_widget_style_get(widget, 
+				   "child-internal-pad-x", 
+				   &child_xpad, NULL);
+	      child_hwidth += (child_xpad*2);
+	         
+	      child_allocation.width =  child_hwidth;
+	      childspace = child_hwidth + childspacing;
+
+	    }
+	  
+	  /* calculate the horizontal location */
 	  if (child->is_secondary)
 	    {
 	      child_allocation.x = secondary_x;
@@ -304,4 +445,104 @@
 	}
     }
 }
+
+/* Function to wrap "hide" and "show" signals to call
+ * osso_gtk_hbutton_box_find_button_detail -function.*/
+static void osso_gtk_hbutton_child_showhide_handler (GtkWidget *widget,
+						     gpointer user_data)
+{
+  osso_gtk_hbutton_box_find_button_detail (widget, GTK_WIDGET (user_data), NULL);
+}
   
+/* Function to remove "show"&"hide" signal handlers
+ * from a child when it's removed. */
+static void osso_gtk_hbutton_box_remove_child_signal_handlers (GtkHButtonBox *hbbox,
+							       GtkWidget *removed_widget,
+							       gpointer data)
+{
+  g_signal_handlers_disconnect_by_func (G_OBJECT (removed_widget), osso_gtk_hbutton_box_find_button_detail, hbbox);
+}
+
+/* Signal handler called when we have to set
+ * painting detail values for buttons in this 
+ * gtk_horizontal_button_box.
+ */  
+static void osso_gtk_hbutton_box_find_button_detail (GtkHButtonBox *hbbox,
+					      GtkWidget *addremovewidget,
+					      gpointer data)
+{
+  GList *child;
+  gint visible_buttons = 0;
+  gint secondary_buttons = 0;
+  GtkWidget *leftmost_button = NULL;
+  GtkWidget *rightmost_button = NULL;
+
+  for( child = GTK_BOX (hbbox)->children ; child ; child = child->next ) 
+    {
+      GtkBoxChild *box_child = child->data;
+      GtkWidget *child_widget = box_child->widget;
+      gulong signal_handler = g_signal_handler_find ( G_OBJECT( child_widget ),
+						      G_SIGNAL_MATCH_FUNC,
+						      0, 0, NULL,
+						      G_CALLBACK (osso_gtk_hbutton_child_showhide_handler),
+						      NULL);
+
+      if (signal_handler == 0)
+	{
+	  g_signal_connect_object ( G_OBJECT( child_widget ), 
+				    "hide", 
+				    G_CALLBACK ( osso_gtk_hbutton_child_showhide_handler ), 
+				    hbbox, G_CONNECT_SWAPPED);
+	  g_signal_connect_object ( G_OBJECT( child_widget ), 
+				    "show", 
+				    G_CALLBACK ( osso_gtk_hbutton_child_showhide_handler ), 
+				    hbbox, G_CONNECT_SWAPPED);
+	}
+
+      if ((GTK_WIDGET_VISIBLE (child_widget)) &&
+         (GTK_IS_BUTTON (child_widget)))
+	visible_buttons++;
+      else
+	continue;
+
+      if (leftmost_button == NULL)
+	leftmost_button = child_widget;
+
+      if (secondary_buttons == 0)
+	rightmost_button = child_widget;
+      else 
+	if (box_child->is_secondary)
+	  {
+	    rightmost_button = child_widget;
+	    secondary_buttons++;
+	  }
+
+      if (box_child->is_secondary) 
+        rightmost_button = child_widget;
+    }
+
+  if (visible_buttons == 0)
+    return;
+
+  for( child = GTK_BOX (hbbox)->children ; child ; child = child->next ) 
+    {
+      GtkBoxChild *box_child = child->data;
+      GtkWidget *child_widget = box_child->widget;
+      OssoGtkButtonAttachFlags attachflags = OSSO_GTK_BUTTON_ATTACH_NORTH | OSSO_GTK_BUTTON_ATTACH_SOUTH;
+      gboolean automatic_detail;
+
+      if (!((GTK_WIDGET_VISIBLE (child_widget)) &&
+	  (GTK_IS_BUTTON (child_widget))))
+	continue;
+
+      if (child_widget == leftmost_button)
+	attachflags |= OSSO_GTK_BUTTON_ATTACH_WEST;
+
+      if (child_widget == rightmost_button)
+	attachflags |= OSSO_GTK_BUTTON_ATTACH_EAST;
+
+      g_object_get (G_OBJECT (child_widget), "automatic_detail", &automatic_detail, NULL);
+      if (automatic_detail == TRUE)
+        g_object_set (G_OBJECT (child_widget), "detail", osso_gtk_button_attach_details[attachflags], NULL);
+    }
+}
--- gtk+/gtk/gtkdnd.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkdnd.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -1536,7 +1536,7 @@
       gtk_drag_source_info_destroy (dest_info->proxy_source);
       dest_info->proxy_source = NULL;
     }
-  
+
   ipc_widget = gtk_drag_get_ipc_widget (gtk_widget_get_screen (widget));
   context = gdk_drag_begin (ipc_widget->window,
 			    dest_info->context->targets);
@@ -1929,7 +1929,7 @@
   GdkDragContext *context;
   GtkWidget *ipc_widget;
   GdkCursor *cursor;
- 
+
   ipc_widget = gtk_drag_get_ipc_widget (gtk_widget_get_screen (widget));
   
   gtk_drag_get_event_actions (event, button, actions,
@@ -2145,6 +2145,9 @@
       g_signal_connect (widget, "button_press_event",
 			G_CALLBACK (gtk_drag_source_event_cb),
 			site);
+      g_signal_connect (widget, "button_release_event",
+                        G_CALLBACK (gtk_drag_source_event_cb),
+                        site);
       g_signal_connect (widget, "motion_notify_event",
 			G_CALLBACK (gtk_drag_source_event_cb),
 			site);
@@ -3699,3 +3702,14 @@
   return (ABS (current_x - start_x) > drag_threshold ||
 	  ABS (current_y - start_y) > drag_threshold);
 }
+
+void
+_gtk_drag_source_ignore_drag (GtkWidget *widget)
+{
+  GtkDragSourceSite *site;
+
+  site = g_object_get_data (G_OBJECT (widget), "gtk-site-data");
+
+  if (site != NULL)
+    site->state &= ~GDK_BUTTON1_MASK;
+}
--- gtk+/gtk/gtkdnd.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkdnd.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -159,6 +159,7 @@
 				    GdkEvent  *event);
 void _gtk_drag_dest_handle_event (GtkWidget *toplevel,
 				  GdkEvent  *event);
+void _gtk_drag_source_ignore_drag (GtkWidget *widget);
 
 #ifndef GTK_DISABLE_DEPRECATED
 void gtk_drag_set_default_icon (GdkColormap   *colormap,
--- gtk+/gtk/gtkmenuitem.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkmenuitem.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -22,6 +22,8 @@
  * file for a list of people on the GTK+ Team.  See the ChangeLog
  * files for a list of changes.  These files are distributed with
  * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
+ *
+ * Modified by Nokia Corporation - 2005.
  */
 
 #define GTK_MENU_INTERNALS
@@ -38,6 +40,9 @@
 #include "gtkmenuitem.h"
 #include "gtkseparatormenuitem.h"
 
+#define HILDON_HEIGHT_INCREMENT  1
+#define HILDON_ARROW_SPACE       6
+
 #define MENU_ITEM_CLASS(w)  GTK_MENU_ITEM_CLASS (GTK_OBJECT (w)->klass)
 
 enum {
@@ -95,6 +100,8 @@
 						  guint      signal_id);
 
 
+static void _gtk_menu_item_activate_submenus (GtkMenuItem *item);
+
 static GtkItemClass *parent_class;
 static guint menu_item_signals[LAST_SIGNAL] = { 0 };
 
@@ -158,7 +165,9 @@
   item_class->select = gtk_real_menu_item_select;
   item_class->deselect = gtk_real_menu_item_deselect;
 
-  klass->activate = NULL;
+  /* Hildon addition : Added this to catch the 
+   * activation of meuuitems with submenus. */
+  klass->activate = _gtk_menu_item_activate_submenus;
   klass->activate_item = gtk_real_menu_item_activate_item;
   klass->toggle_size_request = gtk_real_menu_item_toggle_size_request;
   klass->toggle_size_allocate = gtk_real_menu_item_toggle_size_allocate;
@@ -239,6 +248,16 @@
 							     G_MAXINT,
 							     10,
 							     G_PARAM_READABLE));
+
+   /* Hildon modification - allow themeing of separator height */
+   gtk_widget_class_install_style_property (widget_class,
+                                          g_param_spec_int ("separator_height",
+                                                            "Separator height",
+                                                            "Draw a separator graphics with height of x pixels.",
+                                                            0,
+							    G_MAXINT,
+							    5,
+                                                            G_PARAM_READABLE));
 }
 
 static void
@@ -415,6 +434,13 @@
   g_return_if_fail (GTK_IS_MENU_ITEM (menu_item));
   
   gtk_item_select (GTK_ITEM (menu_item));
+  /* HILDON MOD. This is required as changed focus isn't drawn automatically
+   * and drawing it must be requested. */
+  if ((GTK_WIDGET(menu_item)->parent) && GTK_IS_MENU (GTK_WIDGET(menu_item)->parent))
+    {
+      GtkMenu *menu = GTK_MENU (GTK_WIDGET(menu_item)->parent);
+      if (menu->parent_menu_item) gtk_widget_queue_draw(GTK_WIDGET(menu->parent_menu_item));
+    }
 }
 
 void
@@ -423,6 +449,13 @@
   g_return_if_fail (GTK_IS_MENU_ITEM (menu_item));
   
   gtk_item_deselect (GTK_ITEM (menu_item));
+  /* HILDON MOD. This is required as changed focus isn't drawn automatically
+   * and drawing it must be requested. */
+  if ((GTK_WIDGET(menu_item)->parent) && GTK_IS_MENU (GTK_WIDGET(menu_item)->parent))
+    {
+      GtkMenu *menu = GTK_MENU (GTK_WIDGET(menu_item)->parent);
+      if (menu->parent_menu_item) gtk_widget_queue_draw(GTK_WIDGET(menu->parent_menu_item));
+    }
 }
 
 void
@@ -531,7 +564,7 @@
 				"arrow_spacing", &arrow_spacing,
 				NULL);
 
-	  requisition->width += child_requisition.height;
+	  requisition->width += child_requisition.height + HILDON_ARROW_SPACE;
 	  requisition->width += arrow_spacing;
 
 	  requisition->width = MAX (requisition->width, get_minimum_width (widget));
@@ -543,6 +576,12 @@
       requisition->height += 4;
     }
 
+   /* We get correct focus size if we make the widget a bit bigger.
+    * (If the increment would be big, we should probably adjust the text
+    * position aswell.)
+    */
+   requisition->height += HILDON_HEIGHT_INCREMENT;
+
   accel_width = 0;
   gtk_container_foreach (GTK_CONTAINER (menu_item),
 			 gtk_menu_item_accel_width_foreach,
@@ -596,7 +635,8 @@
 	{
 	  if (direction == GTK_TEXT_DIR_RTL)
 	    child_allocation.x += child_requisition.height;
-	  child_allocation.width -= child_requisition.height;
+          /* HILDON Modification. */
+	  child_allocation.width -= child_requisition.height + HILDON_ARROW_SPACE;
 	}
       
       if (child_allocation.width < 1)
@@ -688,6 +728,7 @@
   GtkShadowType shadow_type, selected_shadow_type;
   gint width, height;
   gint x, y;
+
   gint border_width = GTK_CONTAINER (widget)->border_width;
 
   if (GTK_WIDGET_DRAWABLE (widget))
@@ -704,10 +745,56 @@
       if ((state_type == GTK_STATE_PRELIGHT) &&
 	  (GTK_BIN (menu_item)->child))
 	{
+	  gint focus_x = x;
+	  gint focus_width = width;
 	  gtk_widget_style_get (widget,
 				"selected_shadow_type", &selected_shadow_type,
 				NULL);
-	  gtk_paint_box (widget->style,
+
+          if (menu_item->submenu && menu_item->show_submenu_indicator)
+	    {
+	      GtkRequisition child_requisition;
+	      gint arrow_size;
+	      /* gint arrow_extent; */
+	      gtk_widget_get_child_requisition (GTK_BIN (menu_item)->child,
+						&child_requisition);
+      
+	      arrow_size = child_requisition.height - 2 * widget->style->ythickness;
+	      if (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_LTR) {
+	        focus_width = x + width - arrow_size - 2 - HILDON_ARROW_SPACE;
+	      }
+	      else {
+	        focus_x = x + arrow_size + 2 + HILDON_ARROW_SPACE;
+	      }
+	    }
+	  
+          /*
+	   * Hildon modification:
+	   * This draws different focus depending on if it's the toplevel
+	   * focused menu item. All items that have submenus that in turn
+	   * have an item selected will be drawn with SELECTED - state focus.
+	   * If this isn't the case, PRELIGHT - state focus is used. */
+	  if (menu_item->submenu)
+	    {
+	      GtkMenuItem *msi;
+	      msi = GTK_MENU_ITEM(GTK_MENU_SHELL(&((GTK_MENU(menu_item->submenu))->menu_shell))->active_menu_item);
+	      if ((msi == NULL) || (GTK_WIDGET (msi)->state == 0))
+                gtk_paint_box (widget->style,
+			 widget->window,
+			 GTK_STATE_PRELIGHT,
+			 selected_shadow_type,
+			 area, widget, "menuitem",
+			 focus_x, y, focus_width, height);
+	      else
+                gtk_paint_box (widget->style,
+			 widget->window,
+			 GTK_STATE_SELECTED,
+			 selected_shadow_type,
+			 area, widget, "menuitem",
+			 focus_x, y, focus_width, height);
+	    }
+	  else
+            gtk_paint_box (widget->style,
 			 widget->window,
 			 GTK_STATE_PRELIGHT,
 			 selected_shadow_type,
@@ -747,8 +834,12 @@
 	  arrow_extent = arrow_size * 0.8;
 	  
 	  shadow_type = GTK_SHADOW_OUT;
-	  if (state_type == GTK_STATE_PRELIGHT)
-	    shadow_type = GTK_SHADOW_IN;
+	  /*Hildon: only show the pressed arrow if the submenu is visible*/
+	  if (state_type == GTK_STATE_PRELIGHT	
+	    && GTK_WIDGET_VISIBLE( menu_item->submenu))
+	    {
+	      shadow_type = GTK_SHADOW_IN;
+	    }
 
 	  if (direction == GTK_TEXT_DIR_LTR)
 	    {
@@ -763,6 +854,9 @@
 
 	  arrow_y = y + (height - arrow_extent) / 2;
 
+/* HILDON modification to correct focus drawing with submenu arrow */
+          arrow_x = arrow_x - 4;
+	  
 	  gtk_paint_arrow (widget->style, widget->window,
 			   state_type, shadow_type, 
 			   area, widget, "menuitem", 
@@ -772,18 +866,20 @@
 	}
       else if (!GTK_BIN (menu_item)->child)
 	{
-	  guint horizontal_padding;
+	  guint horizontal_padding, separator_height;
 
 	  gtk_widget_style_get (widget,
 				"horizontal_padding", &horizontal_padding,
+				"separator_height", &separator_height,
 				NULL);
 	  
-	  gtk_paint_hline (widget->style, widget->window, GTK_STATE_NORMAL,
-			   area, widget, "menuitem",
-			   widget->allocation.x + horizontal_padding + widget->style->xthickness,
-			   widget->allocation.x + widget->allocation.width - horizontal_padding - widget->style->xthickness - 1,
-			   widget->allocation.y + (widget->allocation.height -
-						   widget->style->ythickness) / 2);
+	  /* themable menuitem for menu separators */
+	  gtk_paint_box (widget->style, widget->window, GTK_STATE_NORMAL, GTK_SHADOW_NONE,
+	                 area, widget, "separator",
+			 widget->allocation.x + horizontal_padding + widget->style->xthickness,
+		         widget->allocation.y + (widget->allocation.height - widget->style->ythickness) / 2,
+			 widget->allocation.x + widget->allocation.width - horizontal_padding - widget->style->xthickness - 1,
+			 separator_height);
 	}
     }
 }
@@ -851,26 +947,29 @@
 	popup_delay = get_popup_delay (menu_item);
       
       if (popup_delay > 0)
-	{
-	  GdkEvent *event = gtk_get_current_event ();
-	  
-	  menu_item->timer = g_timeout_add (popup_delay,
-					    gtk_menu_item_select_timeout,
-					    menu_item);
-	  if (event &&
-	      event->type != GDK_BUTTON_PRESS &&
-	      event->type != GDK_ENTER_NOTIFY)
-	    menu_item->timer_from_keypress = TRUE;
-	  else
-	    menu_item->timer_from_keypress = FALSE;
+        {
+          GdkEvent *event = gtk_get_current_event ();
 
-	  if (event)
-	    gdk_event_free (event);
-	}
+          /*
+           * Hildon: Disabling the automatic opening of submenus by
+           * removing the corresponding code. 
+           */
+          
+          if (event &&
+              event->type != GDK_BUTTON_PRESS &&
+              event->type != GDK_ENTER_NOTIFY &&
+              event->type != GDK_MOTION_NOTIFY) /*hildon: for some reason, the event is sometimes this and not enter!*/
+            menu_item->timer_from_keypress = TRUE;
+          else
+            menu_item->timer_from_keypress = FALSE;
+          
+          if (event)
+            gdk_event_free (event);
+        }
       else
-	_gtk_menu_item_popup_submenu (GTK_WIDGET (menu_item));
+        _gtk_menu_item_popup_submenu (menu_item);
     }
-  
+
   gtk_widget_set_state (GTK_WIDGET (menu_item), GTK_STATE_PRELIGHT);
   gtk_widget_queue_draw (GTK_WIDGET (menu_item));
 }
@@ -878,25 +977,16 @@
 static void
 gtk_real_menu_item_deselect (GtkItem *item)
 {
-  GtkMenuItem *menu_item;
+  GtkWidget *menu_item;
 
   g_return_if_fail (GTK_IS_MENU_ITEM (item));
 
-  menu_item = GTK_MENU_ITEM (item);
+  menu_item = GTK_WIDGET (item);
 
-  if (menu_item->submenu)
-    {
-      if (menu_item->timer)
-	{
-	  g_source_remove (menu_item->timer);
-	  menu_item->timer = 0;
-	}
-      else
-	gtk_menu_popdown (GTK_MENU (menu_item->submenu));
-    }
+  _gtk_menu_item_popdown_submenu (menu_item);
 
-  gtk_widget_set_state (GTK_WIDGET (menu_item), GTK_STATE_NORMAL);
-  gtk_widget_queue_draw (GTK_WIDGET (menu_item));
+  gtk_widget_set_state (menu_item, GTK_STATE_NORMAL);
+  gtk_widget_queue_draw (menu_item);
 }
 
 static gboolean
@@ -941,10 +1031,7 @@
 	  _gtk_menu_shell_activate (menu_shell);
 
 	  gtk_menu_shell_select_item (GTK_MENU_SHELL (widget->parent), widget); 
-	  _gtk_menu_item_popup_submenu (widget); 
-
-	  gtk_menu_shell_select_first (GTK_MENU_SHELL (menu_item->submenu), TRUE);
-	  submenu = GTK_MENU_SHELL (menu_item->submenu);
+          /* Hildon mod: automatic submenu opening has been removed */
 	}
     }
 }
@@ -983,7 +1070,7 @@
     {
       _gtk_menu_item_popup_submenu (GTK_WIDGET (menu_item));
       if (menu_item->timer_from_keypress && menu_item->submenu)
-	GTK_MENU_SHELL (menu_item->submenu)->ignore_enter = TRUE;
+        GTK_MENU_SHELL (menu_item->submenu)->ignore_enter = TRUE;
     }
 
   GDK_THREADS_LEAVE ();
@@ -1002,7 +1089,16 @@
     g_source_remove (menu_item->timer);
   menu_item->timer = 0;
 
+  /* HILDON MOD. This is required as changed submenu arrow isn't drawn automatically
+   * and drawing it must be requested. */
+  gtk_widget_queue_draw (widget);
+
   if (GTK_WIDGET_IS_SENSITIVE (menu_item->submenu))
+  {
+    gboolean take_focus;
+    take_focus = gtk_menu_shell_get_take_focus (GTK_MENU_SHELL (widget->parent));
+    gtk_menu_shell_set_take_focus (GTK_MENU_SHELL (menu_item->submenu),take_focus);
+    
     gtk_menu_popup (GTK_MENU (menu_item->submenu),
 		    widget->parent,
 		    widget,
@@ -1010,6 +1106,28 @@
 		    menu_item,
 		    GTK_MENU_SHELL (widget->parent)->button,
 		    0);
+  }
+}
+
+void
+_gtk_menu_item_popdown_submenu (GtkWidget *widget)
+{
+  GtkMenuItem *menu_item;
+
+  menu_item = GTK_MENU_ITEM (widget);
+
+  if (menu_item->submenu)
+    {
+      if (menu_item->timer)
+        {
+          g_source_remove (menu_item->timer);
+          menu_item->timer = 0;
+        }
+      else
+        gtk_menu_popdown (GTK_MENU (menu_item->submenu));
+    }
+
+  gtk_widget_queue_draw (widget);
 }
 
 static void
@@ -1092,14 +1210,17 @@
 	  tx += widget->allocation.width - twidth;
 	}
 
+/* HILDON modifications
+ * Here we make the submenu of an menubar appear under the menubar.
+ * The only exception is when the resulting menu would be under 100 pixels
+ * high. In that case, the menu is made 100 pixels high.
+ */
       if ((ty + widget->allocation.height + theight) <= monitor.y + monitor.height)
 	ty += widget->allocation.height;
-      else if ((ty - theight) >= monitor.y)
-	ty -= theight;
-      else if (monitor.y + monitor.height - (ty + widget->allocation.height) > ty)
+      else if ((ty + widget->allocation.height) < monitor.y + monitor.height - 120)
 	ty += widget->allocation.height;
       else
-	ty -= theight;
+	ty = monitor.y + monitor.height - 120;
       break;
 
     case GTK_LEFT_RIGHT:
@@ -1404,3 +1525,44 @@
 
   return TRUE;
 }
+
+/* Hildon modification :
+ * This function exists only for opening submenus on
+ * activation. */
+static void
+_gtk_menu_item_activate_submenus (GtkMenuItem *item)
+{
+  GdkEvent *event;
+  gint popup_delay;
+
+  g_return_if_fail (GTK_IS_MENU_ITEM (item));
+  
+  if (!GTK_IS_MENU (item->submenu) ||
+      GTK_WIDGET_VISIBLE (item->submenu)) 
+    return;
+
+  event = gtk_get_current_event ();
+ 
+  /* Hildon: add a delay before opening a new menu */
+  if (item->timer)
+  {
+      g_source_remove (item->timer);
+      item->timer = 0;
+      popup_delay = 0;
+  }
+  else
+      popup_delay = get_popup_delay (item);
+
+  item->timer = g_timeout_add (popup_delay,
+                               gtk_menu_item_select_timeout,
+                               item);
+  
+  /* We don't want to select first item if the submenu
+   * is opened with mouse release because the selection
+   * would move straigh back under the cursor. */
+  if ((event == NULL) || (event->type != GDK_BUTTON_RELEASE))
+    gtk_menu_shell_select_first (GTK_MENU_SHELL (item->submenu), TRUE);
+      
+  if (event)
+    gdk_event_free (event);
+}
--- gtk+/gtk/gtkmenuitem.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkmenuitem.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -122,6 +122,7 @@
 					       gboolean		    group_changed);
 gboolean  _gtk_menu_item_is_selectable        (GtkWidget           *menu_item);
 void      _gtk_menu_item_popup_submenu        (GtkWidget           *menu_item);
+void      _gtk_menu_item_popdown_submenu      (GtkWidget           *menu_item);
 
 #ifndef GTK_DISABLE_DEPRECATED
 #define gtk_menu_item_right_justify(menu_item) gtk_menu_item_set_right_justified ((menu_item), TRUE)
--- gtk+/gtk/gtkmenu.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkmenu.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -24,10 +24,16 @@
  * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
  */
 
+/* Modified by Nokia Corporation - 2005.
+ * 
+ */
+
 #define GTK_MENU_INTERNALS
 
 #include <config.h>
 #include <string.h> /* memset */
+#include <math.h>
+#include <stdlib.h>
 #include "gdk/gdkkeysyms.h"
 #include "gtkalias.h"
 #include "gtkaccellabel.h"
@@ -44,7 +50,11 @@
 #include "gtkvscrollbar.h"
 #include "gtksettings.h"
 #include "gtkintl.h"
+#include "gtkcombobox.h"
 
+/* Hildon : We need this to figure out if menu should have
+ * corners etc. */
+#include "gtkmenubar.h"
 
 #define MENU_ITEM_CLASS(w)   GTK_MENU_ITEM_GET_CLASS (w)
 
@@ -55,16 +65,37 @@
 					 * extends below the submenu
 					 */
 
+/* HILDON:
+ * Urgh, nasty thing to hard-code things like these :p
+ * One should really do some rewriting here...
+ */
+
 #define MENU_SCROLL_STEP1 8
 #define MENU_SCROLL_STEP2 15
-#define MENU_SCROLL_ARROW_HEIGHT 16
-#define MENU_SCROLL_FAST_ZONE 8
+#define MENU_SCROLL_ARROW_HEIGHT 20 /* This used to be: 23; This hard-coding should be
+ 				     * changed. Add arrow_height style property into 
+ 				     * commongtkrc and read it from there everywhere 
+ 				     * where a reference to MENU_SCROLL_ARROW_HEIGHT
+ 				     * is made.
+                                     * If these changes are made, please modify also
+  	                             * gtkcombobox.c.
+				     */
+#define MENU_SCROLL_FAST_ZONE MENU_SCROLL_ARROW_HEIGHT /* Was originally 8 */
 #define MENU_SCROLL_TIMEOUT1 50
 #define MENU_SCROLL_TIMEOUT2 20
 
 #define ATTACH_INFO_KEY "gtk-menu-child-attach-info-key"
 #define ATTACHED_MENUS "gtk-attached-menus"
 
+/* HILDON: */
+#define HILDON_MENU_NAME_SHARP "menu_with_corners"
+ 
+/* needed to allow different themeing for first level menus */
+#define HILDON_MENU_NAME_ROUND_FIRST_LEVEL "menu_without_corners_first_level"
+#define HILDON_MENU_NAME_ROUND "menu_without_corners"
+#define HILDON_MENU_NAME_FORCE_SHARP "menu_force_with_corners"
+#define HILDON_MENU_NAME_FORCE_ROUND "menu_force_without_corners"
+
 typedef struct _GtkMenuAttachData	GtkMenuAttachData;
 typedef struct _GtkMenuPrivate  	GtkMenuPrivate;
 
@@ -92,6 +123,15 @@
   gboolean have_layout;
   gint n_rows;
   gint n_columns;
+  
+  /* Arrow states */
+  GtkStateType lower_arrow_state;
+  GtkStateType upper_arrow_state;
+
+  /* For context menu behavior */
+  gboolean context_menu;
+  int popup_pointer_x;
+  int popup_pointer_y;
 };
 
 typedef struct
@@ -191,7 +231,8 @@
 static void     gtk_menu_handle_scrolling  (GtkMenu          *menu,
 					    gint	      event_x,
 					    gint	      event_y,
-					    gboolean          enter);
+					    gboolean          enter,
+                                            gboolean          motion);
 static void     gtk_menu_set_tearoff_hints (GtkMenu          *menu,
 					    gint             width);
 static void     gtk_menu_style_set         (GtkWidget        *widget,
@@ -232,6 +273,11 @@
                                                   guint      signal_id);
 static void _gtk_menu_refresh_accel_paths (GtkMenu *menu,
 					   gboolean group_changed);
+static gboolean gtk_menu_check_name (GtkWidget *widget);
+
+static gboolean gtk_menu_window_visibility_notify_event (GtkWidget          *widget,
+                                                         GdkEventVisibility *event,
+                                                         GtkMenu            *menu);
 
 static GtkMenuShellClass *parent_class = NULL;
 static const gchar	  attach_data_key[] = "gtk-menu-attach-data";
@@ -496,7 +542,6 @@
   widget_class->hide_all = gtk_menu_hide_all;
   widget_class->enter_notify_event = gtk_menu_enter_notify;
   widget_class->leave_notify_event = gtk_menu_leave_notify;
-  widget_class->motion_notify_event = gtk_menu_motion_notify;
   widget_class->style_set = gtk_menu_style_set;
   widget_class->focus = gtk_menu_focus;
   widget_class->can_activate_accel = gtk_menu_real_can_activate_accel;
@@ -521,7 +566,7 @@
 			     _gtk_marshal_VOID__ENUM,
 			     G_TYPE_NONE, 1,
 			     GTK_TYPE_SCROLL_TYPE);
-  
+
   g_object_class_install_property (gobject_class,
                                    PROP_TEAROFF_TITLE,
                                    g_param_spec_string ("tearoff-title",
@@ -709,6 +754,25 @@
 						   DEFAULT_POPDOWN_DELAY,
 						   G_PARAM_READWRITE));
 						   
+  /* Hildon addition : border width was 
+     replaced with horizontal-padding and
+     vertical-padding (which already is an style
+     property for GtkMenu). */
+  gtk_widget_class_install_style_property (widget_class,
+					   g_param_spec_int ("horizontal-padding",
+							     P_("Horizontal Padding"),
+							     P_("Extra space at the left and right edges of the menu"),
+							     0,
+							     G_MAXINT,
+							     0, /* 1, */
+							     G_PARAM_READABLE));
+
+  gtk_widget_class_install_style_property (widget_class,
+					   g_param_spec_boolean ("double_arrows",
+								 P_("Double Arrows"),
+								 P_("When scrolling, always show both arrows."),
+								 FALSE,
+								 G_PARAM_READABLE));
 }
 
 
@@ -884,16 +948,23 @@
   menu->toggle_size = 0;
 
   menu->toplevel = g_object_connect (g_object_new (GTK_TYPE_WINDOW,
-						   "type", GTK_WINDOW_POPUP,
-						   "child", menu,
-						   NULL),
+				     "type", GTK_WINDOW_TOPLEVEL,
+				     "child", menu,
+				      NULL),
 				     "signal::event", gtk_menu_window_event, menu,
 				     "signal::size_request", gtk_menu_window_size_request, menu,
 				     "signal::destroy", gtk_widget_destroyed, &menu->toplevel,
+                                     "signal::visibility_notify_event", gtk_menu_window_visibility_notify_event, menu,
 				     NULL);
+
+  gtk_window_set_decorated (GTK_WINDOW (menu->toplevel), FALSE);
+  gtk_window_set_type_hint (GTK_WINDOW (menu->toplevel),
+                            GDK_WINDOW_TYPE_HINT_MENU);
   gtk_window_set_resizable (GTK_WINDOW (menu->toplevel), FALSE);
   gtk_window_set_mnemonic_modifier (GTK_WINDOW (menu->toplevel), 0);
 
+  gtk_widget_add_events (menu->toplevel, GDK_VISIBILITY_NOTIFY_MASK);
+
   /* Refloat the menu, so that reference counting for the menu isn't
    * affected by it being a child of the toplevel
    */
@@ -919,6 +990,15 @@
   menu->lower_arrow_visible = FALSE;
   menu->upper_arrow_prelight = FALSE;
   menu->lower_arrow_prelight = FALSE;
+  
+  /* <Hildon> */
+  priv->upper_arrow_state = GTK_STATE_NORMAL;
+  priv->lower_arrow_state = GTK_STATE_NORMAL;
+
+  priv->context_menu = FALSE;
+  priv->popup_pointer_x = -1;
+  priv->popup_pointer_y = -1;
+  /* </hildon */
 
   priv->have_layout = FALSE;
 }
@@ -1220,7 +1300,8 @@
 
 static gboolean
 popup_grab_on_window (GdkWindow *window,
-		      guint32    activate_time)
+		      guint32    activate_time,
+		      gboolean   grab_keyboard)
 {
   if ((gdk_pointer_grab (window, TRUE,
 			 GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK |
@@ -1228,7 +1309,8 @@
 			 GDK_POINTER_MOTION_MASK,
 			 NULL, NULL, activate_time) == 0))
     {
-      if (gdk_keyboard_grab (window, TRUE,
+      if (!grab_keyboard ||
+		      gdk_keyboard_grab (window, TRUE,
 			     activate_time) == 0)
 	return TRUE;
       else
@@ -1282,17 +1364,21 @@
   GtkWidget *parent;
   GdkEvent *current_event;
   GtkMenuShell *menu_shell;
+  gboolean grab_keyboard;
   GtkMenuPrivate *priv = gtk_menu_get_private (menu);
+  GdkScreen *screen;
+  GdkWindow *active_window;
+  gint try;
 
   g_return_if_fail (GTK_IS_MENU (menu));
-  
+
   widget = GTK_WIDGET (menu);
   menu_shell = GTK_MENU_SHELL (menu);
   
   menu_shell->parent_menu_shell = parent_menu_shell;
 
   priv->seen_item_enter = FALSE;
-  
+
   /* Find the last viewable ancestor, and make an X grab on it
    */
   parent = GTK_WIDGET (menu);
@@ -1333,10 +1419,28 @@
    * probably could just leave the grab on the other window, with a
    * little reorganization of the code in gtkmenu*).
    */
+
+  grab_keyboard = gtk_menu_shell_get_take_focus (menu_shell);
+  gtk_window_set_accept_focus (GTK_WINDOW (menu->toplevel), grab_keyboard);
+  
   if (xgrab_shell && xgrab_shell != widget)
     {
-      if (popup_grab_on_window (xgrab_shell->window, activate_time))
+      if (popup_grab_on_window (xgrab_shell->window, activate_time, grab_keyboard))
 	GTK_MENU_SHELL (xgrab_shell)->have_xgrab = TRUE;
+
+      /* HILDON: 
+       * Check wheter parent is GtkMenuBar. If so,
+       * then we need sharp upper corners for this menu.
+       */
+      if (gtk_menu_check_name (widget))
+        {
+	  if (GTK_IS_MENU_BAR (parent_menu_shell))
+	    gtk_widget_set_name (widget, HILDON_MENU_NAME_SHARP);
+	  else if (GTK_IS_MENU (parent_menu_shell))
+	    gtk_widget_set_name( widget, HILDON_MENU_NAME_ROUND);
+	  else
+	    gtk_widget_set_name (widget, HILDON_MENU_NAME_ROUND_FIRST_LEVEL);
+        }
     }
   else
     {
@@ -1344,8 +1448,14 @@
 
       xgrab_shell = widget;
       transfer_window = menu_grab_transfer_window_get (menu);
-      if (popup_grab_on_window (transfer_window, activate_time))
+      if (popup_grab_on_window (transfer_window, activate_time, grab_keyboard))
 	GTK_MENU_SHELL (xgrab_shell)->have_xgrab = TRUE;
+
+      /* HILDON: 
+       * We want this menu to have round corners (Used by default) 
+       */
+      if (gtk_menu_check_name (widget))
+	gtk_widget_set_name (widget, HILDON_MENU_NAME_ROUND_FIRST_LEVEL);
     }
 
   if (!GTK_MENU_SHELL (xgrab_shell)->have_xgrab)
@@ -1360,7 +1470,6 @@
     }
 
   menu_shell->active = TRUE;
-  menu_shell->button = button;
 
   /* If we are popping up the menu from something other than, a button
    * press then, as a heuristic, we ignore enter events for the menu
@@ -1430,14 +1539,51 @@
 
   gtk_menu_scroll_to (menu, menu->scroll_offset);
 
+  screen = gtk_widget_get_screen (widget);
+
+  if (priv->context_menu)
+    {
+      /* Save position of the pointer during popup */
+      /* currently not-multihead safe */
+      GdkDisplay *display;
+      
+      display = gdk_screen_get_display (screen);
+  
+      gdk_display_get_pointer (display, NULL,
+                               &priv->popup_pointer_x,
+                               &priv->popup_pointer_y,
+                               NULL);
+    }
+
+  gtk_widget_realize (menu->toplevel);
+
+  /* Set the window transient for the currently active window, so that the menu
+   * will get deactivated when a different window is put on top. */
+  for (try = 0; try < 10; try++)
+    {
+      active_window = gdk_screen_get_active_window (screen);
+      if (!active_window)
+        break;
+
+      gdk_error_trap_push ();
+      gdk_window_set_transient_for (menu->toplevel->window, active_window);
+      if (gdk_error_trap_pop ())
+        continue; /* The window we tried to parent to disappeared, retry. */
+
+      /* Success. */
+      break;
+    }
+
+  if (xgrab_shell == widget)
+    popup_grab_on_window (widget->window, activate_time, grab_keyboard); /* Should always succeed */
+  gtk_grab_add (GTK_WIDGET (menu));
+
+  _gtk_menu_shell_set_first_click (menu_shell);
+
   /* Once everything is set up correctly, map the toplevel window on
      the screen.
    */
   gtk_widget_show (menu->toplevel);
-
-  if (xgrab_shell == widget)
-    popup_grab_on_window (widget->window, activate_time); /* Should always succeed */
-  gtk_grab_add (GTK_WIDGET (menu));
 }
 
 void
@@ -1996,6 +2142,7 @@
   GtkWidget *child;
   GList *children;
   guint vertical_padding;
+  guint horizontal_padding;
   
   g_return_if_fail (GTK_IS_MENU (widget));
 
@@ -2025,9 +2172,10 @@
 
   gtk_widget_style_get (GTK_WIDGET (menu),
 			"vertical-padding", &vertical_padding,
+			"horizontal-padding", &horizontal_padding,
 			NULL);
   
-  attributes.x = border_width + widget->style->xthickness;
+  attributes.x = border_width + widget->style->xthickness + horizontal_padding;
   attributes.y = border_width + widget->style->ythickness + vertical_padding;
   attributes.width = MAX (1, widget->allocation.width - attributes.x * 2);
   attributes.height = MAX (1, widget->allocation.height - attributes.y * 2);
@@ -2040,11 +2188,14 @@
   if (menu->lower_arrow_visible)
     attributes.height -= MENU_SCROLL_ARROW_HEIGHT;
 
+  attributes.window_type = GDK_WINDOW_CHILD;
+
   menu->view_window = gdk_window_new (widget->window, &attributes, attributes_mask);
   gdk_window_set_user_data (menu->view_window, menu);
 
   attributes.x = 0;
   attributes.y = 0;
+  attributes.width = MAX (1, widget->allocation.width - (border_width + widget->style->xthickness + horizontal_padding) * 2);
   attributes.height = MAX (1, widget->requisition.height - (border_width + widget->style->ythickness + vertical_padding) * 2);
   
   menu->bin_window = gdk_window_new (menu->view_window, &attributes, attributes_mask);
@@ -2164,6 +2315,10 @@
   guint vertical_padding;
   GtkRequisition child_requisition;
   GtkMenuPrivate *priv;
+  guint horizontal_padding;
+  GdkScreen *screen;
+  GdkRectangle monitor;
+  gint monitor_num;
   
   g_return_if_fail (GTK_IS_MENU (widget));
   g_return_if_fail (requisition != NULL);
@@ -2182,6 +2337,16 @@
   priv->heights = g_new0 (guint, gtk_menu_get_n_rows (menu));
   priv->heights_length = gtk_menu_get_n_rows (menu);
 
+/* Hildon addition to find out the monitor width */
+   screen = gtk_widget_get_screen (widget);
+   if (widget->window != NULL)
+     monitor_num = gdk_screen_get_monitor_at_window (screen, widget->window);
+   else
+     monitor_num = 0;
+   if (monitor_num < 0)
+     monitor_num = 0;
+   gdk_screen_get_monitor_geometry (screen, monitor_num, &monitor);
+
   children = menu_shell->children;
   while (children)
     {
@@ -2223,15 +2388,18 @@
 
   requisition->width += max_toggle_size + max_accel_width;
   requisition->width *= gtk_menu_get_n_columns (menu);
-  requisition->width += (GTK_CONTAINER (menu)->border_width +
-			 widget->style->xthickness) * 2;
 
   gtk_widget_style_get (GTK_WIDGET (menu),
+			"horizontal-padding", &horizontal_padding,
 			"vertical-padding", &vertical_padding,
 			NULL);
+  requisition->width += (GTK_CONTAINER (menu)->border_width + horizontal_padding +
+			 widget->style->xthickness) * 2;
   requisition->height += (GTK_CONTAINER (menu)->border_width + vertical_padding +
 			  widget->style->ythickness) * 2;
   
+/* Hildon addition to not make the menu too wide for the screen. */
+  requisition->width = MIN (requisition->width, monitor.width);
   menu->toggle_size = max_toggle_size;
 
   /* Don't resize the tearoff if it is not active, because it won't redraw (it is only a background pixmap).
@@ -2253,6 +2421,7 @@
   GList *children;
   gint x, y;
   gint width, height;
+  guint horizontal_padding;
   guint vertical_padding;
 
   g_return_if_fail (GTK_IS_MENU (widget));
@@ -2266,10 +2435,11 @@
   gtk_widget_get_child_requisition (GTK_WIDGET (menu), &child_requisition);
 
   gtk_widget_style_get (GTK_WIDGET (menu),
+			"horizontal-padding", &horizontal_padding,
 			"vertical-padding", &vertical_padding,
 			NULL);
   
-  x = GTK_CONTAINER (menu)->border_width + widget->style->xthickness;
+  x = GTK_CONTAINER (menu)->border_width + widget->style->xthickness + horizontal_padding;
   y = GTK_CONTAINER (menu)->border_width + widget->style->ythickness + vertical_padding;
 
   width = MAX (1, allocation->width - x * 2);
@@ -2407,27 +2577,32 @@
 		GdkEventExpose *event)
 {
   GtkMenu *menu;
-  gint width, height;
-  gint border_x, border_y;
-  guint vertical_padding;
   
   g_return_if_fail (GTK_IS_MENU (widget));
 
   menu = GTK_MENU (widget);
 
-  gtk_widget_style_get (GTK_WIDGET (menu),
-			"vertical-padding", &vertical_padding,
-			NULL);
-  
-  border_x = GTK_CONTAINER (widget)->border_width + widget->style->xthickness;
-  border_y = GTK_CONTAINER (widget)->border_width + widget->style->ythickness + vertical_padding;
-  gdk_drawable_get_size (widget->window, &width, &height);
-
   if (event->window == widget->window)
     {
+      gint width, height;
+      gint border_x, border_y;
+      guint vertical_padding;
+      guint horizontal_padding;
+      GtkMenuPrivate *priv;
       gint arrow_space = MENU_SCROLL_ARROW_HEIGHT - 2 * widget->style->ythickness;
       gint arrow_size = 0.7 * arrow_space;
 	
+      priv = gtk_menu_get_private (menu);
+
+      gtk_widget_style_get (GTK_WIDGET (menu),
+			    "vertical-padding", &vertical_padding,
+			    "horizontal-padding", &horizontal_padding,
+			    NULL);
+  
+      border_x = GTK_CONTAINER (widget)->border_width + widget->style->xthickness + horizontal_padding;
+      border_y = GTK_CONTAINER (widget)->border_width + widget->style->ythickness + vertical_padding;
+      gdk_drawable_get_size (widget->window, &width, &height);
+
       gtk_paint_box (widget->style,
 		     widget->window,
 		     GTK_STATE_NORMAL,
@@ -2436,21 +2611,9 @@
 		     0, 0, -1, -1);
       if (menu->upper_arrow_visible && !menu->tearoff_active)
 	{
-	  gtk_paint_box (widget->style,
-			 widget->window,
-			 menu->upper_arrow_prelight ?
-			 GTK_STATE_PRELIGHT : GTK_STATE_NORMAL,
-			 GTK_SHADOW_OUT,
-			 NULL, widget, "menu",
-			 border_x,
-			 border_y,
-			 width - 2 * border_x,
-			 MENU_SCROLL_ARROW_HEIGHT);
-	  
 	  gtk_paint_arrow (widget->style,
 			   widget->window,
-			   menu->upper_arrow_prelight ?
-			   GTK_STATE_PRELIGHT : GTK_STATE_NORMAL,
+			   priv->upper_arrow_state,
 			   GTK_SHADOW_OUT,
 			   NULL, widget, "menu_scroll_arrow_up",
 			   GTK_ARROW_UP,
@@ -2462,21 +2625,9 @@
   
       if (menu->lower_arrow_visible && !menu->tearoff_active)
 	{
-	  gtk_paint_box (widget->style,
-			 widget->window,
-			 menu->lower_arrow_prelight ?
-			 GTK_STATE_PRELIGHT : GTK_STATE_NORMAL,
-			 GTK_SHADOW_OUT,
-			 NULL, widget, "menu",
-			 border_x,
-			 height - border_y - MENU_SCROLL_ARROW_HEIGHT,
-			 width - 2*border_x,
-			 MENU_SCROLL_ARROW_HEIGHT);
-	  
 	  gtk_paint_arrow (widget->style,
 			   widget->window,
-			   menu->lower_arrow_prelight ?
-			   GTK_STATE_PRELIGHT : GTK_STATE_NORMAL,
+			   priv->lower_arrow_state,
 			   GTK_SHADOW_OUT,
 			   NULL, widget, "menu_scroll_arrow_down",
 			   GTK_ARROW_DOWN,
@@ -2516,18 +2667,85 @@
   GTK_WIDGET_CLASS (parent_class)->show (widget);
 }
 
+static GtkWidget *
+find_active_menu_item (GdkEventButton *event)
+{
+  GtkWidget *menu_item;
+      
+  menu_item = gtk_get_event_widget ((GdkEvent*) event);
+  while (menu_item && !GTK_IS_MENU_ITEM (menu_item))
+    menu_item = menu_item->parent;
+
+  return menu_item;
+}
+
+static gboolean
+pointer_in_menu_tree (GtkWidget *widget)
+{
+  GtkMenuShell *mshell;
+  int width, height, x, y;
+  
+  mshell = GTK_MENU_SHELL (widget);
+
+  gdk_window_get_pointer (widget->window, &x, &y, NULL);
+  gdk_drawable_get_size (widget->window, &width, &height);
+
+  if ((x <= width) && (x >= 0) && (y <= height) && (y >= 0))
+    return TRUE;
+
+  if ((mshell->parent_menu_shell != NULL) &&
+      GTK_IS_MENU (mshell->parent_menu_shell))
+    return pointer_in_menu_tree (mshell->parent_menu_shell);
+
+  return FALSE;
+}
+
+static int
+distance_traveled (GtkWidget *widget)
+{
+  GtkMenuPrivate *priv;
+  GdkScreen *screen;
+  GdkDisplay *display;
+  int x, y, dx, dy;
+
+  priv = gtk_menu_get_private (GTK_MENU (widget));
+    
+  screen = gtk_widget_get_screen (widget);
+  display = gdk_screen_get_display (screen);
+  
+  gdk_display_get_pointer (display, NULL, &x, &y, NULL);
+
+  dx = (priv->popup_pointer_x - x);
+  dy = (priv->popup_pointer_y - y);
+
+  return abs ((int) sqrt ((double) (dx * dx + dy * dy)));
+}
+
 static gboolean
 gtk_menu_button_press (GtkWidget      *widget,
-			 GdkEventButton *event)
+                       GdkEventButton *event)
 {
-  /* Don't pop down the menu for releases over scroll arrows
-   */
-  if (GTK_IS_MENU (widget))
+  GtkWidget *menu_item;
+
+  if (event->type != GDK_BUTTON_PRESS)
+    return FALSE;
+
+  menu_item = find_active_menu_item (event);
+  if (menu_item == NULL)
     {
       GtkMenu *menu = GTK_MENU (widget);
 
-      if (menu->upper_arrow_prelight ||  menu->lower_arrow_prelight)
-	return TRUE;
+      if (menu->upper_arrow_prelight || menu->lower_arrow_prelight)
+        {
+	  gtk_menu_handle_scrolling (GTK_MENU (widget), event->x_root, event->y_root, TRUE, FALSE);
+
+	  return TRUE;
+	}
+
+      /* Don't pass down to menu shell if a non-menuitem part
+       * of the menu was clicked. */
+      if (pointer_in_menu_tree (widget))
+        return TRUE;
     }
 
   return GTK_WIDGET_CLASS (parent_class)->button_press_event (widget, event);
@@ -2537,14 +2755,47 @@
 gtk_menu_button_release (GtkWidget      *widget,
 			 GdkEventButton *event)
 {
-  /* Don't pop down the menu for releases over scroll arrows
-   */
-  if (GTK_IS_MENU (widget))
+  GtkMenuPrivate *priv;
+  GtkWidget *menu_item;
+
+  if (event->type != GDK_BUTTON_RELEASE)
+    return FALSE;
+
+  priv = gtk_menu_get_private (GTK_MENU (widget));
+
+  menu_item = find_active_menu_item (event);
+  if (menu_item == NULL)
     {
       GtkMenu *menu = GTK_MENU (widget);
 
-      if (menu->upper_arrow_prelight ||  menu->lower_arrow_prelight)
-	return TRUE;
+      if (menu->upper_arrow_prelight || menu->lower_arrow_prelight)
+        {
+	  gtk_menu_handle_scrolling (GTK_MENU (widget), event->x_root, event->y_root, FALSE, FALSE);
+
+	  return TRUE;
+        }
+
+      if (priv->context_menu &&
+          (priv->popup_pointer_x >= 0) &&
+          (priv->popup_pointer_y >= 0))
+        {
+          int distance;
+
+          distance = distance_traveled (widget);
+
+          priv->popup_pointer_x = -1;
+          priv->popup_pointer_y = -1;
+          
+          /* Don't popdown if we traveled less than 20px since popup point,
+           * as per the Nokia 770 specs. */
+          if (distance < 20)
+            return TRUE;
+        }
+
+      /* Don't pass down to menu shell if a non-menuitem part
+       * of the menu was clicked. */
+      if (pointer_in_menu_tree (widget))
+        return TRUE;
     }
 
   return GTK_WIDGET_CLASS (parent_class)->button_release_event (widget, event);
@@ -2725,35 +2976,6 @@
 }
 
 static gboolean
-check_threshold (GtkWidget *widget,
-		 int start_x, int start_y,
-		 int x, int y)
-{
-#define THRESHOLD 8
-  
-  return
-    ABS (start_x - x) > THRESHOLD  ||
-    ABS (start_y - y) > THRESHOLD;
-}
-
-static gboolean
-definitely_within_item (GtkWidget *widget, 
-			int x,
-			int y)
-{
-  GdkWindow *window = GTK_MENU_ITEM (widget)->event_window;
-  int w, h;
-
-  gdk_drawable_get_size (window, &w, &h);
-  
-  return
-    check_threshold (widget, 0, 0, x, y) &&
-    check_threshold (widget, w - 1, 0, x, y) &&
-    check_threshold (widget, w - 1, h - 1, x, y) &&
-    check_threshold (widget, 0, h - 1, x, y);
-}
-
-static gboolean
 gtk_menu_motion_notify  (GtkWidget	   *widget,
 			 GdkEventMotion    *event)
 {
@@ -2765,7 +2987,7 @@
   gboolean need_enter;
 
   if (GTK_IS_MENU (widget))
-    gtk_menu_handle_scrolling (GTK_MENU (widget), event->x_root, event->y_root, TRUE);
+    gtk_menu_handle_scrolling (GTK_MENU (widget), event->x_root, event->y_root, TRUE, TRUE);
 
   /* We received the event for one of two reasons:
    *
@@ -2779,16 +3001,33 @@
   menu_item = gtk_get_event_widget ((GdkEvent*) event);
   if (!menu_item || !GTK_IS_MENU_ITEM (menu_item) ||
       !GTK_IS_MENU (menu_item->parent))
-    return FALSE;
+    {
+      GtkMenuPrivate *priv;
+      
+      priv = gtk_menu_get_private (GTK_MENU (widget));
+      
+      if (priv->context_menu)
+        {
+          /* Context menu mode. If we dragged out of the menu,
+           * close the menu, as by the specs. */
+          if (!pointer_in_menu_tree (widget) && 
+              (distance_traveled (widget) >= 20) &&
+              (event->state & GDK_BUTTON1_MASK))
+            {
+              gtk_menu_shell_deactivate (GTK_MENU_SHELL (widget));
+
+              return TRUE;
+            }
+        }
+      
+      return FALSE;
+    }
 
   menu_shell = GTK_MENU_SHELL (menu_item->parent);
   menu = GTK_MENU (menu_shell);
 
   priv = gtk_menu_get_private (GTK_MENU (widget));
 
-  if (definitely_within_item (menu_item, event->x, event->y))
-    menu_shell->activate_time = 0;
-  
   need_enter = (menu->navigation_region != NULL || menu_shell->ignore_enter);
 
   /* Check to see if we are within an active submenu's navigation region
@@ -2796,6 +3035,12 @@
   if (gtk_menu_navigating_submenu (menu, event->x_root, event->y_root))
     return TRUE; 
 
+  /* HILDON MOD.
+   * Close the submenus that are two levels down from the currently selected.
+   * This ensures that the focus is correct all the time.*/
+  if (GTK_MENU_ITEM (menu_item)->submenu != NULL)
+    gtk_menu_shell_deselect (GTK_MENU_SHELL (GTK_MENU_ITEM (menu_item)->submenu));
+
   /* Make sure we pop down if we enter a non-selectable menu item, so we
    * don't show a submenu when the cursor is outside the stay-up triangle.
    */
@@ -2828,6 +3073,7 @@
 	  send_event->crossing.y_root = event->y_root;
 	  send_event->crossing.x = event->x;
 	  send_event->crossing.y = event->y;
+          send_event->crossing.state = event->state;
 
 	  /* We send the event to 'widget', the currently active menu,
 	   * instead of 'menu', the menu that the pointer is in. This
@@ -2852,17 +3098,24 @@
   GtkWidget *widget;
   gint offset;
   gint view_width, view_height;
+  gboolean double_arrows;
 
   widget = GTK_WIDGET (menu);
   offset = menu->scroll_offset + step;
 
+  /* get double_arrows style property */
+  gtk_widget_style_get (widget,
+ 			"double_arrows", &double_arrows,
+ 			NULL);
+
   /* If we scroll upward and the non-visible top part
    * is smaller than the scroll arrow it would be
    * pretty stupid to show the arrow and taking more
    * screen space than just scrolling to the top.
    */
-  if ((step < 0) && (offset < MENU_SCROLL_ARROW_HEIGHT))
-    offset = 0;
+  if (!double_arrows)
+    if ((step < 0) && (offset < MENU_SCROLL_ARROW_HEIGHT))
+      offset = 0;
 
   /* Don't scroll over the top if we weren't before: */
   if ((menu->scroll_offset >= 0) && (offset < 0))
@@ -2874,6 +3127,12 @@
   if (menu->scroll_offset > 0)
     view_height -= MENU_SCROLL_ARROW_HEIGHT;
   
+  /* When both arrows are always shown, reduce
+   * view height even more.
+   */
+  if (double_arrows)
+    view_height -= MENU_SCROLL_ARROW_HEIGHT;
+
   if ((menu->scroll_offset + view_height <= widget->requisition.height) &&
       (offset + view_height > widget->requisition.height))
     offset = widget->requisition.height - view_height;
@@ -2922,18 +3181,21 @@
 gtk_menu_handle_scrolling (GtkMenu *menu,
 			   gint x,
 			   gint y,
-			   gboolean enter)
+			   gboolean enter,
+                           gboolean motion)
 {
   GtkMenuShell *menu_shell;
+  GtkMenuPrivate *priv;
   gint width, height;
   gint border;
   GdkRectangle rect;
-  gboolean in_arrow;
   gboolean scroll_fast = FALSE;
   guint vertical_padding;
   gint top_x, top_y;
   gint win_x, win_y;
 
+  priv = gtk_menu_get_private (menu);
+
   menu_shell = GTK_MENU_SHELL (menu);
 
   gdk_drawable_get_size (GTK_WIDGET (menu)->window, &width, &height);
@@ -2946,10 +3208,11 @@
     GTK_WIDGET (menu)->style->ythickness + vertical_padding;
 
   gdk_window_get_position (menu->toplevel->window, &top_x, &top_y);
+  x -= top_x;
+  y -= top_y;
+
   gdk_window_get_position (GTK_WIDGET (menu)->window, &win_x, &win_y);
-  win_x += top_x;
-  win_y += top_y;
-  
+
   if (menu->upper_arrow_visible && !menu->tearoff_active)
     {
       rect.x = win_x;
@@ -2957,35 +3220,49 @@
       rect.width = width;
       rect.height = MENU_SCROLL_ARROW_HEIGHT + border;
       
-      in_arrow = FALSE;
+      menu->upper_arrow_prelight = FALSE;
       if ((x >= rect.x) && (x < rect.x + rect.width) &&
 	  (y >= rect.y) && (y < rect.y + rect.height))
-	{
-	  in_arrow = TRUE;
-	  scroll_fast = (y < rect.y + MENU_SCROLL_FAST_ZONE);
-	}
-	
-      if (enter && in_arrow &&
-	  (!menu->upper_arrow_prelight || menu->scroll_fast != scroll_fast))
-	{
-	  menu->upper_arrow_prelight = TRUE;
-	  menu->scroll_fast = scroll_fast;
-	  gdk_window_invalidate_rect (GTK_WIDGET (menu)->window, &rect, FALSE);
-	  
-	  /* Deselect the active item so that any submenus are poped down */
-	  gtk_menu_shell_deselect (menu_shell);
+        menu->upper_arrow_prelight = TRUE;
 
-	  gtk_menu_remove_scroll_timeout (menu);
-	  menu->scroll_step = (scroll_fast) ? -MENU_SCROLL_STEP2 : -MENU_SCROLL_STEP1;
-	  menu->timeout_id = g_timeout_add ((scroll_fast) ? MENU_SCROLL_TIMEOUT2 : MENU_SCROLL_TIMEOUT1,
-					    gtk_menu_scroll_timeout,
-					    menu);
-	}
-      else if (!enter && !in_arrow && menu->upper_arrow_prelight)
+      if (priv->upper_arrow_state != GTK_STATE_INSENSITIVE)
 	{
-	  gdk_window_invalidate_rect (GTK_WIDGET (menu)->window, &rect, FALSE);
-	  
-	  gtk_menu_stop_scrolling (menu);
+	  if (enter && menu->upper_arrow_prelight &&
+	      (menu->timeout_id == 0 || menu->scroll_fast != scroll_fast))
+	    {
+	      menu->scroll_fast = scroll_fast;
+	      
+	      /* Deselect the active item so that any submenus are poped down */
+	      gtk_menu_shell_deselect (menu_shell);
+
+	      gtk_menu_remove_scroll_timeout (menu);
+	      menu->scroll_step = (scroll_fast) ? -MENU_SCROLL_STEP2 : -MENU_SCROLL_STEP1;
+
+	      if (!motion)
+		{
+		  /* Only do stuff on click. */
+		  GtkSettings *settings;
+		  guint timeout;
+		  
+		  settings = gtk_widget_get_settings (GTK_WIDGET (menu));
+		  g_object_get (settings, "gtk-update-timeout", &timeout, NULL);
+
+		  menu->timeout_id = g_timeout_add (timeout / 2, gtk_menu_scroll_timeout, menu);
+
+		  priv->upper_arrow_state = GTK_STATE_ACTIVE;
+		}
+
+	      gdk_window_invalidate_rect (GTK_WIDGET (menu)->window, &rect, FALSE);
+	    }
+	  else if (!enter)
+	    {
+	      gtk_menu_stop_scrolling (menu);
+
+	      priv->upper_arrow_state = menu->upper_arrow_prelight ?
+					    GTK_STATE_PRELIGHT : GTK_STATE_NORMAL;
+
+	      gdk_window_invalidate_rect (GTK_WIDGET (menu)->window, &rect, FALSE);
+	    }
 	}
     }
   
@@ -2996,36 +3273,50 @@
       rect.width = width;
       rect.height = MENU_SCROLL_ARROW_HEIGHT + border;
 
-      in_arrow = FALSE;
+      menu->lower_arrow_prelight = FALSE;
       if ((x >= rect.x) && (x < rect.x + rect.width) &&
 	  (y >= rect.y) && (y < rect.y + rect.height))
-	{
-	  in_arrow = TRUE;
-	  scroll_fast = (y > rect.y + rect.height - MENU_SCROLL_FAST_ZONE);
-	}
+        menu->lower_arrow_prelight = TRUE;
 
-      if (enter && in_arrow &&
-	  (!menu->lower_arrow_prelight || menu->scroll_fast != scroll_fast))
+      if (priv->lower_arrow_state != GTK_STATE_INSENSITIVE)
 	{
-	  menu->lower_arrow_prelight = TRUE;
-	  menu->scroll_fast = scroll_fast;
-	  gdk_window_invalidate_rect (GTK_WIDGET (menu)->window, &rect, FALSE);
+	  if (enter && menu->lower_arrow_prelight &&
+	      (menu->timeout_id == 0 || menu->scroll_fast != scroll_fast))
+	    {
+	      menu->scroll_fast = scroll_fast;
 
-	  /* Deselect the active item so that any submenus are poped down */
-	  gtk_menu_shell_deselect (menu_shell);
+	      /* Deselect the active item so that any submenus are poped down */
+	      gtk_menu_shell_deselect (menu_shell);
 
-	  gtk_menu_remove_scroll_timeout (menu);
-	  menu->scroll_step = (scroll_fast) ? MENU_SCROLL_STEP2 : MENU_SCROLL_STEP1;
-	  menu->timeout_id = g_timeout_add ((scroll_fast) ? MENU_SCROLL_TIMEOUT2 : MENU_SCROLL_TIMEOUT1,
-					    gtk_menu_scroll_timeout,
-					    menu);
-	}
-      else if (!enter && !in_arrow && menu->lower_arrow_prelight)
-	{
-	  gdk_window_invalidate_rect (GTK_WIDGET (menu)->window, &rect, FALSE);
-	  
-	  gtk_menu_stop_scrolling (menu);
-	}
+	      gtk_menu_remove_scroll_timeout (menu);
+	      menu->scroll_step = (scroll_fast) ? MENU_SCROLL_STEP2 : MENU_SCROLL_STEP1;
+
+	      if (!motion)
+		{ 
+		  /* Only do stuff on click. */
+		  GtkSettings *settings;
+		  guint timeout;
+		  
+		  settings = gtk_widget_get_settings (GTK_WIDGET (menu));
+		  g_object_get (settings, "gtk-update-timeout", &timeout, NULL);
+
+		  menu->timeout_id = g_timeout_add (timeout / 2, gtk_menu_scroll_timeout, menu);
+
+		  priv->lower_arrow_state = GTK_STATE_ACTIVE;
+		}
+
+	      gdk_window_invalidate_rect (GTK_WIDGET (menu)->window, &rect, FALSE);
+	    }
+	  else if (!enter)
+	    {
+	      gtk_menu_stop_scrolling (menu);
+	      
+	      priv->lower_arrow_state = menu->lower_arrow_prelight ?
+					    GTK_STATE_PRELIGHT : GTK_STATE_NORMAL;
+
+	      gdk_window_invalidate_rect (GTK_WIDGET (menu)->window, &rect, FALSE);
+	    }
+        }
     }
 }
 
@@ -3041,45 +3332,9 @@
       GtkMenuShell *menu_shell = GTK_MENU_SHELL (widget);
 
       if (!menu_shell->ignore_enter)
-	gtk_menu_handle_scrolling (GTK_MENU (widget), event->x_root, event->y_root, TRUE);
+	gtk_menu_handle_scrolling (GTK_MENU (widget), event->x_root, event->y_root, TRUE, TRUE);
     }
 
-  if (menu_item && GTK_IS_MENU_ITEM (menu_item))
-    {
-      GtkWidget *menu = menu_item->parent;
-      
-      if (menu && GTK_IS_MENU (menu))
-	{
-	  GtkMenuPrivate *priv = gtk_menu_get_private (GTK_MENU (menu));
-	  GtkMenuShell *menu_shell = GTK_MENU_SHELL (menu);
-
-	  if (priv->seen_item_enter)
-	    {
-	      /* This is the second enter we see for an item
-	       * on this menu. This means a release should always
-	       * mean activate.
-	       */
-	      menu_shell->activate_time = 0;
-	    }
-	  else if ((event->detail != GDK_NOTIFY_NONLINEAR &&
-		    event->detail != GDK_NOTIFY_NONLINEAR_VIRTUAL))
-	    {
-	      if (definitely_within_item (menu_item, event->x, event->y))
-		{
-		  /* This is an actual user-enter (ie. not a pop-under)
-		   * In this case, the user must either have entered
-		   * sufficiently far enough into the item, or he must move
-		   * far enough away from the enter point. (see
-		   * gtk_menu_motion_notify())
-		   */
-		  menu_shell->activate_time = 0;
-		}
-	    }
-	    
-	  priv->seen_item_enter = TRUE;
-	}
-    }
-  
   /* If this is a faked enter (see gtk_menu_motion_notify), 'widget'
    * will not correspond to the event widget's parent.  Check to see
    * if we are in the parent's navigation region.
@@ -3106,7 +3361,7 @@
   if (gtk_menu_navigating_submenu (menu, event->x_root, event->y_root))
     return TRUE; 
 
-  gtk_menu_handle_scrolling (menu, event->x_root, event->y_root, FALSE);
+  gtk_menu_handle_scrolling (menu, event->x_root, event->y_root, FALSE, TRUE);
   
   event_widget = gtk_get_event_widget ((GdkEvent*) event);
   
@@ -3382,7 +3637,6 @@
   
   parent = menu_shell->parent_menu_shell;
   
-  menu_shell->activate_time = 0;
   gtk_menu_popdown (GTK_MENU (menu_shell));
   
   if (parent)
@@ -3433,6 +3687,8 @@
   private->monitor_num = gdk_screen_get_monitor_at_point (screen, x, y);
 
   push_in = FALSE;
+
+  menu->scroll_offset = 0;
   
   if (menu->position_func)
     {
@@ -3558,6 +3814,8 @@
 	{
 	  y = monitor.y;
 	}
+
+      x = CLAMP (x, monitor.x, MAX (monitor.x, monitor.x + monitor.width - requisition.width));
     }
 
   scroll_offset = 0;
@@ -3579,9 +3837,6 @@
 	}
     }
 
-  /* FIXME: should this be done in the various position_funcs ? */
-  x = CLAMP (x, monitor.x, MAX (monitor.x, monitor.x + monitor.width - requisition.width));
- 
   if (GTK_MENU_SHELL (menu)->active)
     {
       private->have_position = TRUE;
@@ -3610,8 +3865,9 @@
       gtk_window_resize (GTK_WINDOW (menu->tearoff_window),
 			 requisition.width, requisition.height);
     }
-  
-  menu->scroll_offset = scroll_offset;
+
+  if (menu->scroll_offset == 0)
+    menu->scroll_offset = scroll_offset;
 }
 
 static void
@@ -3628,9 +3884,6 @@
 gtk_menu_stop_scrolling (GtkMenu *menu)
 {
   gtk_menu_remove_scroll_timeout (menu);
-
-  menu->upper_arrow_prelight = FALSE;
-  menu->lower_arrow_prelight = FALSE;
 }
 
 static void
@@ -3644,6 +3897,8 @@
   gboolean last_visible;
   gint menu_height;
   guint vertical_padding;
+  guint horizontal_padding;
+  gboolean double_arrows;
 
   widget = GTK_WIDGET (menu);
 
@@ -3663,19 +3918,93 @@
 
   gtk_widget_style_get (GTK_WIDGET (menu),
  			"vertical-padding", &vertical_padding,
+			"horizontal-padding", &horizontal_padding,
+			"double_arrows", &double_arrows,
  			NULL);
   
   border_width = GTK_CONTAINER (menu)->border_width;
-  view_width -= (border_width + widget->style->xthickness) * 2;
+  view_width -= (border_width + widget->style->xthickness + horizontal_padding) * 2;
   view_height -= (border_width + widget->style->ythickness + vertical_padding) * 2;
   menu_height = widget->requisition.height -
       (border_width + widget->style->ythickness + vertical_padding) * 2;
 
-  x = border_width + widget->style->xthickness;
+  x = border_width + widget->style->xthickness + horizontal_padding;
   y = border_width + widget->style->ythickness + vertical_padding;
 
+  if (double_arrows && !menu->tearoff_active && (view_height < menu_height))
+  {
+    GtkMenuPrivate *priv;
+    GtkStateType upper_arrow_previous_state, lower_arrow_previous_state;
+    
+    priv = gtk_menu_get_private (menu);
+    
+    upper_arrow_previous_state = priv->upper_arrow_state;
+    lower_arrow_previous_state = priv->lower_arrow_state;
+    
+    if (!menu->upper_arrow_visible || !menu->lower_arrow_visible)
+      gtk_widget_queue_draw (GTK_WIDGET (menu));
+    
+    view_height -= 2*MENU_SCROLL_ARROW_HEIGHT;
+    y += MENU_SCROLL_ARROW_HEIGHT;
+
+    menu->upper_arrow_visible = menu->lower_arrow_visible = TRUE;    
+    if (priv->upper_arrow_state == GTK_STATE_INSENSITIVE)
+      {
+        priv->upper_arrow_state = menu->upper_arrow_prelight ?
+                                    GTK_STATE_PRELIGHT : GTK_STATE_NORMAL;
+      }
+    if (priv->lower_arrow_state == GTK_STATE_INSENSITIVE)
+      {
+        priv->lower_arrow_state = menu->lower_arrow_prelight ?
+                                    GTK_STATE_PRELIGHT : GTK_STATE_NORMAL;
+      }
+
+    if (offset <= 0) 
+    {
+      offset = 0;
+      priv->upper_arrow_state = GTK_STATE_INSENSITIVE;
+    }
+    if (offset >= menu_height - view_height)
+    { 
+      offset = menu_height - view_height;
+      priv->lower_arrow_state = GTK_STATE_INSENSITIVE;
+    }
+    
+    if ((priv->upper_arrow_state != upper_arrow_previous_state) ||
+        (priv->lower_arrow_state != lower_arrow_previous_state))
+      gtk_widget_queue_draw (GTK_WIDGET (menu));
+    
+    if (upper_arrow_previous_state != GTK_STATE_INSENSITIVE &&
+	priv->upper_arrow_state == GTK_STATE_INSENSITIVE)
+      {
+	/* If we hid the upper arrow, possibly remove timeout */
+	if (menu->scroll_step < 0)
+	  {
+	    gtk_menu_stop_scrolling (menu);
+	    gtk_widget_queue_draw (GTK_WIDGET (menu));
+	  }
+      }
+
+    if (lower_arrow_previous_state != GTK_STATE_INSENSITIVE &&
+	priv->lower_arrow_state == GTK_STATE_INSENSITIVE)
+      {
+	/* If we hid the lower arrow, possibly remove timeout */
+	if (menu->scroll_step > 0)
+	  {
+	    gtk_menu_stop_scrolling (menu);
+	    gtk_widget_queue_draw (GTK_WIDGET (menu));
+	  }
+      }
+  }
+  else
   if (!menu->tearoff_active)
     {
+      if (offset <= 0) 
+        offset = 0;
+
+      if (offset >= menu_height - view_height)
+        offset = menu_height - view_height;
+
       last_visible = menu->upper_arrow_visible;
       menu->upper_arrow_visible = offset > 0;
       
@@ -3685,8 +4014,6 @@
       if ( (last_visible != menu->upper_arrow_visible) &&
 	   !menu->upper_arrow_visible)
 	{
-	  menu->upper_arrow_prelight = FALSE;
-	  
 	  /* If we hid the upper arrow, possibly remove timeout */
 	  if (menu->scroll_step < 0)
 	    {
@@ -3704,8 +4031,6 @@
       if ( (last_visible != menu->lower_arrow_visible) &&
 	   !menu->lower_arrow_visible)
 	{
-	  menu->lower_arrow_prelight = FALSE;
-	  
 	  /* If we hid the lower arrow, possibly remove timeout */
 	  if (menu->scroll_step > 0)
 	    {
@@ -3792,12 +4117,14 @@
 			    &child_offset, &child_height, &last_child))
     {
       guint vertical_padding;
+      gboolean double_arrows;
       
       y = menu->scroll_offset;
       gdk_drawable_get_size (GTK_WIDGET (menu)->window, &width, &height);
 
       gtk_widget_style_get (GTK_WIDGET (menu),
 			    "vertical-padding", &vertical_padding,
+			    "double_arrows", &double_arrows,
 			    NULL);
 			    
       height -= 2*GTK_CONTAINER (menu)->border_width + 2*GTK_WIDGET (menu)->style->ythickness + 2*vertical_padding;
@@ -3820,11 +4147,11 @@
 	  if (child_offset + child_height > y + height - arrow_height)
 	    {
 	      arrow_height = 0;
-	      if (!last_child && !menu->tearoff_active)
+	      if ((!last_child && !menu->tearoff_active) || (double_arrows))
 		arrow_height += MENU_SCROLL_ARROW_HEIGHT;
 	      
 	      y = child_offset + child_height - height + arrow_height;
-	      if ((y > 0) && !menu->tearoff_active)
+	      if (((y > 0) && !menu->tearoff_active) || (double_arrows))
 		{
 		  /* Need upper arrow */
 		  arrow_height += MENU_SCROLL_ARROW_HEIGHT;
@@ -4374,3 +4701,118 @@
   return list;
 }
 
+/* Little help function for making some sanity tests on this menu.
+ * Checks that given widget really is a menu and that it has no name 
+ * assigned to it yet.
+ * Names used to do hildon theming:
+ * HILDON_MENU_NAME_SHARP for menu with sharp upper corners
+ * HILDON_MENU_NAME_ROUND for menu with round corners
+ */
+static gboolean 
+gtk_menu_check_name (GtkWidget *widget) 
+{
+  gboolean legal_name = FALSE;
+  gchar **tmp = NULL;
+  const gchar *name = NULL;
+  static gchar *menu_names[] = { "GtkMenu",
+				 HILDON_MENU_NAME_SHARP,
+				 HILDON_MENU_NAME_ROUND,
+				 HILDON_MENU_NAME_ROUND_FIRST_LEVEL,
+				 NULL };
+  if (GTK_IS_MENU (widget) &&
+       (name = gtk_widget_get_name (widget)))
+    {
+      if (!g_ascii_strcasecmp (name, HILDON_MENU_NAME_FORCE_SHARP) || !g_ascii_strcasecmp (name, HILDON_MENU_NAME_FORCE_ROUND))
+	return FALSE;
+      for (tmp = menu_names; *tmp; tmp++) 
+        if (!g_ascii_strcasecmp (name, *tmp ))
+	  {
+  	    legal_name = TRUE;
+	    break;
+          }
+    }
+
+  return legal_name;
+}
+
+/* Hildon function to make context menus behave according to spec */
+void
+_gtk_menu_enable_context_menu_behavior (GtkMenu *menu)
+{
+  GtkMenuPrivate *priv = gtk_menu_get_private (menu);
+
+  priv->context_menu = TRUE;
+}
+
+static gboolean
+gtk_menu_window_visibility_notify_event (GtkWidget          *widget,
+                                         GdkEventVisibility *event,
+                                         GtkMenu            *menu)
+{
+  GtkMenuShell *menu_shell;
+  GdkScreen *screen;
+  GList *stack;
+  gboolean deactivate;
+
+  /* The point here is to close the menu if another window (eg. dialog,
+     even partially!) gets on top of the menu. However our own submenus may
+     also fully obscure us, so we have to check that case.
+
+     It's also possible that we get here while a submenu was opened and
+     closed quickly, so we don't really see it anymore but its window is
+     still obscuring us.. So, never close the menu if another menu is on top
+     of us. */
+  if (event->state == GDK_VISIBILITY_UNOBSCURED)
+    return FALSE;
+
+  menu_shell = GTK_MENU_SHELL (menu);
+
+  screen = gtk_widget_get_screen (widget);
+
+  deactivate = FALSE;
+
+  /* Inspect windows above us */
+  stack = gdk_screen_get_window_stack (screen);
+  if (stack != NULL)
+    {
+      GList *iter;
+
+      iter = g_list_last (stack);
+
+      while (iter)
+        {
+          GdkWindow *win = iter->data;
+          GdkWindowTypeHint type;
+
+          if (win == widget->window)
+            break;
+
+          gdk_error_trap_push ();
+          type = gdk_window_get_type_hint (win);
+          if (!gdk_error_trap_pop () &&
+              (type != GDK_WINDOW_TYPE_HINT_MESSAGE)
+              && (type != GDK_WINDOW_TYPE_HINT_MENU)
+              && gdk_window_is_visible (win))
+            {
+              /* A non-message and non-menu window above us; close. */
+              deactivate = TRUE;
+
+              break;
+            }
+
+          iter = iter->prev;
+        }
+
+      g_list_foreach (stack, (GFunc) g_object_unref, NULL);
+      g_list_free (stack);
+    }
+
+  if (deactivate)
+    {
+      gtk_menu_shell_deactivate (menu_shell);
+
+      return TRUE;
+    }
+
+  return FALSE;
+}
--- gtk+/gtk/gtkrc.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkrc.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -56,6 +56,7 @@
 #include "gtkprivate.h"
 #include "gtksettings.h"
 #include "gtkwindow.h"
+#include "gtkhashtable.h"
 
 #ifdef G_OS_WIN32
 #include <io.h>
@@ -105,6 +106,14 @@
   GtkStyle *default_style;
 };
 
+#define GTK_RC_STYLE_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GTK_TYPE_RC_STYLE, GtkRcStylePrivate))
+
+typedef struct _GtkRcStylePrivate GtkRcStylePrivate;
+
+struct _GtkRcStylePrivate {
+  GSList *logical_color_hashes;
+};
+
 static GtkRcContext *gtk_rc_context_get              (GtkSettings     *settings);
 
 static guint       gtk_rc_style_hash                 (const gchar     *name);
@@ -179,6 +188,13 @@
 						      GScanner        *scanner,
                                                       GtkRcStyle      *rc_style,
                                                       GtkIconFactory  *factory);
+static guint       gtk_rc_parse_logical_color        (GScanner        *scanner,
+                                                              GtkRcStyle      *rc_style,
+                                                             GtkHashTable    *hash);
+static guint       gtk_rc_parse_color_full           (GScanner        *scanner,
+                                                             GdkColor        *color,
+                                                             GtkRcStyle      *style);
+
 static void        gtk_rc_clear_hash_node            (gpointer         key,
                                                       gpointer         data,
                                                       gpointer         user_data);
@@ -277,7 +293,8 @@
   { "stock", GTK_RC_TOKEN_STOCK },
   { "im_module_file", GTK_RC_TOKEN_IM_MODULE_FILE },
   { "LTR", GTK_RC_TOKEN_LTR },
-  { "RTL", GTK_RC_TOKEN_RTL }
+  { "RTL", GTK_RC_TOKEN_RTL },
+  { "logical_color", GTK_RC_TOKEN_LOGICAL_COLOR }
 };
 
 static GHashTable *realized_style_ht = NULL;
@@ -954,6 +971,7 @@
 static void
 gtk_rc_style_init (GtkRcStyle *style)
 {
+  GtkRcStylePrivate *priv = GTK_RC_STYLE_GET_PRIVATE (style);
   guint i;
 
   style->name = NULL;
@@ -976,6 +994,7 @@
 
   style->rc_style_lists = NULL;
   style->icon_factories = NULL;
+  priv->logical_color_hashes = NULL;
 }
 
 static void
@@ -991,6 +1010,21 @@
   klass->create_rc_style = gtk_rc_style_real_create_rc_style;
   klass->merge = gtk_rc_style_real_merge;
   klass->create_style = gtk_rc_style_real_create_style;
+
+  g_type_class_add_private (object_class, sizeof (GtkRcStylePrivate));
+}
+
+static void
+free_object_list (GSList *list)
+{
+  GSList *tmp_list = list;
+  while (tmp_list)
+    {
+      g_object_unref (tmp_list->data);
+      tmp_list = tmp_list->next;
+    }
+  g_slist_free (list);
+  
 }
 
 static void
@@ -998,9 +1032,11 @@
 {
   GSList *tmp_list1, *tmp_list2;
   GtkRcStyle *rc_style;
+  GtkRcStylePrivate *rc_priv;
   gint i;
 
   rc_style = GTK_RC_STYLE (object);
+  rc_priv = GTK_RC_STYLE_GET_PRIVATE (rc_style);
   
   if (rc_style->name)
     g_free (rc_style->name);
@@ -1059,13 +1095,8 @@
       rc_style->rc_properties = NULL;
     }
 
-  tmp_list1 = rc_style->icon_factories;
-  while (tmp_list1)
-    {
-      g_object_unref (tmp_list1->data);
-      tmp_list1 = tmp_list1->next;
-    }
-  g_slist_free (rc_style->icon_factories);
+  free_object_list (rc_style->icon_factories);
+  free_object_list (rc_priv->logical_color_hashes);
   
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
@@ -1125,6 +1156,14 @@
   return g_object_new (G_OBJECT_TYPE (style), NULL);
 }
 
+GSList *
+_gtk_rc_style_get_logical_color_hashes (GtkRcStyle *rc_style)
+{
+  GtkRcStylePrivate *priv = GTK_RC_STYLE_GET_PRIVATE (rc_style);
+
+  return priv->logical_color_hashes;
+}
+
 static gint
 gtk_rc_properties_cmp (gconstpointer bsearch_node1,
 		       gconstpointer bsearch_node2)
@@ -1463,7 +1502,7 @@
 	  if (!rc_file->is_string)
 	    {
 	      if (!g_lstat (rc_file->name, &statbuf) && 
-		  (statbuf.st_mtime > rc_file->mtime))
+		  (statbuf.st_mtime != rc_file->mtime))
 		{
 		  mtime_modified = TRUE;
 		  break;
@@ -1499,6 +1538,22 @@
       context->rc_files = NULL;
 
       gtk_rc_parse_default_files (context);
+/*Hildon- Swapped these sections of code, so the styles from the
+  XSettings theme are available when parsing with gtk_rc_context_parse_string*/
+      g_free (context->theme_name);
+      g_free (context->key_theme_name);
+
+      g_object_get (context->settings,
+		    "gtk-theme-name", &context->theme_name,
+		    "gtk-key-theme-name", &context->key_theme_name,
+		    NULL);
+
+      if (context->theme_name && context->theme_name[0])
+	gtk_rc_parse_named (context, context->theme_name, NULL);
+      if (context->key_theme_name && context->key_theme_name[0])
+	gtk_rc_parse_named (context, context->key_theme_name, "key");
+ 
+/*****/
 
       tmp_list = global_rc_files;
       while (tmp_list)
@@ -1512,19 +1567,6 @@
 
 	  tmp_list = tmp_list->next;
 	}
-
-      g_free (context->theme_name);
-      g_free (context->key_theme_name);
-
-      g_object_get (context->settings,
-		    "gtk-theme-name", &context->theme_name,
-		    "gtk-key-theme-name", &context->key_theme_name,
-		    NULL);
-
-      if (context->theme_name && context->theme_name[0])
-	gtk_rc_parse_named (context, context->theme_name, NULL);
-      if (context->key_theme_name && context->key_theme_name[0])
-	gtk_rc_parse_named (context, context->key_theme_name, "key");
       
       g_object_thaw_notify (G_OBJECT (context->settings));
 
@@ -1905,6 +1947,7 @@
 {
   GScanner *scanner;
   guint	   i;
+  gchar    *name_str;
   gboolean done;
 
   scanner = gtk_rc_scanner_new ();
@@ -1914,6 +1957,14 @@
       g_assert (input_string == NULL);
       
       g_scanner_input_file (scanner, input_fd);
+
+      if (input_name != NULL)
+        {
+          name_str = (gchar *) g_malloc(strlen(input_name) + 7);
+	  sprintf (name_str, "%s.cache", input_name);
+	  osso_g_scanner_cache_open (scanner, name_str);
+	  g_free (name_str);
+	}
     }
   else
     {
@@ -2062,6 +2113,29 @@
   return style;
 }
 
+static GSList *
+concat_object_lists (GSList *list_a, GSList *list_b)
+{
+  GSList *copy;
+  
+  copy = g_slist_copy (list_b);
+  if (copy)
+    {
+      GSList *iter;
+              
+      iter = copy;
+      while (iter != NULL)
+        {
+          g_object_ref (iter->data);
+          iter = g_slist_next (iter);
+        }
+
+      return g_slist_concat (list_a, copy);
+    }
+  else
+    return list_a;
+}
+
 /* Reuses or frees rc_styles */
 static GtkStyle *
 gtk_rc_init_style (GtkRcContext *context,
@@ -2083,6 +2157,7 @@
       GtkRcStyle *base_style = NULL;
       GtkRcStyle *proto_style;
       GtkRcStyleClass *proto_style_class;
+      GtkRcStylePrivate *proto_priv;
       GSList *tmp_styles;
       GType rc_style_type = GTK_TYPE_RC_STYLE;
 
@@ -2109,12 +2184,13 @@
       
       proto_style_class = GTK_RC_STYLE_GET_CLASS (base_style);
       proto_style = proto_style_class->create_rc_style (base_style);
+      proto_priv = GTK_RC_STYLE_GET_PRIVATE (proto_style);
       
       tmp_styles = rc_styles;
       while (tmp_styles)
 	{
 	  GtkRcStyle *rc_style = tmp_styles->data;
-          GSList *factories;
+	  GtkRcStylePrivate *rc_priv = GTK_RC_STYLE_GET_PRIVATE (rc_style);
           
 	  proto_style_class->merge (proto_style, rc_style);	  
           
@@ -2122,22 +2198,12 @@
 	  if (!g_slist_find (rc_style->rc_style_lists, rc_styles))
 	    rc_style->rc_style_lists = g_slist_prepend (rc_style->rc_style_lists, rc_styles);
 
-          factories = g_slist_copy (rc_style->icon_factories);
-          if (factories)
-            {
-              GSList *iter;
-              
-              iter = factories;
-              while (iter != NULL)
-                {
-                  g_object_ref (iter->data);
-                  iter = g_slist_next (iter);
-                }
-
-              proto_style->icon_factories = g_slist_concat (proto_style->icon_factories,
-                                                            factories);
-
-            }
+          proto_style->icon_factories =
+                concat_object_lists (proto_style->icon_factories,
+                                     rc_style->icon_factories);
+	  proto_priv->logical_color_hashes =
+                concat_object_lists (proto_priv->logical_color_hashes,
+                                     rc_priv->logical_color_hashes);
           
 	  tmp_styles = tmp_styles->next;
 	}
@@ -2515,9 +2581,11 @@
   GtkRcStyle *rc_style;
   GtkRcStyle *orig_style;
   GtkRcStyle *parent_style;
+  GtkRcStylePrivate *rc_priv = NULL;
   guint token;
   gint i;
   GtkIconFactory *our_factory = NULL;
+  GtkHashTable *our_hash = NULL;
   
   token = g_scanner_get_next_token (scanner);
   if (token != GTK_RC_TOKEN_STYLE)
@@ -2533,12 +2601,6 @@
   else
     orig_style = NULL;
 
-  /* If there's a list, its first member is always the factory belonging
-   * to this RcStyle
-   */
-  if (rc_style && rc_style->icon_factories)
-    our_factory = rc_style->icon_factories->data;
-  
   if (!rc_style)
     {
       rc_style = gtk_rc_style_new ();
@@ -2550,6 +2612,16 @@
       for (i = 0; i < 5; i++)
 	rc_style->color_flags[i] = 0;
     }
+  
+  rc_priv = GTK_RC_STYLE_GET_PRIVATE (rc_style);
+
+  /* If there's a list, its first member is always the factory belonging
+   * to this RcStyle
+   */
+  if (rc_style->icon_factories)
+    our_factory = rc_style->icon_factories->data;
+  if (rc_priv->logical_color_hashes)
+    our_hash = rc_priv->logical_color_hashes->data;
 
   token = g_scanner_peek_next_token (scanner);
   if (token == G_TOKEN_EQUAL_SIGN)
@@ -2566,8 +2638,8 @@
       parent_style = gtk_rc_style_find (context, scanner->value.v_string);
       if (parent_style)
 	{
-          GSList *factories;
-          
+	  GtkRcStylePrivate *parent_priv = GTK_RC_STYLE_GET_PRIVATE (parent_style); 
+
 	  for (i = 0; i < 5; i++)
 	    {
 	      rc_style->color_flags[i] = parent_style->color_flags[i];
@@ -2621,17 +2693,24 @@
                   rc_style->icon_factories = g_slist_prepend (rc_style->icon_factories,
                                                               our_factory);
                 }
-              
-              rc_style->icon_factories = g_slist_concat (rc_style->icon_factories,
-                                                         g_slist_copy (parent_style->icon_factories));
-              
-              factories = parent_style->icon_factories;
-              while (factories != NULL)
+              rc_style->icon_factories = concat_object_lists (rc_style->icon_factories,
+                                                              parent_style->icon_factories);
+            }
+
+	  /* Also append parent's color hashes, adding a ref to them */
+          if (parent_priv->logical_color_hashes != NULL)
+            {
+	      /* See comment above .. */
+              if (our_hash == NULL)
                 {
-                  g_object_ref (factories->data);
-                  factories = factories->next;
+                  our_hash = _gtk_hash_table_new ();
+                  rc_priv->logical_color_hashes = g_slist_prepend (rc_priv->logical_color_hashes,
+                                                                    our_hash);
                 }
-            }
+               
+              rc_priv->logical_color_hashes = concat_object_lists (rc_priv->logical_color_hashes,
+                                                                    parent_priv->logical_color_hashes);           
+          }
 	}
     }
   
@@ -2689,12 +2768,22 @@
             }
           token = gtk_rc_parse_stock (context, scanner, rc_style, our_factory);
           break;
+    case GTK_RC_TOKEN_LOGICAL_COLOR:
+	  if (our_hash == NULL)
+	    {
+	      our_hash = _gtk_hash_table_new ();
+	      rc_priv->logical_color_hashes = g_slist_prepend (rc_priv->logical_color_hashes,
+								our_hash);
+	    }
+	  token = gtk_rc_parse_logical_color (scanner, rc_style, our_hash);
+	  break;
 	case G_TOKEN_IDENTIFIER:
 	  if (is_c_identifier (scanner->next_value.v_identifier) &&
 	      scanner->next_value.v_identifier[0] >= 'A' &&
 	      scanner->next_value.v_identifier[0] <= 'Z') /* match namespaced type names */
 	    {
 	      GtkRcProperty prop = { 0, 0, NULL, { 0, }, };
+              gchar *name;
 	      
 	      g_scanner_get_next_token (scanner); /* eat type name */
 	      prop.type_name = g_quark_from_string (scanner->value.v_identifier);
@@ -2712,8 +2801,10 @@
 		}
 
 	      /* it's important that we do the same canonification as GParamSpecPool here */
-	      g_strcanon (scanner->value.v_identifier, G_CSET_A_2_Z G_CSET_a_2_z G_CSET_DIGITS "-", '-');
-	      prop.property_name = g_quark_from_string (scanner->value.v_identifier);
+              name = g_strdup (scanner->value.v_identifier);
+              g_strcanon (name, G_CSET_A_2_Z G_CSET_a_2_z G_CSET_DIGITS "-", '-');
+              prop.property_name = g_quark_from_string (name);
+              g_free (name);
 
 	      token = gtk_rc_parse_assignment (scanner, &prop);
 	      if (token == G_TOKEN_NONE)
@@ -2825,7 +2916,7 @@
     return G_TOKEN_EQUAL_SIGN;
 
   style->color_flags[state] |= GTK_RC_BG;
-  return gtk_rc_parse_color (scanner, &style->bg[state]);
+  return gtk_rc_parse_color_full (scanner, &style->bg[state], style);
 }
 
 static guint
@@ -2848,7 +2939,7 @@
     return G_TOKEN_EQUAL_SIGN;
   
   style->color_flags[state] |= GTK_RC_FG;
-  return gtk_rc_parse_color (scanner, &style->fg[state]);
+  return gtk_rc_parse_color_full (scanner, &style->fg[state], style);
 }
 
 static guint
@@ -2871,7 +2962,7 @@
     return G_TOKEN_EQUAL_SIGN;
   
   style->color_flags[state] |= GTK_RC_TEXT;
-  return gtk_rc_parse_color (scanner, &style->text[state]);
+  return gtk_rc_parse_color_full (scanner, &style->text[state], style);
 }
 
 static guint
@@ -2894,7 +2985,7 @@
     return G_TOKEN_EQUAL_SIGN;
 
   style->color_flags[state] |= GTK_RC_BASE;
-  return gtk_rc_parse_color (scanner, &style->base[state]);
+  return gtk_rc_parse_color_full (scanner, &style->base[state], style);
 }
 
 static guint
@@ -3345,11 +3436,45 @@
 
   return G_TOKEN_NONE;
 }
+static gboolean
+lookup_logical_color (GtkRcStyle *style,
+		      const char *color_name,
+		      GdkColor   *color)
+{
+  GtkRcStylePrivate *priv = GTK_RC_STYLE_GET_PRIVATE (style);
+  GSList *iter;
+
+  iter = priv->logical_color_hashes;
+  while (iter != NULL)
+    {
+      GdkColor *match = g_hash_table_lookup (GTK_HASH_TABLE (iter->data)->hash,
+					     color_name);
+      if (match)
+	{
+	  color->red = match->red;
+	  color->green = match->green;
+	  color->blue = match->blue;
+	  return TRUE;
+        }
+
+      iter = g_slist_next (iter);
+    }
+
+  return FALSE;
+}
 
 guint
 gtk_rc_parse_color (GScanner *scanner,
 		    GdkColor *color)
 {
+    return gtk_rc_parse_color_full (scanner, color, NULL);
+}
+
+static guint
+gtk_rc_parse_color_full (GScanner *scanner,
+		         GdkColor *color,
+		         GtkRcStyle *style)
+{
   guint token;
 
   g_return_val_if_fail (scanner != NULL, G_TOKEN_ERROR);
@@ -3407,11 +3532,14 @@
     case G_TOKEN_STRING:
       if (!gdk_color_parse (scanner->value.v_string, color))
 	{
-	  g_scanner_warn (scanner, "Invalid color constant '%s'",
-			  scanner->value.v_string);
-	  return G_TOKEN_STRING;
+	  if (!(style && lookup_logical_color (style, scanner->value.v_string, color)))
+	    {
+	      g_scanner_warn (scanner, "Invalid color constant '%s'",
+			      scanner->value.v_string);
+	      return G_TOKEN_STRING;
+	    }
 	}
-      else
+
 	return G_TOKEN_NONE;
       
     default:
@@ -3625,8 +3753,8 @@
 }
 
 static guint
-gtk_rc_parse_stock_id (GScanner	 *scanner,
-                       gchar    **stock_id)
+gtk_rc_parse_hash_key (GScanner *scanner,
+                       gchar    **hash_key)
 {
   guint token;
   
@@ -3639,12 +3767,12 @@
   if (token != G_TOKEN_STRING)
     return G_TOKEN_STRING;
   
-  *stock_id = g_strdup (scanner->value.v_string);
+  *hash_key = g_strdup (scanner->value.v_string);
   
   token = g_scanner_get_next_token (scanner);
   if (token != G_TOKEN_RIGHT_BRACE)
     {
-      g_free (*stock_id);
+      g_free (*hash_key);
       return G_TOKEN_RIGHT_BRACE;
     }
   
@@ -3854,7 +3982,7 @@
   if (token != GTK_RC_TOKEN_STOCK)
     return GTK_RC_TOKEN_STOCK;
   
-  token = gtk_rc_parse_stock_id (scanner, &stock_id);
+  token = gtk_rc_parse_hash_key (scanner, &stock_id);
   if (token != G_TOKEN_NONE)
     return token;
   
@@ -3965,3 +4093,46 @@
 }
 
 #endif
+
+static guint
+gtk_rc_parse_logical_color (GScanner     *scanner,
+		GtkRcStyle   *rc_style,
+		GtkHashTable *hash)
+{
+	gchar *color_id = NULL;
+	guint token;
+	GdkColor *color;
+
+	token = g_scanner_get_next_token (scanner);
+	if (token != GTK_RC_TOKEN_LOGICAL_COLOR)
+		return GTK_RC_TOKEN_LOGICAL_COLOR;
+
+	token = gtk_rc_parse_hash_key (scanner, &color_id);
+	if (token != G_TOKEN_NONE)
+		return token;
+
+	token = g_scanner_get_next_token (scanner);
+	if (token != G_TOKEN_EQUAL_SIGN)
+	{
+		g_free (color_id);
+		return G_TOKEN_EQUAL_SIGN;
+	}
+
+	color = g_new (GdkColor, 1);
+	token = gtk_rc_parse_color_full (scanner, color, rc_style);
+	if (token != G_TOKEN_NONE)
+	{
+		g_free (color_id);
+		g_free (color);
+		return token;
+	}
+
+	/* Because the hash is created with destroy functions,
+	 * g_hash_table_insert will free any old values for us,
+	 * if a mapping with the specified key already exists. */
+	g_hash_table_insert (hash->hash, color_id, color);
+
+	return G_TOKEN_NONE;
+}
+
+
--- gtk+/gtk/gtkmenu.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkmenu.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -130,7 +130,7 @@
 					   GtkWidget	       *parent_menu_item,
 					   GtkMenuPositionFunc	func,
 					   gpointer		data,
-					   guint		button,
+					   guint		button, /* unused */
 					   guint32		activate_time);
 
 /* Position the menu according to its position function. Called
@@ -200,6 +200,9 @@
                                            gint                 monitor_num);
 GList*     gtk_menu_get_for_attach_widget (GtkWidget           *widget); 
 
+/* Private functions */
+void _gtk_menu_enable_context_menu_behavior (GtkMenu *menu);
+
 #ifndef GTK_DISABLE_DEPRECATED
 #define gtk_menu_append(menu,child)	gtk_menu_shell_append  ((GtkMenuShell *)(menu),(child))
 #define gtk_menu_prepend(menu,child)    gtk_menu_shell_prepend ((GtkMenuShell *)(menu),(child))
--- gtk+/gtk/gtkrc.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkrc.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -211,6 +211,7 @@
   GTK_RC_TOKEN_STOCK,
   GTK_RC_TOKEN_LTR,
   GTK_RC_TOKEN_RTL,
+  GTK_RC_TOKEN_LOGICAL_COLOR,
   GTK_RC_TOKEN_LAST
 } GtkRcTokenType;
 
@@ -241,6 +242,8 @@
 
 const gchar* _gtk_rc_context_get_default_font_name (GtkSettings *settings);
 
+GSList *_gtk_rc_style_get_logical_color_hashes (GtkRcStyle *rc_style);
+
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
--- gtk+/gtk/gtkseparatortoolitem.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkseparatortoolitem.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -29,6 +29,7 @@
 #include "gtktoolbar.h"
 
 #define MENU_ID "gtk-separator-tool-item-menu-id"
+#define HILDON_SEPARATOR_HEIGHT 40
 
 enum {
   PROP_0,
@@ -137,6 +138,18 @@
 							 P_("Whether the separator is drawn, or just blank"),
 							 TRUE,
 							 G_PARAM_READWRITE));
+  /* Hildon addition : some new style properties we need. */
+  gtk_widget_class_install_style_property(widget_class,
+					   g_param_spec_int ("separator_size",
+							      P_("Separator size"), P_("The thickness of the separator. -1 for default behaviour."),
+							     -1, G_MAXINT, -1, G_PARAM_READWRITE));
+
+  gtk_widget_class_install_style_property (widget_class,
+				   g_param_spec_boolean ("is_image",
+							 P_("Is separator an image or a line"),
+							 P_("Whether the separator is drawn as an image, or just as a line"),
+							 FALSE,
+							 G_PARAM_READWRITE));
   
   g_type_class_add_private (object_class, sizeof (GtkSeparatorToolItemPrivate));
 }
@@ -213,14 +226,26 @@
   GtkToolItem *item = GTK_TOOL_ITEM (widget);
   GtkOrientation orientation = gtk_tool_item_get_orientation (item);
   
+  /* Hildon modifications from here on:
+   * if the "separator_size" style property
+   * is the default value (it has not been set
+   * in resource files), use default gtk+ behaviour.
+   */
+  gint separator_size = -1;
+  
+  gtk_widget_style_get( widget, "separator_size", &separator_size, NULL );
+  
+  if (separator_size == -1)
+    separator_size = get_space_size (item);
+
   if (orientation == GTK_ORIENTATION_HORIZONTAL)
     {
-      requisition->width = get_space_size (item);
+      requisition->width = separator_size;
       requisition->height = 1;
     }
   else
     {
-      requisition->height = get_space_size (item);
+      requisition->height = separator_size;
       requisition->width = 1;
     }
 }
@@ -235,10 +260,30 @@
 
   if (priv->draw)
     {
+      gboolean is_image = FALSE;
       if (widget->parent && GTK_IS_TOOLBAR (widget->parent))
 	toolbar = GTK_TOOLBAR (widget->parent);
 
-      _gtk_toolbar_paint_space_line (widget, toolbar,
+      gtk_widget_style_get( widget, "is_image", &is_image, NULL );
+      if (is_image)
+      {
+        gint separator_size = -1;
+        GtkOrientation orientation = gtk_tool_item_get_orientation (GTK_TOOL_ITEM (widget));
+        
+        gtk_widget_style_get( widget, "separator_size", &separator_size, NULL );
+        
+        /* if style property not set, use gtk+
+         * default behaviour. */
+        if (separator_size == -1)
+          separator_size = get_space_size (GTK_TOOL_ITEM (widget));
+        	
+        gtk_paint_box( widget->style, widget->window, GTK_WIDGET_STATE(widget),
+          GTK_SHADOW_NONE, &event->area, widget,
+          orientation == GTK_ORIENTATION_HORIZONTAL ? "vertical" : "horizontal",
+          widget->allocation.x, widget->allocation.y + (widget->allocation.height - HILDON_SEPARATOR_HEIGHT) / 2,
+          separator_size, HILDON_SEPARATOR_HEIGHT );
+      } else
+        _gtk_toolbar_paint_space_line (widget, toolbar,
 				     &(event->area), &widget->allocation);
     }
   
--- gtk+/gtk/gtktreeview.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtktreeview.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -42,6 +42,8 @@
 #include "gtkentry.h"
 #include "gtkframe.h"
 #include "gtktreemodelsort.h"
+#include "gtkscrolledwindow.h"
+#include "gtkprivate.h"
 
 #define GTK_TREE_VIEW_PRIORITY_VALIDATE (GDK_PRIORITY_REDRAW + 5)
 #define GTK_TREE_VIEW_PRIORITY_SCROLL_SYNC (GTK_TREE_VIEW_PRIORITY_VALIDATE + 2)
@@ -114,6 +116,7 @@
   EXPAND_COLLAPSE_CURSOR_ROW,
   SELECT_CURSOR_PARENT,
   START_INTERACTIVE_SEARCH,
+  ROW_INSENSITIVE,
   LAST_SIGNAL
 };
 
@@ -132,7 +135,10 @@
   PROP_SEARCH_COLUMN,
   PROP_FIXED_HEIGHT_MODE,
   PROP_HOVER_SELECTION,
-  PROP_HOVER_EXPAND
+  PROP_HOVER_EXPAND,
+  PROP_DOTTED_LINES,
+  PROP_FORCE_LIST_KLUDGE,
+  PROP_ALLOW_CHECKBOX_MODE
 };
 
 static void     gtk_tree_view_class_init           (GtkTreeViewClass *klass);
@@ -192,6 +198,8 @@
 						    GtkStyle         *previous_style);
 static void     gtk_tree_view_grab_notify          (GtkWidget        *widget,
 						    gboolean          was_grabbed);
+static gboolean gtk_tree_view_tap_and_hold_query   (GtkWidget        *widget,
+                                                    GdkEvent         *event);
 
 /* container signals */
 static void     gtk_tree_view_remove               (GtkContainer     *container,
@@ -338,8 +346,6 @@
 static void     gtk_tree_view_clamp_node_visible             (GtkTreeView       *tree_view,
 							      GtkRBTree         *tree,
 							      GtkRBNode         *node);
-static void     gtk_tree_view_clamp_column_visible           (GtkTreeView       *tree_view,
-							      GtkTreeViewColumn *column);
 static gboolean gtk_tree_view_maybe_begin_dragging_row       (GtkTreeView       *tree_view,
 							      GdkEventMotion    *event);
 static void     gtk_tree_view_focus_to_cursor                (GtkTreeView       *tree_view);
@@ -372,6 +378,18 @@
                                                               gpointer           data);
 static gboolean expand_collapse_timeout                      (gpointer           data);
 static gboolean do_expand_collapse                           (GtkTreeView       *tree_view);
+static void update_checkbox_mode                             (GObject *object,
+                                                              GParamSpec *pspec,
+                                                              gpointer data);
+static void set_dotted_lines                                 (GtkTreeView       *tree_view,
+                                                              gboolean           enable);
+static void selection_changed                                (GtkTreeSelection  *selection,
+                                                              gpointer           data);
+static void check_if_can_focus                               (GtkTreeView       *tree_view);
+static gint scroll_row_timeout                               (gpointer           data);
+
+static void add_scroll_timeout                               (GtkTreeView *tree_view);
+static void remove_scroll_timeout                            (GtkTreeView *tree_view);
 
 /* interactive search */
 static void     gtk_tree_view_ensure_interactive_directory (GtkTreeView *tree_view);
@@ -534,6 +552,7 @@
   widget_class->grab_focus = gtk_tree_view_grab_focus;
   widget_class->style_set = gtk_tree_view_style_set;
   widget_class->grab_notify = gtk_tree_view_grab_notify;
+  widget_class->tap_and_hold_query = gtk_tree_view_tap_and_hold_query;
 
   /* GtkContainer signals */
   container_class->remove = gtk_tree_view_remove;
@@ -694,8 +713,54 @@
                                                            FALSE,
                                                            G_PARAM_READWRITE));
 
+    /**
+     * GtkTreeView:dotted-lines:
+     *
+     * Enables or disables the dotted lines for hierarchical trees.
+     * Hildon patch.
+     */
+    g_object_class_install_property (o_class,
+                                     PROP_DOTTED_LINES,
+                                     g_param_spec_boolean ("dotted_lines",
+                                                           P_("Dotted Lines"),
+                                                           P_("Whether to show or hide dotted lines for hierarchical trees"),
+                                                           FALSE,
+                                                           G_PARAM_READWRITE));
+
+    /**
+     * GtkTreeView:force-list-kludge:
+     *
+     * Hildon kludge for fixing file tree behaviour until a cleaner
+     * implementation is scheduled: if this property is set, then rows
+     * can be activated by tapping even if the underlying tree model is
+     * not technically a list.
+     */
+    g_object_class_install_property (o_class,
+                                     PROP_FORCE_LIST_KLUDGE,
+                                     g_param_spec_boolean ("force_list_kludge",
+                                                           P_("Force List Behaviour"),
+                                                           P_("Whether to activate tapped focused items even if model was not a list"),
+                                                           FALSE,
+                                                           G_PARAM_READWRITE));
+
+    /**
+     * GtkTreeView:enable-checkbox-mode:
+     *
+     * Another Hildon kludge for allowing the existence of GtkTreeViews
+     * that have activatable columns but that still is not a Text Listbox
+     * in multiple selection with checkboxes mode.
+     */
+    g_object_class_install_property (o_class,
+                                     PROP_ALLOW_CHECKBOX_MODE,
+                                     g_param_spec_boolean ("allow_checkbox_mode",
+                                                           P_("Enable Checkbox Mode"),
+                                                           P_("Whether to behave like a Listbox in a multiple selection with checkboxes mode, if checkboxes exist"),
+                                                           TRUE,
+                                                           G_PARAM_READWRITE));
+
   /* Style properties */
 #define _TREE_VIEW_EXPANDER_SIZE 12
+#define _TREE_VIEW_EXPANDER_INDENT 10
 #define _TREE_VIEW_VERTICAL_SEPARATOR 2
 #define _TREE_VIEW_HORIZONTAL_SEPARATOR 2
     
@@ -709,6 +774,15 @@
 							     G_PARAM_READABLE));
 
   gtk_widget_class_install_style_property (widget_class,
+                                           g_param_spec_int ("expander_indent",
+                                                             P_("Expander intent"),
+                                                             P_("Defines the expanders indent"),
+                                                             0,
+                                                             G_MAXINT,
+                                                             _TREE_VIEW_EXPANDER_INDENT,
+                                                             G_PARAM_READABLE));
+
+  gtk_widget_class_install_style_property (widget_class,
 					   g_param_spec_int ("vertical_separator",
 							     P_("Vertical Separator Width"),
 							     P_("Vertical space between cells.  Must be an even number"),
@@ -754,6 +828,13 @@
 							       GDK_TYPE_COLOR,
 G_PARAM_READABLE));
 
+  gtk_widget_class_install_style_property (widget_class,
+                                           g_param_spec_boolean ("passive_focus",
+                                                                 P_("Enables passive focus"),
+                                                                 P_("Used for tree view passive focus"),
+                                                                 TRUE,
+                                                                 G_PARAM_READABLE));
+
   /* Signals */
   widget_class->set_scroll_adjustments_signal =
     g_signal_new ("set_scroll_adjustments",
@@ -917,6 +998,16 @@
 		  _gtk_marshal_BOOLEAN__NONE,
 		  G_TYPE_BOOLEAN, 0);
 
+  tree_view_signals[ROW_INSENSITIVE] =
+     g_signal_new ("row_insensitive",
+                  G_TYPE_FROM_CLASS (o_class),
+                  G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+                  G_STRUCT_OFFSET (GtkTreeViewClass, row_insensitive),
+                  NULL, NULL,
+                  _gtk_marshal_VOID__OBJECT,
+                  G_TYPE_NONE, 1,
+                  GTK_TYPE_TREE_PATH);
+
   /* Key bindings */
   gtk_tree_view_add_move_binding (binding_set, GDK_Up, 0,
 				  GTK_MOVEMENT_DISPLAY_LINES, -1);
@@ -954,43 +1045,6 @@
   gtk_tree_view_add_move_binding (binding_set, GDK_KP_Page_Down, 0,
 				  GTK_MOVEMENT_PAGES, 1);
 
-
-  gtk_binding_entry_add_signal (binding_set, GDK_Right, 0, "move_cursor", 2,
-				G_TYPE_ENUM, GTK_MOVEMENT_VISUAL_POSITIONS,
-				G_TYPE_INT, 1);
-
-  gtk_binding_entry_add_signal (binding_set, GDK_Left, 0, "move_cursor", 2,
-				G_TYPE_ENUM, GTK_MOVEMENT_VISUAL_POSITIONS,
-				G_TYPE_INT, -1);
-
-  gtk_binding_entry_add_signal (binding_set, GDK_KP_Right, 0, "move_cursor", 2,
-				G_TYPE_ENUM, GTK_MOVEMENT_VISUAL_POSITIONS,
-				G_TYPE_INT, 1);
-
-  gtk_binding_entry_add_signal (binding_set, GDK_KP_Left, 0, "move_cursor", 2,
-				G_TYPE_ENUM, GTK_MOVEMENT_VISUAL_POSITIONS,
-				G_TYPE_INT, -1);
-
-  gtk_binding_entry_add_signal (binding_set, GDK_Right, GDK_CONTROL_MASK,
-                                "move_cursor", 2,
-				G_TYPE_ENUM, GTK_MOVEMENT_VISUAL_POSITIONS,
-				G_TYPE_INT, 1);
-
-  gtk_binding_entry_add_signal (binding_set, GDK_Left, GDK_CONTROL_MASK,
-                                "move_cursor", 2,
-				G_TYPE_ENUM, GTK_MOVEMENT_VISUAL_POSITIONS,
-				G_TYPE_INT, -1);
-
-  gtk_binding_entry_add_signal (binding_set, GDK_KP_Right, GDK_CONTROL_MASK,
-                                "move_cursor", 2,
-				G_TYPE_ENUM, GTK_MOVEMENT_VISUAL_POSITIONS,
-				G_TYPE_INT, 1);
-
-  gtk_binding_entry_add_signal (binding_set, GDK_KP_Left, GDK_CONTROL_MASK,
-                                "move_cursor", 2,
-				G_TYPE_ENUM, GTK_MOVEMENT_VISUAL_POSITIONS,
-				G_TYPE_INT, -1);
-
   gtk_binding_entry_add_signal (binding_set, GDK_space, GDK_CONTROL_MASK, "toggle_cursor_row", 0);
 
   gtk_binding_entry_add_signal (binding_set, GDK_a, GDK_CONTROL_MASK, "select_all", 0);
@@ -1004,12 +1058,13 @@
 
   gtk_binding_entry_add_signal (binding_set, GDK_space, 0, "select_cursor_row", 1,
 				G_TYPE_BOOLEAN, TRUE);
+  /* Hildon change: Enter shouldn't select
   gtk_binding_entry_add_signal (binding_set, GDK_Return, 0, "select_cursor_row", 1,
 				G_TYPE_BOOLEAN, TRUE);
   gtk_binding_entry_add_signal (binding_set, GDK_ISO_Enter, 0, "select_cursor_row", 1,
 				G_TYPE_BOOLEAN, TRUE);
   gtk_binding_entry_add_signal (binding_set, GDK_KP_Enter, 0, "select_cursor_row", 1,
-				G_TYPE_BOOLEAN, TRUE);
+				G_TYPE_BOOLEAN, TRUE);*/
 
   /* expand and collapse rows */
   gtk_binding_entry_add_signal (binding_set, GDK_plus, 0, "expand_collapse_cursor_row", 3,
@@ -1123,19 +1178,31 @@
   gtk_binding_entry_add_signal (binding_set, GDK_f, GDK_CONTROL_MASK, "start_interactive_search", 0);
 
   gtk_binding_entry_add_signal (binding_set, GDK_F, GDK_CONTROL_MASK, "start_interactive_search", 0);
+
+  /* Hildon addition: Add key bindings to Right and Left arrows */
+  gtk_binding_entry_add_signal (binding_set, GDK_Right, 0, "expand_collapse_cursor_row", 3,
+                                G_TYPE_BOOLEAN, FALSE, G_TYPE_BOOLEAN, TRUE, G_TYPE_BOOLEAN, FALSE);
+  gtk_binding_entry_add_signal (binding_set, GDK_plus, GDK_SHIFT_MASK, "expand_collapse_cursor_row", 3,
+                                G_TYPE_BOOLEAN, FALSE, G_TYPE_BOOLEAN, TRUE, G_TYPE_BOOLEAN, TRUE);
+  gtk_binding_entry_add_signal (binding_set, GDK_Left, 0, "expand_collapse_cursor_row", 3,
+                                G_TYPE_BOOLEAN, FALSE, G_TYPE_BOOLEAN, FALSE, G_TYPE_BOOLEAN, FALSE);
+  gtk_binding_entry_add_signal (binding_set, GDK_Left, GDK_SHIFT_MASK, "expand_collapse_cursor_row", 3,
+                                G_TYPE_BOOLEAN, FALSE, G_TYPE_BOOLEAN, FALSE, G_TYPE_BOOLEAN, TRUE);
 }
 
 static void
 gtk_tree_view_init (GtkTreeView *tree_view)
 {
   tree_view->priv = g_new0 (GtkTreeViewPrivate, 1);
-  GTK_WIDGET_SET_FLAGS (tree_view, GTK_CAN_FOCUS);
+
+  /* Hildon: focus cannot be gained until at least one row is added */
+  GTK_WIDGET_UNSET_FLAGS (tree_view, GTK_CAN_FOCUS);
 
   gtk_widget_set_redraw_on_allocate (GTK_WIDGET (tree_view), FALSE);
 
+  /* Hildon: Headers invisible by default */
   tree_view->priv->flags =  GTK_TREE_VIEW_SHOW_EXPANDERS
-                            | GTK_TREE_VIEW_DRAW_KEYFOCUS
-                            | GTK_TREE_VIEW_HEADERS_VISIBLE;
+                            | GTK_TREE_VIEW_DRAW_KEYFOCUS;
 
   /* We need some padding */
   tree_view->priv->dy = 0;
@@ -1165,6 +1232,27 @@
           
   tree_view->priv->hover_selection = FALSE;
   tree_view->priv->hover_expand = FALSE;
+
+  tree_view->priv->ctrl_pressed = FALSE;
+  tree_view->priv->shift_pressed = FALSE;
+
+  tree_view->priv->checkbox_mode = FALSE;
+  tree_view->priv->allow_checkbox_mode = TRUE;
+  tree_view->priv->pen_down = FALSE;
+  tree_view->priv->pen_drag_active = FALSE;
+  tree_view->priv->pen_drag_reverse = FALSE;
+  tree_view->priv->first_drag_row = NULL;
+  tree_view->priv->last_drag_row = NULL;
+  tree_view->priv->queued_expand_row = NULL;
+  tree_view->priv->queued_select_row = NULL;
+  tree_view->priv->queued_activate_row = NULL;
+  tree_view->priv->pen_focus = TRUE;
+
+  /* Hildon: cursor should follow when selection changes */
+  g_signal_connect (tree_view->priv->selection, "changed",
+                    G_CALLBACK (selection_changed), tree_view);
+
+  gtk_widget_set_name (GTK_WIDGET (tree_view), "treeview");
 }
 
 
@@ -1223,6 +1311,27 @@
     case PROP_HOVER_EXPAND:
       tree_view->priv->hover_expand = g_value_get_boolean (value);
       break;
+    case PROP_DOTTED_LINES:
+      set_dotted_lines (tree_view, g_value_get_boolean (value));
+      break;
+    case PROP_FORCE_LIST_KLUDGE:
+      tree_view->priv->force_list_kludge = g_value_get_boolean (value);
+      break;
+    case PROP_ALLOW_CHECKBOX_MODE:
+      if ((tree_view->priv->allow_checkbox_mode = g_value_get_boolean (value)))
+        {
+          gtk_widget_set_name (GTK_WIDGET(tree_view), "treeview");
+          update_checkbox_mode (NULL, NULL, tree_view);
+        }
+      else
+        {
+          /* ugly hack - to ensure that checkboxes are independent of the
+             selection if !allow_checkbox_mode, we must be able to use
+             different theming in that case */
+          gtk_widget_set_name (GTK_WIDGET(tree_view), "no_checkbox_mode");
+          tree_view->priv->checkbox_mode = FALSE;
+        }
+      break;
     default:
       break;
     }
@@ -1276,6 +1385,15 @@
     case PROP_HOVER_EXPAND:
       g_value_set_boolean (value, tree_view->priv->hover_expand);
       break;
+    case PROP_DOTTED_LINES:
+      g_value_set_boolean (value, tree_view->priv->dotted_lines);
+      break;
+    case PROP_FORCE_LIST_KLUDGE:
+      g_value_set_boolean (value, tree_view->priv->force_list_kludge);
+      break;
+    case PROP_ALLOW_CHECKBOX_MODE:
+      g_value_set_boolean (value, tree_view->priv->allow_checkbox_mode);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -1376,6 +1494,32 @@
       tree_view->priv->destroy_count_data = NULL;
     }
 
+  if (tree_view->priv->first_drag_row)
+    {
+      gtk_tree_row_reference_free (tree_view->priv->first_drag_row);
+      tree_view->priv->first_drag_row = NULL;
+    }
+  if (tree_view->priv->last_drag_row)
+    {
+      gtk_tree_row_reference_free (tree_view->priv->last_drag_row);
+      tree_view->priv->last_drag_row = NULL;
+    }
+  if (tree_view->priv->queued_expand_row)
+    {
+      gtk_tree_row_reference_free (tree_view->priv->queued_expand_row);
+      tree_view->priv->queued_expand_row = NULL;
+    }
+  if (tree_view->priv->queued_select_row)
+    {
+      gtk_tree_row_reference_free (tree_view->priv->queued_select_row);
+      tree_view->priv->queued_select_row = NULL;
+    }
+  if (tree_view->priv->queued_activate_row)
+    {
+      gtk_tree_row_reference_free (tree_view->priv->queued_activate_row);
+      tree_view->priv->queued_activate_row = NULL;
+    }
+
   gtk_tree_row_reference_free (tree_view->priv->cursor);
   tree_view->priv->cursor = NULL;
 
@@ -1494,6 +1638,8 @@
   gtk_tree_view_map_buttons (tree_view);
 
   gdk_window_show (widget->window);
+
+  check_if_can_focus (tree_view);
 }
 
 static void
@@ -1641,7 +1787,13 @@
       g_source_remove (tree_view->priv->typeselect_flush_timeout);
       tree_view->priv->typeselect_flush_timeout = 0;
     }
-  
+
+  if (tree_view->priv->check_if_can_focus_idle_id != 0)
+    {
+      g_source_remove (tree_view->priv->check_if_can_focus_idle_id);
+      tree_view->priv->check_if_can_focus_idle_id = 0;
+    }
+
   for (list = tree_view->priv->columns; list; list = list->next)
     _gtk_tree_view_column_unrealize_button (GTK_TREE_VIEW_COLUMN (list->data));
 
@@ -1895,6 +2047,8 @@
   gint full_requested_width = 0;
   gint number_of_expand_columns = 0;
   gboolean rtl;
+  GtkWidget *scroll;
+  GtkPolicyType ptype;
   
   tree_view = GTK_TREE_VIEW (widget);
 
@@ -1969,6 +2123,19 @@
       allocation.x = width;
       column->width = real_requested_width;
 
+      /* a dirty Hildon hack to force truncation if not enough space. This hack is applied
+       * only if we are NOT in a scrolled window with hscroll*/
+      scroll = gtk_widget_get_ancestor(widget, GTK_TYPE_SCROLLED_WINDOW);
+      if ((!scroll ||
+          (gtk_scrolled_window_get_policy (GTK_SCROLLED_WINDOW (scroll), &ptype, NULL), ptype == GTK_POLICY_NEVER))
+        && (width + real_requested_width > widget->allocation.width))
+      {
+          column->width = widget->allocation.width - width;
+          if (column->width < 1)
+            column->width = 1;
+          gtk_widget_queue_draw (widget);
+      }
+
       if (column->expand)
 	{
 	  if (number_of_expand_columns == 1)
@@ -2166,6 +2333,7 @@
   gint vertical_separator;
   gint horizontal_separator;
   gboolean rtl;
+  gint expander_indent;
 
   g_return_val_if_fail (GTK_IS_TREE_VIEW (widget), FALSE);
   g_return_val_if_fail (event != NULL, FALSE);
@@ -2176,6 +2344,7 @@
   gtk_widget_style_get (widget,
 			"vertical_separator", &vertical_separator,
 			"horizontal_separator", &horizontal_separator,
+                        "expander_indent", &expander_indent,
 			NULL);
 
 
@@ -2199,6 +2368,14 @@
       gint column_handled_click = FALSE;
       gboolean row_double_click = FALSE;
       gboolean rtl;
+      gboolean force_list_kludge;
+      GtkRBNode *cursor = NULL;
+      gboolean focus_grab = FALSE;
+
+      if (!GTK_WIDGET_HAS_FOCUS (widget))
+         focus_grab = TRUE;
+      
+      GTK_TREE_VIEW_UNSET_FLAG (tree_view, GTK_TREE_VIEW_DRAW_KEYFOCUS);
 
       /* Empty tree? */
       if (tree_view->priv->tree == NULL)
@@ -2207,7 +2384,9 @@
 	  return TRUE;
 	}
 
-      /* are we in an arrow? */
+      /* In Hildon we don't want to use the arrows */
+#if 0
+      /* are we in an arrow? */ 
       if (tree_view->priv->prelight_node &&
           GTK_TREE_VIEW_FLAG_SET (tree_view, GTK_TREE_VIEW_ARROW_PRELIT))
 	{
@@ -2226,6 +2405,7 @@
 	  grab_focus_and_unset_draw_keyfocus (tree_view);
 	  return TRUE;
 	}
+#endif
 
       /* find the node that was clicked */
       new_y = TREE_WINDOW_Y_TO_RBTREE_Y(tree_view, event->y);
@@ -2247,6 +2427,57 @@
       background_area.height = ROW_HEIGHT (tree_view, GTK_RBNODE_GET_HEIGHT (node));
       background_area.x = 0;
 
+      if (tree_view->priv->first_drag_row)
+        {
+          gtk_tree_row_reference_free (tree_view->priv->first_drag_row);
+          tree_view->priv->first_drag_row = NULL;
+        }
+      if (tree_view->priv->last_drag_row)
+        {
+          gtk_tree_row_reference_free (tree_view->priv->last_drag_row);
+          tree_view->priv->last_drag_row = NULL;
+        }
+      tree_view->priv->first_drag_row =
+        gtk_tree_row_reference_new (tree_view->priv->model, path);
+      tree_view->priv->last_drag_row = gtk_tree_row_reference_copy (tree_view->priv->first_drag_row);
+
+      /* force_list_kludge allows pen dragging even if
+         GTK_TREE_MODEL_LIST_ONLY is not set (to fix file tree) */
+      g_object_get (widget, "force_list_kludge", &force_list_kludge, NULL);
+
+      /* Hildon: activate pen dragging, if listbox is not hierarchical and
+         the pen was not put down in a position that initiates drag'n'drop */
+      if (!tree_view->priv->pen_down &&
+          (force_list_kludge ||
+           (gtk_tree_model_get_flags(tree_view->priv->model)
+            & GTK_TREE_MODEL_LIST_ONLY)) &&
+          (tree_view->priv->checkbox_mode ||
+           !gtk_tree_selection_path_is_selected(tree_view->priv->selection, path)))
+        {
+          tree_view->priv->pen_down = TRUE;
+          tree_view->priv->pen_focus = TRUE;
+
+          _gtk_drag_source_ignore_drag (widget);
+        }
+
+      /* For the Hildon buttonpress find out the previously selected row */
+      GtkRBTree *cursor_tree = NULL;
+      GtkTreePath *cursor_path = NULL;
+  
+      if (tree_view->priv->cursor)
+        {
+          cursor_path = gtk_tree_row_reference_get_path (tree_view->priv->cursor);
+          if (cursor_path)
+            {
+              _gtk_tree_view_find_node (tree_view, cursor_path,
+                                        &cursor_tree, &cursor);
+              gtk_tree_path_free (cursor_path);
+            }
+         }
+
+      /* Hildon: in checkbox mode, dragging sets all checkboxes
+         to the same state as the first toggled checkbox */
+      tree_view->priv->new_state = !gtk_tree_selection_path_is_selected(tree_view->priv->selection, path);
 
       /* Let the column have a chance at selecting it. */
       rtl = (gtk_widget_get_direction (GTK_WIDGET (tree_view)) == GTK_TEXT_DIR_RTL);
@@ -2275,8 +2506,11 @@
 	  if (gtk_tree_view_is_expander_column (tree_view, column) &&
               TREE_VIEW_DRAW_EXPANDERS(tree_view))
 	    {
-	      cell_area.x += depth * tree_view->priv->expander_size;
-	      cell_area.width -= depth * tree_view->priv->expander_size;
+              gint adjust;
+
+              adjust = depth * tree_view->priv->expander_size + (depth - 1) * expander_indent;
+              cell_area.x += adjust;
+              cell_area.width -= adjust;
 	    }
 	  break;
 	}
@@ -2364,15 +2598,19 @@
        */
       if (event->type == GDK_BUTTON_PRESS)
         {
+          /* Hildon: ignore Ctrl and Shift */
+#if 0
           if ((event->state & GDK_CONTROL_MASK) == GDK_CONTROL_MASK)
             tree_view->priv->ctrl_pressed = TRUE;
           if ((event->state & GDK_SHIFT_MASK) == GDK_SHIFT_MASK)
             tree_view->priv->shift_pressed = TRUE;
+#endif
 
           focus_cell = _gtk_tree_view_column_get_cell_at_pos (column, event->x - background_area.x);
           if (focus_cell)
             gtk_tree_view_column_focus_cell (column, focus_cell);
 
+#if 0
           if (event->state & GDK_CONTROL_MASK)
             {
               gtk_tree_view_real_set_cursor (tree_view, path, FALSE, TRUE);
@@ -2387,6 +2625,92 @@
             {
               gtk_tree_view_real_set_cursor (tree_view, path, TRUE, TRUE);
             }
+#endif
+          if (tree_view->priv->checkbox_mode)
+            {
+              GtkRBTree *tree = NULL;
+              GtkRBNode *node = NULL;
+
+              _gtk_tree_view_find_node (tree_view, path, &tree, &node);
+
+              /* cursor cannot move to an insensitive row, so we
+                 need to check here to avoid toggling the current
+                 row by clicking on an insensitive row */
+              if (_gtk_tree_selection_is_row_selectable (tree_view->priv->selection,
+                                                         node, path))
+                {
+                  gtk_tree_view_real_set_cursor (tree_view, path,
+                                                 FALSE, TRUE);
+                  gtk_tree_view_real_toggle_cursor_row (tree_view);
+                }
+              else
+                /* Usually this would be emitted by real_set_cursor.
+                   However in this case we never call it. */
+                g_signal_emit (tree_view, tree_view_signals[ROW_INSENSITIVE], 0, path);
+            }
+          else
+            {
+              gboolean queue_row = TRUE;
+              gboolean force_list_kludge;
+
+              /* force_list_kludge allows rows to be activated even if
+                 GTK_TREE_MODEL_LIST_ONLY is not set (to fix file tree) */
+              g_object_get (widget, "force_list_kludge",
+                            &force_list_kludge, NULL);
+              if ((force_list_kludge ||
+                   (gtk_tree_model_get_flags (tree_view->priv->model) &
+                    GTK_TREE_MODEL_LIST_ONLY)) &&
+                  gtk_tree_row_reference_valid (tree_view->priv->cursor))
+                {
+                  /* special case: text listbox without checkboxes
+                     should activate selected rows when user taps
+                     on cursor row, but not affect selection*/
+                  GtkTreePath *cursor_path =
+                    gtk_tree_row_reference_get_path (tree_view->priv->cursor);
+                  if (gtk_tree_path_compare (cursor_path, path) == 0)
+                    {
+                      if (tree_view->priv->queued_activate_row)
+                        gtk_tree_row_reference_free (tree_view->priv->queued_activate_row);
+                      tree_view->priv->queued_activate_row =
+                        gtk_tree_row_reference_new (tree_view->priv->model, path);
+
+                      queue_row = FALSE;
+                    }
+                  gtk_tree_path_free (cursor_path);
+                }
+
+              if (queue_row &&
+                  (gtk_tree_selection_get_mode (tree_view->priv->selection) == GTK_SELECTION_MULTIPLE) &&
+                   gtk_tree_selection_path_is_selected (tree_view->priv->selection, path))
+                {
+                  GtkTreePath *old_cursor_path = NULL;
+
+                  /* we don't know if the user is selecting an item or performing
+                     multiple item drag and drop until we know where button is released */
+                  if (tree_view->priv->queued_select_row)
+                    gtk_tree_row_reference_free (tree_view->priv->queued_select_row);
+                  tree_view->priv->queued_select_row =
+                    gtk_tree_row_reference_new (tree_view->priv->model, path);
+
+                  /* however, move focus */
+                  if (tree_view->priv->cursor)
+                    {
+                      old_cursor_path = gtk_tree_row_reference_get_path (tree_view->priv->cursor);
+                      gtk_tree_row_reference_free (tree_view->priv->cursor);
+                    }
+                  tree_view->priv->cursor = gtk_tree_row_reference_new (tree_view->priv->model,
+                                                                            path);
+                  gtk_tree_view_queue_draw_path (tree_view, path, NULL);
+                  if (old_cursor_path)
+                    {
+                      gtk_tree_view_queue_draw_path (tree_view, old_cursor_path, NULL);
+                      gtk_tree_path_free (old_cursor_path);
+                    }
+                }
+              else
+                gtk_tree_view_real_set_cursor (tree_view, path,
+                                               queue_row, TRUE);
+            }
 
           tree_view->priv->ctrl_pressed = FALSE;
           tree_view->priv->shift_pressed = FALSE;
@@ -2412,6 +2736,15 @@
           tree_view->priv->press_start_y = event->y;
         }
 
+      /* Hildon: if selected row is tapped -> the row gets activated and expands */
+      if (!focus_grab)
+        {
+          /* ...although not until button is released */
+          gtk_tree_row_reference_free (tree_view->priv->queued_expand_row);
+          tree_view->priv->queued_expand_row =
+            gtk_tree_row_reference_new (tree_view->priv->model, path);
+        }
+
       /* Test if a double click happened on the same row. */
       if (event->button == 1)
         {
@@ -2433,6 +2766,8 @@
                 }
             }
 
+          /* Hildon doesn't support double clicks */
+#if 0
           if (row_double_click)
             {
               if (tree_view->priv->last_button_press)
@@ -2443,6 +2778,7 @@
               tree_view->priv->last_button_press_2 = NULL;
             }
           else
+#endif
             {
               if (tree_view->priv->last_button_press)
                 gtk_tree_row_reference_free (tree_view->priv->last_button_press);
@@ -2615,6 +2951,23 @@
   return TRUE;
 }
 
+/* helper function for gtk_tree_view_button_release */
+static void
+activate_callback (GtkTreeModel *model,
+                   GtkTreePath  *path,
+                   GtkTreeIter  *iter,
+                   gpointer      data)
+{
+  GtkTreeView *tree_view = GTK_TREE_VIEW (data);
+
+  /* Hildon: if the tree view has no active focus we don't activate
+   * the selected row */
+  if ( !GTK_WIDGET_HAS_FOCUS (GTK_WIDGET(data)) )
+      return;
+  
+  gtk_tree_view_row_activated (tree_view, path, tree_view->priv->focus_column);
+}
+
 static gboolean
 gtk_tree_view_button_release (GtkWidget      *widget,
 			      GdkEventButton *event)
@@ -2626,6 +2979,17 @@
 
   tree_view = GTK_TREE_VIEW (widget);
 
+  /* stop pen dragging */
+  if (tree_view->priv->first_drag_row)
+    gtk_tree_row_reference_free (tree_view->priv->first_drag_row);
+  if (tree_view->priv->last_drag_row)
+    gtk_tree_row_reference_free (tree_view->priv->last_drag_row);
+  tree_view->priv->first_drag_row = NULL;
+  tree_view->priv->last_drag_row = NULL;
+  tree_view->priv->pen_down = FALSE;
+  tree_view->priv->pen_drag_active = FALSE;
+  remove_scroll_timeout (tree_view);
+
   if (GTK_TREE_VIEW_FLAG_SET (tree_view, GTK_TREE_VIEW_IN_COLUMN_DRAG))
     return gtk_tree_view_button_release_drag_column (widget, event);
 
@@ -2635,6 +2999,83 @@
   if (GTK_TREE_VIEW_FLAG_SET (tree_view, GTK_TREE_VIEW_IN_COLUMN_RESIZE))
     return gtk_tree_view_button_release_column_resize (widget, event);
 
+  if (gtk_tree_row_reference_valid (tree_view->priv->queued_select_row))
+    {
+      gtk_tree_view_real_set_cursor (tree_view,
+                                     gtk_tree_row_reference_get_path (tree_view->priv->queued_select_row),
+                                     TRUE, TRUE);
+      gtk_tree_row_reference_free (tree_view->priv->queued_select_row);
+      tree_view->priv->queued_select_row = NULL;
+    }
+
+  if (gtk_tree_row_reference_valid (tree_view->priv->queued_activate_row))
+    {
+      if (gtk_tree_row_reference_valid (tree_view->priv->cursor))
+        {
+          GtkTreePath *cursor_path = gtk_tree_row_reference_get_path (tree_view->priv->cursor);
+          GtkTreePath *queued_path = gtk_tree_row_reference_get_path (tree_view->priv->queued_activate_row);
+
+          if (gtk_tree_path_compare (cursor_path, queued_path) == 0)
+            {
+              gtk_tree_selection_selected_foreach (tree_view->priv->selection,
+                                                   activate_callback,
+                                                   tree_view);
+            }
+
+          gtk_tree_path_free (cursor_path);
+          gtk_tree_path_free (queued_path);
+        }
+
+      gtk_tree_row_reference_free (tree_view->priv->queued_activate_row);
+      tree_view->priv->queued_activate_row = NULL;
+    }
+
+  /* for handling expand/collapse postponed from button_press (since we
+     don't want expand/collapse before tap on node has been completed) */
+  if (gtk_tree_row_reference_valid (tree_view->priv->queued_expand_row) &&
+      tree_view->priv->tree != NULL)
+    {
+      GtkTreePath *queued_expand_path;
+      GtkRBTree *tree;
+      GtkRBNode *node;
+      GtkRBNode *old_node;
+      gint y;
+
+      queued_expand_path =
+        gtk_tree_row_reference_get_path (tree_view->priv->queued_expand_row);
+
+      if (queued_expand_path)
+        {
+          /* must check that cursor hasn't moved elsewhere since button_press */
+          y = TREE_WINDOW_Y_TO_RBTREE_Y (tree_view, event->y);
+          _gtk_rbtree_find_offset (tree_view->priv->tree, y, &tree, &node);
+
+          _gtk_tree_view_find_node (tree_view, queued_expand_path,
+                                    &tree, &old_node);
+
+          if (node && old_node == node)
+            {
+              if (node->children == NULL)
+                gtk_tree_view_real_expand_row (tree_view,
+                                               queued_expand_path,
+                                               tree,
+                                               node,
+                                               FALSE, TRUE);
+              else
+                gtk_tree_view_real_collapse_row (tree_view,
+                                                 queued_expand_path,
+                                                 tree,
+                                                 node,
+                                                 TRUE);
+            }
+
+          gtk_tree_path_free (queued_expand_path);
+        }
+
+      gtk_tree_row_reference_free( tree_view->priv->queued_expand_row);
+      tree_view->priv->queued_expand_row = NULL;
+    }
+
   if (tree_view->priv->button_pressed_node == NULL)
     return FALSE;
 
@@ -3311,6 +3752,7 @@
   GtkTreeView *tree_view;
   GtkRBTree *tree;
   GtkRBNode *node;
+  GtkTreePath *path, *last_drag_path, *current_path;
   gint new_y;
 
   tree_view = (GtkTreeView *) widget;
@@ -3319,7 +3761,8 @@
     return FALSE;
 
   /* only check for an initiated drag when a button is pressed */
-  if (tree_view->priv->pressed_button >= 0)
+  /* Hildon: active pen drag overrides drag and drop */
+  if (tree_view->priv->pressed_button >= 0 && !tree_view->priv->pen_down)
     gtk_tree_view_maybe_begin_dragging_row (tree_view, event);
 
   new_y = TREE_WINDOW_Y_TO_RBTREE_Y(tree_view, event->y);
@@ -3328,6 +3771,101 @@
 
   _gtk_rbtree_find_offset (tree_view->priv->tree, new_y, &tree, &node);
 
+  /* Hildon: pen dragging */
+  if (tree_view->priv->pen_down && node != NULL &&
+      tree_view->priv->queued_select_row == NULL &&
+      gtk_tree_row_reference_valid (tree_view->priv->last_drag_row))
+    {
+      gint direction;
+
+      last_drag_path = gtk_tree_row_reference_get_path (tree_view->priv->last_drag_row);
+      path = _gtk_tree_view_find_path (tree_view, tree, node);
+      direction = gtk_tree_path_compare (path, last_drag_path);
+
+      if (direction != 0)
+        {
+          current_path = gtk_tree_path_copy (last_drag_path);
+
+          /* we must ensure that no row is skipped because stylus
+             is moving faster than motion events are generated */
+          do {
+            if (direction > 0)
+              {
+                /* gtk_tree_path_next does not let us know when it failed */
+                GtkTreeIter iter;
+                gtk_tree_model_get_iter (tree_view->priv->model, &iter, current_path);
+                if (!gtk_tree_model_iter_next (tree_view->priv->model, &iter))
+                  break;
+
+                gtk_tree_path_next (current_path);
+              }
+            else if (!gtk_tree_path_prev (current_path))
+              break;
+      
+            /* set cursor, and start scrolling */
+            gtk_tree_view_real_set_cursor (tree_view, current_path, FALSE, FALSE);
+            add_scroll_timeout (tree_view);
+
+            if (tree_view->priv->checkbox_mode)
+              {
+                /* always set to same state as the first tapped node */
+                if (tree_view->priv->new_state)
+                  gtk_tree_selection_select_path (tree_view->priv->selection,
+                                                  current_path);
+                else
+                  gtk_tree_selection_unselect_path (tree_view->priv->selection,
+                                                    current_path);
+              }
+            else
+              {
+                if (gtk_tree_selection_path_is_selected (tree_view->priv->selection,
+                                                         current_path))
+                  {
+                    /* apparently we have reversed the pen drag direction */
+                    GtkTreePath *reverse_path;
+                    gint reverse_direction;
+
+                    reverse_direction = gtk_tree_path_compare (current_path,
+                                                               last_drag_path);
+                    reverse_path = gtk_tree_path_copy (last_drag_path);
+                    do {
+                      gtk_tree_selection_unselect_path (tree_view->priv->selection,
+                                                        reverse_path);
+                      tree_view->priv->pen_drag_reverse = TRUE;
+                      if (reverse_direction > 0)
+                        {
+                          GtkTreeIter iter;
+                          gtk_tree_model_get_iter (tree_view->priv->model, &iter, reverse_path);
+                          if (!gtk_tree_model_iter_next (tree_view->priv->model, &iter))
+                            break;
+
+                          gtk_tree_path_next (reverse_path);
+                        }
+                      else if (!gtk_tree_path_prev (reverse_path))
+                        break;
+                    } while (gtk_tree_path_compare (reverse_path, current_path) != 0);
+                    gtk_tree_path_free (reverse_path);
+                  }
+                else
+                  {
+                    gtk_tree_selection_select_path (tree_view->priv->selection,
+                                                    current_path);
+                    tree_view->priv->pen_drag_reverse = FALSE;
+                  }
+              }
+          } while (gtk_tree_path_compare(current_path, path) != 0);
+          gtk_tree_path_free (current_path);
+
+          /* update last_drag_row */
+          gtk_tree_row_reference_free (tree_view->priv->last_drag_row);
+          tree_view->priv->last_drag_row =
+            gtk_tree_row_reference_new (tree_view->priv->model, path);
+          gtk_tree_path_free (path);
+        }
+
+      gtk_tree_path_free (last_drag_path);
+    }
+
   /* If we are currently pressing down a button, we don't want to prelight anything else. */
   if ((tree_view->priv->button_pressed_node != NULL) &&
       (tree_view->priv->button_pressed_node != node))
@@ -3404,6 +3942,90 @@
 		     1, 1, w, h);
 }
 
+/* Hildon: helper function for dotted slash drawing;
+   returns TRUE or FALSE, depending it there are
+   more nodes at current level */
+static gboolean
+iter_has_next (GtkTreeModel *model, GtkTreeIter *iter)
+{
+  GtkTreeIter *check_iter;
+  gboolean result;
+    
+  check_iter = gtk_tree_iter_copy(iter);
+  result = gtk_tree_model_iter_next (model, check_iter);
+
+  gtk_tree_iter_free (check_iter);   
+  return result;
+}
+
+static void
+draw_drop_indicator (GtkWidget *widget,
+                     GdkEventExpose *event,
+                     GdkRectangle *background_area,
+                     GtkTreePath *drag_dest_path,
+                     gint bin_window_width,
+                     gint highlight_x,
+                     gboolean is_first,
+                     gboolean is_last)
+{
+  GtkTreeView *tree_view = GTK_TREE_VIEW (widget);
+
+  /* Draw indicator for the drop
+   */
+  gint highlight_y = -1;
+  GtkRBTree *tree = NULL;
+  GtkRBNode *node = NULL;
+
+  switch (tree_view->priv->drag_dest_pos)
+    {
+    case GTK_TREE_VIEW_DROP_BEFORE:
+      highlight_y = background_area->y - 1;
+      if (highlight_y < 0)
+        highlight_y = 0;
+      break;
+
+    case GTK_TREE_VIEW_DROP_AFTER:
+      highlight_y = background_area->y + background_area->height - 1;
+      break;
+
+    case GTK_TREE_VIEW_DROP_INTO_OR_BEFORE:
+    case GTK_TREE_VIEW_DROP_INTO_OR_AFTER:
+      _gtk_tree_view_find_node (tree_view, drag_dest_path, &tree, &node);
+
+      if (tree == NULL)
+        break;
+
+      gtk_paint_focus (widget->style,
+                       tree_view->priv->bin_window,
+                       GTK_WIDGET_STATE (widget),
+                       NULL,
+                       widget,
+                       (is_first
+                        ? (is_last
+                           ? "treeview-drop-indicator"
+                           : "treeview-drop-indicator-left")
+                        : (is_last
+                           ? "treeview-drop-indicator-right"
+                           : "treeview-drop-indicator-middle")),
+                       background_area->x,
+                       background_area->y,
+                       background_area->width,
+                       background_area->height);
+      break;
+    }
+
+  if (highlight_y >= 0)
+    {
+      gdk_draw_line (event->window,
+                     widget->style->black_gc,
+                     highlight_x,
+                     highlight_y,
+                     bin_window_width - highlight_x,
+                     highlight_y);
+    }
+}
+
+
 /* Warning: Very scary function.
  * Modify at your own risk
  *
@@ -3433,16 +4055,25 @@
   guint flags;
   gint highlight_x;
   gint bin_window_width;
-  GtkTreePath *cursor_path;
-  GtkTreePath *drag_dest_path;
+  GtkTreePath *cursor_path = NULL;
+  GtkTreePath *drag_dest_path = NULL;
   GList *last_column;
   gint vertical_separator;
   gint horizontal_separator;
+  gint expander_indent;
   gint focus_line_width;
   gboolean allow_rules;
   gboolean has_special_cell;
   gboolean rtl;
   gint n_visible_columns;
+  gboolean dottedlines, passivefocus, res;
+
+  /* Hildon: these variables are added for dotted slash drawing
+     (Hierarchical listbox) */
+  gint i;
+  gint node_elements = 64;
+  gboolean *iter_value = NULL;
+  GtkTreeIter node_iter, parent_iter;
 
   g_return_val_if_fail (GTK_IS_TREE_VIEW (widget), FALSE);
 
@@ -3455,8 +4086,12 @@
 			"vertical_separator", &vertical_separator,
 			"allow_rules", &allow_rules,
 			"focus-line-width", &focus_line_width,
+                        "expander_indent", &expander_indent,
+                        "passive_focus", &passivefocus,
 			NULL);
 
+  g_object_get (widget, "dotted_lines", &dottedlines, NULL);
+
   if (tree_view->priv->tree == NULL)
     {
       draw_empty_focus (tree_view, &event->area);
@@ -3478,6 +4113,8 @@
   if (node == NULL)
     return TRUE;
 
+  iter_value = g_new (gboolean, node_elements);
+
   /* find the path for the node */
   path = _gtk_tree_view_find_path ((GtkTreeView *)widget,
 				   tree,
@@ -3486,11 +4123,25 @@
 			   &iter,
 			   path);
   depth = gtk_tree_path_get_depth (path);
+
+  node_iter = iter;
+  for (i = depth - 1; i >= 1; i--)
+    {
+      res = gtk_tree_model_iter_parent (tree_view->priv->model, &parent_iter, &node_iter);
+      /* Check, if we should grow array */
+      if (i >= node_elements - 1)
+        {
+          node_elements *= 2;
+          iter_value = g_renew (gboolean, iter_value, node_elements);
+          if (!iter_value)
+            goto done;
+        }
+      iter_value[i] = iter_has_next (tree_view->priv->model, &parent_iter);
+      node_iter = parent_iter;
+    }
+  gtk_tree_model_get_iter (tree_view->priv->model, &iter, path);
   gtk_tree_path_free (path);
   
-  cursor_path = NULL;
-  drag_dest_path = NULL;
-
   if (tree_view->priv->cursor)
     cursor_path = gtk_tree_row_reference_get_path (tree_view->priv->cursor);
 
@@ -3570,6 +4221,8 @@
 	  GtkTreeViewColumn *column = list->data;
 	  const gchar *detail = NULL;
 	  GtkStateType state;
+          gboolean is_first = (rtl ? !list->next : !list->prev);
+          gboolean is_last = (rtl ? !list->prev : !list->next);
 
 	  if (!column->visible)
             continue;
@@ -3660,31 +4313,179 @@
 	  else
 	    state = GTK_STATE_NORMAL;
 
-	  /* Draw background */
-          gtk_paint_flat_box (widget->style,
-                              event->window,
-			      state,
-                              GTK_SHADOW_NONE,
-                              &event->area,
-                              widget,
-                              detail,
-                              background_area.x,
-                              background_area.y,
-                              background_area.width,
-                              background_area.height);
+          if (tree_view->priv->pen_focus)
+            {
+              if (node != cursor ||
+                  (!GTK_WIDGET_HAS_FOCUS (widget) && !passivefocus))
+                { 
+                  if ((flags & GTK_CELL_RENDERER_SELECTED) 	 
+                      && !tree_view->priv->checkbox_mode)
+                    state = GTK_STATE_SELECTED; 	 
+                  else 	 
+                    state = GTK_STATE_NORMAL; 
+
+                  /* Draw background */
+                  gtk_paint_flat_box (widget->style,
+                                      event->window,
+                                      state,
+                                      GTK_SHADOW_NONE,
+                                      &event->area,
+                                      widget,
+				      (is_first
+				       ? (is_last ? "full" : "left")
+				       : (is_last ? "right" : "middle")),
+				      background_area.x,
+                                      background_area.y,
+                                      background_area.width,
+                                      background_area.height);
+                 }
+               else if ((flags & GTK_CELL_RENDERER_SELECTED) &&
+                        !tree_view->priv->checkbox_mode &&
+                        node != cursor)
+                 {
+      			 gtk_paint_flat_box (widget->style,
+                                       event->window,
+                                       GTK_STATE_SELECTED,
+                                       GTK_SHADOW_NONE,
+                                       &event->area,
+                                       widget,
+                                       detail,
+                                       background_area.x,
+                                       background_area.y,
+                                       background_area.width,
+                                       background_area.height);
+                 }
+            }
+	  else
+            {
+              /* Draw background */
+              gtk_paint_flat_box (widget->style,
+                                  event->window,
+                                  state,
+                                  GTK_SHADOW_NONE,
+                                  &event->area,
+                                  widget,
+				  (is_first
+				   ? (is_last ? "full" : "left")
+				   : (is_last ? "right" : "middle")),
+				  background_area.x,
+                                  background_area.y,
+                                  background_area.width,
+                                  background_area.height);
+            }
+          /* Hildon change: drawing focus is moved here because it didn't work
+             properly before. Some changes where also made.*/
+          /* draw the big row-spanning focus rectangle, if needed */
+          if (node == cursor &&
+              (!passivefocus || GTK_WIDGET_HAS_FOCUS (widget)))
+            {
+              gtk_paint_focus (widget->style,
+                               event->window,
+                               GTK_STATE_ACTIVE,
+                               &event->area,
+                               widget,
+                               (is_first
+                                ? (is_last ? "full" : "left")
+                                : (is_last ? "right" : "middle")),
+                               background_area.x,
+                               background_area.y,
+                               background_area.width,
+                               background_area.height);
+            }
+          else if (node == cursor && passivefocus &&
+                  !GTK_WIDGET_HAS_FOCUS (widget))
+            {
+              if (tree_view->priv->selection->type == GTK_SELECTION_MULTIPLE &&
+                  !tree_view->priv->checkbox_mode)
+                {
+                  /* don't use passive focus graphics in multiple selection mode
+                     because it might make cursor row look unselected */
+                  gtk_paint_flat_box (widget->style,
+                                      event->window,
+                                      GTK_STATE_SELECTED,
+                                      GTK_SHADOW_NONE,
+                                      &event->area,
+                                      widget,
+				      (is_first
+				       ? (is_last ? "full" : "left")
+				       : (is_last ? "right" : "middle")),
+				      background_area.x,
+                                      background_area.y,
+                                      background_area.width,
+                                      background_area.height);
+                } else {
+                  GtkStyle *style = gtk_rc_get_style_by_paths (gtk_widget_get_settings (widget),
+                                                               "hildon-focus",
+                                                               NULL,
+                                                               G_TYPE_NONE);
+                  if (style != NULL)
+                    gtk_style_attach (style, event->window);
+                  else
+                    style = widget->style;
+                         
+                  gtk_paint_focus (style, event->window, GTK_STATE_SELECTED,
+                                   &event->area, widget,
+                                   (is_first
+                                    ? (is_last ? "full" : "left")
+                                    : (is_last ? "right" : "middle")),
+                                   background_area.x,
+                                   background_area.y,
+                                   background_area.width,
+                                   background_area.height);
+                }
+            }
+
+          if (node == cursor)
+            {
+              gint width, x_offset;
+              GtkStateType focus_rect_state; 
+              focus_rect_state =
+                flags & GTK_CELL_RENDERER_FOCUSED ? GTK_STATE_ACTIVE :
+                 (flags & GTK_CELL_RENDERER_PRELIT ? GTK_STATE_PRELIGHT :
+                  (flags & GTK_CELL_RENDERER_INSENSITIVE ? GTK_STATE_INSENSITIVE :
+                   (flags & GTK_CELL_RENDERER_SELECTED ? GTK_STATE_SELECTED :
+                    GTK_STATE_NORMAL)));
+
+              gtk_tree_view_get_arrow_xrange (tree_view, tree, &x_offset, NULL);
+              gdk_drawable_get_size (tree_view->priv->bin_window, &width, NULL);
+            }
+
+          if (node == drag_highlight)
+            draw_drop_indicator(widget, event, &background_area,
+                                drag_dest_path, bin_window_width,
+                                highlight_x, is_first, is_last);
 
 	  if (gtk_tree_view_is_expander_column (tree_view, column) &&
               TREE_VIEW_DRAW_EXPANDERS(tree_view))
 	    {
+              gint px, px2, py, i;
+
+              if (depth <= 1)
+                px = 0;
+              else
+                px = (depth - 1) * tree_view->priv->expander_size +
+                     (depth - 2) * expander_indent;
+
+              /* Hildonlike hack for making the indent look better.
+               * indent is added to all rows except the first one */
+
 	      if (!rtl)
-		cell_area.x += depth * tree_view->priv->expander_size;
-	      cell_area.width -= depth * tree_view->priv->expander_size;
+                cell_area.x += depth * tree_view->priv->expander_size + (depth-1) * expander_indent;
+              cell_area.width -= depth * tree_view->priv->expander_size + (depth-1) * expander_indent;
 
               /* If we have an expander column, the highlight underline
                * starts with that column, so that it indicates which
                * level of the tree we're dropping at.
                */
               highlight_x = cell_area.x;
+
+              if (!GTK_WIDGET_IS_SENSITIVE (widget))
+                {
+                  flags &= ~ (GTK_CELL_RENDERER_PRELIT + GTK_CELL_RENDERER_INSENSITIVE +
+                              GTK_CELL_RENDERER_FOCUSED);
+                  flags &= GTK_CELL_RENDERER_INSENSITIVE;
+                }
+
 	      if (is_separator)
 		gtk_paint_hline (widget->style,
 				 event->window,
@@ -3702,6 +4503,48 @@
 						   &cell_area,
 						   &event->area,
 						   flags);
+
+              /* Hildon dotted slash line drawing for Hierarchical Listbox
+                 widget */
+              if (dottedlines)
+                {
+                  py = cell_area.y + cell_area.height / 2;
+                  px2 = depth * tree_view->priv->expander_size +
+                    (depth - 1) * expander_indent;
+
+                  gdk_gc_set_line_attributes (widget->style->fg_gc[GTK_WIDGET_STATE (widget)],
+                                              1, GDK_LINE_ON_OFF_DASH, GDK_CAP_BUTT, GDK_JOIN_BEVEL);
+
+                  gdk_draw_line (tree_view->priv->bin_window, widget->style->fg_gc[GTK_WIDGET_STATE (widget)],
+                                 px, py, px2, py);
+
+                  if (depth > 1)
+                    {
+                      gdk_draw_line (tree_view->priv->bin_window, widget->style->fg_gc[GTK_WIDGET_STATE (widget)],
+                                     px, cell_area.y, px, py);
+                      if (iter_has_next (tree_view->priv->model, &iter))
+                        {
+                          gdk_draw_line (tree_view->priv->bin_window, widget->style->fg_gc[GTK_WIDGET_STATE (widget)],
+                                        px, py, px, cell_area.y + cell_area.height);
+                        }
+                    }
+
+                  if (node->children)
+                    {
+                      gdk_draw_line (tree_view->priv->bin_window, widget->style->fg_gc[GTK_WIDGET_STATE (widget)],
+                                     px2, py, px2, cell_area.y + cell_area.height);
+                    }
+                  for (i = depth - 1; i >= 2; i--)
+                    {
+                      if (iter_value[i])
+                        {
+                          px = (i - 1)* tree_view->priv->expander_size + (i - 2) * expander_indent;
+                          gdk_draw_line (tree_view->priv->bin_window, widget->style->fg_gc[GTK_WIDGET_STATE (widget)],
+                                         px, cell_area.y, px, cell_area.y + cell_area.height);
+                        }
+                    }
+                }
+              
 	      if ((node->flags & GTK_RBNODE_IS_PARENT) == GTK_RBNODE_IS_PARENT)
 		{
 		  gint x, y;
@@ -3748,61 +4591,8 @@
 	  cell_offset += column->width;
 	}
 
-      if (node == drag_highlight)
-        {
-          /* Draw indicator for the drop
-           */
-          gint highlight_y = -1;
-	  GtkRBTree *tree = NULL;
-	  GtkRBNode *node = NULL;
-	  gint width;
-	  gint focus_line_width;
-
-          switch (tree_view->priv->drag_dest_pos)
-            {
-            case GTK_TREE_VIEW_DROP_BEFORE:
-              highlight_y = background_area.y - 1;
-	      if (highlight_y < 0)
-		      highlight_y = 0;
-              break;
-
-            case GTK_TREE_VIEW_DROP_AFTER:
-              highlight_y = background_area.y + background_area.height - 1;
-              break;
-
-            case GTK_TREE_VIEW_DROP_INTO_OR_BEFORE:
-            case GTK_TREE_VIEW_DROP_INTO_OR_AFTER:
-	      _gtk_tree_view_find_node (tree_view, drag_dest_path, &tree, &node);
-
-	      if (tree == NULL)
-		break;
-	      gdk_drawable_get_size (tree_view->priv->bin_window,
-				     &width, NULL);
-	      gtk_widget_style_get (widget, "focus-line-width", &focus_line_width, NULL);
-	      gtk_paint_focus (widget->style,
-			       tree_view->priv->bin_window,
-			       GTK_WIDGET_STATE (widget),
-			       NULL,
-			       widget,
-			       "treeview-drop-indicator",
-			       0, BACKGROUND_FIRST_PIXEL (tree_view, tree, node)
-			       - focus_line_width / 2,
-			       width, ROW_HEIGHT (tree_view, BACKGROUND_HEIGHT (node))
-			       - focus_line_width + 1);
-              break;
-            }
-
-          if (highlight_y >= 0)
-            {
-              gdk_draw_line (event->window,
-                             widget->style->black_gc,
-                             highlight_x,
-                             highlight_y,
-                             bin_window_width - highlight_x,
-                             highlight_y);
-            }
-        }
-
+      /* Hildon: disabled this */
+#if 0
       /* draw the big row-spanning focus rectangle, if needed */
       if (!has_special_cell && node == cursor &&
 	  GTK_TREE_VIEW_FLAG_SET (tree_view, GTK_TREE_VIEW_DRAW_KEYFOCUS) &&
@@ -3830,6 +4620,7 @@
 			   width,
 			   ROW_HEIGHT (tree_view, BACKGROUND_HEIGHT (node)));
 	}
+#endif
 
       y_offset += max_height;
       if (node->children)
@@ -3847,6 +4638,17 @@
 	  has_child = gtk_tree_model_iter_children (tree_view->priv->model,
 						    &iter,
 						    &parent);
+
+          /* Check if we need to grow array */
+          if (depth >= node_elements - 1)
+            {
+              node_elements *= 2;
+              iter_value = g_renew (gboolean, iter_value, node_elements);
+              if (!iter_value)
+                goto done;
+            }
+          iter_value[depth] = iter_has_next (tree_view->priv->model, &parent);
+
 	  depth++;
 
 	  /* Sanity Check! */
@@ -3897,6 +4699,9 @@
   if (drag_dest_path)
     gtk_tree_path_free (drag_dest_path);
 
+  if (iter_value)
+    g_free (iter_value);
+
   return FALSE;
 }
 
@@ -4179,6 +4984,64 @@
 
   rtl = (gtk_widget_get_direction (GTK_WIDGET (tree_view)) == GTK_TEXT_DIR_RTL);
 
+  /* Special Hildon keyboard interactions */
+  if (event->keyval == GDK_Return &&
+      gtk_tree_row_reference_valid (tree_view->priv->cursor))
+    {
+      gboolean force_list_kludge;
+
+      g_object_get (widget, "force_list_kludge", &force_list_kludge, NULL);
+      if (force_list_kludge ||
+          (gtk_tree_model_get_flags (tree_view->priv->model) &
+           GTK_TREE_MODEL_LIST_ONLY))
+        {
+          /* text listbox */
+          if (tree_view->priv->checkbox_mode)
+            {
+              /* multisel with checkboxes: select key toggles focused */
+              gtk_tree_view_real_toggle_cursor_row (tree_view);
+            }
+          else
+            {
+              /* no checkboxes: select key activates focused */
+              GtkTreePath *cursor_path =
+                gtk_tree_row_reference_get_path (tree_view->priv->cursor);
+
+              gtk_tree_view_row_activated (tree_view, cursor_path,
+                                           tree_view->priv->focus_column);
+
+              gtk_tree_path_free (cursor_path);
+             }
+         }
+       else
+         {
+           /* hierarchical listbox */
+           GtkTreePath *cursor_path;
+           GtkRBTree *tree;
+           GtkRBNode *node;
+
+           cursor_path = gtk_tree_row_reference_get_path (tree_view->priv->cursor);
+           _gtk_tree_view_find_node (tree_view, cursor_path, &tree, &node);
+
+           if (node->children == NULL)
+             gtk_tree_view_real_expand_row (tree_view,
+                                            cursor_path,
+                                            tree,
+                                            node,
+                                            FALSE, TRUE);
+           else
+             gtk_tree_view_real_collapse_row (tree_view,
+                                              cursor_path,
+                                              tree,
+                                              node,
+                                              TRUE);
+
+           gtk_tree_path_free (cursor_path);
+         }
+
+       return TRUE;
+     }
+
   if (GTK_TREE_VIEW_FLAG_SET (tree_view, GTK_TREE_VIEW_IN_COLUMN_DRAG))
     {
       if (event->keyval == GDK_Escape)
@@ -4420,6 +5283,7 @@
 
 /* FIXME Is this function necessary? Can I get an enter_notify event
  * w/o either an expose event or a mouse motion event?
+ * Hildon => it is necessary to make pen dragging work correctly
  */
 static gboolean
 gtk_tree_view_enter_notify (GtkWidget        *widget,
@@ -4434,6 +5298,10 @@
 
   tree_view = GTK_TREE_VIEW (widget);
 
+  /* stop "automatic" pen dragging */
+  tree_view->priv->pen_drag_active = FALSE;
+  remove_scroll_timeout (tree_view);
+
   /* Sanity check it */
   if (event->window != tree_view->priv->bin_window)
     return FALSE;
@@ -4463,6 +5331,9 @@
   tree_view = GTK_TREE_VIEW (widget);
   tree_view->priv->pressed_button = -1;
 
+  if (tree_view->priv->pen_down && tree_view->priv->queued_select_row == NULL)
+    tree_view->priv->pen_drag_active = TRUE;
+
   if (event->mode == GDK_CROSSING_GRAB)
     return TRUE;
 
@@ -4530,11 +5401,13 @@
   GtkTreeViewColumn *column;
   GList *list;
   gint height = 0;
+  gint vertical_separator;
   gint horizontal_separator;
   gint depth = gtk_tree_path_get_depth (path);
   gboolean retval = FALSE;
   gboolean is_separator = FALSE;
   gint focus_pad;
+  gint expander_indent;
       
   /* double check the row needs validating */
   if (! GTK_RBNODE_FLAG_SET (node, GTK_RBNODE_INVALID) &&
@@ -4551,6 +5424,8 @@
   gtk_widget_style_get (GTK_WIDGET (tree_view),
 			"focus-padding", &focus_pad,
 			"horizontal_separator", &horizontal_separator,
+                        "vertical_separator", &vertical_separator,
+                        "expander_indent", &expander_indent,
 			NULL);
   
   for (list = tree_view->priv->columns; list; list = list->next)
@@ -4575,6 +5450,8 @@
 
       if (!is_separator)
 	{
+          tmp_height += vertical_separator;
+
 	  height = MAX (height, tmp_height);
 	  height = MAX (height, tree_view->priv->expander_size);
 	}
@@ -4583,7 +5460,7 @@
 
       if (gtk_tree_view_is_expander_column (tree_view, column) && TREE_VIEW_DRAW_EXPANDERS (tree_view))
         {
-	  tmp_width = tmp_width + horizontal_separator + depth * (tree_view->priv->expander_size);
+	  tmp_width = tmp_width + horizontal_separator + depth * (tree_view->priv->expander_size) + (depth - 1) * expander_indent;
 	}
       else
 	tmp_width = tmp_width + horizontal_separator;
@@ -4657,6 +5534,8 @@
 	      area_below = total_height - area_above - height;
 	      area_above = MAX (area_above, 0);
 	      area_below = MAX (area_below, 0);
+
+              update_dy = TRUE;
 	    }
 	  else
 	    {
@@ -4670,8 +5549,8 @@
 	      dy = _gtk_rbtree_node_find_offset (tree, node);
 
 	      if (dy >= tree_view->priv->vadjustment->value &&
-		  dy < (tree_view->priv->vadjustment->value
-		        + tree_view->priv->vadjustment->page_size))
+		  (dy + height) <= (tree_view->priv->vadjustment->value
+		                   + tree_view->priv->vadjustment->page_size))
 	        {
 		  /* row visible: keep the row at the same position */
 		  area_above = dy - tree_view->priv->vadjustment->value;
@@ -4684,37 +5563,16 @@
 		  /* row not visible */
                   update_dy = TRUE;
 
-		  if (dy >= 0 && dy <= tree_view->priv->vadjustment->page_size)
-		    {
-		      /* row at the beginning -- fixed */
-		      area_above = dy;
-		      area_below = tree_view->priv->vadjustment->page_size
-				   - area_above - height;
-		    }
-		  else if (dy >= (tree_view->priv->vadjustment->upper -
-			          tree_view->priv->vadjustment->page_size)
-		           && dy <= tree_view->priv->vadjustment->upper)
-		    {
-		      /* row at the end -- fixed */
-		      area_above = dy - (tree_view->priv->vadjustment->upper -
-			           tree_view->priv->vadjustment->page_size);
-                      area_below = tree_view->priv->vadjustment->page_size -
-                                   area_above - height;
-
-                      if (area_below < 0)
-                        {
-                          area_above += area_below;
-                          area_below = 0;
-                        }
-		    }
-		  else
-		    {
-		      /* row somewhere in the middle, bring it to the top
-		       * of the view
-		       */
-		      area_above = 0;
+                  if (dy < tree_view->priv->vadjustment->value)
+                    {
+                      area_above = 0;
 		      area_below = total_height - height;
 		    }
+                  if (dy + height > tree_view->priv->vadjustment->value + total_height)
+                    {
+                      area_above = total_height - height;
+		      area_below = 0;
+                    }
 		}
 	    }
 	}
@@ -5585,6 +6443,16 @@
 #endif /* 0 */
 
 static void
+add_scroll_timeout (GtkTreeView *tree_view)
+{
+  if (tree_view->priv->scroll_timeout == 0)
+    {
+      tree_view->priv->scroll_timeout =
+        g_timeout_add (150, scroll_row_timeout, tree_view);
+    }
+}
+
+static void
 remove_scroll_timeout (GtkTreeView *tree_view)
 {
   if (tree_view->priv->scroll_timeout != 0)
@@ -5874,7 +6742,7 @@
   gint cell_x, cell_y;
   GtkTreeModel *model;
   gboolean retval = FALSE;
-
+  
   di = get_info (tree_view);
 
   if (di == NULL || !di->source_set)
@@ -6130,10 +6998,9 @@
           tree_view->priv->open_dest_timeout =
             g_timeout_add (AUTO_EXPAND_TIMEOUT, open_row_timeout, tree_view);
         }
-      else if (tree_view->priv->scroll_timeout == 0)
+      else
         {
-	  tree_view->priv->scroll_timeout =
-	    g_timeout_add (150, scroll_row_timeout, tree_view);
+          add_scroll_timeout (tree_view);
 	}
 
       if (target == gdk_atom_intern ("GTK_TREE_MODEL_ROW", FALSE))
@@ -6901,8 +7768,6 @@
 				GtkMovementStep    step,
 				gint               count)
 {
-  GdkModifierType state;
-
   g_return_val_if_fail (GTK_IS_TREE_VIEW (tree_view), FALSE);
   g_return_val_if_fail (step == GTK_MOVEMENT_LOGICAL_POSITIONS ||
 			step == GTK_MOVEMENT_VISUAL_POSITIONS ||
@@ -6919,6 +7784,8 @@
   GTK_TREE_VIEW_SET_FLAG (tree_view, GTK_TREE_VIEW_DRAW_KEYFOCUS);
   gtk_widget_grab_focus (GTK_WIDGET (tree_view));
 
+  /* Hildon: Ignore ctrl and shift */
+#if 0
   if (gtk_get_current_event_state (&state))
     {
       if ((state & GDK_CONTROL_MASK) == GDK_CONTROL_MASK)
@@ -6926,6 +7793,7 @@
       if ((state & GDK_SHIFT_MASK) == GDK_SHIFT_MASK)
         tree_view->priv->shift_pressed = TRUE;
     }
+#endif
   /* else we assume not pressed */
 
   switch (step)
@@ -7032,7 +7900,6 @@
   GtkRBTree *tree;
   GtkRBNode *node;
   gboolean free_path = FALSE;
-  gint vertical_separator;
   GList *list;
 
   g_return_if_fail (path != NULL || iter != NULL);
@@ -7045,8 +7912,6 @@
   if (tree_view->priv->edited_column)
     gtk_tree_view_stop_editing (tree_view, TRUE);
 
-  gtk_widget_style_get (GTK_WIDGET (data), "vertical_separator", &vertical_separator, NULL);
-
   if (path == NULL)
     {
       path = gtk_tree_model_get_path (model, iter);
@@ -7092,6 +7957,31 @@
  done:
   if (!tree_view->priv->fixed_height_mode)
     install_presize_handler (tree_view);
+
+  /* Hildon: has row now been dimmed? If so, unselect it */
+  _gtk_tree_view_find_node (tree_view, path, &tree, &node);
+  if (!_gtk_tree_selection_is_row_selectable (tree_view->priv->selection,
+                                              node,
+                                              path) &&
+      gtk_tree_row_reference_valid (tree_view->priv->cursor))
+    {
+      GtkTreePath *cursor_path = gtk_tree_row_reference_get_path (tree_view->priv->cursor);
+ 
+      if (gtk_tree_path_compare (path, cursor_path)
+          == 0)
+        {
+          gtk_tree_row_reference_free (tree_view->priv->cursor);
+          tree_view->priv->cursor = NULL;
+        }
+
+      gtk_tree_selection_unselect_path (tree_view->priv->selection, path);
+      gtk_tree_view_collapse_row (tree_view, path);
+
+      gtk_tree_path_free (cursor_path);
+    }
+
+  check_if_can_focus (tree_view);
+  
   if (free_path)
     gtk_tree_path_free (path);
 }
@@ -7196,6 +8086,11 @@
     install_presize_handler (tree_view);
   if (free_path)
     gtk_tree_path_free (path);
+
+  /* Hildon: after a focusable row has been added, the
+     entire widget becomes focusable if it wasn't before */
+  if ((GTK_WIDGET_FLAGS (tree_view) & GTK_CAN_FOCUS) == 0)
+    check_if_can_focus (tree_view);
 }
 
 static void
@@ -7295,6 +8190,16 @@
     _gtk_rbtree_traverse (node->children, node->children->root, G_POST_ORDER, check_selection_helper, data);
 }
 
+static gboolean
+check_if_can_focus_idle (GtkTreeView *tree_view)
+{
+  check_if_can_focus (tree_view);
+
+  tree_view->priv->check_if_can_focus_idle_id = 0;
+
+  return FALSE;
+}
+
 static void
 gtk_tree_view_row_deleted (GtkTreeModel *model,
 			   GtkTreePath  *path,
@@ -7375,6 +8280,13 @@
 
   if (selection_changed)
     g_signal_emit_by_name (tree_view->priv->selection, "changed");
+
+  /* FIXME whacky hack to work around the treeview not being in a clean state
+   * when in a tree a row has been removed, but has_child_toggled not been
+   * called yet */
+  if (tree_view->priv->check_if_can_focus_idle_id == 0)
+    tree_view->priv->check_if_can_focus_idle_id =
+      g_idle_add ((GSourceFunc) check_if_can_focus_idle, tree_view);
 }
 
 static void
@@ -7508,6 +8420,7 @@
   GList *list;
   GtkTreeViewColumn *tmp_column = NULL;
   gint total_width;
+  gint expander_indent, depth;
   gboolean indent_expanders;
   gboolean rtl;
 
@@ -7535,14 +8448,19 @@
 
   gtk_widget_style_get (GTK_WIDGET (tree_view),
 			"indent_expanders", &indent_expanders,
+                        "expander_indent", &expander_indent,
 			NULL);
 
+  /* Hildonlike hack for making the indent look better.
+   * indent is added to all rows except the first one */
+  depth = _gtk_rbtree_get_depth (tree);
+
   if (indent_expanders)
     {
       if (rtl)
-	x_offset -= tree_view->priv->expander_size * _gtk_rbtree_get_depth (tree);
+	x_offset -= tree_view->priv->expander_size * depth + (depth) * expander_indent;
       else
-	x_offset += tree_view->priv->expander_size * _gtk_rbtree_get_depth (tree);
+	x_offset += tree_view->priv->expander_size * depth + (depth) * expander_indent;
     }
   if (x1)
     {
@@ -7617,9 +8535,11 @@
   gboolean retval = FALSE;
   gint tmpheight;
   gint horizontal_separator;
+  gint expander_indent;
 
   gtk_widget_style_get (GTK_WIDGET (tree_view),
 			"horizontal_separator", &horizontal_separator,
+                        "expander_indent", &expander_indent,
 			NULL);
 
   if (height)
@@ -7657,7 +8577,7 @@
       if (gtk_tree_view_is_expander_column (tree_view, column) &&
           TREE_VIEW_DRAW_EXPANDERS (tree_view))
 	{
-	  if (depth * tree_view->priv->expander_size + horizontal_separator + width > column->requested_width)
+          if ((depth - 1) *expander_indent + depth * tree_view->priv->expander_size + horizontal_separator + width > column->requested_width)
 	    {
 	      _gtk_tree_view_column_cell_set_dirty (column, TRUE);
 	      retval = TRUE;
@@ -7747,6 +8667,7 @@
     }
 }
 
+#if 0
 static void
 gtk_tree_view_clamp_column_visible (GtkTreeView       *tree_view,
 				    GtkTreeViewColumn *column)
@@ -7762,6 +8683,7 @@
     gtk_adjustment_set_value (tree_view->priv->hadjustment,
 			      column->button->allocation.x);
 }
+#endif
 
 /* This function could be more efficient.  I'll optimize it if profiling seems
  * to imply that it is important */
@@ -8290,7 +9212,7 @@
 
   area.x = x_offset;
   area.y = CELL_FIRST_PIXEL (tree_view, tree, node, vertical_separator);
-  area.width = expander_size + 2;
+  area.width = expander_size;
   area.height = MAX (CELL_HEIGHT (node, vertical_separator), (expander_size - vertical_separator));
 
   if (node == tree_view->priv->button_pressed_node)
@@ -8397,7 +9319,10 @@
   GtkRBNode *cursor_node = NULL;
   GtkRBTree *new_cursor_tree = NULL;
   GtkRBNode *new_cursor_node = NULL;
+  GtkRBTree *old_cursor_tree;
+  GtkRBNode *old_cursor_node;
   GtkTreePath *cursor_path = NULL;
+  GtkTreePath *new_cursor_path = NULL;
 
   if (! GTK_WIDGET_HAS_FOCUS (tree_view))
     return;
@@ -8415,12 +9340,30 @@
   if (cursor_tree == NULL)
     /* FIXME: we lost the cursor; should we get the first? */
     return;
-  if (count == -1)
-    _gtk_rbtree_prev_full (cursor_tree, cursor_node,
-			   &new_cursor_tree, &new_cursor_node);
-  else
-    _gtk_rbtree_next_full (cursor_tree, cursor_node,
-			   &new_cursor_tree, &new_cursor_node);
+
+  old_cursor_tree = cursor_tree;
+  old_cursor_node = cursor_node;
+  do {
+    if (count == -1)
+      _gtk_rbtree_prev_full (old_cursor_tree, old_cursor_node,
+                             &new_cursor_tree, &new_cursor_node);
+    else
+      _gtk_rbtree_next_full (old_cursor_tree, old_cursor_node,
+                             &new_cursor_tree, &new_cursor_node);
+
+    if (new_cursor_node)
+      {
+        if (new_cursor_path)
+          gtk_tree_path_free (new_cursor_path);
+
+        new_cursor_path = _gtk_tree_view_find_path (tree_view, new_cursor_tree, new_cursor_node);
+        old_cursor_tree = new_cursor_tree;
+        old_cursor_node = new_cursor_node;
+      }
+  } while (new_cursor_node &&
+           !_gtk_tree_selection_is_row_selectable (tree_view->priv->selection,
+                                                   new_cursor_node,
+                                                   new_cursor_path));
 
   /*
    * If the list has only one item and multi-selection is set then select
@@ -8450,7 +9393,38 @@
   if (new_cursor_node)
     {
       cursor_path = _gtk_tree_view_find_path (tree_view, new_cursor_tree, new_cursor_node);
-      gtk_tree_view_real_set_cursor (tree_view, cursor_path, TRUE, TRUE);
+
+      if (tree_view->priv->checkbox_mode)
+        gtk_tree_view_real_set_cursor (tree_view, cursor_path, FALSE, TRUE);
+      else
+        gtk_tree_view_real_set_cursor (tree_view, cursor_path, TRUE, TRUE);
+
+      if (tree_view->priv->pen_drag_active)
+        {
+          GtkTreePath *last_drag_row_path = gtk_tree_row_reference_get_path (tree_view->priv->last_drag_row);
+          GtkTreePath *first_drag_row_path = gtk_tree_row_reference_get_path (tree_view->priv->first_drag_row);
+
+          if (gtk_tree_path_compare (last_drag_row_path, first_drag_row_path) == 0)
+            tree_view->priv->pen_drag_reverse = FALSE;
+
+          if (tree_view->priv->pen_drag_reverse)
+            {
+              gtk_tree_selection_select_path (tree_view->priv->selection,
+                                              cursor_path);
+              gtk_tree_selection_unselect_path (tree_view->priv->selection,
+                                                last_drag_row_path);
+            }
+
+          gtk_tree_path_free (last_drag_row_path);
+          gtk_tree_path_free (first_drag_row_path);
+          
+          gtk_tree_row_reference_free (tree_view->priv->last_drag_row);
+          
+          tree_view->priv->last_drag_row =
+            gtk_tree_row_reference_new (tree_view->priv->model,
+                                        cursor_path);
+        }
+
       gtk_tree_path_free (cursor_path);
     }
   else
@@ -8467,6 +9441,8 @@
 {
   GtkRBTree *cursor_tree = NULL;
   GtkRBNode *cursor_node = NULL;
+  GtkRBTree *old_cursor_tree = NULL;
+  GtkRBNode *old_cursor_node = NULL;
   GtkTreePath *cursor_path = NULL;
   gint y;
   gint vertical_separator;
@@ -8474,6 +9450,9 @@
   if (! GTK_WIDGET_HAS_FOCUS (tree_view))
     return;
 
+  if (tree_view->priv->tree == NULL)
+    return;
+
   if (gtk_tree_row_reference_valid (tree_view->priv->cursor))
     cursor_path = gtk_tree_row_reference_get_path (tree_view->priv->cursor);
   else
@@ -8504,7 +9483,65 @@
 
   _gtk_rbtree_find_offset (tree_view->priv->tree, y, &cursor_tree, &cursor_node);
   cursor_path = _gtk_tree_view_find_path (tree_view, cursor_tree, cursor_node);
-  g_return_if_fail (cursor_path != NULL);
+
+  while (cursor_node &&
+         !_gtk_tree_selection_is_row_selectable (tree_view->priv->selection,
+                                                 cursor_node,
+                                                 cursor_path))
+    {
+      old_cursor_tree = cursor_tree;
+      old_cursor_node = cursor_node;
+
+      if (count < 0)
+        _gtk_rbtree_prev_full (old_cursor_tree, old_cursor_node,
+                               &cursor_tree, &cursor_node);
+      else
+        _gtk_rbtree_next_full (old_cursor_tree, old_cursor_node,
+                               &cursor_tree, &cursor_node);
+
+      if (cursor_path)
+        {
+          gtk_tree_path_free(cursor_path);
+          cursor_path = NULL;
+        }
+
+      if (cursor_node)
+        cursor_path = _gtk_tree_view_find_path (tree_view, cursor_tree, cursor_node);
+    }
+
+  if (cursor_path == NULL)
+    {
+       /* looks like we reached the end without finding a sensitive row,
+          so search backwards and try to find the last sensitive row as
+          the next best thing */
+      _gtk_rbtree_find_offset (tree_view->priv->tree, y, &cursor_tree, &cursor_node);
+      cursor_path = _gtk_tree_view_find_path (tree_view, cursor_tree, cursor_node);
+      while (cursor_node &&
+             !_gtk_tree_selection_is_row_selectable (tree_view->priv->selection,
+                                                     cursor_node,
+                                                     cursor_path))
+        {
+          old_cursor_tree = cursor_tree;
+          old_cursor_node = cursor_node;
+
+          if (count < 0)
+            _gtk_rbtree_next_full (old_cursor_tree, old_cursor_node,
+                                   &cursor_tree, &cursor_node);
+          else
+            _gtk_rbtree_prev_full (old_cursor_tree, old_cursor_node,
+                                   &cursor_tree, &cursor_node);
+
+          if (cursor_path)
+            {
+              gtk_tree_path_free(cursor_path);
+              cursor_path = NULL;
+            }
+
+          if (cursor_node)
+            cursor_path = _gtk_tree_view_find_path (tree_view, cursor_tree, cursor_node);
+        }
+    }
+
   gtk_tree_view_real_set_cursor (tree_view, cursor_path, TRUE, TRUE);
   gtk_tree_view_clamp_node_visible (tree_view, cursor_tree, cursor_node);
   gtk_tree_path_free (cursor_path);
@@ -8514,6 +9551,8 @@
 gtk_tree_view_move_cursor_left_right (GtkTreeView *tree_view,
 				      gint         count)
 {
+  /* Hildon: cursor is always displayed on an entire row anyway */
+#if 0
   GtkRBTree *cursor_tree = NULL;
   GtkRBNode *cursor_node = NULL;
   GtkTreePath *cursor_path = NULL;
@@ -8589,12 +9628,15 @@
       g_signal_emit (tree_view, tree_view_signals[CURSOR_CHANGED], 0);
     }
   gtk_tree_view_clamp_column_visible (tree_view, tree_view->priv->focus_column);
+#endif
 }
 
 static void
 gtk_tree_view_move_cursor_start_end (GtkTreeView *tree_view,
 				     gint         count)
 {
+  /* Hildon: cursor is always displayed on an entire row anyway */
+#if 0
   GtkRBTree *cursor_tree;
   GtkRBNode *cursor_node;
   GtkTreePath *path;
@@ -8631,6 +9673,7 @@
   path = _gtk_tree_view_find_path (tree_view, cursor_tree, cursor_node);
   gtk_tree_view_real_set_cursor (tree_view, path, TRUE, TRUE);
   gtk_tree_path_free (path);
+#endif
 }
 
 static gboolean
@@ -8670,7 +9713,7 @@
   GtkTreePath *cursor_path = NULL;
   GtkTreeSelectMode mode = 0;
 
-  if (! GTK_WIDGET_HAS_FOCUS (tree_view))
+  if (! GTK_WIDGET_HAS_FOCUS (tree_view) && !tree_view->priv->checkbox_mode)
     return FALSE;
 
   if (tree_view->priv->cursor)
@@ -8731,7 +9774,7 @@
   GtkRBNode *cursor_node = NULL;
   GtkTreePath *cursor_path = NULL;
 
-  if (! GTK_WIDGET_HAS_FOCUS (tree_view))
+  if (! GTK_WIDGET_HAS_FOCUS (tree_view) && !tree_view->priv->checkbox_mode)
     return FALSE;
 
   cursor_path = NULL;
@@ -8774,6 +9817,7 @@
   GtkTreePath *cursor_path = NULL;
   GtkRBTree *tree;
   GtkRBNode *node;
+  gboolean hildon_row = FALSE;
 
   if (! GTK_WIDGET_HAS_FOCUS (tree_view))
     return FALSE;
@@ -8786,20 +9830,46 @@
     return FALSE;
 
   if (_gtk_tree_view_find_node (tree_view, cursor_path, &tree, &node))
-    return FALSE;
+    {
+      gtk_tree_path_free (cursor_path);
 
-  /* Don't handle the event if we aren't an expander */
-  if (!((node->flags & GTK_RBNODE_IS_PARENT) == GTK_RBNODE_IS_PARENT))
-    return FALSE;
+      return FALSE;
+    }
 
+  /* Don't handle the event if we aren't an expander */
   if (!logical
       && gtk_widget_get_direction (GTK_WIDGET (tree_view)) == GTK_TEXT_DIR_RTL)
     expand = !expand;
 
-  if (expand)
-    gtk_tree_view_real_expand_row (tree_view, cursor_path, tree, node, open_all, TRUE);
+  /* Keyboard Navigation: if we can't expand/collapse row, we should either move active focus
+     to child item (right arrow) or move active focus to the parent item (left arrow) */
+  if (expand) 
+    {
+      if ((node->flags & GTK_RBNODE_IS_PARENT) == GTK_RBNODE_IS_PARENT)
+        hildon_row = gtk_tree_view_real_expand_row (tree_view, cursor_path, tree,
+                                                    node, open_all, TRUE);
+
+      if (!hildon_row || !node->children)
+        g_signal_emit_by_name (gtk_widget_get_ancestor (GTK_WIDGET (tree_view),
+                                                        GTK_TYPE_WINDOW),
+                               "move_focus",
+                               GTK_DIR_TAB_FORWARD);
+    }
   else
-    gtk_tree_view_real_collapse_row (tree_view, cursor_path, tree, node, TRUE);
+    {
+      if ((node->flags & GTK_RBNODE_IS_PARENT) == GTK_RBNODE_IS_PARENT)
+        hildon_row = gtk_tree_view_real_collapse_row (tree_view, cursor_path, tree,
+                                                      node, TRUE);
+
+      if (hildon_row == FALSE)
+        {
+          g_signal_emit_by_name (gtk_widget_get_ancestor (GTK_WIDGET(tree_view),
+                                                          GTK_TYPE_WINDOW),
+                                 "move_focus",
+                                 GTK_DIR_TAB_BACKWARD);
+          gtk_tree_view_real_select_cursor_parent (tree_view);
+        }
+    }
 
   gtk_tree_path_free (cursor_path);
 
@@ -9327,6 +10397,16 @@
       tree_view->priv->last_button_press_2 = NULL;
       gtk_tree_row_reference_free (tree_view->priv->scroll_to_path);
       tree_view->priv->scroll_to_path = NULL;
+      gtk_tree_row_reference_free (tree_view->priv->first_drag_row);
+      tree_view->priv->first_drag_row = NULL;
+      gtk_tree_row_reference_free (tree_view->priv->last_drag_row);
+      tree_view->priv->last_drag_row = NULL;
+      gtk_tree_row_reference_free (tree_view->priv->queued_expand_row);
+      tree_view->priv->queued_expand_row = NULL;
+      gtk_tree_row_reference_free (tree_view->priv->queued_select_row);
+      tree_view->priv->queued_select_row = NULL;
+      gtk_tree_row_reference_free (tree_view->priv->queued_activate_row);
+      tree_view->priv->queued_activate_row = NULL;
 
       tree_view->priv->scroll_to_column = NULL;
 
@@ -9402,6 +10482,8 @@
       install_presize_handler (tree_view);
     }
 
+  check_if_can_focus (tree_view);
+
   g_object_notify (G_OBJECT (tree_view), "model");
 
   if (GTK_WIDGET_REALIZED (tree_view))
@@ -9744,6 +10826,10 @@
                                         G_CALLBACK (column_sizing_notify),
                                         tree_view);
 
+  g_signal_handlers_disconnect_by_func (column,
+                                        G_CALLBACK (update_checkbox_mode),
+                                        tree_view);
+
   _gtk_tree_view_column_unset_tree_view (column);
 
   tree_view->priv->columns = g_list_remove (tree_view->priv->columns, column);
@@ -9773,6 +10859,9 @@
   g_object_unref (column);
   g_signal_emit (tree_view, tree_view_signals[COLUMNS_CHANGED], 0);
 
+  if(tree_view->priv->allow_checkbox_mode)
+    update_checkbox_mode (NULL, NULL, tree_view);
+
   return tree_view->priv->n_columns;
 }
 
@@ -9815,6 +10904,9 @@
   g_signal_connect (column, "notify::sizing",
                     G_CALLBACK (column_sizing_notify), tree_view);
 
+  g_signal_connect (column, "notify::visible",
+                    G_CALLBACK (update_checkbox_mode), tree_view);
+
   tree_view->priv->columns = g_list_insert (tree_view->priv->columns,
 					    column, position);
   tree_view->priv->n_columns++;
@@ -9838,6 +10930,11 @@
 
   g_signal_emit (tree_view, tree_view_signals[COLUMNS_CHANGED], 0);
 
+  if(tree_view->priv->allow_checkbox_mode)
+    update_checkbox_mode (NULL, NULL, tree_view);
+
+  check_if_can_focus (tree_view);
+
   return tree_view->priv->n_columns;
 }
 
@@ -10214,12 +11311,20 @@
    * scrolling code, we short-circuit validate_visible_area's immplementation as
    * it is much slower than just going to the point.
    */
-  if (! GTK_WIDGET_REALIZED (tree_view) ||
+  if (!GTK_WIDGET_VISIBLE (tree_view) || GTK_WIDGET_ALLOC_NEEDED (tree_view) ||
       GTK_RBNODE_FLAG_SET (tree_view->priv->tree->root, GTK_RBNODE_DESCENDANTS_INVALID))
     {
       if (tree_view->priv->scroll_to_path)
 	gtk_tree_row_reference_free (tree_view->priv->scroll_to_path);
 
+      /* Unset top row reference since we are going to scroll to new row 
+      to avoid race conditions */
+      if (tree_view->priv->top_row)
+        {
+          gtk_tree_row_reference_free (tree_view->priv->top_row);
+	  tree_view->priv->top_row = NULL;
+	}
+
       tree_view->priv->scroll_to_path = NULL;
       tree_view->priv->scroll_to_column = NULL;
 
@@ -10295,7 +11400,6 @@
 			     GtkTreeViewColumn *column)
 {
   g_return_if_fail (GTK_IS_TREE_VIEW (tree_view));
-
   g_signal_emit (tree_view, tree_view_signals[ROW_ACTIVATED], 0, path, column);
 }
 
@@ -10560,6 +11664,15 @@
   GtkTreeIter iter;
   GtkTreeIter temp;
   gboolean expand;
+  GtkTreePath *collapse_path;
+  GtkRBTree *tree2;
+  GtkRBNode *node2;
+  GtkTreePath *child_path = NULL;
+  GtkTreeIter parent_iter;
+  GtkTreeIter child_iter;
+  GdkRectangle visible_rect;
+  gint children, n;
+  guint total_height, dy;
 
   remove_auto_expand_timeout (tree_view);
 
@@ -10573,8 +11686,12 @@
   if (! gtk_tree_model_iter_has_child (tree_view->priv->model, &iter))
     return FALSE;
 
+  /* Hildon: insensitive rows cannot be expanded */
+  if (!_gtk_tree_selection_is_row_selectable (tree_view->priv->selection,
+                                              node, path))
+    return FALSE;
 
-   if (node->children && open_all)
+  if (node->children && open_all)
     {
       gboolean retval = FALSE;
       GtkTreePath *tmp_path = gtk_tree_path_copy (path);
@@ -10603,6 +11720,35 @@
       return retval;
     }
 
+  /* Hildon: collapse other items in the same level */
+
+  /* find the first child */
+  collapse_path = gtk_tree_path_copy (path);
+  while (gtk_tree_path_prev (collapse_path))
+    ;
+
+  do {
+    if (gtk_tree_path_compare (collapse_path, path) != 0)
+      {
+        _gtk_tree_view_find_node (tree_view, collapse_path, &tree2, &node2);
+ 
+        if (tree2 == NULL)
+          /* end reached already */
+          break;
+ 
+        if (node2->children != NULL &&
+            gtk_tree_view_real_collapse_row (tree_view, collapse_path,
+                                             tree2, node2, FALSE))
+            /* no need to do anything else since only one row may
+               be expanded on any particular level at any time */
+            break;
+      }
+
+    gtk_tree_path_next (collapse_path);
+  } while (1);
+
+  gtk_tree_path_free (collapse_path);
+
   g_signal_emit (tree_view, tree_view_signals[TEST_EXPAND_ROW], 0, &iter, path, &expand);
 
   if (expand)
@@ -10643,8 +11789,59 @@
       GTK_RBNODE_SET_FLAG (node, GTK_RBNODE_IS_SEMI_COLLAPSED);
     }
 
+  /* Do this before the scrolling: ensures the treeview size
+   * is marked as dirty, so that the right scrolling mechanism
+   * will be chosen. */
+  if (GTK_WIDGET_MAPPED (tree_view))
+    {
+      gtk_widget_queue_resize (GTK_WIDGET (tree_view));
+    }
+
   install_presize_handler (tree_view);
 
+  /* autoscroll if necessary */
+  gtk_tree_model_get_iter (tree_view->priv->model, &parent_iter, path);
+  _gtk_tree_view_find_node (tree_view, path, &tree2, &node2);
+  validate_row (tree_view, tree2, node2, &parent_iter, path);
+  total_height = BACKGROUND_HEIGHT (node2);
+  dy = _gtk_rbtree_node_find_offset (tree2, node2);
+  children = gtk_tree_model_iter_n_children (tree_view->priv->model, &parent_iter);
+  for (n = 0; n < children; n++)
+    {
+      gtk_tree_model_iter_nth_child (tree_view->priv->model,
+                                     &child_iter, &parent_iter, n);
+
+      /* must free here so the path of last child is kept for later */
+      if (child_path != NULL)
+        gtk_tree_path_free (child_path);
+
+      child_path = gtk_tree_model_get_path (tree_view->priv->model, &child_iter);
+      _gtk_tree_view_find_node (tree_view, child_path, &tree2, &node2);
+
+      if (CELL_HEIGHT (node2, 0) == 0)
+        validate_row (tree_view, tree2, node2, &child_iter, child_path);
+
+      total_height += BACKGROUND_HEIGHT (node2);
+    }
+
+  gtk_tree_view_get_visible_rect (tree_view, &visible_rect);
+
+  /* Scroll to expanding row, if:
+   * 1. The expanding row + children do not fit into the view
+   * 2. The expanding row is not visible. This only happens when
+   * it has shifted upwards to due to collapsing above. This means
+   * that the expanding row will be clamped to the top, and all
+   * its children will be visible.
+   */
+  if ((total_height > visible_rect.height) ||
+      (dy < tree_view->priv->vadjustment->value))
+    gtk_tree_view_scroll_to_cell (tree_view, path, NULL, TRUE, 0.0, 0.0);
+  else /* Otherwise, scroll to the last child, to make sure all children
+          are visible */
+    gtk_tree_view_scroll_to_cell (tree_view, child_path, NULL, FALSE, 0.0, 0.0);
+
+  gtk_tree_path_free (child_path);
+
   g_signal_emit (tree_view, tree_view_signals[ROW_EXPANDED], 0, &iter, path);
   return TRUE;
 }
@@ -11070,6 +12267,16 @@
   GtkRBTree *tree = NULL;
   GtkRBNode *node = NULL;
 
+  _gtk_tree_view_find_node (tree_view, path, &tree, &node);
+
+  /* Hildon: cursor cannot move to an insensitive row */
+  if (!_gtk_tree_selection_is_row_selectable (tree_view->priv->selection,
+                                              node, path))
+    {
+      g_signal_emit (tree_view, tree_view_signals[ROW_INSENSITIVE], 0, path);
+      return;
+    }
+
   if (gtk_tree_row_reference_valid (tree_view->priv->cursor))
     {
       GtkTreePath *cursor_path;
@@ -11083,7 +12290,6 @@
   tree_view->priv->cursor = gtk_tree_row_reference_new_proxy (G_OBJECT (tree_view),
 							      tree_view->priv->model,
 							      path);
-  _gtk_tree_view_find_node (tree_view, path, &tree, &node);
   if (tree != NULL)
     {
       GtkRBTree *new_tree = NULL;
@@ -11093,7 +12299,8 @@
         {
           GtkTreeSelectMode mode = 0;
 
-          if (tree_view->priv->ctrl_pressed)
+          if (tree_view->priv->ctrl_pressed ||
+              tree_view->priv->pen_drag_active)
             mode |= GTK_TREE_SELECT_MODE_TOGGLE;
           if (tree_view->priv->shift_pressed)
             mode |= GTK_TREE_SELECT_MODE_EXTEND;
@@ -11213,6 +12420,9 @@
 {
   g_return_if_fail (GTK_IS_TREE_VIEW (tree_view));
   g_return_if_fail (path != NULL);
+
+  tree_view->priv->pen_focus = FALSE;
+  
   if (focus_column)
     g_return_if_fail (GTK_IS_TREE_VIEW_COLUMN (focus_column));
   if (focus_cell)
@@ -11414,6 +12624,7 @@
   GtkRBNode *node = NULL;
   gint vertical_separator;
   gint horizontal_separator;
+  gint expander_indent;
 
   g_return_if_fail (GTK_IS_TREE_VIEW (tree_view));
   g_return_if_fail (column == NULL || GTK_IS_TREE_VIEW_COLUMN (column));
@@ -11424,6 +12635,7 @@
   gtk_widget_style_get (GTK_WIDGET (tree_view),
 			"vertical_separator", &vertical_separator,
 			"horizontal_separator", &horizontal_separator,
+                        "expander_indent", &expander_indent,
 			NULL);
 
   rect->x = 0;
@@ -11453,9 +12665,11 @@
 	  TREE_VIEW_DRAW_EXPANDERS (tree_view))
 	{
 	  gint depth = gtk_tree_path_get_depth (path) - 1;
+          gint adjust;
 
-	  rect->x += depth * tree_view->priv->expander_size;
-	  rect->width -= depth * tree_view->priv->expander_size;
+          adjust = depth * tree_view->priv->expander_size + (depth - 1) * expander_indent;
+          rect->x += adjust;
+          rect->width -= adjust;
 	  rect->width = MAX (rect->width, 0);
 	}
     }
@@ -12077,8 +13291,13 @@
       if (gtk_tree_view_is_expander_column (tree_view, column) &&
           TREE_VIEW_DRAW_EXPANDERS(tree_view))
         {
-          cell_area.x += depth * tree_view->priv->expander_size;
-          cell_area.width -= depth * tree_view->priv->expander_size;
+          gint adjust, expander_indent;
+
+          gtk_widget_style_get (widget, "expander_indent", &expander_indent, NULL);
+
+          adjust = depth * tree_view->priv->expander_size + (depth - 1) * expander_indent;
+          cell_area.x += adjust;
+          cell_area.width -= adjust;
         }
 
       if (gtk_tree_view_column_cell_is_visible (column))
@@ -13051,14 +14270,230 @@
   tree_view->priv->row_separator_destroy = destroy;
 }
 
-  
 static void
 gtk_tree_view_grab_notify (GtkWidget *widget,
 			   gboolean   was_grabbed)
 {
   GtkTreeView *tree_view = GTK_TREE_VIEW (widget);
-
   if (!was_grabbed)
-    tree_view->priv->pressed_button = -1;
+    {
+      tree_view->priv->pressed_button = -1;
+
+      if (tree_view->priv->queued_expand_row)
+        {
+          gtk_tree_row_reference_free (tree_view->priv->queued_expand_row);
+          tree_view->priv->queued_expand_row = NULL;
+        }
+      if (tree_view->priv->queued_select_row)
+        {
+          gtk_tree_row_reference_free (tree_view->priv->queued_select_row);
+          tree_view->priv->queued_select_row = NULL;
+        }
+      if (tree_view->priv->queued_activate_row)
+        {
+          gtk_tree_row_reference_free (tree_view->priv->queued_activate_row);
+          tree_view->priv->queued_activate_row = NULL;
+        }
+
+      /* stop pen dragging */
+      if (tree_view->priv->first_drag_row)
+        gtk_tree_row_reference_free (tree_view->priv->first_drag_row);
+      if (tree_view->priv->last_drag_row)
+        gtk_tree_row_reference_free (tree_view->priv->last_drag_row);
+      tree_view->priv->first_drag_row = NULL;
+      tree_view->priv->last_drag_row = NULL;
+      tree_view->priv->pen_down = FALSE;
+      tree_view->priv->pen_drag_active = FALSE;
+      remove_scroll_timeout (tree_view);
+    }
+}
+
+
+static gboolean gtk_tree_view_tap_and_hold_query (GtkWidget *widget,
+                                                  GdkEvent *event)
+{
+  GtkTreeView *tree_view = GTK_TREE_VIEW (widget);
+  GtkTreePath *path;
+  GtkRBTree *tree = NULL;
+  GtkRBNode *node = NULL;
+  gdouble x, y;
+  gint new_y;
+  gboolean sensitive;
+
+  if (!tree_view->priv->tree)
+    return FALSE;
+  
+  if (!gdk_event_get_coords(event, &x, &y))
+    return FALSE;
+
+  new_y = TREE_WINDOW_Y_TO_RBTREE_Y(tree_view, y);
+  if (new_y < 0)
+    new_y = 0;
+  _gtk_rbtree_find_offset (tree_view->priv->tree, new_y, &tree, &node);
+
+  if (node == NULL)
+    return TRUE;
+
+  path = _gtk_tree_view_find_path (tree_view, tree, node);
+  sensitive = _gtk_tree_selection_is_row_selectable (tree_view->priv->selection,
+                                                     node, path);
+  gtk_tree_path_free (path);
+
+  return !sensitive;
+}
+
+
+/* Hildon addition: iterates through columns and cells, looks for
+    a cell with "activatable" attribute and sets or unsets
+    priv->checkbox_mode accordingly (except when checkbox mode
+    is disabled by unsetting allow_checkbox_mode).
+ */
+static void
+update_checkbox_mode (GObject *object, GParamSpec *pspec, gpointer data)
+{
+  GtkTreeView *tree_view = GTK_TREE_VIEW (data);
+  GList *columns = gtk_tree_view_get_columns (tree_view);
+  GList *list;
+  GList *renderers;
+  gboolean allow_checkbox_mode;
+
+  g_object_get (GTK_WIDGET (data),
+                "allow_checkbox_mode", &allow_checkbox_mode, NULL);
+  g_return_if_fail (allow_checkbox_mode);
+
+  for (list = columns; list; list = list->next)
+    {
+      GtkTreeViewColumn *col = GTK_TREE_VIEW_COLUMN (list->data);
+      if (gtk_tree_view_column_get_visible (col) &&
+          _gtk_tree_view_column_has_activatable_cell (col))
+        {
+          /* checkbox column found */
+        
+          for (renderers = gtk_tree_view_column_get_cell_renderers (col);
+               renderers; renderers = renderers->next)
+            {
+              if (GTK_IS_CELL_RENDERER_TOGGLE (renderers->data))
+                {
+                  g_object_set (G_OBJECT (renderers->data),
+                                "checkbox_mode", TRUE,
+                                NULL);
+                }
+            }
+          
+          g_list_free (renderers);
+          
+          tree_view->priv->checkbox_mode = TRUE;
+          g_list_free (columns);
+          return;
+        }
+    }
+
+  /* no checkbox column was found */
+  tree_view->priv->checkbox_mode = FALSE;
+  g_list_free (columns);
+}
+
+static void
+set_dotted_lines (GtkTreeView *tree_view, gboolean enable)
+{
+  if (enable != tree_view->priv->dotted_lines)
+    {
+      tree_view->priv->dotted_lines = enable;
+      gtk_widget_queue_draw (GTK_WIDGET (tree_view));
+    }
+}
+
+/* This function is used to ensure two things:
+ * - in single selection mode, focus will always equal selection
+ * - in multiple selection mode, focus is removed if cursor row is
+ *   explicitly unselected
+ */
+static void
+selection_changed (GtkTreeSelection *selection, gpointer data)
+{
+  GtkTreeView *tree_view = GTK_TREE_VIEW(data);
+  GtkTreePath *cursor_path = NULL;
+  GtkTreeIter iter;
+
+  /* if there are checkboxes, cursor row doesn't have to be selected */
+  if (tree_view->priv->checkbox_mode)
+    return;
+
+  if (gtk_tree_row_reference_valid (tree_view->priv->cursor))
+    cursor_path = gtk_tree_row_reference_get_path (tree_view->priv->cursor);
+
+  if (cursor_path == NULL ||
+      !gtk_tree_selection_path_is_selected (selection, cursor_path))
+    {
+      GtkTreePath *selected_path;
+      GtkRBTree *tree = NULL;
+      GtkRBNode *node = NULL;
+        
+      if (gtk_tree_selection_get_mode (selection) != GTK_SELECTION_MULTIPLE &&
+          gtk_tree_selection_get_selected (selection, NULL, &iter))
+        {
+          selected_path = gtk_tree_model_get_path (tree_view->priv->model,
+                                                   &iter);
+          gtk_tree_view_real_set_cursor (tree_view, selected_path, TRUE, TRUE);
+          _gtk_tree_view_find_node (tree_view, selected_path, &tree, &node);
+          gtk_tree_view_clamp_node_visible (tree_view, tree, node);
+          gtk_tree_path_free (selected_path);
+          gtk_widget_grab_focus (GTK_WIDGET (tree_view));
+        }
+      else
+        {
+          gtk_tree_row_reference_free (tree_view->priv->cursor);
+          tree_view->priv->cursor = NULL;
+        }
+    }
+
+  if (cursor_path)
+    gtk_tree_path_free (cursor_path);
 }
 
+/* Helper function for ensuring that GtkTreeView is focusable
+ * if and only if it contains at least one sensitive top-level row.
+ * Should be called whenever the existence of a sensitive top-level row
+ * might have changed.
+ */
+static void
+check_if_can_focus (GtkTreeView *tree_view)
+{
+  GtkTreeModel *model = gtk_tree_view_get_model (tree_view);
+  GtkTreeIter iter;
+
+  if (model == NULL || !GTK_WIDGET_MAPPED (tree_view))
+    return;
+
+  if (gtk_tree_model_get_iter_first (model, &iter) == FALSE)
+    {
+      GTK_WIDGET_UNSET_FLAGS (tree_view, GTK_CAN_FOCUS);
+      return;
+    }
+
+  do {
+    GtkTreePath *path = gtk_tree_model_get_path (model, &iter);
+    GtkRBTree *tree;
+    GtkRBNode *node;
+
+    _gtk_tree_view_find_node (tree_view, path, &tree, &node);
+
+    if (tree && node &&
+        _gtk_tree_selection_is_row_selectable (tree_view->priv->selection,
+                                               node, path))
+      {
+        GTK_WIDGET_SET_FLAGS (tree_view, GTK_CAN_FOCUS);
+        if (!gtk_tree_row_reference_valid (tree_view->priv->cursor))
+          gtk_tree_view_real_set_cursor (tree_view, path,
+                                         !tree_view->priv->checkbox_mode,
+                                         TRUE);
+
+        gtk_tree_path_free (path);
+        return;
+      }
+
+    gtk_tree_path_free (path);
+  } while (gtk_tree_model_iter_next (model, &iter));
+
+  GTK_WIDGET_UNSET_FLAGS (tree_view, GTK_CAN_FOCUS);
+}
--- gtk+/gtk/gtkhashtable.c	(.../2.6.4)	(revision 0)
+++ gtk+/gtk/gtkhashtable.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -0,0 +1,99 @@
+/* GTK - The GIMP Toolkit
+ * Copyright (C) 2005 Nokia Corporation
+ * Author: Jorn Baayen <jbaayen@gnome.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <config.h>
+#include "gtkhashtable.h"
+
+static gpointer parent_class = NULL;
+
+static void _gtk_hash_table_init       (GtkHashTable      *hash_table);
+static void _gtk_hash_table_class_init (GtkHashTableClass *klass);
+static void _gtk_hash_table_finalize   (GObject           *object);
+
+GType
+_gtk_hash_table_get_type (void)
+{
+  static GType hash_table_type = 0;
+
+  if (!hash_table_type)
+    {
+      static const GTypeInfo hash_table_info =
+      {
+        sizeof (GtkHashTableClass),
+        NULL,		/* base_init */
+        NULL,		/* base_finalize */
+        (GClassInitFunc) _gtk_hash_table_class_init,
+        NULL,           /* class_finalize */
+        NULL,           /* class_data */
+        sizeof (GtkHashTable),
+        0,              /* n_preallocs */
+        (GInstanceInitFunc) _gtk_hash_table_init,
+      };
+      
+      hash_table_type =
+	g_type_register_static (G_TYPE_OBJECT, "GtkHashTable",
+				&hash_table_info, 0);
+    }
+  
+  return hash_table_type;
+}
+
+static void
+_gtk_hash_table_init (GtkHashTable *hash_table)
+{
+  hash_table->hash = g_hash_table_new_full (g_str_hash, g_str_equal,
+				            g_free, g_free);
+}
+
+static void
+_gtk_hash_table_class_init (GtkHashTableClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+  
+  parent_class = g_type_class_peek_parent (klass);
+
+  object_class->finalize = _gtk_hash_table_finalize;
+}
+
+static void
+_gtk_hash_table_finalize (GObject *object)
+{
+  GtkHashTable *hash_table = GTK_HASH_TABLE (object);
+
+  g_hash_table_destroy (hash_table->hash);
+  
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+/**
+ * _gtk_hash_table_new:
+ *
+ * Creates a new #GtkHashTable. This is a #GHashTable wrapped in a GObject,
+ * thereby supporting refcounting.
+ * 
+ * Return value: a new #GtkHashTable
+ **/
+GtkHashTable*
+_gtk_hash_table_new (void)
+{
+  return g_object_new (GTK_TYPE_HASH_TABLE, NULL);
+}
+
+
--- gtk+/gtk/gtktreeview.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtktreeview.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -102,12 +102,14 @@
   gboolean (* select_cursor_parent)       (GtkTreeView       *tree_view);
   gboolean (* start_interactive_search)   (GtkTreeView       *tree_view);
 
+  void     (* row_insensitive)            (GtkTreeView       *tree_view,
+                                           GtkTreePath       *path);
+
   /* Padding for future expansion */
   void (*_gtk_reserved0) (void);
   void (*_gtk_reserved1) (void);
   void (*_gtk_reserved2) (void);
   void (*_gtk_reserved3) (void);
-  void (*_gtk_reserved4) (void);
 };
 
 
--- gtk+/gtk/gtkhashtable.h	(.../2.6.4)	(revision 0)
+++ gtk+/gtk/gtkhashtable.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -0,0 +1,61 @@
+/* GTK - The GIMP Toolkit
+ * Copyright (C) 2005 Nokia Corporation.
+ * Author: Jorn Baayen <jbaayen@gnome.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GTK_HASH_TABLE_H__
+#define __GTK_HASH_TABLE_H__
+
+#include <glib-object.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+typedef struct _GtkHashTable GtkHashTable;
+typedef struct _GtkHashTableClass GtkHashTableClass;
+
+#define GTK_TYPE_HASH_TABLE              (_gtk_hash_table_get_type ())
+#define GTK_HASH_TABLE(object)           (G_TYPE_CHECK_INSTANCE_CAST ((object), GTK_TYPE_HASH_TABLE, GtkHashTable))
+#define GTK_HASH_TABLE_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST ((klass), GTK_TYPE_HASH_TABLE, GtkHashTableClass))
+#define GTK_IS_HASH_TABLE(object)        (G_TYPE_CHECK_INSTANCE_TYPE ((object), GTK_TYPE_HASH_TABLE))
+#define GTK_IS_HASH_TABLE_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE ((klass), GTK_TYPE_HASH_TABLE))
+#define GTK_HASH_TABLE_GET_CLASS(obj)    (G_TYPE_INSTANCE_GET_CLASS ((obj), GTK_TYPE_HASH_TABLE, GtkHashTableClass))
+
+struct _GtkHashTable
+{
+  GObject parent_instance;
+
+  GHashTable *hash;
+};
+
+struct _GtkHashTableClass
+{
+  GObjectClass parent_class;
+};
+
+GType         _gtk_hash_table_get_type (void) G_GNUC_CONST;
+GtkHashTable* _gtk_hash_table_new      (void);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __GTK_HASH_TABLE_H__ */
+
+
--- gtk+/gtk/gtktoolbar.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtktoolbar.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -67,7 +67,9 @@
 
 #define DEFAULT_ICON_SIZE GTK_ICON_SIZE_LARGE_TOOLBAR
 #define DEFAULT_TOOLBAR_STYLE GTK_TOOLBAR_BOTH
+#define DEFAULT_ANIMATION_STATE FALSE
 
+#define DEFAULT_MAX_CHILD_SPACING   G_MAXINT
 #define MAX_HOMOGENEOUS_N_CHARS 13 /* Items that are wider than this do not participate
 				    * in the homogeneous game. In units of
 				    * pango_font_get_estimated_char_width().
@@ -140,10 +142,14 @@
   
   GTimer *	timer;
   
+  guint   animation_connection;
+
   guint		show_arrow : 1;
   guint		need_sync : 1;
   guint		is_sliding : 1;
   guint		need_rebuild : 1;	/* whether the overflow menu should be regenerated */
+  guint   animation_set : 1;
+  guint   animation : 1;
 };
 
 static void       gtk_toolbar_init                 (GtkToolbar          *toolbar);
@@ -225,9 +231,11 @@
 static void       gtk_toolbar_reconfigured         (GtkToolbar          *toolbar);
 static gboolean   gtk_toolbar_check_new_api        (GtkToolbar          *toolbar);
 static gboolean   gtk_toolbar_check_old_api        (GtkToolbar          *toolbar);
+static void       gtk_toolbar_update_animation_state (GtkToolbar         *toolbar);
 
 static GtkReliefStyle       get_button_relief    (GtkToolbar *toolbar);
 static gint                 get_internal_padding (GtkToolbar *toolbar);
+static gint                 get_max_child_expand (GtkToolbar *toolbar);
 static GtkShadowType        get_shadow_type      (GtkToolbar *toolbar);
 static gint                 get_space_size       (GtkToolbar *toolbar);
 static GtkToolbarSpaceStyle get_space_style      (GtkToolbar *toolbar);
@@ -563,6 +571,15 @@
                                                              G_PARAM_READABLE));
   
   gtk_widget_class_install_style_property (widget_class,
+					   g_param_spec_int ("max_child_expand",
+							     P_("Maximum toolbar item spacing"),
+							     P_("Maximum space between the toolbar items."),
+							     0,
+							     G_MAXINT,
+                                                             DEFAULT_MAX_CHILD_SPACING,
+                                                             G_PARAM_READABLE));
+  
+  gtk_widget_class_install_style_property (widget_class,
 					   g_param_spec_enum ("space_style",
 							      P_("Space style"),
 							      P_("Whether spacers are vertical lines or just blank"),
@@ -598,6 +615,12 @@
                                                     GTK_TYPE_ICON_SIZE,
                                                     DEFAULT_ICON_SIZE,
                                                     G_PARAM_READWRITE));  
+
+  gtk_settings_install_property (g_param_spec_boolean ("gtk-toolbar-animation",
+                                                    P_("Toolbar animation"),
+                                                    P_("Are we using toolbar animation"),
+                                                    DEFAULT_ANIMATION_STATE,
+                                                    G_PARAM_READWRITE));  
   
   binding_set = gtk_binding_set_by_class (klass);
   
@@ -638,6 +661,7 @@
   toolbar->orientation = GTK_ORIENTATION_HORIZONTAL;
   toolbar->style = DEFAULT_TOOLBAR_STYLE;
   toolbar->icon_size = DEFAULT_ICON_SIZE;
+  priv->animation = DEFAULT_ANIMATION_STATE;
   toolbar->tooltips = gtk_tooltips_new ();
   g_object_ref (toolbar->tooltips);
   gtk_object_sink (GTK_OBJECT (toolbar->tooltips));
@@ -960,7 +984,7 @@
 }
 
 static gint
-position (gint from, gint to, gdouble elapsed)
+position (GtkToolbar *toolbar, gint from, gint to, gdouble elapsed)
 {
   gint n_pixels;
 
@@ -978,11 +1002,20 @@
       n_pixels = (SLIDE_SPEED / ACCEL_THRESHOLD) * elapsed * elapsed -
 	SLIDE_SPEED * elapsed + SLIDE_SPEED * ACCEL_THRESHOLD;
     }
-  
-  if (to > from)
-    return MIN (from + n_pixels, to);
-  else
-    return MAX (from - n_pixels, to);
+  if (GTK_TOOLBAR_GET_PRIVATE (toolbar)->animation) {
+    if (to > from)
+      return MIN (from + n_pixels, to);
+    else
+      return MAX (from - n_pixels, to);
+  }
+  return to;
+}
+
+static GtkSettings *
+toolbar_get_settings (GtkToolbar *toolbar)
+{
+   GtkToolbarPrivate *priv = GTK_TOOLBAR_GET_PRIVATE (toolbar);
+   return priv->settings;
 }
 
 static void
@@ -994,12 +1027,12 @@
   GtkToolbarPrivate *priv = GTK_TOOLBAR_GET_PRIVATE (toolbar);
   gdouble elapsed = g_timer_elapsed (priv->timer, NULL);
   
-  intermediate->x = position (start->x, goal->x, elapsed);
-  intermediate->y = position (start->y, goal->y, elapsed);
+  intermediate->x = position (toolbar, start->x, goal->x, elapsed);
+  intermediate->y = position (toolbar, start->y, goal->y, elapsed);
   intermediate->width =
-    position (start->x + start->width, goal->x + goal->width, elapsed) - intermediate->x;
+    position (toolbar, start->x + start->width, goal->x + goal->width, elapsed) - intermediate->x;
   intermediate->height =
-    position (start->y + start->height, goal->y + goal->height, elapsed) - intermediate->y;
+    position (toolbar, start->y + start->height, goal->y + goal->height, elapsed) - intermediate->y;
 }
 
 static void
@@ -1047,6 +1080,32 @@
     }
 }
 
+static void
+gtk_toolbar_update_animation_state (GtkToolbar *toolbar)
+{
+  gboolean animation_state;
+  GtkToolbarPrivate *priv = GTK_TOOLBAR_GET_PRIVATE (toolbar);
+  
+  g_return_if_fail (GTK_IS_TOOLBAR (toolbar));
+  
+  if (priv->animation_set)
+    {
+      GtkSettings *settings = toolbar_get_settings (toolbar);
+      
+      if (settings)
+      	{
+      	  g_object_get (settings,
+      			"gtk-toolbar-animation", &animation_state,
+      			NULL);
+        }
+      else
+      	animation_state = DEFAULT_ANIMATION_STATE;
+
+      priv->animation = animation_state;
+      priv->animation_set = FALSE;
+    }
+}
+
 static gboolean
 slide_idle_handler (gpointer data)
 {
@@ -1537,10 +1596,14 @@
 	  
 	  if (toolbar_content_get_expand (content) && new_states[i] == NORMAL)
 	    {
+	      gint mexpand = get_max_child_expand(toolbar);
 	      gint extra = size / n_expand_items;
 	      if (size % n_expand_items != 0)
 		extra++;
-	      
+	      if (extra > mexpand) {
+		extra = mexpand;
+	      }
+
 	      allocations[i].width += extra;
 	      size -= extra;
 	      n_expand_items--;
@@ -1932,11 +1995,16 @@
     }
 }
 
-static GtkSettings *
-toolbar_get_settings (GtkToolbar *toolbar)
+static void
+animation_change_notify (GtkToolbar *toolbar)
 {
   GtkToolbarPrivate *priv = GTK_TOOLBAR_GET_PRIVATE (toolbar);
-  return priv->settings;
+  if (!priv->animation_set)
+    {
+      /* pretend it was set, then unset, thus reverting to new default */
+      priv->animation_set = TRUE; 
+      gtk_toolbar_update_animation_state (toolbar);
+    }
 }
 
 static void
@@ -1960,6 +2028,7 @@
     {
       g_signal_handler_disconnect (old_settings, toolbar->style_set_connection);
       g_signal_handler_disconnect (old_settings, toolbar->icon_size_connection);
+      g_signal_handler_disconnect (old_settings, priv->animation_connection);
       
       g_object_unref (old_settings);
     }
@@ -1976,6 +2045,11 @@
 				  "notify::gtk-toolbar-icon-size",
 				  G_CALLBACK (icon_size_change_notify),
 				  toolbar);
+      priv->animation_connection =
+	g_signal_connect_swapped (settings,
+				  "notify::gtk-toolbar-animation",
+				  G_CALLBACK (animation_change_notify),
+				  toolbar);
       
       g_object_ref (settings);
       priv->settings = settings;
@@ -1985,6 +2059,7 @@
   
   style_change_notify (toolbar);
   icon_size_change_notify (toolbar);
+  animation_change_notify (toolbar);
 }
 
 static int
@@ -2913,7 +2988,7 @@
  * gtk_toolbar_get_icon_size:
  * @toolbar: a #GtkToolbar
  *
- * Retrieves the icon size fo the toolbar. See gtk_toolbar_set_icon_size().
+ * Retrieves the icon size for the toolbar. See gtk_toolbar_set_icon_size().
  *
  * Return value: the current icon size for the icons on the toolbar.
  **/
@@ -4642,6 +4717,17 @@
   return ipadding;
 }
 
+static gint
+get_max_child_expand (GtkToolbar *toolbar)
+{
+  gint mexpand = DEFAULT_MAX_CHILD_SPACING;
+  
+  gtk_widget_style_get (GTK_WIDGET (toolbar),
+		  	"max_child_expand", &mexpand,
+			NULL);
+  return mexpand;
+}
+
 static GtkShadowType
 get_shadow_type (GtkToolbar *toolbar)
 {
--- gtk+/gtk/gtktreeselection.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtktreeselection.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -190,11 +190,28 @@
 			     GtkSelectionMode  type)
 {
   GtkTreeSelectionFunc tmp_func;
+  
   g_return_if_fail (GTK_IS_TREE_SELECTION (selection));
 
   if (selection->type == type)
     return;
 
+  /* Hildon addition */
+  if ((type == GTK_SELECTION_SINGLE) &&
+      (selection->type == GTK_SELECTION_MULTIPLE ||
+       selection->type == GTK_SELECTION_BROWSE))
+    {
+      GtkTreePath *cursor_path;
+
+      /* to successfully switch from multiple selection mode to single
+         selection, we must ensure that anchor exists and is selected
+         since otherwise gtk_tree_selection_select_path won't work anymore */
+      if (gtk_tree_row_reference_valid (selection->tree_view->priv->cursor))
+        {
+          cursor_path = gtk_tree_row_reference_get_path (selection->tree_view->priv->cursor);          gtk_tree_selection_select_path (selection, cursor_path);
+          gtk_tree_path_free (cursor_path);
+        }
+    }
   
   if (type == GTK_SELECTION_NONE)
     {
@@ -251,6 +268,20 @@
     }
 
   selection->type = type;
+
+  /* Hildon addition */
+  if (type == GTK_SELECTION_SINGLE)
+    {
+      GtkTreePath *path;
+      GtkTreeIter iter;
+
+      /* reset cursor to the selected row */
+      gtk_tree_selection_get_selected (selection, NULL, &iter);
+      path = gtk_tree_model_get_path (selection->tree_view->priv->model,
+                                      &iter);
+      gtk_tree_view_set_cursor (selection->tree_view, path, NULL, FALSE);
+      gtk_tree_path_free (path);
+    }
 }
 
 /**
@@ -1319,10 +1350,10 @@
   return sensitive;
 }
 
-static gboolean
-row_is_selectable (GtkTreeSelection *selection,
-		   GtkRBNode        *node,
-		   GtkTreePath      *path)
+gboolean
+_gtk_tree_selection_is_row_selectable (GtkTreeSelection *selection,
+                                       GtkRBNode        *node,
+                                       GtkTreePath      *path)
 {
   GList *list;
   GtkTreeIter iter;
@@ -1411,7 +1442,7 @@
 	    {
 	      /* We only want to select the new node if we can unselect the old one,
 	       * and we can select the new one. */
-	      dirty = row_is_selectable (selection, node, path);
+	      dirty = _gtk_tree_selection_is_row_selectable (selection, node, path);
 
 	      /* if dirty is FALSE, we weren't able to select the new one, otherwise, we try to
 	       * unselect the new one
@@ -1528,8 +1559,13 @@
   if (GTK_RBNODE_FLAG_SET (node, GTK_RBNODE_IS_SELECTED) != select)
     {
       path = _gtk_tree_view_find_path (selection->tree_view, tree, node);
-      selected = row_is_selectable (selection, node, path);
+      selected = _gtk_tree_selection_is_row_selectable (selection, node, path);
       gtk_tree_path_free (path);
+
+      /* if row is unselectable, allow unselection only */
+      if (!selected && !select &&
+          GTK_RBNODE_FLAG_SET (node, GTK_RBNODE_IS_SELECTED))
+        selected = TRUE;
     }
 
   if (selected == TRUE)
--- gtk+/gtk/gtk.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtk.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -156,6 +156,7 @@
 #include <gtk/gtktearoffmenuitem.h>
 #include <gtk/gtktext.h>
 #include <gtk/gtktextbuffer.h>
+#include <gtk/gtktextbufferserialize.h>
 #include <gtk/gtktextview.h>
 #include <gtk/gtktipsquery.h>
 #include <gtk/gtktoggleaction.h>
--- gtk+/gtk/gtkimmulticontext.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkimmulticontext.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -59,6 +59,8 @@
 static void     gtk_im_multicontext_focus_in           (GtkIMContext            *context);
 static void     gtk_im_multicontext_focus_out          (GtkIMContext            *context);
 static void     gtk_im_multicontext_reset              (GtkIMContext            *context);
+static void     gtk_im_multicontext_show               (GtkIMContext            *context);
+static void     gtk_im_multicontext_hide               (GtkIMContext            *context);
 static void     gtk_im_multicontext_set_cursor_location (GtkIMContext            *context,
 							GdkRectangle		*area);
 static void     gtk_im_multicontext_set_use_preedit    (GtkIMContext            *context,
@@ -88,7 +90,34 @@
 							     GtkIMMulticontext *multicontext);
 static GtkIMContextClass *parent_class;
 
-static const gchar *global_context_id = NULL;
+static gchar*
+get_global_context_id(void)
+{
+  GdkAtom atom, type, actual_type;
+
+  gint actual_format, actual_length;
+  guchar *context_id;
+
+  atom = gdk_atom_intern("gtk-global-immodule", FALSE);
+  type = gdk_atom_intern("STRING", FALSE);
+  if (!gdk_property_get(gdk_screen_get_root_window (gdk_screen_get_default ()),
+			atom,
+			type,
+			0,
+			G_MAXLONG,
+			FALSE,
+			&actual_type,
+			&actual_format,
+			&actual_length,
+			&context_id)) {
+    /* Fall back to default locale */
+    gchar *locale = _gtk_get_lc_ctype ();
+    context_id = _gtk_im_module_get_default_context_id (locale);
+    g_free (locale);
+  }
+  
+  return context_id;
+}
 
 GType
 gtk_im_multicontext_get_type (void)
@@ -118,6 +147,67 @@
   return im_multicontext_type;
 }
 
+static GtkIMContext *
+gtk_im_multicontext_get_slave (GtkIMMulticontext *multicontext);
+
+enum {
+  PROP_INPUT_MODE = 1,
+  PROP_AUTOCAP,
+  PROP_VISIBILITY,
+  PROP_USE_SHOW_HIDE
+};
+
+static void gtk_im_multicontext_set_property(GObject * object,
+                                                  guint property_id,
+                                                  const GValue * value,
+                                                  GParamSpec * pspec)
+{
+  GtkIMContext *slave = gtk_im_multicontext_get_slave (GTK_IM_MULTICONTEXT(object));
+
+  GParamSpec *param_spec = g_object_class_find_property 
+    (G_OBJECT_GET_CLASS(slave),
+     pspec->name);
+
+  if(param_spec != NULL)   
+    g_object_set_property(G_OBJECT(slave), pspec->name, value);
+}
+
+static void gtk_im_multicontext_get_property(GObject * object,
+                                                  guint property_id,
+                                                  GValue * value,
+                                                  GParamSpec * pspec)
+{
+  GtkIMContext *slave = gtk_im_multicontext_get_slave (GTK_IM_MULTICONTEXT(object));
+  GParamSpec *param_spec = g_object_class_find_property 
+    (G_OBJECT_GET_CLASS(slave),
+     pspec->name);
+  
+  if(param_spec != NULL)
+    g_object_get_property(G_OBJECT(slave), pspec->name, value);
+  else
+    {
+      switch (property_id)
+	{
+	case PROP_INPUT_MODE:
+	  /* return 0 */
+	  g_value_set_int(value, 0);
+	  break;
+	case PROP_AUTOCAP:
+	  /* return FALSE */
+	  g_value_set_boolean(value, FALSE);
+	  break;
+	case PROP_VISIBILITY:
+	  /* return TRUE */
+	  g_value_set_boolean(value, TRUE);	  
+	  break;
+	case PROP_USE_SHOW_HIDE:
+	default:
+	  G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+	  break;	  
+	}
+    }
+}
+
 static void
 gtk_im_multicontext_class_init (GtkIMMulticontextClass *class)
 {
@@ -132,12 +222,38 @@
   im_context_class->focus_in = gtk_im_multicontext_focus_in;
   im_context_class->focus_out = gtk_im_multicontext_focus_out;
   im_context_class->reset = gtk_im_multicontext_reset;
+  im_context_class->show = gtk_im_multicontext_show;
+  im_context_class->hide = gtk_im_multicontext_hide;
   im_context_class->set_cursor_location = gtk_im_multicontext_set_cursor_location;
   im_context_class->set_use_preedit = gtk_im_multicontext_set_use_preedit;
   im_context_class->set_surrounding = gtk_im_multicontext_set_surrounding;
   im_context_class->get_surrounding = gtk_im_multicontext_get_surrounding;
 
   gobject_class->finalize = gtk_im_multicontext_finalize;
+
+  gobject_class->set_property = gtk_im_multicontext_set_property;
+  gobject_class->get_property = gtk_im_multicontext_get_property;
+
+  g_object_class_install_property(gobject_class, PROP_INPUT_MODE,
+        g_param_spec_int("input-mode", "Input mode",
+          "Specifies the set of allowed characters",
+          0, 9, 0,  /* We don't move symbolic definitions here. See hildon-input-mode.h */
+          G_PARAM_READWRITE));
+
+  g_object_class_install_property(gobject_class, PROP_AUTOCAP,
+        g_param_spec_boolean("autocap", "Autocap",
+          "Whether the client wants the first character in a sentense to be automatic upper case",
+          FALSE, G_PARAM_READWRITE));
+
+  g_object_class_install_property(gobject_class, PROP_VISIBILITY,
+        g_param_spec_boolean("visibility", "Visibility",
+          "FALSE displays the \"invisible char\"instead of the actual text (password mode)",
+          TRUE, G_PARAM_READABLE | G_PARAM_WRITABLE));
+
+  g_object_class_install_property(gobject_class, PROP_VISIBILITY,
+        g_param_spec_boolean("use-show-hide", "Use show/hide functions",
+          "Use show/hide functions to show/hide IM instead of focus_in/focus_out",
+          FALSE, G_PARAM_READABLE | G_PARAM_WRITABLE));
 }
 
 static void
@@ -204,6 +320,9 @@
       g_object_unref (multicontext->slave);
       multicontext->slave = NULL;
 
+      g_free (multicontext->context_id);
+      multicontext->context_id = NULL;
+
       if (!finalizing)
 	need_preedit_changed = TRUE;
     }
@@ -253,18 +372,13 @@
   if (!multicontext->slave)
     {
       GtkIMContext *slave;
+      gchar *global_context_id = get_global_context_id();
 
-      if (!global_context_id)
-	{
-	  gchar *locale = _gtk_get_lc_ctype ();
-	  global_context_id = _gtk_im_module_get_default_context_id (locale);
-	  g_free (locale);
-	}
-	
       slave = _gtk_im_module_create (global_context_id);
       gtk_im_multicontext_set_slave (multicontext, slave, FALSE);
       g_object_unref (slave);
 
+      g_free (multicontext->context_id);
       multicontext->context_id = global_context_id;
     }
 
@@ -323,6 +437,7 @@
 {
   GtkIMMulticontext *multicontext = GTK_IM_MULTICONTEXT (context);
   GtkIMContext *slave;
+  gchar *global_context_id = get_global_context_id();
 
   /* If the global context type is different from the context we were
    * using before, get rid of the old slave and create a new one
@@ -338,6 +453,8 @@
   
   if (slave)
     gtk_im_context_focus_in (slave);
+
+  g_free (global_context_id);
 }
 
 static void
@@ -485,11 +602,8 @@
 {
   if (GTK_CHECK_MENU_ITEM (menuitem)->active)
     {
-      const gchar *id = g_object_get_data (G_OBJECT (menuitem), "gtk-context-id");
-
       gtk_im_context_reset (GTK_IM_CONTEXT (context));
       
-      global_context_id = id;
       gtk_im_multicontext_set_slave (context, NULL, FALSE);
     }
 }
@@ -510,6 +624,7 @@
   const GtkIMContextInfo **contexts;
   guint n_contexts, i;
   GSList *group = NULL;
+  gchar *global_context_id = get_global_context_id();
   
   _gtk_im_module_list (&contexts, &n_contexts);
 
@@ -564,6 +679,43 @@
       gtk_menu_shell_append (menushell, menuitem);
     }
 
+  g_free (global_context_id);
   g_free (contexts);
 }
 
+static void
+gtk_im_multicontext_show (GtkIMContext   *context)
+{
+  GtkIMMulticontext *multicontext = GTK_IM_MULTICONTEXT (context);
+  GtkIMContext *slave;
+  gchar *global_context_id = get_global_context_id();
+
+  /* If the global context type is different from the context we were
+   * using before, get rid of the old slave and create a new one
+   * for the new global context type.
+   */
+  if (!multicontext->context_id ||
+      strcmp (global_context_id, multicontext->context_id) != 0)
+    gtk_im_multicontext_set_slave (multicontext, NULL, FALSE);
+
+  slave = gtk_im_multicontext_get_slave (multicontext);
+  
+  multicontext->priv->focus_in = TRUE;
+  
+  if (slave)
+    gtk_im_context_show (slave);
+  
+  g_free (global_context_id);
+}
+
+static void
+gtk_im_multicontext_hide (GtkIMContext   *context)
+{
+  GtkIMMulticontext *multicontext = GTK_IM_MULTICONTEXT (context);
+  GtkIMContext *slave = gtk_im_multicontext_get_slave (multicontext);
+
+  multicontext->priv->focus_in = FALSE;
+  
+  if (slave)
+    gtk_im_context_hide (slave);
+}
--- gtk+/gtk/gtkimmulticontext.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkimmulticontext.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -48,7 +48,7 @@
 
   GtkIMMulticontextPrivate *priv;
 
-  const gchar *context_id;
+  gchar *context_id;
 };
 
 struct _GtkIMMulticontextClass
--- gtk+/gtk/gtkmenushell.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkmenushell.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -39,19 +39,25 @@
 #include "gtkmnemonichash.h"
 #include "gtktearoffmenuitem.h"
 #include "gtkwindow.h"
-
-#define MENU_SHELL_TIMEOUT   500
+#include "gtkprivate.h"
+#include "gtkintl.h"
 
 enum {
   DEACTIVATE,
   SELECTION_DONE,
   MOVE_CURRENT,
   ACTIVATE_CURRENT,
+  CLOSE,
   CANCEL,
   CYCLE_FOCUS,
   LAST_SIGNAL
 };
 
+enum {
+  PROP_0,
+  PROP_TAKE_FOCUS
+};
+
 typedef void (*GtkMenuShellSignal1) (GtkObject           *object,
 				     GtkMenuDirectionType arg1,
 				     gpointer             data);
@@ -110,6 +116,9 @@
  *     the current menu item always. Otherwise, only hide
  *     it if menu_item->klass->hide_on_activate is true.
  *
+ *  ::close ()
+ *  	Closes the active menu. 
+ *
  *  ::cancel ()
  *     Cancels the current selection
  */
@@ -122,16 +131,28 @@
 {
   GtkMnemonicHash *mnemonic_hash;
   GtkKeyHash *key_hash;
+  gboolean activated_submenu;
+  gboolean take_focus;
+  gboolean first_click;
 };
 
 static void gtk_menu_shell_class_init        (GtkMenuShellClass *klass);
 static void gtk_menu_shell_init              (GtkMenuShell      *menu_shell);
+static void gtk_menu_shell_set_property      (GObject           *object,
+                                               guint              prop_id,
+                                               const GValue      *value,
+                                               GParamSpec        *pspec);
+static void gtk_menu_shell_get_property      (GObject           *object,
+                                               guint              prop_id,
+                                               GValue            *value,
+                                               GParamSpec        *pspec);
 static void gtk_menu_shell_realize           (GtkWidget         *widget);
 static void gtk_menu_shell_finalize          (GObject           *object);
 static gint gtk_menu_shell_button_press      (GtkWidget         *widget,
 					      GdkEventButton    *event);
 static gint gtk_menu_shell_button_release    (GtkWidget         *widget,
 					      GdkEventButton    *event);
+static void gtk_menu_shell_insensitive_press (GtkWidget         *widget);
 static gint gtk_menu_shell_key_press         (GtkWidget	        *widget,
 					      GdkEventKey       *event);
 static gint gtk_menu_shell_enter_notify      (GtkWidget         *widget,
@@ -166,6 +187,7 @@
 static void gtk_real_menu_shell_activate_current (GtkMenuShell      *menu_shell,
 						  gboolean           force_hide);
 static void gtk_real_menu_shell_cancel           (GtkMenuShell      *menu_shell);
+static void gtk_real_menu_shell_close            (GtkMenuShell      *menu_shell);
 static void gtk_real_menu_shell_cycle_focus      (GtkMenuShell      *menu_shell,
 						  GtkDirectionType   dir);
 
@@ -176,7 +198,6 @@
 static GtkContainerClass *parent_class = NULL;
 static guint menu_shell_signals[LAST_SIGNAL] = { 0 };
 
-
 GType
 gtk_menu_shell_get_type (void)
 {
@@ -220,12 +241,15 @@
   container_class = (GtkContainerClass*) klass;
 
   parent_class = g_type_class_peek_parent (klass);
+  object_class->set_property = gtk_menu_shell_set_property;
+  object_class->get_property = gtk_menu_shell_get_property;
 
   object_class->finalize = gtk_menu_shell_finalize;
 
   widget_class->realize = gtk_menu_shell_realize;
   widget_class->button_press_event = gtk_menu_shell_button_press;
   widget_class->button_release_event = gtk_menu_shell_button_release;
+  widget_class->insensitive_press = gtk_menu_shell_insensitive_press;
   widget_class->key_press_event = gtk_menu_shell_key_press;
   widget_class->enter_notify_event = gtk_menu_shell_enter_notify;
   widget_class->leave_notify_event = gtk_menu_shell_leave_notify;
@@ -241,6 +265,7 @@
   klass->selection_done = NULL;
   klass->move_current = gtk_real_menu_shell_move_current;
   klass->activate_current = gtk_real_menu_shell_activate_current;
+  klass->close = gtk_real_menu_shell_close;
   klass->cancel = gtk_real_menu_shell_cancel;
   klass->select_item = gtk_menu_shell_real_select_item;
   klass->insert = gtk_menu_shell_real_insert;
@@ -279,6 +304,14 @@
 		  _gtk_marshal_VOID__BOOLEAN,
 		  G_TYPE_NONE, 1, 
 		  G_TYPE_BOOLEAN);
+  menu_shell_signals[CLOSE] =
+    g_signal_new ("close",
+		  G_OBJECT_CLASS_TYPE (object_class),
+		  G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+		  G_STRUCT_OFFSET (GtkMenuShellClass, close),
+		  NULL, NULL,
+		  _gtk_marshal_VOID__VOID,
+		  G_TYPE_NONE, 0);
   menu_shell_signals[CANCEL] =
     g_signal_new ("cancel",
 		  G_OBJECT_CLASS_TYPE (object_class),
@@ -299,8 +332,12 @@
 
 
   binding_set = gtk_binding_set_by_class (klass);
+
   gtk_binding_entry_add_signal (binding_set,
 				GDK_Escape, 0,
+				"close", 0);
+  gtk_binding_entry_add_signal (binding_set,
+				GDK_F4, 0,
 				"cancel", 0);
   gtk_binding_entry_add_signal (binding_set,
 				GDK_Return, 0,
@@ -330,6 +367,22 @@
 				GDK_F10, GDK_SHIFT_MASK,
 				"cycle_focus", 1,
                                 GTK_TYPE_DIRECTION_TYPE, GTK_DIR_TAB_BACKWARD);
+  /**
+   * GtkMenuShell:take-focus:
+   *
+   * A boolean that determines whether the menu and its submenus grab the
+   * keyboard focus. See gtk_menu_shell_set_take_focus() and
+   * gtk_menu_shell_get_take_focus().
+   *
+   * Since: 2.8
+   **/
+  g_object_class_install_property (object_class,
+		  		   PROP_TAKE_FOCUS,
+				   g_param_spec_boolean ("take-focus",
+					   		 P_("Take Focus"),
+							 P_("A boolean that determines whether the menu grabs the keyboard focus"),
+							 TRUE,
+							 G_PARAM_READWRITE));
 
   g_type_class_add_private (object_class, sizeof (GtkMenuShellPrivate));
 }
@@ -356,6 +409,47 @@
 
   priv->mnemonic_hash = NULL;
   priv->key_hash = NULL;
+  priv->take_focus = TRUE;
+  priv->activated_submenu = FALSE;
+  priv->first_click = FALSE;
+}
+
+static void
+gtk_menu_shell_set_property (GObject      *object,
+                             guint         prop_id,
+                             const GValue *value,
+                             GParamSpec   *pspec)
+{
+  GtkMenuShell *menu_shell = GTK_MENU_SHELL (object);
+
+  switch (prop_id)
+    {
+    case PROP_TAKE_FOCUS:
+      gtk_menu_shell_set_take_focus (menu_shell, g_value_get_boolean (value));
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+}
+
+static void
+gtk_menu_shell_get_property (GObject     *object,
+                             guint        prop_id,
+                             GValue      *value,
+                             GParamSpec  *pspec)
+{
+  GtkMenuShell *menu_shell = GTK_MENU_SHELL (object);
+
+  switch (prop_id)
+    {
+    case PROP_TAKE_FOCUS:
+      g_value_set_boolean (value, gtk_menu_shell_get_take_focus (menu_shell));
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
 }
 
 static void
@@ -466,10 +560,19 @@
     }
 }
 
+void
+_gtk_menu_shell_set_first_click (GtkMenuShell *menu_shell)
+{
+  GtkMenuShellPrivate *priv = GTK_MENU_SHELL_GET_PRIVATE (menu_shell);
+
+  priv->first_click = TRUE;
+}
+
 static gint
 gtk_menu_shell_button_press (GtkWidget      *widget,
 			     GdkEventButton *event)
 {
+  GtkMenuShellPrivate *priv;
   GtkMenuShell *menu_shell;
   GtkWidget *menu_item;
 
@@ -479,42 +582,56 @@
   if (event->type != GDK_BUTTON_PRESS)
     return FALSE;
 
+  priv = GTK_MENU_SHELL_GET_PRIVATE (widget);
+
   menu_shell = GTK_MENU_SHELL (widget);
+  menu_item = gtk_menu_shell_get_item (menu_shell, (GdkEvent*) event);
 
-  if (menu_shell->parent_menu_shell)
-    {
-      return gtk_widget_event (menu_shell->parent_menu_shell, (GdkEvent*) event);
-    }
-  else if (!menu_shell->active || !menu_shell->button)
+  if (!menu_shell->active)
     {
       _gtk_menu_shell_activate (menu_shell);
-      
-      menu_shell->button = event->button;
-
-      menu_item = gtk_menu_shell_get_item (menu_shell, (GdkEvent *)event);
 
       if (menu_item && _gtk_menu_item_is_selectable (menu_item))
 	{
-	  if ((menu_item->parent == widget) &&
+          if ((menu_item->parent == widget) &&
 	      (menu_item != menu_shell->active_menu_item))
 	    {
 	      if (GTK_MENU_SHELL_GET_CLASS (menu_shell)->submenu_placement == GTK_TOP_BOTTOM)
-		{
-		  menu_shell->activate_time = event->time;
-		}
-      
-	      gtk_menu_shell_select_item (menu_shell, menu_item);
+                menu_shell->activate_time = event->time;
+
+              gtk_menu_shell_select_item (menu_shell, menu_item);
 	    }
-	}
+        }
     }
   else
     {
+      priv->first_click = FALSE;
+
+      /* Activate submenu on button press, so that we can drag-move into it if
+       * necessary. */
+      if (menu_item && _gtk_menu_item_is_selectable (menu_item) &&
+          GTK_MENU_ITEM (menu_item)->submenu != NULL &&
+          !GTK_WIDGET_VISIBLE (GTK_MENU_ITEM (menu_item)->submenu))
+        {
+          /* Hildon-crack: The item could be unselected when the tap
+           * occurs, make sure it gets selected. The real fix is bug#11670,
+           * remove this crack when it is done.
+           */
+          gtk_menu_shell_select_item (menu_shell, menu_item);
+        
+          gtk_menu_shell_activate_item (menu_shell, menu_item, FALSE);
+
+          priv->activated_submenu = TRUE;
+        }
+
+      /* Deactivate if we clicked on the menu shell itself
+       * (This excludes menu items) */
       widget = gtk_get_event_widget ((GdkEvent*) event);
       if (widget == GTK_WIDGET (menu_shell))
-	{
-	  gtk_menu_shell_deactivate (menu_shell);
+        {
+          gtk_menu_shell_deactivate (menu_shell);
 	  g_signal_emit (menu_shell, menu_shell_signals[SELECTION_DONE], 0);
-	}
+        }
     }
 
   return TRUE;
@@ -524,6 +641,7 @@
 gtk_menu_shell_button_release (GtkWidget      *widget,
 			       GdkEventButton *event)
 {
+  GtkMenuShellPrivate *priv;
   GtkMenuShell *menu_shell;
   GtkWidget *menu_item;
   gint deactivate;
@@ -531,81 +649,102 @@
   g_return_val_if_fail (GTK_IS_MENU_SHELL (widget), FALSE);
   g_return_val_if_fail (event != NULL, FALSE);
 
+  if (event->type != GDK_BUTTON_RELEASE)
+    return FALSE;
+
+  priv = GTK_MENU_SHELL_GET_PRIVATE (widget);
+
   menu_shell = GTK_MENU_SHELL (widget);
-  if (menu_shell->active)
+
+  if (!menu_shell->active)
+    return TRUE;
+
+  menu_item = gtk_menu_shell_get_item (menu_shell, (GdkEvent*) event);
+
+  if (menu_item && _gtk_menu_item_is_selectable (menu_item))
     {
-      if (menu_shell->button && (event->button != menu_shell->button))
+      if (GTK_MENU_ITEM (menu_item)->submenu == NULL)
 	{
-	  menu_shell->button = 0;
-	  if (menu_shell->parent_menu_shell)
-	    return gtk_widget_event (menu_shell->parent_menu_shell, (GdkEvent*) event);
+          GtkSettings *settings = gtk_widget_get_settings (widget);
+          int timeout;
+
+          g_object_get (settings, "gtk-initial-timeout", &timeout, NULL);
+
+          /* Prevent immediate activation on first click, this is mainly
+           * for combo popups and the like. */
+          if (!priv->first_click ||
+              (menu_shell->activate_time == 0) ||
+              ((event->time - menu_shell->activate_time) > timeout))
+	    gtk_menu_shell_activate_item (menu_shell, menu_item, TRUE);
+
+          /* activate_item will take care of deactivation if needed */
+          deactivate = FALSE;
 	}
+      else
+        {
+	  /* If we ended up on an item with a submenu, leave the menu up. */
+          deactivate = FALSE;
 
-      menu_shell->button = 0;
-      menu_item = gtk_menu_shell_get_item (menu_shell, (GdkEvent*) event);
+          /* popdown the submenu if we didn't pop it up in this click */
+          if (!priv->activated_submenu &&
+              GTK_MENU_SHELL_GET_CLASS (menu_shell)->submenu_placement != GTK_TOP_BOTTOM)
+            _gtk_menu_item_popdown_submenu (menu_item);
+        }
+    }
+  else if (menu_item &&
+	   !_gtk_menu_item_is_selectable (menu_item) &&
+	   GTK_MENU_SHELL_GET_CLASS (menu_shell)->submenu_placement != GTK_TOP_BOTTOM)
+    {
+      deactivate = FALSE;
+    }
+  else if (menu_shell->parent_menu_shell)
+    {
+      /* Forward to parent (deactivate, mostly) if we have one */
+      gtk_widget_event (menu_shell->parent_menu_shell, (GdkEvent*) event);
 
+      deactivate = FALSE;
+    }
+  else
+    {
+      /* Not over a menuitem of any kind, no parent shell, so deactivate. */
       deactivate = TRUE;
+    }
 
-      if ((event->time - menu_shell->activate_time) > MENU_SHELL_TIMEOUT)
-	{
-	  if (menu_item && (menu_shell->active_menu_item == menu_item) &&
-	      _gtk_menu_item_is_selectable (menu_item))
-	    {
-	      if (GTK_MENU_ITEM (menu_item)->submenu == NULL)
-		{
-		  gtk_menu_shell_activate_item (menu_shell, menu_item, TRUE);
-		  return TRUE;
-		}
-	      else if (GTK_MENU_SHELL_GET_CLASS (menu_shell)->submenu_placement != GTK_TOP_BOTTOM)
-		{
-		  gtk_menu_item_select (GTK_MENU_ITEM (menu_item));
-		  return TRUE;
-		}
-	    }
-	  else if (menu_item &&
-		   !_gtk_menu_item_is_selectable (menu_item) &&
-		   GTK_MENU_SHELL_GET_CLASS (menu_shell)->submenu_placement != GTK_TOP_BOTTOM)
-	    {
-	      deactivate = FALSE;
-	    }
-	  else if (menu_shell->parent_menu_shell)
-	    {
-	      menu_shell->active = TRUE;
-	      gtk_widget_event (menu_shell->parent_menu_shell, (GdkEvent*) event);
-	      return TRUE;
-	    }
+  if (priv->first_click)
+    {
+      /* We only ever want to prevent deactivation on the first
+       * press/release. */
+      priv->first_click = FALSE;
 
-	  /* If we ended up on an item with a submenu, leave the menu up.
-	   */
-	  if (menu_item && (menu_shell->active_menu_item == menu_item) &&
-	      GTK_MENU_SHELL_GET_CLASS (menu_shell)->submenu_placement != GTK_TOP_BOTTOM)
-	    {
-	      deactivate = FALSE;
-	    }
-	}
-      else /* a very fast press-release */
-	{
-	  /* We only ever want to prevent deactivation on the first
-           * press/release. Setting the time to zero is a bit of a
-	   * hack, since we could be being triggered in the first
-	   * few fractions of a second after a server time wraparound.
-	   * the chances of that happening are ~1/10^6, without
-	   * serious harm if we lose.
-	   */
-	  menu_shell->activate_time = 0;
-	  deactivate = FALSE;
-	}
-      
-      if (deactivate)
-	{
-	  gtk_menu_shell_deactivate (menu_shell);
-	  g_signal_emit (menu_shell, menu_shell_signals[SELECTION_DONE], 0);
-	}
+      deactivate = FALSE;
     }
 
+  if (deactivate)
+    {
+      gtk_menu_shell_deactivate (menu_shell);
+      g_signal_emit (menu_shell, menu_shell_signals[SELECTION_DONE], 0);
+    }
+
+  priv->activated_submenu = FALSE;
+
   return TRUE;
 }
 
+static void
+gtk_menu_shell_insensitive_press (GtkWidget *widget)
+{
+  GtkMenuShell *menu_shell;
+  GdkEvent *event;
+
+  g_return_if_fail (GTK_IS_MENU_SHELL (widget));
+
+  menu_shell = GTK_MENU_SHELL (widget);
+
+  event = gtk_get_current_event ();
+
+  gtk_widget_insensitive_press (gtk_get_event_widget (event));
+}
+
 static gint
 gtk_menu_shell_key_press (GtkWidget   *widget,
 			  GdkEventKey *event)
@@ -630,12 +769,14 @@
 gtk_menu_shell_enter_notify (GtkWidget        *widget,
 			     GdkEventCrossing *event)
 {
+  GtkMenuShellPrivate *priv;
   GtkMenuShell *menu_shell;
   GtkWidget *menu_item;
 
   g_return_val_if_fail (GTK_IS_MENU_SHELL (widget), FALSE);
   g_return_val_if_fail (event != NULL, FALSE);
 
+  priv = GTK_MENU_SHELL_GET_PRIVATE (widget);
   menu_shell = GTK_MENU_SHELL (widget);
 
   if (menu_shell->active)
@@ -658,6 +799,17 @@
 	      (GTK_WIDGET_STATE (menu_item) != GTK_STATE_PRELIGHT))
 	    {
 	      gtk_menu_shell_select_item (menu_shell, menu_item);
+              
+              /* If the pen is down, and there is a submenu that is not
+               * yet visible, activate it */
+              if ((event->state & GDK_BUTTON1_MASK) &&
+                  GTK_MENU_ITEM (menu_item)->submenu != NULL &&
+                  !GTK_WIDGET_VISIBLE (GTK_MENU_ITEM (menu_item)->submenu))
+                {
+                  gtk_menu_shell_activate_item (menu_shell, menu_item, FALSE);
+
+                  priv->activated_submenu = TRUE;
+                }
 	    }
 	}
       else if (menu_shell->parent_menu_shell)
@@ -694,7 +846,8 @@
 	return TRUE;
 
       if ((menu_shell->active_menu_item == event_widget) &&
-	  (menu_item->submenu == NULL))
+          ((menu_item->submenu == NULL) ||
+           (!GTK_WIDGET_VISIBLE (menu_item->submenu))))
 	{
 	  if ((event->detail != GDK_NOTIFY_INFERIOR) &&
 	      (GTK_WIDGET_STATE (menu_item) != GTK_STATE_NORMAL))
@@ -785,7 +938,10 @@
 {
   if (menu_shell->active)
     {
-      menu_shell->button = 0;
+      GtkMenuShellPrivate *priv = GTK_MENU_SHELL_GET_PRIVATE (menu_shell);
+
+      priv->first_click = FALSE;
+
       menu_shell->active = FALSE;
       menu_shell->activate_time = 0;
 
@@ -867,9 +1023,6 @@
     class->select_item (menu_shell, menu_item);
 }
 
-void _gtk_menu_item_set_placement (GtkMenuItem         *menu_item,
-				   GtkSubmenuPlacement  placement);
-
 static void
 gtk_menu_shell_real_select_item (GtkMenuShell *menu_shell,
 				 GtkWidget    *menu_item)
@@ -880,15 +1033,19 @@
     return;
 
   menu_shell->active_menu_item = menu_item;
-  _gtk_menu_item_set_placement (GTK_MENU_ITEM (menu_shell->active_menu_item),
-			       GTK_MENU_SHELL_GET_CLASS (menu_shell)->submenu_placement);
   gtk_menu_item_select (GTK_MENU_ITEM (menu_shell->active_menu_item));
 
   /* This allows the bizarre radio buttons-with-submenus-display-history
    * behavior
    */
+  /* Hildon modification. We probably won't have those
+   * bizarre radio buttons-with-submenus so we don't
+   * need this. Also, this functionality interferes with
+   * other functionality. */
+/*
   if (GTK_MENU_ITEM (menu_shell->active_menu_item)->submenu)
     gtk_widget_activate (menu_shell->active_menu_item);
+*/
 }
 
 void
@@ -903,6 +1060,9 @@
     }
 }
 
+void _gtk_menu_item_set_placement (GtkMenuItem         *menu_item,
+				   GtkSubmenuPlacement  placement);
+
 void
 gtk_menu_shell_activate_item (GtkMenuShell      *menu_shell,
 			      GtkWidget         *menu_item,
@@ -910,16 +1070,22 @@
 {
   GSList *slist, *shells = NULL;
   gboolean deactivate = force_deactivate;
+  gboolean submenu = FALSE;
 
   g_return_if_fail (GTK_IS_MENU_SHELL (menu_shell));
   g_return_if_fail (GTK_IS_MENU_ITEM (menu_item));
 
+  if (GTK_MENU_ITEM (menu_item)->submenu != NULL)
+    submenu = TRUE;
+
   if (!deactivate)
     deactivate = GTK_MENU_ITEM_GET_CLASS (menu_item)->hide_on_activate;
 
   g_object_ref (menu_shell);
 
-  if (deactivate)
+  /* We don't want to deactivate if we're activating
+   * a submenu item. */
+  if (deactivate && !submenu)
     {
       GtkMenuShell *parent_menu_shell = menu_shell;
 
@@ -939,15 +1105,23 @@
        */
       gdk_display_sync (gtk_widget_get_display (menu_item));
     }
+  else if (submenu)
+    {
+      _gtk_menu_item_set_placement (GTK_MENU_ITEM (menu_item),
+			            GTK_MENU_SHELL_GET_CLASS (menu_shell)->submenu_placement);
+    }
 
   gtk_widget_activate (menu_item);
 
-  for (slist = shells; slist; slist = slist->next)
+  if (!submenu)
     {
-      g_signal_emit (slist->data, menu_shell_signals[SELECTION_DONE], 0);
-      g_object_unref (slist->data);
+      for (slist = shells; slist; slist = slist->next)
+        {
+          g_signal_emit (slist->data, menu_shell_signals[SELECTION_DONE], 0);
+          g_object_unref (slist->data);
+        }
+      g_slist_free (shells);
     }
-  g_slist_free (shells);
 
   g_object_unref (menu_shell);
 }
@@ -965,29 +1139,30 @@
       
       if (distance > 0)
 	{
+	  /*Hildon: selection no longer wraps around at the
+	  *bottom of the menu*/
+
 	  node = node->next;
-	  while (node != start_node && 
-		 (!node || !_gtk_menu_item_is_selectable (node->data)))
+	  while (node && node != start_node && 
+		 !_gtk_menu_item_is_selectable (node->data))
 	    {
-	      if (!node)
-		node = menu_shell->children;
-	      else
 		node = node->next;
 	    }
 	}
       else
 	{
+	  /*Hildon: selection no longer wraps around at the top
+	  *of the menu*/
+
 	  node = node->prev;
-	  while (node != start_node &&
-		 (!node || !_gtk_menu_item_is_selectable (node->data)))
+	  while (node && node != start_node &&
+		 !_gtk_menu_item_is_selectable (node->data))
 	    {
-	      if (!node)
-		node = g_list_last (menu_shell->children);
-	      else
 		node = node->prev;
 	    }
 	}
       
+      /*note: gtk_menu_shell_select_item won't select non-selectable items*/
       if (node)
 	gtk_menu_shell_select_item (menu_shell, node->data);
     }
@@ -1071,7 +1246,8 @@
   
   if (menu_item->submenu)
     {
-      _gtk_menu_item_popup_submenu (GTK_WIDGET (menu_item));
+      gtk_menu_shell_activate_item (menu_shell, GTK_WIDGET (menu_item), FALSE);
+
       gtk_menu_shell_select_first (GTK_MENU_SHELL (menu_item->submenu), TRUE);
       if (GTK_MENU_SHELL (menu_item->submenu)->active_menu_item)
 	return TRUE;
@@ -1119,6 +1295,16 @@
   switch (direction)
     {
     case GTK_MENU_DIR_PARENT:
+
+      if(!parent_menu_shell || GTK_IS_MENU_BAR(parent_menu_shell))
+        break;
+
+      /* hildon-modification - menu should be closed when returning from submenu.
+       * WARNING: This function is from GtkMenu, which normally
+       * shouldn't be called from GtkMenuShell, but currently
+       * there are no better alternatives. */
+      gtk_menu_popdown (GTK_MENU (menu_shell));
+
       if (parent_menu_shell)
 	{
 	  if (GTK_MENU_SHELL_GET_CLASS (parent_menu_shell)->submenu_placement == 
@@ -1155,6 +1341,10 @@
 	    break;
 	}
 
+#if 0
+      /* this code is kept here because at some point we might need to get this
+       * functionality back */      
+
       /* Try to find a menu running the opposite direction */
       while (parent_menu_shell && 
 	     (GTK_MENU_SHELL_GET_CLASS (parent_menu_shell)->submenu_placement ==
@@ -1173,6 +1363,7 @@
 	  gtk_menu_shell_move_selected (parent_menu_shell, 1);
 	  gtk_menu_shell_select_submenu_first (parent_menu_shell);
 	}
+#endif
       break;
       
     case GTK_MENU_DIR_PREV:
@@ -1199,15 +1390,25 @@
 {
   if (menu_shell->active_menu_item &&
       _gtk_menu_item_is_selectable (menu_shell->active_menu_item))
-  {
-   
-    if (GTK_MENU_ITEM (menu_shell->active_menu_item)->submenu == NULL)
+    {
       gtk_menu_shell_activate_item (menu_shell,
-				    menu_shell->active_menu_item,
+                                    menu_shell->active_menu_item,
 				    force_hide);
-    else
-      _gtk_menu_item_popup_submenu (menu_shell->active_menu_item);
-  }
+    }
+}
+
+static void
+gtk_real_menu_shell_close (GtkMenuShell      *menu_shell)
+{
+	if (menu_shell->parent_menu_shell) {
+		if (GTK_IS_MENU_BAR (menu_shell->parent_menu_shell)) {
+			gtk_menu_popdown (GTK_MENU (menu_shell));
+		} else {
+			gtk_real_menu_shell_move_current (menu_shell, GTK_MENU_DIR_PARENT);
+		}
+	} else {
+		gtk_real_menu_shell_cancel(menu_shell);
+	}
 }
 
 static void
@@ -1390,4 +1591,72 @@
 			     keyval, target);
   gtk_menu_shell_reset_key_hash (menu_shell);
 }
+/**
+ * gtk_menu_shell_get_take_focus:
+ * @menu: a #GtkMenuShell
+ *
+ * @returns: %TRUE if the menu_shell will take the keyboard focus on popup.
+ *
+ * Since: 2.8
+ **/
+gboolean
+gtk_menu_shell_get_take_focus (GtkMenuShell *menu_shell)
+{
+  GtkMenuShellPrivate *priv;
+
+  g_return_val_if_fail (GTK_IS_MENU_SHELL (menu_shell), FALSE);
+
+  priv = GTK_MENU_SHELL_GET_PRIVATE (menu_shell);
+
+  return priv->take_focus;
+}
 
+/**
+ * gtk_menu_shell_set_take_focus:
+ * @menu: a #GtkMenuShell
+ * @take_focus: %TRUE if the menu_shell should take the keyboard focus on popup.
+ *
+ * If @take_focus is %TRUE (the default) the menu will take the keyboard focus
+ * so that it will receive all keyboard events which is needed to enable
+ * keyboard navigation in menus.
+ *
+ * Setting @take_focus to %FALSE is useful only for special applications
+ * like virtual keyboard implementations which should not take keyboard
+ * focus.
+ *
+ * The @take_focus state of a menu or menu bar is automatically propagated
+ * to submenus whenever a submenu is popped up, so you don't have to worry
+ * about recursively setting it for your entire menu hierarchy. Only when
+ * programmatically picking a submenu and popping it up manually, the
+ * @take_focus property of the submenu needs to be set explicitely.
+ *
+ * Note that setting it to %FALSE has side-effects:
+ *
+ * If the focus is in some other app, it keeps the focus and keynav in
+ * the menu doesn't work. Consequently, keynav on the menu will only
+ * work if the focus is on some toplevel owned by the onscreen keyboard.
+ *
+ * To avoid confusing the user, menus with @take_focus set to %FALSE
+ * should not display mnemonics or accelerators, since it cannot be
+ * guaranteed that they will work.
+ *
+ * See also gdk_keyboard_grab()
+ *
+ * Since: 2.8
+ **/
+void
+gtk_menu_shell_set_take_focus (GtkMenuShell *menu_shell,
+                               gboolean      take_focus)
+{
+  GtkMenuShellPrivate *priv;
+
+  g_return_if_fail (GTK_IS_MENU_SHELL (menu_shell));
+
+  priv = GTK_MENU_SHELL_GET_PRIVATE (menu_shell);
+
+  if (priv->take_focus != take_focus)
+    {
+      priv->take_focus = take_focus;
+      g_object_notify (G_OBJECT (menu_shell), "take-focus");
+    }
+}
--- gtk+/gtk/gtkmenushell.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkmenushell.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -56,7 +56,7 @@
   GtkWidget *active_menu_item;
   GtkWidget *parent_menu_shell;
   
-  guint button;
+  guint button;                 /* unused */
   guint32 activate_time;
 
   guint active : 1;
@@ -80,6 +80,7 @@
 			    GtkMenuDirectionType direction);
   void (*activate_current) (GtkMenuShell *menu_shell,
 			    gboolean      force_hide);
+  void (*close)            (GtkMenuShell *menu_shell);
   void (*cancel)           (GtkMenuShell *menu_shell);
   void (*select_item)      (GtkMenuShell *menu_shell,
 			    GtkWidget    *menu_item);
@@ -124,6 +125,12 @@
 void _gtk_menu_shell_remove_mnemonic (GtkMenuShell *menu_shell,
 				      guint         keyval,
 				      GtkWidget    *target);
+gboolean gtk_menu_shell_get_take_focus (GtkMenuShell *menu_shell);
+void     gtk_menu_shell_set_take_focus (GtkMenuShell *menu_shell,
+                                        gboolean      take_focus);
+
+/* Private function */
+void _gtk_menu_shell_set_first_click (GtkMenuShell *menu_shell);
 
 #ifdef __cplusplus
 }
--- gtk+/gtk/gtkwindow.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkwindow.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -166,6 +166,7 @@
   guint skips_taskbar : 1;
   guint skips_pager : 1;
   guint accept_focus : 1;
+  GtkWidget *prev_focus_widget;
   guint focus_on_map : 1;
 };
 
@@ -293,6 +294,8 @@
 				     GValue          *value,
 				     GParamSpec      *pspec);
 
+static void gtk_window_focus_weak_notify (GtkWindow *window,
+		GtkWidget *widget);
 
 GType
 gtk_window_get_type (void)
@@ -771,6 +774,7 @@
   window->decorated = TRUE;
   window->mnemonic_modifier = GDK_MOD1_MASK;
   window->screen = gdk_screen_get_default ();
+  priv->prev_focus_widget = NULL;
 
   priv->accept_focus = TRUE;
   priv->focus_on_map = TRUE;
@@ -7505,3 +7509,44 @@
 }
 
 #endif
+/*Hildon focus handling*/
+GtkWidget *gtk_window_get_prev_focus_widget (GtkWindow *window)
+{
+  g_return_val_if_fail (GTK_IS_WINDOW (window), NULL);
+  return GTK_WINDOW_GET_PRIVATE (window)->prev_focus_widget;
+}
+
+void gtk_window_set_prev_focus_widget (GtkWindow *window, GtkWidget *widget)
+{
+  GtkWindowPrivate *priv;
+
+  g_return_if_fail (GTK_IS_WINDOW (window));
+  g_return_if_fail (widget == NULL || GTK_IS_WIDGET (widget));
+
+  if (widget == NULL)
+    return;
+
+  priv = GTK_WINDOW_GET_PRIVATE (window);
+
+  if (priv->prev_focus_widget == widget)
+    return;
+
+  if (GTK_IS_WIDGET (priv->prev_focus_widget))
+    g_object_weak_unref (G_OBJECT (priv->prev_focus_widget),
+			   (GWeakNotify)gtk_window_focus_weak_notify,
+			   (gpointer)window);
+
+  priv->prev_focus_widget = widget;
+  g_object_weak_ref (G_OBJECT (widget), (GWeakNotify)gtk_window_focus_weak_notify,
+		     (gpointer)window);
+}
+
+static void gtk_window_focus_weak_notify (GtkWindow *window, GtkWidget *widget)
+{
+  GtkWindowPrivate *priv;
+
+  priv = GTK_WINDOW_GET_PRIVATE (window);
+  priv->prev_focus_widget = NULL;
+
+  gtk_window_set_prev_focus_widget (window, window->focus_widget);
+}
\ No newline at end of file
--- gtk+/gtk/gtkcheckbutton.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkcheckbutton.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -31,27 +31,47 @@
 #include "gtklabel.h"
 
 
-#define INDICATOR_SIZE     13
+#define INDICATOR_SIZE     24
 #define INDICATOR_SPACING  2
+#define FOCUS_X_PADDING    2
 
+/* maJiK numbers for indicator */
+#define INDICATOR_SIDE_PADDING 5
+#define FOCUS_TOP_PADDING 7
+#define FOCUS_DOWN_PADDING 1 
+
+/* spacing to take account of the 1 pixel 
+   transparency of the widgetfocus.png 
+*/
+#define HILDON_SPACING 1 
+ 
+#define TOGGLE_ON_CLICK "toggle-on-click"
 
-static void gtk_check_button_class_init          (GtkCheckButtonClass *klass);
-static void gtk_check_button_init                (GtkCheckButton      *check_button);
-static void gtk_check_button_size_request        (GtkWidget           *widget,
-						  GtkRequisition      *requisition);
-static void gtk_check_button_size_allocate       (GtkWidget           *widget,
-						  GtkAllocation       *allocation);
-static gint gtk_check_button_expose              (GtkWidget           *widget,
-						  GdkEventExpose      *event);
-static void gtk_check_button_paint               (GtkWidget           *widget,
-						  GdkRectangle        *area);
-static void gtk_check_button_draw_indicator      (GtkCheckButton      *check_button,
-						  GdkRectangle        *area);
-static void gtk_real_check_button_draw_indicator (GtkCheckButton      *check_button,
-						  GdkRectangle        *area);
+static void gtk_check_button_class_init   (GtkCheckButtonClass *klass);
+static void gtk_check_button_init         (GtkCheckButton     *check_button);
+static void gtk_check_button_size_request (GtkWidget         *widget,
+					   GtkRequisition    *requisition);
+static void gtk_check_button_size_allocate (GtkWidget         *widget,
+					    GtkAllocation     *allocation);
+static gint gtk_check_button_expose        (GtkWidget         *widget,
+					    GdkEventExpose    *event);
+static gint gtk_check_button_button_press  (GtkWidget        *widget,
+					    GdkEventButton   *event);
+static void gtk_check_button_paint         (GtkWidget        *widget,
+					    GdkRectangle     *area);
+static void gtk_check_button_draw_indicator (GtkCheckButton   *check_button,
+					     GdkRectangle     *area);
+static void gtk_real_check_button_draw_indicator 
+                                             (GtkCheckButton *check_button,
+					      GdkRectangle   *area);
 
-static GtkToggleButtonClass *parent_class = NULL;
+static void gtk_check_button_calc_indicator_size( GtkCheckButton *button, 
+                                                  GdkRectangle *rect );
+
+static void gtk_check_button_clicked (GtkButton *button);
+static void gtk_check_button_update_state (GtkButton *button);
 
+static GtkToggleButtonClass *parent_class = NULL;
 
 GType
 gtk_check_button_get_type (void)
@@ -85,32 +105,45 @@
 gtk_check_button_class_init (GtkCheckButtonClass *class)
 {
   GtkWidgetClass *widget_class;
-  
+  GtkButtonClass *button_class;
+
   widget_class = (GtkWidgetClass*) class;
+  button_class = (GtkButtonClass*) class;
   parent_class = g_type_class_peek_parent (class);
   
   widget_class->size_request = gtk_check_button_size_request;
   widget_class->size_allocate = gtk_check_button_size_allocate;
   widget_class->expose_event = gtk_check_button_expose;
+  widget_class->button_press_event = gtk_check_button_button_press;
+
+  button_class->clicked = gtk_check_button_clicked;
 
   class->draw_indicator = gtk_real_check_button_draw_indicator;
 
   gtk_widget_class_install_style_property (widget_class,
 					   g_param_spec_int ("indicator_size",
-							     P_("Indicator Size"),
-							     P_("Size of check or radio indicator"),
-							     0,
-							     G_MAXINT,
-							     INDICATOR_SIZE,
-							     G_PARAM_READABLE));
+				               P_("Indicator Size"),
+                       P_("Size of check or radio indicator"),
+                       0,
+                       G_MAXINT,
+                       INDICATOR_SIZE,
+                       G_PARAM_READABLE));
   gtk_widget_class_install_style_property (widget_class,
 					   g_param_spec_int ("indicator_spacing",
-							     P_("Indicator Spacing"),
-							     P_("Spacing around check or radio indicator"),
-							     0,
-							     G_MAXINT,
-							     INDICATOR_SPACING,
-							     G_PARAM_READABLE));
+					             P_("Indicator Spacing"),
+                       P_("Spacing around check or radio indicator"),
+                       0,
+                       G_MAXINT,
+                       INDICATOR_SPACING,
+                       G_PARAM_READABLE));
+  gtk_widget_class_install_style_property (class,
+					   g_param_spec_int ("focus-x-padding",
+					             P_("Horizontal focus padding"),
+                       P_("Additional horizontal focus padding for the checkbox indicator"),
+                       0,
+                       G_MAXINT,
+                       FOCUS_X_PADDING,
+                       G_PARAM_READABLE));
 }
 
 static void
@@ -148,7 +181,8 @@
 GtkWidget*
 gtk_check_button_new_with_mnemonic (const gchar *label)
 {
-  return g_object_new (GTK_TYPE_CHECK_BUTTON, "label", label, "use_underline", TRUE, NULL);
+  return g_object_new (GTK_TYPE_CHECK_BUTTON, "label", label, 
+                                              "use_underline", TRUE, NULL);
 }
 
 
@@ -163,39 +197,81 @@
   
   if (GTK_WIDGET_DRAWABLE (widget))
     {
-      gint border_width;
-      gint interior_focus;
-      gint focus_width;
-      gint focus_pad;
-	  
+      gint border_width = 0;
+      gint interior_focus = 0;
+      gint focus_x_pad = 0;
+      gint focus_width = 0;
+      gint focus_pad = 0;
+      gint indicator_size = 0;
+      gint indicator_spacing = 0;
+      
       gtk_widget_style_get (widget,
 			    "interior-focus", &interior_focus,
 			    "focus-line-width", &focus_width,
 			    "focus-padding", &focus_pad,
+			    "focus-x-padding", &focus_x_pad,
+			    "indicator-size", &indicator_size,
+			    "indicator-spacing", &indicator_spacing,
 			    NULL);
-
-      gtk_check_button_draw_indicator (check_button, area);
       
       border_width = GTK_CONTAINER (widget)->border_width;
+      
+      /* Hildon: change the focus so that it draws around the entire
+       * widget - including both the indicator *and* the label 
+       */
       if (GTK_WIDGET_HAS_FOCUS (widget))
 	{
-	  GtkWidget *child = GTK_BIN (widget)->child;
+          GtkWidget *child = GTK_BIN (widget)->child;
+          gint w, h, x, y;
+	  
+	  if(child)
+            {
+              w = indicator_size + 2 * indicator_spacing + 
+                  4 * (focus_width + focus_pad + focus_x_pad) + 
+                  widget->style->xthickness + child->allocation.width;
+            }
+          else
+            {
+              w = indicator_size + 2 * indicator_spacing +
+                  2 * (focus_width + focus_pad) + 2 * focus_x_pad;
+            }
+          
+	  h = indicator_size + 2 * indicator_spacing + 
+	          2 * (focus_width + focus_pad);
+	  x = widget->allocation.x;
+	  y = widget->allocation.y + (widget->allocation.height - h) / 2;
 	  
+	  if (gtk_widget_get_direction(widget) == GTK_TEXT_DIR_RTL)
+	    x = widget->allocation.x + widget->allocation.width - 
+	      (2 * HILDON_SPACING) - (indicator_size + 2) - 
+	      (indicator_spacing + 2);	  
+
 	  if (interior_focus && child && GTK_WIDGET_VISIBLE (child))
-	    gtk_paint_focus (widget->style, widget->window, GTK_WIDGET_STATE (widget),
-			     NULL, widget, "checkbutton",
-			     child->allocation.x - focus_width - focus_pad,
-			     child->allocation.y - focus_width - focus_pad,
-			     child->allocation.width + 2 * (focus_width + focus_pad),
-			     child->allocation.height + 2 * (focus_width + focus_pad));
+	    {
+              if (gtk_widget_get_direction(widget) == GTK_TEXT_DIR_RTL)
+		{
+		  /* Move the "x" to the left, and enlarge the width, 
+		     both accounting for the child 
+                   */               
+		  x += - child->allocation.width - HILDON_SPACING - 
+		    (widget->style->xthickness);
+		  w += child->allocation.width + HILDON_SPACING + 
+		    (widget->style->xthickness);
+		} else {
+		  w = child->allocation.x + child->allocation.width + 
+		    2 * widget->style->xthickness - x;
+		}
+		  
+	      gtk_paint_focus (widget->style, widget->window, 
+			       GTK_WIDGET_STATE (widget),
+			       NULL, widget, "checkbutton", x, y, w, h);
+	    }
 	  else
-	    gtk_paint_focus (widget->style, widget->window, GTK_WIDGET_STATE (widget), 
-			     NULL, widget, "checkbutton",
-			     border_width + widget->allocation.x,
-			     border_width + widget->allocation.y,
-			     widget->allocation.width - 2 * border_width,
-			     widget->allocation.height - 2 * border_width);
+	    gtk_paint_focus (widget->style, widget->window, 
+                             GTK_WIDGET_STATE (widget), 
+			     NULL, widget, "checkbutton", x, y, w, h);
 	}
+      gtk_check_button_draw_indicator (check_button, area);
     }
 }
 
@@ -205,10 +281,10 @@
 			     gint           *indicator_spacing)
 {
   GtkWidget *widget =  GTK_WIDGET (check_button);
-
+  
   if (indicator_size)
     gtk_widget_style_get (widget, "indicator_size", indicator_size, NULL);
-
+  
   if (indicator_spacing)
     gtk_widget_style_get (widget, "indicator_spacing", indicator_spacing, NULL);
 }
@@ -228,12 +304,14 @@
       gint border_width = GTK_CONTAINER (widget)->border_width;
       gint focus_width;
       gint focus_pad;
+      gint focus_x_pad;
 
       gtk_widget_style_get (GTK_WIDGET (widget),
 			    "focus-line-width", &focus_width,
 			    "focus-padding", &focus_pad,
+			    "focus-x-padding", &focus_x_pad,
 			    NULL);
- 
+
       requisition->width = border_width * 2;
       requisition->height = border_width * 2;
 
@@ -246,15 +324,19 @@
 	  GtkRequisition child_requisition;
 	  
 	  gtk_widget_size_request (child, &child_requisition);
-
-	  requisition->width += child_requisition.width + indicator_spacing;
+	  
+	  requisition->width += child_requisition.width + 
+	    2 * widget->style->xthickness;
 	  requisition->height += child_requisition.height;
+	  requisition->width += 2 * widget->style->xthickness;
 	}
       
-      requisition->width += (indicator_size + indicator_spacing * 2 + 2 * (focus_width + focus_pad));
+      requisition->width += (indicator_size + indicator_spacing * 2 + 
+			     2 * (focus_width + focus_pad) + 2 * focus_x_pad);
       
       temp = indicator_size + indicator_spacing * 2;
-      requisition->height = MAX (requisition->height, temp) + 2 * (focus_width + focus_pad);
+      requisition->height = MAX (requisition->height, temp) + 
+	2 * (focus_width + focus_pad);
     }
   else
     (* GTK_WIDGET_CLASS (parent_class)->size_request) (widget, requisition);
@@ -279,46 +361,62 @@
       gint indicator_spacing;
       gint focus_width;
       gint focus_pad;
+      gint focus_x_pad;
       
-      _gtk_check_button_get_props (check_button, &indicator_size, &indicator_spacing);
+      _gtk_check_button_get_props (check_button, 
+				   &indicator_size, &indicator_spacing);
       gtk_widget_style_get (widget,
 			    "focus-line-width", &focus_width,
 			    "focus-padding", &focus_pad,
+			    "focus-x-padding", &focus_x_pad,
 			    NULL);
-						    
+
       widget->allocation = *allocation;
       if (GTK_WIDGET_REALIZED (widget))
 	gdk_window_move_resize (button->event_window,
 				allocation->x, allocation->y,
 				allocation->width, allocation->height);
       
-      if (GTK_BIN (button)->child && GTK_WIDGET_VISIBLE (GTK_BIN (button)->child))
+      if (GTK_BIN (button)->child && 
+	  GTK_WIDGET_VISIBLE (GTK_BIN (button)->child))
 	{
 	  GtkRequisition child_requisition;
  	  gint border_width = GTK_CONTAINER (widget)->border_width;
-
-	  gtk_widget_get_child_requisition (GTK_BIN (button)->child, &child_requisition);
+	  
+	  gtk_widget_get_child_requisition (GTK_BIN (button)->child, 
+                                            &child_requisition);
  
-	  child_allocation.width = MIN (child_requisition.width,
+	  child_allocation.width = MIN (
+					child_requisition.width,
 					allocation->width -
-					((border_width + focus_width + focus_pad) * 2
-					 + indicator_size + indicator_spacing * 3));
-	  child_allocation.width = MAX (child_allocation.width, 1);
+					((border_width + focus_width + 
+					  focus_pad) * 2
+					 - 2 * widget->style->xthickness + 
+					 indicator_size + 
+					 indicator_spacing * 2 ) );
 
+	  child_allocation.width = MAX (child_allocation.width, 1);
+	  
 	  child_allocation.height = MIN (child_requisition.height,
-					 allocation->height - (border_width + focus_width + focus_pad) * 2);
+					 allocation->height - 
+					 (border_width + focus_width + 
+					  focus_pad) * 2);
 	  child_allocation.height = MAX (child_allocation.height, 1);
 	  
-	  child_allocation.x = (border_width + indicator_size + indicator_spacing * 3 +
-				widget->allocation.x + focus_width + focus_pad);
+	  child_allocation.x = (border_width + indicator_size + 
+				indicator_spacing * 2 +
+				widget->style->xthickness + 
+				widget->allocation.x + 
+				focus_width + focus_pad + focus_x_pad); 
 	  child_allocation.y = widget->allocation.y +
-		  (allocation->height - child_allocation.height) / 2;
-
+	    (allocation->height - child_allocation.height) / 2;
+	  
 	  if (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_RTL)
-	    child_allocation.x = allocation->x + allocation->width
-	      - (child_allocation.x - allocation->x + child_allocation.width);
+	    child_allocation.x = allocation->x + allocation->width - 
+	      (child_allocation.x - allocation->x + child_allocation.width);
 	  
-	  gtk_widget_size_allocate (GTK_BIN (button)->child, &child_allocation);
+	  gtk_widget_size_allocate (GTK_BIN (button)->child, 
+				    &child_allocation);
 	}
     }
   else
@@ -355,6 +453,55 @@
   return FALSE;
 }
 
+/* This event handler was introduced to fix problems with check buttons packed
+   inside Hildon Caption Controls; in such cases the widget might be allocated
+   a lot of blank space which isn't supposed to react to stylus taps. */
+static gboolean
+gtk_check_button_button_press (GtkWidget      *widget,
+			       GdkEventButton *event)
+{
+  GtkButton *button;
+
+  if (event->type == GDK_BUTTON_PRESS)
+    {
+      GdkRectangle indicator = {0, 0, 0, 0};
+      gint child_x = 0;
+      gint child_y = 0;
+      gint child_width = 0;
+      gint child_height = 0;
+
+      button = GTK_BUTTON (widget);
+      gtk_check_button_calc_indicator_size(GTK_CHECK_BUTTON(widget),
+                                           &indicator);
+
+      if (GTK_BIN(widget)->child)
+	{
+	  GtkWidget *child = GTK_BIN(widget)->child;
+
+	  child_x = child->allocation.x;
+	  child_y = child->allocation.y;
+	  child_width = child->allocation.width;
+	  child_height = child->allocation.height;
+          
+          /* did the event occur above or below the actual check button? */
+          if (event->y < child_y - widget->allocation.y ||
+              event->y > child_y + child_height - widget->allocation.y)
+            return FALSE;
+        }
+
+      /* did the event occur to the right from the actual check button? */
+      if (event->x > 2 * indicator.x + indicator.width + child_width)
+        return FALSE;
+
+      if (button->focus_on_click && !GTK_WIDGET_HAS_FOCUS (widget))
+	gtk_widget_grab_focus (widget);
+
+      if (event->button == 1)
+	gtk_button_pressed (button);
+    }
+
+  return TRUE;
+}
 
 static void
 gtk_check_button_draw_indicator (GtkCheckButton *check_button,
@@ -375,45 +522,33 @@
 				      GdkRectangle   *area)
 {
   GtkWidget *widget;
-  GtkWidget *child;
   GtkButton *button;
   GtkToggleButton *toggle_button;
   GtkStateType state_type;
   GtkShadowType shadow_type;
-  gint x, y;
-  gint indicator_size;
-  gint indicator_spacing;
-  gint focus_width;
-  gint focus_pad;
-  gboolean interior_focus;
+  
+  GdkRectangle indicator = {0, 0, 0, 0};
   
   if (GTK_WIDGET_DRAWABLE (check_button))
     {
       widget = GTK_WIDGET (check_button);
       button = GTK_BUTTON (check_button);
       toggle_button = GTK_TOGGLE_BUTTON (check_button);
-  
-      gtk_widget_style_get (widget, "interior_focus", &interior_focus,
-			    "focus-line-width", &focus_width, 
-			    "focus-padding", &focus_pad, NULL);
-
-      _gtk_check_button_get_props (check_button, &indicator_size, &indicator_spacing);
-
-      x = widget->allocation.x + indicator_spacing + GTK_CONTAINER (widget)->border_width;
-      y = widget->allocation.y + (widget->allocation.height - indicator_size) / 2;
-
-      child = GTK_BIN (check_button)->child;
-      if (!interior_focus || !(child && GTK_WIDGET_VISIBLE (child)))
-	x += focus_width + focus_pad;      
-
+      gtk_check_button_calc_indicator_size( check_button, &indicator );
+      
+      /* move indicator to root coordinates */
+      indicator.x += widget->allocation.x;
+      indicator.y += widget->allocation.y;
+      
       if (toggle_button->inconsistent)
 	shadow_type = GTK_SHADOW_ETCHED_IN;
       else if (toggle_button->active)
 	shadow_type = GTK_SHADOW_IN;
       else
 	shadow_type = GTK_SHADOW_OUT;
-
-      if (button->activate_timeout || (button->button_down && button->in_button))
+      
+      if (button->activate_timeout || 
+	  (button->button_down && button->in_button))
 	state_type = GTK_STATE_ACTIVE;
       else if (button->in_button)
 	state_type = GTK_STATE_PRELIGHT;
@@ -422,32 +557,105 @@
       else
 	state_type = GTK_STATE_NORMAL;
       
-      if (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_RTL)
-	x = widget->allocation.x + widget->allocation.width - (indicator_size + x - widget->allocation.x);
+      /* Hildon change. We want to draw active image always when we have
+       * focus. */
+      if (GTK_WIDGET_HAS_FOCUS (widget))
+	state_type = GTK_STATE_ACTIVE;
 
-      if (GTK_WIDGET_STATE (toggle_button) == GTK_STATE_PRELIGHT)
+      if (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_RTL)
 	{
-	  GdkRectangle restrict_area;
-	  GdkRectangle new_area;
-	      
-	  restrict_area.x = widget->allocation.x + GTK_CONTAINER (widget)->border_width;
-	  restrict_area.y = widget->allocation.y + GTK_CONTAINER (widget)->border_width;
-	  restrict_area.width = widget->allocation.width - (2 * GTK_CONTAINER (widget)->border_width);
-	  restrict_area.height = widget->allocation.height - (2 * GTK_CONTAINER (widget)->border_width);
+	  indicator.x = widget->allocation.x + widget->allocation.width 
+	    - (indicator.width + indicator.x - widget->allocation.x);
 	  
-	  if (gdk_rectangle_intersect (area, &restrict_area, &new_area))
-	    {
-	      gtk_paint_flat_box (widget->style, widget->window, GTK_STATE_PRELIGHT,
-				  GTK_SHADOW_ETCHED_OUT, 
-				  area, widget, "checkbutton",
-				  new_area.x, new_area.y,
-				  new_area.width, new_area.height);
-	    }
 	}
 
       gtk_paint_check (widget->style, widget->window,
 		       state_type, shadow_type,
 		       area, widget, "checkbutton",
-		       x, y, indicator_size, indicator_size);
+		       indicator.x, indicator.y, 
+		       indicator.width, indicator.height);
+    }
+}
+
+
+/* calculates the size and position of the indicator
+ * relative to the origin of the check button.
+ */
+static void gtk_check_button_calc_indicator_size( GtkCheckButton *button, 
+						  GdkRectangle *rect )
+{
+  gint indicator_size;
+  gint indicator_spacing;
+  gint focus_width;
+  gint focus_pad;
+  gint focus_x_pad;
+  gboolean interior_focus;
+  GtkWidget *child; 
+  GtkWidget *widget = GTK_WIDGET(button);
+  
+    
+  gtk_widget_style_get (widget, "interior_focus", &interior_focus,
+			"focus-line-width", &focus_width, 
+			"focus-padding", &focus_pad, 
+			"focus-x-padding", &focus_x_pad, 
+			"indicator-size", &indicator_size,
+			"indicator-spacing", &indicator_spacing,
+			NULL
+			);
+  
+
+  /* HILDON: We want the indicator to be positioned according to the spec.
+   *
+   */
+  rect->x = indicator_spacing + focus_x_pad;
+  rect->y = ( widget->allocation.height - indicator_size ) / 2;
+  
+  /* Hildon: we always add space for the focus */
+  rect->x += focus_width + focus_pad;      
+
+  child = GTK_BIN (widget)->child;
+  if (interior_focus && child && GTK_WIDGET_VISIBLE (child))
+    {
+      rect->y += HILDON_SPACING;      
     }
+  
+  rect->width = indicator_size;
+  rect->height = indicator_size;
+}
+
+static void
+gtk_check_button_clicked (GtkButton *button)
+{
+  GtkToggleButton *toggle_button = GTK_TOGGLE_BUTTON (button);
+
+  toggle_button->active = !toggle_button->active;
+  gtk_toggle_button_toggled (toggle_button);
+  
+  gtk_check_button_update_state (button);
+  
+  g_object_notify (G_OBJECT (toggle_button), "active");
+}
+
+static void
+gtk_check_button_update_state (GtkButton *button)
+{
+  GtkToggleButton *toggle_button = GTK_TOGGLE_BUTTON (button);
+  gboolean depressed;
+  GtkStateType new_state;
+  
+  if (toggle_button->inconsistent)
+    depressed = FALSE;
+  else if (button->in_button && button->button_down)
+    depressed = TRUE;
+  else
+    depressed = toggle_button->active;
+      
+  if (button->in_button && 
+      (!button->button_down || toggle_button->draw_indicator))
+    new_state = GTK_STATE_PRELIGHT;
+  else
+    new_state = depressed ? GTK_STATE_ACTIVE : GTK_STATE_NORMAL;
+  
+  _gtk_button_set_depressed (button, depressed); 
+  gtk_widget_set_state (GTK_WIDGET (toggle_button), new_state);
 }
--- gtk+/gtk/gtktoolbutton.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtktoolbutton.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -41,6 +41,7 @@
 
 enum {
   CLICKED,
+  INSENSITIVE_PRESS,
   LAST_SIGNAL
 };
 
@@ -74,7 +75,10 @@
 						     GtkToolButton   *button);
 
 static void gtk_tool_button_construct_contents (GtkToolItem *tool_item);
-      
+
+ static void insensitive_press (GtkWidget       *widget,
+						                    GtkToolButton   *button);
+    
 static GObjectClass *parent_class = NULL;
 static guint         toolbutton_signals[LAST_SIGNAL] = { 0 };
 
@@ -226,7 +230,7 @@
 		  NULL, NULL,
 		  g_cclosure_marshal_VOID__VOID,
 		  G_TYPE_NONE, 0);
-  
+
   g_type_class_add_private (object_class, sizeof (GtkToolButtonPrivate));
 }
 
@@ -246,6 +250,10 @@
   g_signal_connect_object (button->priv->button, "clicked",
 			   G_CALLBACK (button_clicked), button, 0);
 
+  /* Hildon: connect "insensitive_press" signal for private button */
+  g_signal_connect_object (button->priv->button, "insensitive_press",
+			   G_CALLBACK (insensitive_press), button, 0);
+
   gtk_container_add (GTK_CONTAINER (button), button->priv->button);
   gtk_widget_show (button->priv->button);
 }
@@ -519,7 +527,7 @@
 
 	  src_pixbuf = gtk_image_get_pixbuf (image);
 	  dest_pixbuf = gdk_pixbuf_scale_simple (src_pixbuf, width, height,
-						 GDK_INTERP_BILINEAR);
+						 GDK_INTERP_NEAREST);
 
 	  return gtk_image_new_from_pixbuf (dest_pixbuf);
 	}
@@ -594,6 +602,13 @@
 }
 
 static void
+insensitive_press (GtkWidget     *widget,
+		GtkToolButton *button)
+{
+  g_signal_emit_by_name (button, "insensitive_press");
+}
+
+static void
 gtk_tool_button_toolbar_reconfigured (GtkToolItem *tool_item)
 {
   gtk_tool_button_construct_contents (tool_item);
--- gtk+/gtk/gtkimcontext.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkimcontext.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -360,6 +360,44 @@
 }
 
 /**
+ * gtk_im_context_show:
+ * @context: a #GtkIMContext
+ *
+ * Notify the input method that widget thinks the actual
+ * input method show be opened.
+ **/
+void
+gtk_im_context_show (GtkIMContext   *context)
+{
+  GtkIMContextClass *klass;
+  
+  g_return_if_fail (GTK_IS_IM_CONTEXT (context));
+  
+  klass = GTK_IM_CONTEXT_GET_CLASS (context);
+  if (klass->show)
+    klass->show (context);
+}
+
+/**
+ * gtk_im_context_hide:
+ * @context: a #GtkIMContext
+ *
+ * Notify the input method that widget thinks the actual
+ * input method show be closed.
+ **/
+void
+gtk_im_context_hide (GtkIMContext   *context)
+{
+  GtkIMContextClass *klass;
+  
+  g_return_if_fail (GTK_IS_IM_CONTEXT (context));
+
+  klass = GTK_IM_CONTEXT_GET_CLASS (context);
+  if (klass->hide)
+    klass->hide (context);
+}
+
+/**
  * gtk_im_context_reset:
  * @context: a #GtkIMContext
  *
@@ -553,4 +591,3 @@
 
   return result;
 }
-
--- gtk+/gtk/gtkcellrenderertext.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkcellrenderertext.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -182,8 +182,8 @@
 
   GTK_CELL_RENDERER (celltext)->xalign = 0.0;
   GTK_CELL_RENDERER (celltext)->yalign = 0.5;
-  GTK_CELL_RENDERER (celltext)->xpad = 2;
-  GTK_CELL_RENDERER (celltext)->ypad = 2;
+  GTK_CELL_RENDERER (celltext)->xpad = 0;
+  GTK_CELL_RENDERER (celltext)->ypad = 0;
   celltext->fixed_height_rows = -1;
   celltext->font = pango_font_description_new ();
 
@@ -1429,7 +1429,7 @@
   /* The minimum size for ellipsized labels is ~ 3 chars */
   if (width)
     {
-      if (priv->ellipsize || priv->width_chars > 0)
+      /*if (priv->ellipsize || priv->width_chars > 0)
 	{
 	  PangoContext *context;
 	  PangoFontMetrics *metrics;
@@ -1444,9 +1444,9 @@
 	  *width += (PANGO_PIXELS (char_width) * MAX (priv->width_chars, 3));
 	}
       else
-	{
+	{*/
 	  *width = GTK_CELL_RENDERER (celltext)->xpad * 2 + rect.width;
-	}	  
+	/*}	  */
     }
 
   if (cell_area)
@@ -1501,6 +1501,7 @@
   gint x_offset;
   gint y_offset;
   GtkCellRendererTextPrivate *priv;
+  PangoRectangle logical_rect;
 
   priv = GTK_CELL_RENDERER_TEXT_GET_PRIVATE (cell);
 
@@ -1521,7 +1522,7 @@
   else if ((flags & GTK_CELL_RENDERER_PRELIT) == GTK_CELL_RENDERER_PRELIT &&
 	   GTK_WIDGET_STATE (widget) == GTK_STATE_PRELIGHT)
     {
-      state = GTK_STATE_PRELIGHT;
+      state = GTK_STATE_NORMAL;
     }
   else
     {
@@ -1559,6 +1560,14 @@
       g_object_unref (gc);
     }
 
+  /* Dirty Hildon hack to force ellipsation */
+  pango_layout_get_extents (layout, NULL, &logical_rect);
+  if (PANGO_PIXELS (logical_rect.width) > MIN (background_area->width, expose_area->width))
+    {
+      priv->ellipsize = PANGO_ELLIPSIZE_END;
+      priv->ellipsize_set = TRUE;
+    }
+
   if (priv->ellipsize)
     pango_layout_set_width (layout, 
 			    (cell_area->width - x_offset - 2 * cell->xpad) * PANGO_SCALE);
--- gtk+/gtk/gtkwindow.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkwindow.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -413,6 +413,10 @@
 						 guint		 accel_key,
 						 GdkModifierType accel_mods);
 
+GtkWidget *gtk_window_get_prev_focus_widget( GtkWindow *window );
+void gtk_window_set_prev_focus_widget( GtkWindow *window, GtkWidget *widget );
+
+
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
--- gtk+/gtk/gtktoolbutton.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtktoolbutton.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -54,12 +54,12 @@
 
   /* signal */
   void       (* clicked)             (GtkToolButton    *tool_item);
+  void       (* insensitive_press)             (GtkToolButton    *tool_item);
 
   /* Padding for future expansion */
   void (* _gtk_reserved1) (void);
   void (* _gtk_reserved2) (void);
   void (* _gtk_reserved3) (void);
-  void (* _gtk_reserved4) (void);
 };
 
 GType        gtk_tool_button_get_type       (void) G_GNUC_CONST;
--- gtk+/gtk/gtkimcontext.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkimcontext.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -85,14 +85,15 @@
   gboolean (*get_surrounding)     (GtkIMContext   *context,
 				   gchar         **text,
 				   gint           *cursor_index);
+  void     (*show)                (GtkIMContext   *context);
+  void     (*hide)                (GtkIMContext   *context);
+   
 
   /* Padding for future expansion */
   void (*_gtk_reserved1) (void);
   void (*_gtk_reserved2) (void);
   void (*_gtk_reserved3) (void);
   void (*_gtk_reserved4) (void);
-  void (*_gtk_reserved5) (void);
-  void (*_gtk_reserved6) (void);
 };
 
 GType    gtk_im_context_get_type            (void) G_GNUC_CONST;
@@ -122,6 +123,8 @@
 gboolean gtk_im_context_delete_surrounding  (GtkIMContext   *context,
 					     gint            offset,
 					     gint            n_chars);
+void     gtk_im_context_show                (GtkIMContext   *context);
+void     gtk_im_context_hide                (GtkIMContext   *context);
 
 #ifdef __cplusplus
 }
--- gtk+/gtk/gtkviewport.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkviewport.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -152,7 +152,7 @@
 						      P_("Shadow type"),
 						      P_("Determines how the shadowed box around the viewport is drawn"),
 						      GTK_TYPE_SHADOW_TYPE,
-						      GTK_SHADOW_IN,
+						      GTK_SHADOW_NONE,
 						      G_PARAM_READWRITE));
 
   widget_class->set_scroll_adjustments_signal =
@@ -229,7 +229,7 @@
   gtk_widget_set_redraw_on_allocate (GTK_WIDGET (viewport), FALSE);
   gtk_container_set_resize_mode (GTK_CONTAINER (viewport), GTK_RESIZE_QUEUE);
   
-  viewport->shadow_type = GTK_SHADOW_IN;
+  viewport->shadow_type = GTK_SHADOW_NONE;
   viewport->view_window = NULL;
   viewport->bin_window = NULL;
   viewport->hadjustment = NULL;
--- gtk+/gtk/gtkfilesystem.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkfilesystem.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -1147,4 +1147,9 @@
   return fs;
 }
 
+/* In Hildon we need to publish the previous symbol */
+GtkFileSystem *hildon_gtk_file_system_create(const char *file_system_name)
+{
+  return _gtk_file_system_create (file_system_name);
+}
 
--- gtk+/gtk/gtkmain.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkmain.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -68,6 +68,7 @@
 #include "gtkwindow.h"
 #include "gtkprivate.h"
 #include "gtkdebug.h"
+#include "gtkwidget.h"
 
 /* Private type definitions
  */
@@ -1289,15 +1290,14 @@
        *  then we send the event to the original event widget.
        *  This is the key to implementing modality.
        */
-      if (GTK_WIDGET_IS_SENSITIVE (event_widget) &&
-	  gtk_widget_is_ancestor (event_widget, grab_widget))
+      if (gtk_widget_is_ancestor (event_widget, grab_widget))
 	grab_widget = event_widget;
     }
   else
     {
       grab_widget = event_widget;
     }
-
+  
   /* Not all events get sent to the grabbing widget.
    * The delete, destroy, expose, focus change and resize
    *  events still get sent to the event widget because
@@ -1361,8 +1361,11 @@
       gtk_widget_event (event_widget, event);
       break;
 
-    case GDK_SCROLL:
     case GDK_BUTTON_PRESS:
+      if (!GTK_WIDGET_IS_SENSITIVE (event_widget))
+        gtk_widget_insensitive_press (grab_widget);
+      /* fall through */
+    case GDK_SCROLL:
     case GDK_2BUTTON_PRESS:
     case GDK_3BUTTON_PRESS:
       gtk_propagate_event (grab_widget, event);
@@ -2090,7 +2093,7 @@
   handled_event = FALSE;
 
   g_object_ref (widget);
-      
+  
   if ((event->type == GDK_KEY_PRESS) ||
       (event->type == GDK_KEY_RELEASE))
     {
--- gtk+/gtk/gtktable.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtktable.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -28,6 +28,7 @@
 #include "gtkalias.h"
 #include "gtktable.h"
 #include "gtkintl.h"
+#include "gtkbutton.h"
 
 enum
 {
@@ -507,6 +508,33 @@
   return GTK_WIDGET (table);
 }
 
+void osso_gtk_table_find_button_detail (GtkTable *table,
+					GtkTableChild *table_child)
+{
+  OssoGtkButtonAttachFlags attachflags = 0;
+  gboolean automatic_detail;
+
+  g_return_if_fail (GTK_IS_TABLE (table));
+  g_return_if_fail (table_child != NULL);
+  g_return_if_fail (GTK_IS_BUTTON (table_child->widget));
+
+  if (table_child->top_attach == 0)
+    attachflags |= OSSO_GTK_BUTTON_ATTACH_NORTH;
+
+  if (table_child->bottom_attach == table->nrows)
+    attachflags |= OSSO_GTK_BUTTON_ATTACH_SOUTH;
+
+  if (table_child->left_attach == 0)
+    attachflags |= OSSO_GTK_BUTTON_ATTACH_WEST;
+
+  if (table_child->right_attach == table->ncols)
+    attachflags |= OSSO_GTK_BUTTON_ATTACH_EAST;
+
+  g_object_get (G_OBJECT (table_child->widget), "automatic_detail", &automatic_detail, NULL);
+  if (automatic_detail == TRUE)
+    g_object_set (G_OBJECT (table_child->widget), "detail", osso_gtk_button_attach_details[attachflags], NULL);
+}
+
 void
 gtk_table_resize (GtkTable *table,
 		  guint     n_rows,
@@ -523,6 +551,18 @@
       n_cols != table->ncols)
     {
       GList *list;
+      guint recalc_column = -1;
+      guint recalc_row = -1;
+
+      if (n_rows > table->nrows)
+        recalc_row = table->nrows;
+      else
+        recalc_row = n_rows;
+
+      if (n_cols > table->ncols)
+        recalc_column = table->ncols;
+      else
+        recalc_column = n_cols;
       
       for (list = table->children; list; list = list->next)
 	{
@@ -577,6 +617,20 @@
 
 	  g_object_notify (G_OBJECT (table), "n_columns");
 	}
+
+      if ((recalc_column != -1) || (recalc_row != -1))
+	for (list = table->children; list; list = list->next)
+	{
+	  GtkTableChild *child;
+	  
+	  child = list->data;
+
+          if (GTK_IS_BUTTON (child->widget) &&
+               ((child->bottom_attach == recalc_row) ||
+               (child->right_attach == recalc_column)))
+
+	    osso_gtk_table_find_button_detail (table, child);
+	}
     }
 }
 
@@ -623,6 +677,10 @@
   table_child->yshrink = (yoptions & GTK_SHRINK) != 0;
   table_child->yfill = (yoptions & GTK_FILL) != 0;
   table_child->ypadding = ypadding;
+
+
+  if (GTK_IS_BUTTON (table_child->widget))
+    osso_gtk_table_find_button_detail (table, table_child);
   
   table->children = g_list_prepend (table->children, table_child);
   
--- gtk+/gtk/gtkfilesystem.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkfilesystem.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -70,7 +70,8 @@
   GTK_FILE_SYSTEM_ERROR_INVALID_URI,
   GTK_FILE_SYSTEM_ERROR_BAD_FILENAME,
   GTK_FILE_SYSTEM_ERROR_FAILED,
-  GTK_FILE_SYSTEM_ERROR_ALREADY_EXISTS
+  GTK_FILE_SYSTEM_ERROR_ALREADY_EXISTS,
+  GTK_FILE_SYSTEM_ERROR_TIMEOUT
 } GtkFileSystemError;
 
 GQuark     gtk_file_system_error_quark      (void);
@@ -364,6 +365,9 @@
 
 GtkFileSystem  *_gtk_file_system_create (const char *file_system_name);
 
+/* In Hildon we need to publish the previous symbol */
+GtkFileSystem *hildon_gtk_file_system_create(const char *file_system_name);
+
 G_END_DECLS
 
 #endif /* __GTK_FILE_SYSTEM_H__ */
--- gtk+/gtk/gtkframe.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkframe.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -24,6 +24,10 @@
  * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
  */
 
+/* Modified by Nokia Corporation - 2005.
+ * 
+ */
+
 #include <config.h>
 #include <string.h>
 #include "gtkalias.h"
@@ -33,6 +37,7 @@
 
 #define LABEL_PAD 1
 #define LABEL_SIDE_PAD 2
+#define FRAME_BORDER_WIDTH 3
 
 enum {
   PROP_0,
@@ -172,6 +177,14 @@
                                                         P_("A widget to display in place of the usual frame label"),
                                                         GTK_TYPE_WIDGET,
                                                         G_PARAM_READABLE | G_PARAM_WRITABLE));
+
+   /* draw hildonlike frame */
+   gtk_widget_class_install_style_property (widget_class,
+ 					   g_param_spec_boolean ("hildonlike",
+								 _("hildonlike looks"),
+								 _("Draw frame, 1/0"),
+								 FALSE,
+								 G_PARAM_READABLE));
   
   widget_class->expose_event = gtk_frame_expose;
   widget_class->size_request = gtk_frame_size_request;
@@ -276,7 +289,7 @@
 GtkWidget*
 gtk_frame_new (const gchar *label)
 {
-  return g_object_new (GTK_TYPE_FRAME, "label", label, NULL);
+  return g_object_new (GTK_TYPE_FRAME, "label", label, "border-width", FRAME_BORDER_WIDTH, NULL);
 }
 
 static void
@@ -533,6 +546,9 @@
 {
   GtkFrame *frame;
   gint x, y, width, height;
+  gboolean hildonlike;
+
+  gtk_widget_style_get ( widget, "hildonlike", &hildonlike, NULL );
 
   if (GTK_WIDGET_DRAWABLE (widget))
     {
@@ -543,7 +559,16 @@
       width = frame->child_allocation.width + 2 * widget->style->xthickness;
       height =  frame->child_allocation.height + 2 * widget->style->ythickness;
 
-      if (frame->label_widget)
+      if (hildonlike) {
+          /* draw hildon application borders */
+         gtk_paint_box (widget->style,
+			     widget->window,
+			     GTK_WIDGET_STATE( widget ),
+			     GTK_SHADOW_OUT,
+			     NULL, widget, "frame",
+			     x, y, width, height);
+      }
+      else if (frame->label_widget)
 	{
 	  GtkRequisition child_requisition;
 	  gfloat xalign;
@@ -586,7 +611,7 @@
 {
   if (GTK_WIDGET_DRAWABLE (widget))
     {
-      gtk_frame_paint (widget, &event->area);
+      	    gtk_frame_paint (widget, &event->area);
 
       (* GTK_WIDGET_CLASS (parent_class)->expose_event) (widget, event);
     }
--- gtk+/gtk/Makefile.in	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/Makefile.in	(.../2.6.4-1.osso62)	(revision 904)
@@ -485,6 +485,7 @@
 	gtktearoffmenuitem.h    \
 	gtktext.h		\
 	gtktextbuffer.h		\
+	gtktextbufferserialize.h\
 	gtktextchild.h		\
 	gtktextdisplay.h	\
 	gtktextiter.h		\
@@ -629,6 +630,8 @@
 	gtkframe.c		\
 	gtkgamma.c		\
 	gtkgc.c			\
+	gtkhashtable.c		\
+	gtkhashtable.h		\
 	gtkhandlebox.c		\
 	gtkhbbox.c		\
 	gtkhbox.c		\
@@ -712,6 +715,7 @@
 	gtktext.c		\
 	gtktextbtree.c		\
 	gtktextbuffer.c		\
+	gtktextbufferserialize.c\
 	gtktextchild.c		\
 	gtktextdisplay.c	\
 	gtktextiter.c		\
@@ -884,7 +888,7 @@
 #
 # Installed tools
 #
-bin_PROGRAMS = gtk-query-immodules-2.0 gtk-update-icon-cache
+bin_PROGRAMS = gtk-query-immodules-2.0 gtk-update-icon-cache maemo-gtk-im-switch
 
 gtk_query_immodules_2_0_DEPENDENCIES = $(DEPS)
 gtk_query_immodules_2_0_LDADD = $(LDADDS)
@@ -895,6 +899,10 @@
 gtk_update_icon_cache_LDADD = $(LDADDS)
 
 gtk_update_icon_cache_SOURCES = updateiconcache.c
+
+maemo_gtk_im_switch_LDADD = $(LDADDS)
+
+maemo_gtk_im_switch_SOURCES = maemo-gtk-im-switch.c
 subdir = gtk
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
@@ -927,14 +935,14 @@
 	gtkfilechooserdefault.c gtkfilechooserutils.c \
 	gtkfilechooserwidget.c gtkfilefilter.c gtkfilesel.c \
 	gtkfilesystem.c gtkfilesystemmodel.c gtkfixed.c gtkfontbutton.c \
-	gtkfontsel.c gtkframe.c gtkgamma.c gtkgc.c gtkhandlebox.c \
-	gtkhbbox.c gtkhbox.c gtkhpaned.c gtkhruler.c gtkhscale.c \
-	gtkhscrollbar.c gtkhseparator.c gtkhsv.c gtkhsv.h \
-	gtkiconfactory.c gtkiconcache.c gtkicontheme.c gtkiconview.c \
-	gtkimage.c gtkimagemenuitem.c gtkimcontext.c \
-	gtkimcontextsimple.c gtkimmodule.c gtkimmulticontext.c \
-	gtkinputdialog.c gtkintl.h gtkinvisible.c gtkitem.c \
-	gtkitemfactory.c gtkkeyhash.c gtkkeyhash.h gtklabel.c \
+	gtkfontsel.c gtkframe.c gtkgamma.c gtkgc.c gtkhashtable.c \
+	gtkhashtable.h gtkhandlebox.c gtkhbbox.c gtkhbox.c gtkhpaned.c \
+	gtkhruler.c gtkhscale.c gtkhscrollbar.c gtkhseparator.c \
+	gtkhsv.c gtkhsv.h gtkiconfactory.c gtkiconcache.c \
+	gtkicontheme.c gtkiconview.c gtkimage.c gtkimagemenuitem.c \
+	gtkimcontext.c gtkimcontextsimple.c gtkimmodule.c \
+	gtkimmulticontext.c gtkinputdialog.c gtkintl.h gtkinvisible.c \
+	gtkitem.c gtkitemfactory.c gtkkeyhash.c gtkkeyhash.h gtklabel.c \
 	gtklayout.c gtklist.c gtklistitem.c gtkliststore.c gtkmain.c \
 	gtkmarshal.c gtkmarshalers.c gtkmenu.c gtkmenubar.c \
 	gtkmenuitem.c gtkmenushell.c gtkmenutoolbutton.c \
@@ -949,21 +957,21 @@
 	gtkseparatortoolitem.c gtksettings.c gtksignal.c gtksizegroup.c \
 	gtkspinbutton.c gtkstatusbar.c gtkstock.c gtkstyle.c gtktable.c \
 	gtktearoffmenuitem.c gtktext.c gtktextbtree.c gtktextbuffer.c \
-	gtktextchild.c gtktextdisplay.c gtktextiter.c \
-	gtktextiterprivate.h gtktextlayout.c gtktextmark.c \
-	gtktextmarkprivate.h gtktextsegment.c gtktexttag.c \
-	gtktexttagtable.c gtktexttypes.c gtktextutil.c gtktextview.c \
-	gtkthemes.c gtktipsquery.c gtktoggleaction.c gtktogglebutton.c \
-	gtktoggletoolbutton.c gtktoolbar.c gtktoolbutton.c \
-	gtktoolitem.c gtktooltips.c gtktree.c gtktreedatalist.c \
-	gtktreednd.c gtktreeitem.c gtktreemodel.c gtktreemodelfilter.c \
-	gtktreemodelsort.c gtktreeselection.c gtktreesortable.c \
-	gtktreestore.c gtktreeview.c gtktreeviewcolumn.c \
-	gtktypebuiltins.c gtktypeutils.c gtkuimanager.c gtkvbbox.c \
-	gtkvbox.c gtkviewport.c gtkvpaned.c gtkvruler.c gtkvscale.c \
-	gtkvscrollbar.c gtkvseparator.c gtkwidget.c \
-	gtkwindow-decorate.c gtkwindow.c xembed.h gtkfilesystemunix.c \
-	gtkfilesystemwin32.c
+	gtktextbufferserialize.c gtktextchild.c gtktextdisplay.c \
+	gtktextiter.c gtktextiterprivate.h gtktextlayout.c \
+	gtktextmark.c gtktextmarkprivate.h gtktextsegment.c \
+	gtktexttag.c gtktexttagtable.c gtktexttypes.c gtktextutil.c \
+	gtktextview.c gtkthemes.c gtktipsquery.c gtktoggleaction.c \
+	gtktogglebutton.c gtktoggletoolbutton.c gtktoolbar.c \
+	gtktoolbutton.c gtktoolitem.c gtktooltips.c gtktree.c \
+	gtktreedatalist.c gtktreednd.c gtktreeitem.c gtktreemodel.c \
+	gtktreemodelfilter.c gtktreemodelsort.c gtktreeselection.c \
+	gtktreesortable.c gtktreestore.c gtktreeview.c \
+	gtktreeviewcolumn.c gtktypebuiltins.c gtktypeutils.c \
+	gtkuimanager.c gtkvbbox.c gtkvbox.c gtkviewport.c gtkvpaned.c \
+	gtkvruler.c gtkvscale.c gtkvscrollbar.c gtkvseparator.c \
+	gtkwidget.c gtkwindow-decorate.c gtkwindow.c xembed.h \
+	gtkfilesystemunix.c gtkfilesystemwin32.c
 @OS_UNIX_TRUE@am__objects_1 = gtkfilesystemunix.lo
 @OS_WIN32_TRUE@am__objects_2 = gtkfilesystemwin32.lo
 am__objects_3 = fnmatch.lo gtkaboutdialog.lo gtkaccelgroup.lo \
@@ -986,16 +994,16 @@
 	gtkfilechooserutils.lo gtkfilechooserwidget.lo gtkfilefilter.lo \
 	gtkfilesel.lo gtkfilesystem.lo gtkfilesystemmodel.lo \
 	gtkfixed.lo gtkfontbutton.lo gtkfontsel.lo gtkframe.lo \
-	gtkgamma.lo gtkgc.lo gtkhandlebox.lo gtkhbbox.lo gtkhbox.lo \
-	gtkhpaned.lo gtkhruler.lo gtkhscale.lo gtkhscrollbar.lo \
-	gtkhseparator.lo gtkhsv.lo gtkiconfactory.lo gtkiconcache.lo \
-	gtkicontheme.lo gtkiconview.lo gtkimage.lo gtkimagemenuitem.lo \
-	gtkimcontext.lo gtkimcontextsimple.lo gtkimmodule.lo \
-	gtkimmulticontext.lo gtkinputdialog.lo gtkinvisible.lo \
-	gtkitem.lo gtkitemfactory.lo gtkkeyhash.lo gtklabel.lo \
-	gtklayout.lo gtklist.lo gtklistitem.lo gtkliststore.lo \
-	gtkmain.lo gtkmarshal.lo gtkmarshalers.lo gtkmenu.lo \
-	gtkmenubar.lo gtkmenuitem.lo gtkmenushell.lo \
+	gtkgamma.lo gtkgc.lo gtkhashtable.lo gtkhandlebox.lo \
+	gtkhbbox.lo gtkhbox.lo gtkhpaned.lo gtkhruler.lo gtkhscale.lo \
+	gtkhscrollbar.lo gtkhseparator.lo gtkhsv.lo gtkiconfactory.lo \
+	gtkiconcache.lo gtkicontheme.lo gtkiconview.lo gtkimage.lo \
+	gtkimagemenuitem.lo gtkimcontext.lo gtkimcontextsimple.lo \
+	gtkimmodule.lo gtkimmulticontext.lo gtkinputdialog.lo \
+	gtkinvisible.lo gtkitem.lo gtkitemfactory.lo gtkkeyhash.lo \
+	gtklabel.lo gtklayout.lo gtklist.lo gtklistitem.lo \
+	gtkliststore.lo gtkmain.lo gtkmarshal.lo gtkmarshalers.lo \
+	gtkmenu.lo gtkmenubar.lo gtkmenuitem.lo gtkmenushell.lo \
 	gtkmenutoolbutton.lo gtkmessagedialog.lo gtkmisc.lo \
 	gtkmnemonichash.lo gtkmodules.lo gtknotebook.lo gtkobject.lo \
 	gtkoldeditable.lo gtkoptionmenu.lo gtkpaned.lo gtkpathbar.lo \
@@ -1007,14 +1015,15 @@
 	gtkseparatormenuitem.lo gtkseparatortoolitem.lo gtksettings.lo \
 	gtksignal.lo gtksizegroup.lo gtkspinbutton.lo gtkstatusbar.lo \
 	gtkstock.lo gtkstyle.lo gtktable.lo gtktearoffmenuitem.lo \
-	gtktext.lo gtktextbtree.lo gtktextbuffer.lo gtktextchild.lo \
-	gtktextdisplay.lo gtktextiter.lo gtktextlayout.lo \
-	gtktextmark.lo gtktextsegment.lo gtktexttag.lo \
-	gtktexttagtable.lo gtktexttypes.lo gtktextutil.lo \
-	gtktextview.lo gtkthemes.lo gtktipsquery.lo gtktoggleaction.lo \
-	gtktogglebutton.lo gtktoggletoolbutton.lo gtktoolbar.lo \
-	gtktoolbutton.lo gtktoolitem.lo gtktooltips.lo gtktree.lo \
-	gtktreedatalist.lo gtktreednd.lo gtktreeitem.lo gtktreemodel.lo \
+	gtktext.lo gtktextbtree.lo gtktextbuffer.lo \
+	gtktextbufferserialize.lo gtktextchild.lo gtktextdisplay.lo \
+	gtktextiter.lo gtktextlayout.lo gtktextmark.lo \
+	gtktextsegment.lo gtktexttag.lo gtktexttagtable.lo \
+	gtktexttypes.lo gtktextutil.lo gtktextview.lo gtkthemes.lo \
+	gtktipsquery.lo gtktoggleaction.lo gtktogglebutton.lo \
+	gtktoggletoolbutton.lo gtktoolbar.lo gtktoolbutton.lo \
+	gtktoolitem.lo gtktooltips.lo gtktree.lo gtktreedatalist.lo \
+	gtktreednd.lo gtktreeitem.lo gtktreemodel.lo \
 	gtktreemodelfilter.lo gtktreemodelsort.lo gtktreeselection.lo \
 	gtktreesortable.lo gtktreestore.lo gtktreeview.lo \
 	gtktreeviewcolumn.lo gtktypebuiltins.lo gtktypeutils.lo \
@@ -1042,14 +1051,14 @@
 	gtkfilechooserdefault.c gtkfilechooserutils.c \
 	gtkfilechooserwidget.c gtkfilefilter.c gtkfilesel.c \
 	gtkfilesystem.c gtkfilesystemmodel.c gtkfixed.c gtkfontbutton.c \
-	gtkfontsel.c gtkframe.c gtkgamma.c gtkgc.c gtkhandlebox.c \
-	gtkhbbox.c gtkhbox.c gtkhpaned.c gtkhruler.c gtkhscale.c \
-	gtkhscrollbar.c gtkhseparator.c gtkhsv.c gtkhsv.h \
-	gtkiconfactory.c gtkiconcache.c gtkicontheme.c gtkiconview.c \
-	gtkimage.c gtkimagemenuitem.c gtkimcontext.c \
-	gtkimcontextsimple.c gtkimmodule.c gtkimmulticontext.c \
-	gtkinputdialog.c gtkintl.h gtkinvisible.c gtkitem.c \
-	gtkitemfactory.c gtkkeyhash.c gtkkeyhash.h gtklabel.c \
+	gtkfontsel.c gtkframe.c gtkgamma.c gtkgc.c gtkhashtable.c \
+	gtkhashtable.h gtkhandlebox.c gtkhbbox.c gtkhbox.c gtkhpaned.c \
+	gtkhruler.c gtkhscale.c gtkhscrollbar.c gtkhseparator.c \
+	gtkhsv.c gtkhsv.h gtkiconfactory.c gtkiconcache.c \
+	gtkicontheme.c gtkiconview.c gtkimage.c gtkimagemenuitem.c \
+	gtkimcontext.c gtkimcontextsimple.c gtkimmodule.c \
+	gtkimmulticontext.c gtkinputdialog.c gtkintl.h gtkinvisible.c \
+	gtkitem.c gtkitemfactory.c gtkkeyhash.c gtkkeyhash.h gtklabel.c \
 	gtklayout.c gtklist.c gtklistitem.c gtkliststore.c gtkmain.c \
 	gtkmarshal.c gtkmarshalers.c gtkmenu.c gtkmenubar.c \
 	gtkmenuitem.c gtkmenushell.c gtkmenutoolbutton.c \
@@ -1064,21 +1073,21 @@
 	gtkseparatortoolitem.c gtksettings.c gtksignal.c gtksizegroup.c \
 	gtkspinbutton.c gtkstatusbar.c gtkstock.c gtkstyle.c gtktable.c \
 	gtktearoffmenuitem.c gtktext.c gtktextbtree.c gtktextbuffer.c \
-	gtktextchild.c gtktextdisplay.c gtktextiter.c \
-	gtktextiterprivate.h gtktextlayout.c gtktextmark.c \
-	gtktextmarkprivate.h gtktextsegment.c gtktexttag.c \
-	gtktexttagtable.c gtktexttypes.c gtktextutil.c gtktextview.c \
-	gtkthemes.c gtktipsquery.c gtktoggleaction.c gtktogglebutton.c \
-	gtktoggletoolbutton.c gtktoolbar.c gtktoolbutton.c \
-	gtktoolitem.c gtktooltips.c gtktree.c gtktreedatalist.c \
-	gtktreednd.c gtktreeitem.c gtktreemodel.c gtktreemodelfilter.c \
-	gtktreemodelsort.c gtktreeselection.c gtktreesortable.c \
-	gtktreestore.c gtktreeview.c gtktreeviewcolumn.c \
-	gtktypebuiltins.c gtktypeutils.c gtkuimanager.c gtkvbbox.c \
-	gtkvbox.c gtkviewport.c gtkvpaned.c gtkvruler.c gtkvscale.c \
-	gtkvscrollbar.c gtkvseparator.c gtkwidget.c \
-	gtkwindow-decorate.c gtkwindow.c xembed.h gtkfilesystemunix.c \
-	gtkfilesystemwin32.c
+	gtktextbufferserialize.c gtktextchild.c gtktextdisplay.c \
+	gtktextiter.c gtktextiterprivate.h gtktextlayout.c \
+	gtktextmark.c gtktextmarkprivate.h gtktextsegment.c \
+	gtktexttag.c gtktexttagtable.c gtktexttypes.c gtktextutil.c \
+	gtktextview.c gtkthemes.c gtktipsquery.c gtktoggleaction.c \
+	gtktogglebutton.c gtktoggletoolbutton.c gtktoolbar.c \
+	gtktoolbutton.c gtktoolitem.c gtktooltips.c gtktree.c \
+	gtktreedatalist.c gtktreednd.c gtktreeitem.c gtktreemodel.c \
+	gtktreemodelfilter.c gtktreemodelsort.c gtktreeselection.c \
+	gtktreesortable.c gtktreestore.c gtktreeview.c \
+	gtktreeviewcolumn.c gtktypebuiltins.c gtktypeutils.c \
+	gtkuimanager.c gtkvbbox.c gtkvbox.c gtkviewport.c gtkvpaned.c \
+	gtkvruler.c gtkvscale.c gtkvscrollbar.c gtkvseparator.c \
+	gtkwidget.c gtkwindow-decorate.c gtkwindow.c xembed.h \
+	gtkfilesystemunix.c gtkfilesystemwin32.c
 am_libgtk_win32_2_0_la_OBJECTS = $(am__objects_3)
 libgtk_win32_2_0_la_OBJECTS = $(am_libgtk_win32_2_0_la_OBJECTS)
 @OS_UNIX_TRUE@libgtk_x11_2_0_la_DEPENDENCIES = \
@@ -1106,14 +1115,14 @@
 	gtkfilechooserdefault.c gtkfilechooserutils.c \
 	gtkfilechooserwidget.c gtkfilefilter.c gtkfilesel.c \
 	gtkfilesystem.c gtkfilesystemmodel.c gtkfixed.c gtkfontbutton.c \
-	gtkfontsel.c gtkframe.c gtkgamma.c gtkgc.c gtkhandlebox.c \
-	gtkhbbox.c gtkhbox.c gtkhpaned.c gtkhruler.c gtkhscale.c \
-	gtkhscrollbar.c gtkhseparator.c gtkhsv.c gtkhsv.h \
-	gtkiconfactory.c gtkiconcache.c gtkicontheme.c gtkiconview.c \
-	gtkimage.c gtkimagemenuitem.c gtkimcontext.c \
-	gtkimcontextsimple.c gtkimmodule.c gtkimmulticontext.c \
-	gtkinputdialog.c gtkintl.h gtkinvisible.c gtkitem.c \
-	gtkitemfactory.c gtkkeyhash.c gtkkeyhash.h gtklabel.c \
+	gtkfontsel.c gtkframe.c gtkgamma.c gtkgc.c gtkhashtable.c \
+	gtkhashtable.h gtkhandlebox.c gtkhbbox.c gtkhbox.c gtkhpaned.c \
+	gtkhruler.c gtkhscale.c gtkhscrollbar.c gtkhseparator.c \
+	gtkhsv.c gtkhsv.h gtkiconfactory.c gtkiconcache.c \
+	gtkicontheme.c gtkiconview.c gtkimage.c gtkimagemenuitem.c \
+	gtkimcontext.c gtkimcontextsimple.c gtkimmodule.c \
+	gtkimmulticontext.c gtkinputdialog.c gtkintl.h gtkinvisible.c \
+	gtkitem.c gtkitemfactory.c gtkkeyhash.c gtkkeyhash.h gtklabel.c \
 	gtklayout.c gtklist.c gtklistitem.c gtkliststore.c gtkmain.c \
 	gtkmarshal.c gtkmarshalers.c gtkmenu.c gtkmenubar.c \
 	gtkmenuitem.c gtkmenushell.c gtkmenutoolbutton.c \
@@ -1128,27 +1137,28 @@
 	gtkseparatortoolitem.c gtksettings.c gtksignal.c gtksizegroup.c \
 	gtkspinbutton.c gtkstatusbar.c gtkstock.c gtkstyle.c gtktable.c \
 	gtktearoffmenuitem.c gtktext.c gtktextbtree.c gtktextbuffer.c \
-	gtktextchild.c gtktextdisplay.c gtktextiter.c \
-	gtktextiterprivate.h gtktextlayout.c gtktextmark.c \
-	gtktextmarkprivate.h gtktextsegment.c gtktexttag.c \
-	gtktexttagtable.c gtktexttypes.c gtktextutil.c gtktextview.c \
-	gtkthemes.c gtktipsquery.c gtktoggleaction.c gtktogglebutton.c \
-	gtktoggletoolbutton.c gtktoolbar.c gtktoolbutton.c \
-	gtktoolitem.c gtktooltips.c gtktree.c gtktreedatalist.c \
-	gtktreednd.c gtktreeitem.c gtktreemodel.c gtktreemodelfilter.c \
-	gtktreemodelsort.c gtktreeselection.c gtktreesortable.c \
-	gtktreestore.c gtktreeview.c gtktreeviewcolumn.c \
-	gtktypebuiltins.c gtktypeutils.c gtkuimanager.c gtkvbbox.c \
-	gtkvbox.c gtkviewport.c gtkvpaned.c gtkvruler.c gtkvscale.c \
-	gtkvscrollbar.c gtkvseparator.c gtkwidget.c \
-	gtkwindow-decorate.c gtkwindow.c xembed.h gtkfilesystemunix.c \
-	gtkfilesystemwin32.c gtkplug.c gtksocket.c gtkxembed.c \
-	gtkxembed.h
+	gtktextbufferserialize.c gtktextchild.c gtktextdisplay.c \
+	gtktextiter.c gtktextiterprivate.h gtktextlayout.c \
+	gtktextmark.c gtktextmarkprivate.h gtktextsegment.c \
+	gtktexttag.c gtktexttagtable.c gtktexttypes.c gtktextutil.c \
+	gtktextview.c gtkthemes.c gtktipsquery.c gtktoggleaction.c \
+	gtktogglebutton.c gtktoggletoolbutton.c gtktoolbar.c \
+	gtktoolbutton.c gtktoolitem.c gtktooltips.c gtktree.c \
+	gtktreedatalist.c gtktreednd.c gtktreeitem.c gtktreemodel.c \
+	gtktreemodelfilter.c gtktreemodelsort.c gtktreeselection.c \
+	gtktreesortable.c gtktreestore.c gtktreeview.c \
+	gtktreeviewcolumn.c gtktypebuiltins.c gtktypeutils.c \
+	gtkuimanager.c gtkvbbox.c gtkvbox.c gtkviewport.c gtkvpaned.c \
+	gtkvruler.c gtkvscale.c gtkvscrollbar.c gtkvseparator.c \
+	gtkwidget.c gtkwindow-decorate.c gtkwindow.c xembed.h \
+	gtkfilesystemunix.c gtkfilesystemwin32.c gtkplug.c gtksocket.c \
+	gtkxembed.c gtkxembed.h
 am__objects_4 = gtkplug.lo gtksocket.lo gtkxembed.lo
 am_libgtk_x11_2_0_la_OBJECTS = $(am__objects_3) $(am__objects_4)
 libgtk_x11_2_0_la_OBJECTS = $(am_libgtk_x11_2_0_la_OBJECTS)
 bin_PROGRAMS = gtk-query-immodules-2.0$(EXEEXT) \
-	gtk-update-icon-cache$(EXEEXT)
+	gtk-update-icon-cache$(EXEEXT) maemo-gtk-im-switch$(EXEEXT)
+
 PROGRAMS = $(bin_PROGRAMS)
 
 am_gtk_query_immodules_2_0_OBJECTS = queryimmodules.$(OBJEXT)
@@ -1157,6 +1167,12 @@
 am_gtk_update_icon_cache_OBJECTS = updateiconcache.$(OBJEXT)
 gtk_update_icon_cache_OBJECTS = $(am_gtk_update_icon_cache_OBJECTS)
 gtk_update_icon_cache_LDFLAGS =
+am_maemo_gtk_im_switch_OBJECTS = maemo-gtk-im-switch.$(OBJEXT)
+maemo_gtk_im_switch_OBJECTS = $(am_maemo_gtk_im_switch_OBJECTS)
+maemo_gtk_im_switch_DEPENDENCIES = \
+	$(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la \
+	$(top_builddir)/gdk/$(gdktargetlib)
+maemo_gtk_im_switch_LDFLAGS =
 
 DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
@@ -1224,6 +1240,7 @@
 @AMDEP_TRUE@	./$(DEPDIR)/gtkfontsel.Plo ./$(DEPDIR)/gtkframe.Plo \
 @AMDEP_TRUE@	./$(DEPDIR)/gtkgamma.Plo ./$(DEPDIR)/gtkgc.Plo \
 @AMDEP_TRUE@	./$(DEPDIR)/gtkhandlebox.Plo \
+@AMDEP_TRUE@	./$(DEPDIR)/gtkhashtable.Plo \
 @AMDEP_TRUE@	./$(DEPDIR)/gtkhbbox.Plo ./$(DEPDIR)/gtkhbox.Plo \
 @AMDEP_TRUE@	./$(DEPDIR)/gtkhpaned.Plo ./$(DEPDIR)/gtkhruler.Plo \
 @AMDEP_TRUE@	./$(DEPDIR)/gtkhscale.Plo \
@@ -1292,6 +1309,7 @@
 @AMDEP_TRUE@	./$(DEPDIR)/gtktext.Plo \
 @AMDEP_TRUE@	./$(DEPDIR)/gtktextbtree.Plo \
 @AMDEP_TRUE@	./$(DEPDIR)/gtktextbuffer.Plo \
+@AMDEP_TRUE@	./$(DEPDIR)/gtktextbufferserialize.Plo \
 @AMDEP_TRUE@	./$(DEPDIR)/gtktextchild.Plo \
 @AMDEP_TRUE@	./$(DEPDIR)/gtktextdisplay.Plo \
 @AMDEP_TRUE@	./$(DEPDIR)/gtktextiter.Plo \
@@ -1335,6 +1353,7 @@
 @AMDEP_TRUE@	./$(DEPDIR)/gtkwidget.Plo \
 @AMDEP_TRUE@	./$(DEPDIR)/gtkwindow-decorate.Plo \
 @AMDEP_TRUE@	./$(DEPDIR)/gtkwindow.Plo ./$(DEPDIR)/gtkxembed.Plo \
+@AMDEP_TRUE@	./$(DEPDIR)/maemo-gtk-im-switch.Po \
 @AMDEP_TRUE@	./$(DEPDIR)/queryimmodules.Po \
 @AMDEP_TRUE@	./$(DEPDIR)/updateiconcache.Po
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
@@ -1348,7 +1367,7 @@
 	$(am__libgtk_win32_2_0_la_SOURCES_DIST) \
 	$(am__libgtk_x11_2_0_la_SOURCES_DIST) \
 	$(gtk_query_immodules_2_0_SOURCES) \
-	$(gtk_update_icon_cache_SOURCES)
+	$(gtk_update_icon_cache_SOURCES) $(maemo_gtk_im_switch_SOURCES)
 DATA = $(noinst_DATA)
 
 HEADERS = $(gtkinclude_HEADERS)
@@ -1361,7 +1380,7 @@
 	check-recursive installcheck-recursive
 DIST_COMMON = $(gtkinclude_HEADERS) $(srcdir)/Makefile.in Makefile.am \
 	gtk-win32.rc.in gtkversion.h.in makefile.msc.in
-SOURCES = $(libgtk_linux_fb_2_0_la_SOURCES) $(libgtk_win32_2_0_la_SOURCES) $(libgtk_x11_2_0_la_SOURCES) $(gtk_query_immodules_2_0_SOURCES) $(gtk_update_icon_cache_SOURCES)
+SOURCES = $(libgtk_linux_fb_2_0_la_SOURCES) $(libgtk_win32_2_0_la_SOURCES) $(libgtk_x11_2_0_la_SOURCES) $(gtk_query_immodules_2_0_SOURCES) $(gtk_update_icon_cache_SOURCES) $(maemo_gtk_im_switch_SOURCES)
 
 all: $(BUILT_SOURCES)
 	$(MAKE) $(AM_MAKEFLAGS) all-recursive
@@ -1448,6 +1467,9 @@
 gtk-update-icon-cache$(EXEEXT): $(gtk_update_icon_cache_OBJECTS) $(gtk_update_icon_cache_DEPENDENCIES) 
 	@rm -f gtk-update-icon-cache$(EXEEXT)
 	$(LINK) $(gtk_update_icon_cache_LDFLAGS) $(gtk_update_icon_cache_OBJECTS) $(gtk_update_icon_cache_LDADD) $(LIBS)
+maemo-gtk-im-switch$(EXEEXT): $(maemo_gtk_im_switch_OBJECTS) $(maemo_gtk_im_switch_DEPENDENCIES) 
+	@rm -f maemo-gtk-im-switch$(EXEEXT)
+	$(LINK) $(maemo_gtk_im_switch_LDFLAGS) $(maemo_gtk_im_switch_OBJECTS) $(maemo_gtk_im_switch_LDADD) $(LIBS)
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT) core *.core
@@ -1524,6 +1546,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gtkgamma.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gtkgc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gtkhandlebox.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gtkhashtable.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gtkhbbox.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gtkhbox.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gtkhpaned.Plo@am__quote@
@@ -1604,6 +1627,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gtktext.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gtktextbtree.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gtktextbuffer.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gtktextbufferserialize.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gtktextchild.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gtktextdisplay.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gtktextiter.Plo@am__quote@
@@ -1651,6 +1675,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gtkwindow-decorate.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gtkwindow.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gtkxembed.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maemo-gtk-im-switch.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/queryimmodules.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/updateiconcache.Po@am__quote@
 
--- gtk+/gtk/gtkbutton.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkbutton.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -24,6 +24,10 @@
  * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
  */
 
+/* Modified by Nokia Corporation - 2005.
+ * 
+ */
+
 #include <config.h>
 #include <string.h>
 #include "gtkalias.h"
@@ -38,8 +42,33 @@
 #include "gtkiconfactory.h"
 #include "gtkintl.h"
 
+/* Osso addition:
+ * Here are the details for each attach 
+ * bitmask combination. */
+const gchar *osso_gtk_button_attach_details [OSSO_GTK_BUTTON_ATTACH_ENUM_END] =
+  { "osso_button",
+    "osso_button_n",
+    "osso_button_e",
+    "osso_button_ne",
+    "osso_button_s",
+    "osso_button_ns",
+    "osso_button_es",
+    "osso_button_nes",
+    "osso_button_w",
+    "osso_button_nw",
+    "osso_button_ew",
+    "osso_button_new",
+    "osso_button_sw",
+    "osso_button_nsw",
+    "osso_button_esw",
+    "osso_button_nesw",
+  };
+
 #define CHILD_SPACING     1
 
+/* Take this away after font drawing is fixed */
+#define OSSO_FONT_HACK TRUE
+
 static const GtkBorder default_default_border = { 1, 1, 1, 1 };
 static const GtkBorder default_default_outside_border = { 0, 0, 0, 0 };
 
@@ -68,6 +97,9 @@
   PROP_FOCUS_ON_CLICK,
   PROP_XALIGN,
   PROP_YALIGN,
+  PROP_DETAIL,
+  PROP_AUTOMATIC_DETAIL,
+  PROP_KEYBOARD_BUTTON
 };
 
 #define GTK_BUTTON_GET_PRIVATE(o)       (G_TYPE_INSTANCE_GET_PRIVATE ((o), GTK_TYPE_BUTTON, GtkButtonPrivate))
@@ -80,6 +112,10 @@
   GtkWidget   *image;
   guint        align_set : 1;
   guint        image_is_stock : 1;
+  gchar       *detail;
+  gboolean     automatic_detail;
+  gboolean     keyboard_button;
+  GtkLabel    *keyboard_label;
 };
 
 static void gtk_button_class_init     (GtkButtonClass   *klass);
@@ -231,6 +267,14 @@
                                                         G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
   
   g_object_class_install_property (gobject_class,
+				   PROP_KEYBOARD_BUTTON,
+                                   g_param_spec_boolean ("keyboard_button",
+							 P_("Keyboard button"),
+							 P_("If set, label foo"),
+                                                        FALSE,
+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
+  
+  g_object_class_install_property (gobject_class,
                                    PROP_USE_STOCK,
                                    g_param_spec_boolean ("use_stock",
 							 P_("Use stock"),
@@ -418,6 +462,77 @@
 						       P_("Whether stock icons should be shown in buttons"),
 						       TRUE,
 						       G_PARAM_READWRITE));
+
+  gtk_widget_class_install_style_property (widget_class,
+					   g_param_spec_int ("child_spacing",
+							     _("Child spacing"),
+							     _("Spacing between button edges and child."),
+							     0,
+							     G_MAXINT,
+							     CHILD_SPACING,
+							     G_PARAM_READABLE));
+  /* Osso additions below */
+  g_object_class_install_property (gobject_class,
+				   PROP_DETAIL,
+				   g_param_spec_string ("detail",
+							P_("Detail"),
+							P_("The detail the button is drawn with."),
+							"buttondefault",
+							G_PARAM_READWRITE));
+
+  g_object_class_install_property (gobject_class,
+				   PROP_AUTOMATIC_DETAIL,
+				   g_param_spec_boolean ("automatic_detail",
+							 P_("Automatic Detail"),
+							 P_("Whether setting detail is automatic based on GtkTable/GtkHButtonBox."),
+							 TRUE,
+							 G_PARAM_READWRITE));
+
+
+  gtk_widget_class_install_style_property (widget_class,
+					   g_param_spec_int ("child_offset_y",
+							     _("Child Y Offset"),
+							     _("Enable hack how many pixels to add/take away from GtkButton's child size allocation."),
+							     G_MININT,
+							     G_MAXINT,
+							     0,
+							     G_PARAM_READABLE));
+
+  /* OSSO: This is used to find out whether
+   * button is a GtkTreeView column Listbox
+   * header or not */
+  gtk_widget_class_install_style_property (widget_class,
+					   g_param_spec_boolean ("listboxheader",
+								 P_( "Listbox header" ),
+								 P_( "Listbox header ( FALSE / TRUE )" ),
+								 FALSE,
+								 G_PARAM_READABLE));
+
+  /* OSSO: Column Listbox header separator height */
+  gtk_widget_class_install_style_property (widget_class,
+					   g_param_spec_int ("separator-height",
+							     P_( "Separator height" ),
+							     P_( "Listbox header separator height ( FALSE / TRUE )" ),
+							     0,
+							     G_MAXINT,
+							     0,
+							     G_PARAM_READABLE));
+
+  gtk_widget_class_install_style_property (widget_class,
+					   g_param_spec_boxed ("padding",
+							       P_("Padding"),
+							       P_("Paddings around the button child"),
+							       GTK_TYPE_BORDER,
+							       G_PARAM_READABLE));
+
+  gtk_widget_class_install_style_property (widget_class,
+					   g_param_spec_int ("minimum_width",
+							     P_("Minimum Width"),
+							     P_("Minimum width of the button"),
+							     0,
+							     G_MAXINT,
+							     0,
+							     G_PARAM_READABLE));
   
   g_type_class_add_private (gobject_class, sizeof (GtkButtonPrivate));  
 }
@@ -445,19 +560,33 @@
   priv->xalign = 0.5;
   priv->yalign = 0.5;
   priv->align_set = 0;
+  priv->detail = g_strdup ("buttondefault");
+  priv->automatic_detail = TRUE;
+  priv->keyboard_button = FALSE;
+  priv->keyboard_label = NULL;
   priv->image_is_stock = TRUE;
+
+  g_object_set (G_OBJECT (button), "tap_and_hold_state",
+                GTK_STATE_ACTIVE, NULL);
 }
 
 static void
 gtk_button_destroy (GtkObject *object)
 {
   GtkButton *button = GTK_BUTTON (object);
+  GtkButtonPrivate *priv = GTK_BUTTON_GET_PRIVATE (button);
   
   if (button->label_text)
     {
       g_free (button->label_text);
       button->label_text = NULL;
     }
+
+  if (priv->detail)
+    {
+      g_free (priv->detail);
+      priv->detail = NULL;
+    }
   
   (* GTK_OBJECT_CLASS (parent_class)->destroy) (object);
 }
@@ -560,6 +689,18 @@
     case PROP_YALIGN:
       gtk_button_set_alignment (button, priv->xalign, g_value_get_float (value));
       break;
+    case PROP_DETAIL:
+      if (priv->detail)
+        g_free (priv->detail);
+      priv->detail = g_strdup (g_value_get_string (value));
+      gtk_widget_queue_draw (GTK_WIDGET (button));
+      break;
+    case PROP_AUTOMATIC_DETAIL:
+      priv->automatic_detail = g_value_get_boolean (value);
+      break;
+    case PROP_KEYBOARD_BUTTON:
+      priv->keyboard_button = g_value_get_boolean (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -601,6 +742,15 @@
     case PROP_YALIGN:
       g_value_set_float (value, priv->yalign);
       break;
+    case PROP_DETAIL:
+      g_value_set_string (value, priv->detail);
+      break;
+    case PROP_AUTOMATIC_DETAIL:
+      g_value_set_boolean (value, priv->automatic_detail);
+      break;
+    case PROP_KEYBOARD_BUTTON:
+      g_value_set_boolean (value, priv->keyboard_button);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -641,6 +791,26 @@
   if (button->label_text == NULL)
     return;
 
+  if (priv->keyboard_button)
+    {
+      if (priv->keyboard_label)
+	{
+	  gtk_label_set_label (priv->keyboard_label, button->label_text);
+	}
+      else
+	{
+	  GtkWidget *label = gtk_label_new (button->label_text);
+	  priv->keyboard_label = GTK_LABEL (label);
+  	  
+	  if (priv->align_set)
+	    gtk_misc_set_alignment (GTK_MISC (label),
+				    priv->xalign, priv->yalign);
+	  gtk_widget_show (priv->keyboard_label);
+	  gtk_container_add (GTK_CONTAINER (button), label);
+	}
+      return;
+    }
+
   if (GTK_BIN (button)->child)
     {
       if (priv->image && !priv->image_is_stock)
@@ -944,16 +1114,20 @@
   GtkBorder default_border;
   gint focus_width;
   gint focus_pad;
+  gint child_spacing;
+  gint separator_height;
 
   gtk_button_get_props (button, &default_border, NULL, NULL);
   gtk_widget_style_get (GTK_WIDGET (widget),
 			"focus-line-width", &focus_width,
 			"focus-padding", &focus_pad,
+			"child-spacing", &child_spacing,
+			"separator-height", &separator_height,
 			NULL);
  
-  requisition->width = (GTK_CONTAINER (widget)->border_width + CHILD_SPACING +
+  requisition->width = (GTK_CONTAINER (widget)->border_width + child_spacing +
 			GTK_WIDGET (widget)->style->xthickness) * 2;
-  requisition->height = (GTK_CONTAINER (widget)->border_width + CHILD_SPACING +
+  requisition->height = (GTK_CONTAINER (widget)->border_width + child_spacing +
 			 GTK_WIDGET (widget)->style->ythickness) * 2;
 
   if (GTK_WIDGET_CAN_DEFAULT (widget))
@@ -965,15 +1139,37 @@
   if (GTK_BIN (button)->child && GTK_WIDGET_VISIBLE (GTK_BIN (button)->child))
     {
       GtkRequisition child_requisition;
+      GtkBorder *padding;
+      gint minimum_width;
 
       gtk_widget_size_request (GTK_BIN (button)->child, &child_requisition);
 
+      gtk_widget_style_get (widget,
+			    "padding",
+			    &padding,
+			    "minimum_width",
+			    &minimum_width,
+			    NULL);
+		
+      if ( padding )
+	{
+	  requisition->width += padding->left + padding->right;
+	  requisition->height += padding->top + padding->bottom;
+
+          g_free (padding);
+	}
+
       requisition->width += child_requisition.width;
       requisition->height += child_requisition.height;
+
+      if (requisition->width < minimum_width)
+        requisition->width = minimum_width;
     }
   
   requisition->width += 2 * (focus_width + focus_pad);
   requisition->height += 2 * (focus_width + focus_pad);
+
+  requisition->height += separator_height;
 }
 
 static void
@@ -989,14 +1185,15 @@
   GtkBorder default_border;
   gint focus_width;
   gint focus_pad;
+  gint child_spacing;
 
   gtk_button_get_props (button, &default_border, NULL, NULL);
   gtk_widget_style_get (GTK_WIDGET (widget),
 			"focus-line-width", &focus_width,
 			"focus-padding", &focus_pad,
+			"child-spacing", &child_spacing,
 			NULL);
- 
-			    
+
   widget->allocation = *allocation;
 
   if (GTK_WIDGET_REALIZED (widget))
@@ -1008,14 +1205,27 @@
 
   if (GTK_BIN (button)->child && GTK_WIDGET_VISIBLE (GTK_BIN (button)->child))
     {
-      child_allocation.x = widget->allocation.x + border_width + CHILD_SPACING + xthickness;
-      child_allocation.y = widget->allocation.y + border_width + CHILD_SPACING + ythickness;
+      child_allocation.x = widget->allocation.x + border_width + child_spacing + xthickness;
+      child_allocation.y = widget->allocation.y + border_width + child_spacing + ythickness;
       
-      child_allocation.width = MAX (1, widget->allocation.width - (CHILD_SPACING + xthickness) * 2 -
+      child_allocation.width = MAX (1, widget->allocation.width - (child_spacing + xthickness) * 2 -
 				    border_width * 2);
-      child_allocation.height = MAX (1, widget->allocation.height - (CHILD_SPACING + ythickness) * 2 -
+      child_allocation.height = MAX (1, widget->allocation.height - (child_spacing + ythickness) * 2 -
 				     border_width * 2);
 
+#ifdef OSSO_FONT_HACK
+      {
+	gint child_offset_y;
+	
+	gtk_widget_style_get (widget, "child_offset_y", &child_offset_y, NULL);
+	
+	if( GTK_IS_LABEL(GTK_BIN (button)->child) )
+	  {
+	    child_allocation.y += child_offset_y;
+	  }
+      }
+#endif
+      
       if (GTK_WIDGET_CAN_DEFAULT (button))
 	{
 	  child_allocation.x += default_border.left;
@@ -1066,7 +1276,14 @@
   gboolean interior_focus;
   gint focus_width;
   gint focus_pad;
-   
+  gint separator_height;
+  gboolean listboxheader;
+  GtkButtonPrivate *priv;
+
+  g_return_if_fail (GTK_IS_BUTTON (button));
+  
+  priv = GTK_BUTTON_GET_PRIVATE (button);
+  
   if (GTK_WIDGET_DRAWABLE (button))
     {
       widget = GTK_WIDGET (button);
@@ -1076,6 +1293,8 @@
       gtk_widget_style_get (GTK_WIDGET (widget),
 			    "focus-line-width", &focus_width,
 			    "focus-padding", &focus_pad,
+                            "listboxheader", &listboxheader,
+                            "separator-height", &separator_height,
 			    NULL); 
 	
       x = widget->allocation.x + border_width;
@@ -1083,13 +1302,55 @@
       width = widget->allocation.width - border_width * 2;
       height = widget->allocation.height - border_width * 2;
 
+      if (listboxheader)
+        {
+          /* this changes everything! */
+          PangoLayout *layout;
+          int layout_height;
+
+          /* construct layout - see get_layout in gtkcellrenderertext.c */
+          layout = gtk_widget_create_pango_layout (widget, /* use parent treeview instead? */
+                                                   button->label_text);
+          pango_layout_set_width (layout, -1);
+          pango_layout_get_pixel_size (layout, NULL, &layout_height);
+
+          /* render text */
+          gtk_paint_layout (widget->style,
+                            widget->window,
+                            GTK_STATE_NORMAL,
+                            TRUE,
+                            area,
+                            widget,
+                            "listboxheader",
+                            x,
+                            y,
+                            layout);
+
+          g_object_unref (layout);
+
+          /* draw separator */
+          gtk_paint_hline (widget->style,
+                           widget->window,
+                           GTK_STATE_NORMAL,
+                           area,
+                           widget,
+                           "listboxseparator",
+                           area->x - focus_width - focus_pad,
+                           area->x + area->width + focus_width + focus_pad,
+                           layout_height + separator_height * 2);
+          return;
+        }
+
       if (GTK_WIDGET_HAS_DEFAULT (widget) &&
 	  GTK_BUTTON (widget)->relief == GTK_RELIEF_NORMAL)
 	{
-	  gtk_paint_box (widget->style, widget->window,
+          /* This comment is here because it's part of the
+           * normal GtkButton
+           */
+	  /*  gtk_paint_box (widget->style, widget->window,
 			 GTK_STATE_NORMAL, GTK_SHADOW_IN,
 			 area, widget, "buttondefault",
-			 x, y, width, height);
+			 x, y, width, height); */
 
 	  x += default_border.left;
 	  y += default_border.top;
@@ -1116,7 +1377,7 @@
 	  GTK_WIDGET_STATE(widget) == GTK_STATE_PRELIGHT)
 	gtk_paint_box (widget->style, widget->window,
 		       state_type,
-		       shadow_type, area, widget, "button",
+		       shadow_type, area, widget, priv->detail,
 		       x, y, width, height);
        
       if (GTK_WIDGET_HAS_FOCUS (widget))
@@ -1151,10 +1412,14 @@
 	      x += child_displacement_x;
 	      y += child_displacement_y;
 	    }
-
+          /* Comment exists, because it is part of normal GtkButton
 	  gtk_paint_focus (widget->style, widget->window, GTK_WIDGET_STATE (widget),
 			   area, widget, "button",
 			   x, y, width, height);
+          */
+	  gtk_paint_focus (widget->style, widget->window, GTK_WIDGET_STATE (widget),
+			   area, widget, priv->detail,
+			   x, y, width, height);
 	}
     }
 }
@@ -1786,5 +2051,13 @@
   
   return priv->image;
 }
-  
-  
+void osso_gtk_button_set_detail_from_attach_flags (GtkButton *button,OssoGtkButtonAttachFlags flags)
+{
+  g_return_if_fail (GTK_IS_BUTTON (button));
+  g_object_set (G_OBJECT (button),
+                "automatic_detail",
+		FALSE,
+		"detail",
+		osso_gtk_button_attach_details[flags],
+		NULL);
+} 
--- gtk+/gtk/gtkbutton.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkbutton.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -134,6 +134,20 @@
 					    const gchar   *main_detail,
 					    const gchar   *default_detail);
 
+/* Osso addition : Button attach flags */
+typedef enum {
+  OSSO_GTK_BUTTON_ATTACH_NORTH =    1 << 0,
+  OSSO_GTK_BUTTON_ATTACH_EAST =     1 << 1,
+  OSSO_GTK_BUTTON_ATTACH_SOUTH =    1 << 2,
+  OSSO_GTK_BUTTON_ATTACH_WEST =     1 << 3,
+  OSSO_GTK_BUTTON_ATTACH_ENUM_END = 1 << 4
+} OssoGtkButtonAttachFlags;
+
+extern const gchar *osso_gtk_button_attach_details [OSSO_GTK_BUTTON_ATTACH_ENUM_END];
+
+void osso_gtk_button_set_detail_from_attach_flags (GtkButton *button,
+						   OssoGtkButtonAttachFlags flags);
+
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
--- gtk+/gtk/gtksettings.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtksettings.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -1,4 +1,4 @@
-/* GTK - The GIMP Toolkit
+/*
  * Copyright (C) 2000 Red Hat, Inc.
  *
  * This library is free software; you can redistribute it and/or
@@ -24,6 +24,9 @@
 #include "gtkintl.h"
 #include "gtkwidget.h"
 
+#define DEFAULT_INITIAL_TIMEOUT 300
+#define DEFAULT_UPDATE_TIMEOUT 125
+
 typedef struct _GtkSettingsValuePrivate GtkSettingsValuePrivate;
 
 typedef enum
@@ -72,6 +75,9 @@
   PROP_XFT_RGBA,
   PROP_XFT_DPI,
 #endif
+  PROP_INITIAL_TIMEOUT,
+  PROP_UPDATE_TIMEOUT,
+  PROP_HILDON_KEYBOARD_NAVIGATION,	  
   PROP_ALTERNATIVE_BUTTON_ORDER
 };
 
@@ -426,6 +432,37 @@
 					     NULL);
   
   g_assert (result == PROP_XFT_DPI);
+
+  result = settings_install_property_parser (class,
+					     g_param_spec_int ("gtk-initial-timeout",
+ 							       P_("Start timeout"),
+ 							       P_("Starting value for timeouts, when button is pressed"),
+ 							       0, G_MAXINT, DEFAULT_INITIAL_TIMEOUT,
+ 							       G_PARAM_READWRITE),
+					     NULL);
+
+  g_assert (result == PROP_INITIAL_TIMEOUT);
+
+  result = settings_install_property_parser (class,
+					     g_param_spec_int ("gtk-update-timeout",
+ 							       P_("Repeat timeout"),
+ 							       P_("Repeat value for timeouts, when button is pressed"),
+ 							       0, G_MAXINT, DEFAULT_UPDATE_TIMEOUT,
+ 							       G_PARAM_READWRITE),
+					     NULL);
+
+  g_assert (result == PROP_UPDATE_TIMEOUT);
+
+  result = settings_install_property_parser (class,
+                                             g_param_spec_boolean ("hildon-keyboard-navigation",
+								   P_("Keyboard navigation"),
+								   P_("This property can be used to enable keyboard navigation"),
+								   FALSE,
+								   G_PARAM_READWRITE),
+					     NULL);
+
+   g_assert (result == PROP_HILDON_KEYBOARD_NAVIGATION);
+  
 #endif  /* GDK_WINDOWING_X11 */
   result = settings_install_property_parser (class,
                                              g_param_spec_boolean ("gtk-alternative-button-order",
--- gtk+/gtk/xdgmime/xdgmime.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/xdgmime/xdgmime.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -63,7 +63,7 @@
 #define xdg_mime_dump                         XDG_ENTRY(dump)
 #endif
 
-extern const char *xdg_mime_type_unknown;
+extern const char xdg_mime_type_unknown[];
 #define XDG_MIME_TYPE_UNKNOWN xdg_mime_type_unknown
 
 const char  *xdg_mime_get_mime_type_for_data       (const void *data,
--- gtk+/gtk/xdgmime/xdgmime.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/xdgmime/xdgmime.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -55,7 +55,7 @@
 static XdgParentList *parent_list = NULL;
 static XdgDirTimeList *dir_time_list = NULL;
 static XdgCallbackList *callback_list = NULL;
-const char *xdg_mime_type_unknown = "application/octet-stream";
+const char xdg_mime_type_unknown[] = "application/octet-stream";
 
 
 enum
--- gtk+/gtk/gtkcontainer.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkcontainer.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -37,9 +37,14 @@
 #include "gtkwindow.h"
 #include "gtkintl.h"
 #include "gtktoolbar.h"
+#include "gtkmenu.h"
+#include "gtkentry.h"
+#include "gtktextview.h"
+#include "gtkwidget.h"
 #include <gobject/gobjectnotifyqueue.c>
 #include <gobject/gvaluecollector.h>
 
+#include "gtkdialog.h"
 
 enum {
   ADD,
@@ -56,6 +61,19 @@
   PROP_CHILD
 };
 
+enum {
+  FOCUS_MOVE_OK,
+  FOCUS_MOVE_OK_NO_MOVE,
+  FOCUS_MOVE_FAIL_NO_TEXT
+};
+
+typedef struct
+{
+  GtkWidget *menu;
+  void *func;
+  GtkWidgetTapAndHoldFlags flags;
+} GtkContainerTAH;
+
 #define PARAM_SPEC_PARAM_ID(pspec)              ((pspec)->param_id)
 #define PARAM_SPEC_SET_PARAM_ID(pspec, id)      ((pspec)->param_id = (id))
 
@@ -87,6 +105,9 @@
 static gboolean gtk_container_focus_move           (GtkContainer      *container,
 						    GList             *children,
 						    GtkDirectionType   direction);
+static gint gtk_container_focus_move_with_tab  (GtkContainer        *container,
+                                                GtkDirectionType    direction,
+                                                GtkWidget           **fallback);
 static void     gtk_container_children_callback    (GtkWidget         *widget,
 						    gpointer           client_data);
 static void     gtk_container_show_all             (GtkWidget         *widget);
@@ -95,10 +116,16 @@
 						    GdkEventExpose    *event);
 static void     gtk_container_map                  (GtkWidget         *widget);
 static void     gtk_container_unmap                (GtkWidget         *widget);
-
+static void gtk_container_tap_and_hold_setup (GtkWidget *widget,
+               GtkWidget *menu, GtkCallback func, GtkWidgetTapAndHoldFlags flags);
 static gchar* gtk_container_child_default_composite_name (GtkContainer *container,
 							  GtkWidget    *child);
+static void gtk_container_tap_and_hold_setup_forall( GtkWidget *widget,
+                                                     GtkContainerTAH *tah );
+
+static void gtk_container_grab_focus( GtkWidget *focus_widget );
 
+static GtkWidget *gtk_container_is_dialog(GtkWidget *widget);
 
 /* --- variables --- */
 static const gchar           vadjustment_key[] = "gtk-vadjustment";
@@ -190,7 +217,9 @@
   widget_class->map = gtk_container_map;
   widget_class->unmap = gtk_container_unmap;
   widget_class->focus = gtk_container_focus;
-  
+  widget_class->tap_and_hold_setup = gtk_container_tap_and_hold_setup;
+  widget_class->grab_focus = gtk_container_grab_focus;
+
   class->add = gtk_container_add_unimplemented;
   class->remove = gtk_container_remove_unimplemented;
   class->check_resize = gtk_container_real_check_resize;
@@ -1983,6 +2012,9 @@
 			   GtkDirectionType  direction,
 			   GtkWidget        *old_focus)
 {
+  GtkWidget *dialog = NULL;
+  dialog = gtk_container_is_dialog (GTK_WIDGET (container));
+  
   children = g_list_copy (children);
   
   switch (direction)
@@ -1992,7 +2024,26 @@
       return gtk_container_focus_sort_tab (container, children, direction, old_focus);
     case GTK_DIR_UP:
     case GTK_DIR_DOWN:
-      return gtk_container_focus_sort_up_down (container, children, direction, old_focus);
+      /*
+       * If we're in a dialog -> sort the chuildren in the tab order.
+       */
+      if (dialog)
+      {
+        if (direction == GTK_DIR_UP)
+        {
+          direction = GTK_DIR_TAB_BACKWARD;
+          return gtk_container_focus_sort_tab (container, children, 
+                                               GTK_DIR_TAB_BACKWARD, old_focus);
+        }
+        else if (direction == GTK_DIR_DOWN)
+        {
+          direction = GTK_DIR_TAB_FORWARD;
+          return gtk_container_focus_sort_tab (container, children, 
+                                               GTK_DIR_TAB_FORWARD, old_focus);
+        }
+      }
+      else
+        return gtk_container_focus_sort_up_down (container, children, direction, old_focus);
     case GTK_DIR_LEFT:
     case GTK_DIR_RIGHT:
       return gtk_container_focus_sort_left_right (container, children, direction, old_focus);
@@ -2011,24 +2062,76 @@
   GtkWidget *focus_child;
   GtkWidget *child;
 
-  focus_child = container->focus_child;
+  gboolean looped = FALSE;
+  gboolean is_toplevel = FALSE;
+  GtkWidget *dialog = NULL;
+
+  /*
+   * If there's an item focus already and tab was pressed, only go thru
+   * GtkEntries and GtkTextviews. Do _not_ jump from last widget to the first
+   * one and vice verca.
+   */
+  if ((direction == GTK_DIR_TAB_FORWARD || direction == GTK_DIR_TAB_BACKWARD) &&
+      container->focus_child != NULL)
+    {
+      GtkWidget *fallback;
+      fallback = NULL;
+      if (gtk_container_focus_move_with_tab (container, direction, &fallback)
+              != FOCUS_MOVE_FAIL_NO_TEXT)
+        return TRUE;
+
+      if (fallback && gtk_widget_child_focus (fallback, direction))
+        return TRUE;
+    }
 
+  focus_child = container->focus_child;
+  
+  /* Check if we are in a dialog */
+  dialog = gtk_container_is_dialog (GTK_WIDGET (container));
+  if (dialog)
+  {
+      /* 
+       * Check if we're handling the focus event for the topmost 
+       * container in the dialog window. is_toplevel indicates that we
+       * are in the topmost container, but also that we're in a dialog.
+       */
+      if (container == GTK_DIALOG(dialog)->vbox)
+          is_toplevel = TRUE;
+  }
+  
   while (children)
     {
       child = children->data;
-      children = children->next;
+      
+      /*
+       * If we have focusable candidates left, we have already looped
+       * them all through once or we are not in the topmost vbox of
+       * a dialog window -> proceed normally.
+       */
+      if (children->next != NULL || looped || !is_toplevel)
+      {
+          children = children->next;
+      }
+      /*
+       * In dialog however, we should loop through the widgets if 
+       * suitable widget is not found before the end of the widget list.
+       */
+      else
+      {
+          children = g_list_first (children);
+          looped = TRUE;
+      }
 
       if (!child)
-	continue;
+        continue;
       
       if (focus_child)
         {
           if (focus_child == child)
             {
               focus_child = NULL;
-
-		if (gtk_widget_child_focus (child, direction))
-		  return TRUE;
+             if (gtk_widget_child_focus (child, direction))
+                return TRUE;
             }
         }
       else if (GTK_WIDGET_DRAWABLE (child) &&
@@ -2042,6 +2145,105 @@
   return FALSE;
 }
 
+static gint
+gtk_container_focus_move_with_tab (GtkContainer     *container,
+                                   GtkDirectionType direction,
+                                   GtkWidget        **fallback)
+{
+  GList *children, *sorted_children;
+  GtkWidget *child;
+  GtkWidget *focus_child;
+  gboolean found_text;
+  gint ret;
+
+  found_text = FALSE;
+  focus_child = container->focus_child;
+
+  /* This part is copied from gtk_container_focus() */
+  if (container->has_focus_chain)
+    children = g_list_copy (get_focus_chain (container));
+  else
+    children = gtk_container_get_all_children (container);
+
+  if (container->has_focus_chain &&
+      (direction == GTK_DIR_TAB_FORWARD ||
+       direction == GTK_DIR_TAB_BACKWARD))
+    {
+      sorted_children = g_list_copy (children);
+
+      if (direction == GTK_DIR_TAB_BACKWARD)
+        sorted_children = g_list_reverse (sorted_children);
+    }
+  else
+    sorted_children = _gtk_container_focus_sort (container, children,
+                                                 direction, NULL);
+  g_list_free(children);
+  children = sorted_children;
+
+  while (children)
+    {
+      child = children->data;
+      children = children->next;
+
+      if (!child)
+        continue;
+
+      if (GTK_IS_ENTRY (child) || GTK_IS_TEXT_VIEW (child))
+        found_text = TRUE;
+
+      if (focus_child)
+        {
+          if (child == focus_child)
+            {
+              focus_child = NULL;
+              if (GTK_IS_CONTAINER (child))
+                {
+                  ret = gtk_container_focus_move_with_tab (GTK_CONTAINER (child),
+                                                           direction,
+                                                           fallback);
+                  if (ret == FOCUS_MOVE_OK)
+                    {
+                      g_list_free (sorted_children);
+                      return FOCUS_MOVE_OK;
+                    }
+                  else if (ret == FOCUS_MOVE_OK_NO_MOVE)
+                    found_text = TRUE;
+                }
+            }
+        }
+      else if (GTK_WIDGET_DRAWABLE (child) &&
+               gtk_widget_is_ancestor (child, GTK_WIDGET (container)))
+        {
+          if (GTK_IS_ENTRY (child) || GTK_IS_TEXT_VIEW (child))
+            {
+              if (gtk_widget_child_focus (child, direction))
+                {
+                  g_list_free (sorted_children);
+                  return FOCUS_MOVE_OK;
+                }
+            }
+          else if (GTK_IS_CONTAINER (child))
+            {
+              ret = gtk_container_focus_move_with_tab (GTK_CONTAINER (child),
+                                                       direction,
+                                                       fallback);
+              if (ret == FOCUS_MOVE_OK)
+                {
+                  g_list_free (sorted_children);
+                  return FOCUS_MOVE_OK;
+                }
+              else if (ret == FOCUS_MOVE_OK_NO_MOVE)
+                found_text = TRUE;
+            }
+          if (GTK_WIDGET_CAN_FOCUS (child) && *fallback == NULL)
+            *fallback = child;
+        }
+    }
+
+  g_list_free (sorted_children);
+
+  return found_text ? FOCUS_MOVE_OK_NO_MOVE : FOCUS_MOVE_FAIL_NO_TEXT;
+}
 
 static void
 gtk_container_children_callback (GtkWidget *widget,
@@ -2463,3 +2665,74 @@
       gdk_event_free (child_event);
     }
 }
+
+static void gtk_container_tap_and_hold_setup_forall( GtkWidget *widget,
+                                                     GtkContainerTAH *tah )
+{
+  gtk_widget_tap_and_hold_setup( widget, tah->menu, tah->func,
+                                 tah->flags );
+}
+
+static void gtk_container_tap_and_hold_setup( GtkWidget *widget,
+            GtkWidget *menu, GtkCallback func, GtkWidgetTapAndHoldFlags flags )
+{
+  GtkContainerTAH tah;
+  g_return_if_fail( GTK_IS_WIDGET(widget));
+  g_return_if_fail( menu == NULL || GTK_IS_MENU(menu) );
+  tah.menu = menu;
+  tah.func = func;
+  tah.flags = flags;
+  if (flags & GTK_TAP_AND_HOLD_NO_INTERNALS)
+    gtk_container_foreach( GTK_CONTAINER(widget),
+                (GtkCallback)gtk_container_tap_and_hold_setup_forall, &tah );
+  else
+    gtk_container_forall( GTK_CONTAINER(widget),
+                (GtkCallback)gtk_container_tap_and_hold_setup_forall, &tah );
+  parent_class->tap_and_hold_setup (widget, menu, func, flags);
+}
+
+static void gtk_container_grab_focus( GtkWidget *focus_widget )
+{
+  if( GTK_WIDGET_CAN_FOCUS(focus_widget) )
+    parent_class->grab_focus( focus_widget );
+  else
+  {
+    GList *first = NULL;
+    GList *children = NULL;
+    GtkWidget *old_focus = NULL;
+    GtkWidget *toplevel = NULL;
+
+    toplevel = gtk_widget_get_toplevel( focus_widget );
+    if( !GTK_IS_WINDOW(toplevel) )
+      return;
+
+    old_focus = GTK_WINDOW(toplevel)->focus_widget;
+    first = gtk_container_get_all_children(
+                               GTK_CONTAINER(focus_widget) );
+    children = g_list_last( first );
+    
+    while( children && GTK_WINDOW(toplevel)->focus_widget == old_focus )
+    {
+      gtk_widget_grab_focus( GTK_WIDGET(children->data) );
+      children = children->prev;
+    }
+    g_list_free( first );
+  }
+}
+
+/*
+ * Because the focus behaviour is specified differently for the 
+ * dialog widget, we should be able to ask whether we are in a dialog or 
+ * not. 
+ *
+ * This function return NULL if we're not inside a dialog,
+ * otherwise it'll return the dialog widget itself.
+ */
+static GtkWidget *gtk_container_is_dialog(GtkWidget *widget)
+{
+  GtkWidget *dialog = NULL;  
+  dialog = gtk_widget_get_ancestor (widget, GTK_TYPE_DIALOG);
+
+  return dialog;
+}
+
--- gtk+/gtk/gtknotebook.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtknotebook.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -40,10 +40,10 @@
 
 #define TAB_OVERLAP    2
 #define TAB_CURVATURE  1
-#define ARROW_SIZE     12
+#define ARROW_WIDTH    20
+#define ARROW_HEIGHT   27
 #define ARROW_SPACING  0
-#define NOTEBOOK_INIT_SCROLL_DELAY (200)
-#define NOTEBOOK_SCROLL_DELAY      (100)
+#define LABEL_PADDING  0
 
 
 enum {
@@ -57,7 +57,9 @@
 
 enum {
   STEP_PREV,
-  STEP_NEXT
+  STEP_NEXT,
+  STEP_PREV_CYCLE,
+  STEP_NEXT_CYCLE
 };
 
 typedef enum
@@ -216,7 +218,7 @@
 					      GList            *list,
 					      gboolean		destroying);
 static void gtk_notebook_update_labels       (GtkNotebook      *notebook);
-static gint gtk_notebook_timer               (GtkNotebook      *notebook);
+static gint gtk_notebook_timer               (GtkNotebook      *notebook        );
 static gint gtk_notebook_page_compare        (gconstpointer     a,
 					      gconstpointer     b);
 static GList* gtk_notebook_find_child        (GtkNotebook      *notebook,
@@ -458,7 +460,7 @@
 				   g_param_spec_boolean ("scrollable",
  							 P_("Scrollable"),
  							 P_("If TRUE, scroll arrows are added if there are too many tabs to fit"),
- 							 FALSE,
+ 							 TRUE,
  							 G_PARAM_READWRITE));
   g_object_class_install_property (gobject_class,
 				   PROP_ENABLE_POPUP,
@@ -584,6 +586,75 @@
 								 
                                                                    G_PARAM_READABLE));
 
+  /* Hildon: for adding paddings to the inner borders of the visible page */
+  gtk_widget_class_install_style_property (widget_class,
+                                           g_param_spec_int ("inner_left_border",
+                                                             _("Inner left border of the visible page"),
+                                                             _("Width of inner left border of the visible page"),
+                                                             0,
+                                                             G_MAXINT,
+                                                             0,
+                                                             G_PARAM_READABLE));
+  gtk_widget_class_install_style_property (widget_class,
+                                           g_param_spec_int ("inner_right_border",
+                                                             _("Inner right border of the visible page"),
+                                                             _("Width of inner right border of the visible page"),
+                                                             0,
+                                                             G_MAXINT,
+                                                             0,
+                                                             G_PARAM_READABLE));
+
+  /* Hildon: previously hardcoded constants ARROW_WIDTH, ARROW_HEIGHT,
+     ARROW_SPACING, TAB_OVERLAP and TAB_CURVATURE are now style properties */
+  gtk_widget_class_install_style_property (widget_class,
+                                           g_param_spec_int ("arrow-width",
+                                                             _("Arrow width"),
+                                                             _("Scroll arrow width"),
+                                                             0,
+                                                             G_MAXINT,
+                                                             ARROW_WIDTH,
+                                                             G_PARAM_READABLE));
+  gtk_widget_class_install_style_property (widget_class,
+                                           g_param_spec_int ("arrow-height",
+                                                             _("Arrow height"),
+                                                             _("Scroll arrow height"),
+                                                             0,
+                                                             G_MAXINT,
+                                                             ARROW_HEIGHT,
+                                                             G_PARAM_READABLE));
+  gtk_widget_class_install_style_property (widget_class,
+                                           g_param_spec_int ("arrow-spacing",
+                                                             _("Arrow spacing"),
+                                                             _("Scroll arrow spacing"),
+                                                             0,
+                                                             G_MAXINT,
+                                                             ARROW_SPACING,
+                                                             G_PARAM_READABLE));
+  gtk_widget_class_install_style_property (widget_class,
+                                           g_param_spec_int ("tab-overlap",
+                                                             _("Tab overlap"),
+                                                             _("Tab overlap"),
+                                                             0,
+                                                             G_MAXINT,
+                                                             TAB_OVERLAP,
+                                                             G_PARAM_READABLE));
+  gtk_widget_class_install_style_property (widget_class,
+                                           g_param_spec_int ("tab-curvature",
+                                                             _("Tab curvature"),
+                                                             _("Tab curvature"),
+                                                             0,
+                                                             G_MAXINT,
+                                                             TAB_CURVATURE,
+                                                             G_PARAM_READABLE));
+  gtk_widget_class_install_style_property (widget_class,
+                                           g_param_spec_int ("label-padding",
+                                                             _("Label padding"),
+                                                             _("Label padding"),
+                                                             0,
+                                                             G_MAXINT,
+                                                             LABEL_PADDING,
+                                                             G_PARAM_READABLE));
+
   notebook_signals[SWITCH_PAGE] =
     g_signal_new ("switch_page",
 		  G_TYPE_FROM_CLASS (gobject_class),
@@ -705,12 +776,11 @@
   notebook->show_tabs = TRUE;
   notebook->show_border = TRUE;
   notebook->tab_pos = GTK_POS_TOP;
-  notebook->scrollable = FALSE;
+  notebook->scrollable = TRUE;
   notebook->in_child = 0;
   notebook->click_child = 0;
   notebook->button = 0;
-  notebook->need_timer = 0;
-  notebook->child_has_focus = FALSE;
+  notebook->child_has_focus = TRUE;
   notebook->have_visible_child = FALSE;
   notebook->focus_out = FALSE;
 
@@ -1189,9 +1259,18 @@
   GtkRequisition child_requisition;
   gboolean switch_page = FALSE;
   gint vis_pages;
-  gint focus_width;
+  gint focus_width, label_padding;
+  gint arrow_width, arrow_height, arrow_spacing, tab_overlap, tab_curvature;
 
-  gtk_widget_style_get (widget, "focus-line-width", &focus_width, NULL);
+  gtk_widget_style_get (widget,
+                        "focus-line-width", &focus_width,
+                        "arrow-width", &arrow_width,
+                        "arrow-height", &arrow_height,
+                        "arrow-spacing", &arrow_spacing,
+                        "tab-overlap", &tab_overlap,
+                        "tab-curvature", &tab_curvature,
+                        "label-padding", &label_padding,
+                        NULL);
   
   widget->requisition.width = 0;
   widget->requisition.height = 0;
@@ -1229,6 +1308,22 @@
     {
       widget->requisition.width += widget->style->xthickness * 2;
       widget->requisition.height += widget->style->ythickness * 2;
+   
+      /* Hildon workaround: inner border paddings */
+      if (notebook->children && notebook->show_border)
+        {
+          gint inner_left_border, inner_right_border;
+
+          gtk_widget_style_get (widget,
+                                "inner_left_border",
+                                &inner_left_border,
+                                "inner_right_border",
+                                &inner_right_border,
+                                NULL);
+
+          widget->requisition.width += inner_left_border + inner_right_border;
+        }
+
 
       if (notebook->show_tabs)
 	{
@@ -1249,6 +1344,7 @@
 
 		  gtk_widget_size_request (page->tab_label,
 					   &child_requisition);
+                  child_requisition.width += 2 * label_padding;
 
 		  page->requisition.width = 
 		    child_requisition.width +
@@ -1292,10 +1388,10 @@
 
 		  if (notebook->scrollable && vis_pages > 1 && 
 		      widget->requisition.width < tab_width)
-		    tab_height = MAX (tab_height, ARROW_SIZE);
+		    tab_height = MAX (tab_height, arrow_height);
 
-		  padding = 2 * (TAB_CURVATURE + focus_width +
-				 notebook->tab_hborder) - TAB_OVERLAP;
+		  padding = 2 * (tab_curvature + focus_width +
+				 notebook->tab_hborder) - tab_overlap;
 		  tab_max += padding;
 		  while (children)
 		    {
@@ -1316,15 +1412,15 @@
 
 		  if (notebook->scrollable && vis_pages > 1 &&
 		      widget->requisition.width < tab_width)
-		    tab_width = tab_max + 2 * (ARROW_SIZE + ARROW_SPACING);
+		    tab_width = tab_max + 2 * (arrow_width + arrow_spacing);
 
                   if (notebook->homogeneous && !notebook->scrollable)
                     widget->requisition.width = MAX (widget->requisition.width,
                                                      vis_pages * tab_max +
-                                                     TAB_OVERLAP);
+                                                     tab_overlap);
                   else
                     widget->requisition.width = MAX (widget->requisition.width,
-                                                     tab_width + TAB_OVERLAP);
+                                                     tab_width + tab_overlap);
 
 		  widget->requisition.height += tab_height;
 		  break;
@@ -1335,10 +1431,10 @@
 
 		  if (notebook->scrollable && vis_pages > 1 && 
 		      widget->requisition.height < tab_height)
-		    tab_width = MAX (tab_width, ARROW_SPACING + 2 * ARROW_SIZE);
+		    tab_width = MAX (tab_width, arrow_spacing + 2 * arrow_width);
 
-		  padding = 2 * (TAB_CURVATURE + focus_width +
-				 notebook->tab_vborder) - TAB_OVERLAP;
+		  padding = 2 * (tab_curvature + focus_width +
+				 notebook->tab_vborder) - tab_overlap;
 		  tab_max += padding;
 
 		  while (children)
@@ -1361,24 +1457,24 @@
 
 		  if (notebook->scrollable && vis_pages > 1 && 
 		      widget->requisition.height < tab_height)
-		    tab_height = tab_max + ARROW_SIZE + ARROW_SPACING;
+		    tab_height = tab_max + arrow_height + arrow_spacing;
 
 		  widget->requisition.width += tab_width;
 
                   if (notebook->homogeneous && !notebook->scrollable)
                     widget->requisition.height =
 		      MAX (widget->requisition.height,
-			   vis_pages * tab_max + TAB_OVERLAP);
+			   vis_pages * tab_max + tab_overlap);
                   else
                     widget->requisition.height =
 		      MAX (widget->requisition.height,
-			   tab_height + TAB_OVERLAP);
+			   tab_height + tab_overlap);
 
 		  if (!notebook->homogeneous || notebook->scrollable)
 		    vis_pages = 1;
 		  widget->requisition.height = MAX (widget->requisition.height,
 						    vis_pages * tab_max +
-						    TAB_OVERLAP);
+						    tab_overlap);
 		  break;
 		}
 	    }
@@ -1499,7 +1595,26 @@
 	    }
 	}
 
+      /* Hildon workaround: inner border paddings */
+      if (notebook->show_border)
+        {
+          gint inner_left_border, inner_right_border;
+
+          gtk_widget_style_get (widget,
+                                "inner_left_border",
+                                &inner_left_border,
+                                "inner_right_border",
+                                &inner_right_border,
+                                NULL);
+
+          child_allocation.x += inner_left_border;
+          child_allocation.width -= inner_left_border + inner_right_border;
+          if (child_allocation.width < 0)
+            child_allocation.width = 0;
+        }
+
       children = notebook->children;
+
       while (children)
 	{
 	  page = children->data;
@@ -1580,11 +1695,18 @@
   GdkRectangle event_window_pos;
   gboolean before = ARROW_IS_BEFORE (arrow);
   gboolean left = ARROW_IS_LEFT (arrow);
+  gint arrow_width, arrow_height, arrow_spacing;
+
+  gtk_widget_style_get (GTK_WIDGET(notebook),
+                        "arrow-width", &arrow_width,
+                        "arrow-height", &arrow_height,
+                        "arrow-spacing", &arrow_spacing,
+                        NULL);
 
   if (gtk_notebook_get_event_window_position (notebook, &event_window_pos))
     {
-      rectangle->width = ARROW_SIZE;
-      rectangle->height = ARROW_SIZE;
+      rectangle->width = arrow_width;
+      rectangle->height = arrow_height;
 
       switch (notebook->tab_pos)
 	{
@@ -1602,6 +1724,8 @@
 	    rectangle->y += event_window_pos.height - rectangle->height;
 	  break;
 	case GTK_POS_TOP:
+          arrow_spacing = - arrow_spacing;
+          /* Fall through */
 	case GTK_POS_BOTTOM:
 	  if (before)
 	    {
@@ -1617,7 +1741,11 @@
 	      else
 		rectangle->x = event_window_pos.x + event_window_pos.width - 2 * rectangle->width;
 	    }
-	  rectangle->y = event_window_pos.y + (event_window_pos.height - rectangle->height) / 2;
+	  rectangle->y = event_window_pos.y;
+          if (arrow_spacing > 0)
+            rectangle->y += arrow_spacing;
+          else
+            rectangle->y += (event_window_pos.height - rectangle->height) / 2;
 	  break;
 	}
     }
@@ -1678,6 +1806,8 @@
 				left ? STEP_PREV : STEP_NEXT,
 				TRUE))
     {
+      notebook->child_has_focus = TRUE;
+
       if (notebook->tab_pos == GTK_POS_LEFT ||
 	  notebook->tab_pos == GTK_POS_RIGHT)
 	dir = ARROW_IS_LEFT (arrow) ? GTK_DIR_UP : GTK_DIR_DOWN;
@@ -1685,6 +1815,10 @@
 	dir = ARROW_IS_LEFT (arrow) ? GTK_DIR_LEFT : GTK_DIR_RIGHT;
       gtk_widget_child_focus (widget, dir);
     }
+  else if ( notebook->focus_tab )
+  {
+      gtk_widget_child_focus (widget, GTK_DIR_DOWN);
+  }
 }
 
 static gboolean
@@ -1696,6 +1830,10 @@
   gboolean is_rtl = gtk_widget_get_direction (widget) == GTK_TEXT_DIR_RTL;
   gboolean left = (ARROW_IS_LEFT (arrow) && !is_rtl) || 
                   (!ARROW_IS_LEFT (arrow) && is_rtl);
+  GtkSettings *settings = gtk_widget_get_settings (widget);
+  guint timeout;
+
+  g_object_get (settings, "gtk-initial-timeout", &timeout, NULL);
 
   if (!GTK_WIDGET_HAS_FOCUS (widget))
     gtk_widget_grab_focus (widget);
@@ -1706,19 +1844,19 @@
   if (event->button == 1)
     {
       gtk_notebook_do_arrow (notebook, arrow);
-      
+
       if (!notebook->timer)
-	{
-	  notebook->timer = g_timeout_add (NOTEBOOK_INIT_SCROLL_DELAY, 
-					   (GSourceFunc) gtk_notebook_timer, 
-					   (gpointer) notebook);
-	  notebook->need_timer = TRUE;
-	}
+        {
+          notebook->timer = g_timeout_add (timeout,
+                                           (GSourceFunc) gtk_notebook_timer,
+                                           (gpointer) notebook);
+          notebook->need_timer = TRUE;
+        }
     }
   else if (event->button == 2)
-    gtk_notebook_page_select (notebook, TRUE);
+      gtk_notebook_page_select (notebook, TRUE);
   else if (event->button == 3)
-    gtk_notebook_switch_focus_tab (notebook,
+      gtk_notebook_switch_focus_tab (notebook,
 				   gtk_notebook_search_page (notebook,
 							     NULL,
 							     left ? STEP_NEXT : STEP_PREV,
@@ -1844,8 +1982,10 @@
 	  gboolean page_changed = page != notebook->cur_page;
 	  gboolean was_focus = gtk_widget_is_focus (widget);
 	  
-	  gtk_notebook_switch_focus_tab (notebook, children);
-	  gtk_widget_grab_focus (widget);
+	  notebook->child_has_focus = TRUE;
+
+          gtk_widget_grab_focus (widget);
+          gtk_notebook_switch_focus_tab (notebook, children);
 	  
 	  if (page_changed && !was_focus)
 	    gtk_widget_child_focus (page->child, GTK_DIR_TAB_FORWARD);
@@ -1862,7 +2002,7 @@
 static void 
 stop_scrolling (GtkNotebook *notebook)
 {
-  if (notebook->timer)
+   if (notebook->timer)
     {
       g_source_remove (notebook->timer);
       notebook->timer = 0;
@@ -2343,9 +2483,9 @@
 	   */
 	  return focus_child_in (notebook, GTK_DIR_TAB_FORWARD);
 	case GTK_DIR_LEFT:
-	  return focus_tabs_move (notebook, direction, STEP_PREV);
+	  return focus_tabs_move (notebook, direction, STEP_PREV_CYCLE);
 	case GTK_DIR_RIGHT:
-	  return focus_tabs_move (notebook, direction, STEP_NEXT);
+	  return focus_tabs_move (notebook, direction, STEP_NEXT_CYCLE);
 	}
     }
   else /* Focus was not on widget */
@@ -2481,7 +2621,6 @@
  * gtk_notebook_redraw_tabs
  * gtk_notebook_real_remove
  * gtk_notebook_update_labels
- * gtk_notebook_timer
  * gtk_notebook_page_compare
  * gtk_notebook_real_page_position
  * gtk_notebook_search_page
@@ -2574,22 +2713,27 @@
 gtk_notebook_timer (GtkNotebook *notebook)
 {
   gboolean retval = FALSE;
+  guint timeout;
+  GtkSettings *settings;
 
   GDK_THREADS_ENTER ();
 
+  settings = gtk_widget_get_settings (GTK_WIDGET (notebook));
+  g_object_get (settings, "gtk-update-timeout", &timeout, NULL);
+
   if (notebook->timer)
     {
       gtk_notebook_do_arrow (notebook, notebook->click_child);
 
-      if (notebook->need_timer) 
-	{
-	  notebook->need_timer = FALSE;
-	  notebook->timer = g_timeout_add (NOTEBOOK_SCROLL_DELAY,
-					   (GSourceFunc) gtk_notebook_timer, 
-					   (gpointer) notebook);
-	}
+      if (notebook->need_timer)
+        {
+          notebook->need_timer = FALSE;
+          notebook->timer = g_timeout_add (timeout,
+                                           (GSourceFunc) gtk_notebook_timer,
+                                           (gpointer) notebook);
+        }
       else
-	retval = TRUE;
+        retval = TRUE;
     }
 
   GDK_THREADS_LEAVE ();
@@ -2781,10 +2925,12 @@
   switch (direction)
     {
     case STEP_PREV:
+    case STEP_PREV_CYCLE:
       flag = GTK_PACK_END;
       break;
 
     case STEP_NEXT:
+    case STEP_NEXT_CYCLE:
       flag = GTK_PACK_START;
       break;
     }
@@ -2827,6 +2973,37 @@
       old_list = list;
       list = list->prev;
     }
+
+  /* Hildon hack: keyboard navigation should cycle around */
+  if (direction == STEP_PREV_CYCLE)
+    {
+      /* find and return the last (visible) page */
+      list = g_list_last (notebook->children);
+      if (!find_visible)
+        return list;
+      while (list)
+        {
+          page = list->data;
+          if (GTK_WIDGET_VISIBLE (page->child))
+            return list;
+          list = list->prev;
+        }
+    }
+  if (direction == STEP_NEXT_CYCLE)
+    {
+      /* find and return the first (visible) page */
+      list = g_list_first (notebook->children);
+      if (!find_visible)
+        return list;
+      while (list)
+        {
+          page = list->data;
+          if (GTK_WIDGET_VISIBLE (page->child))
+            return list;
+          list = list->next;
+        }
+    }
+
   return NULL;
 }
 
@@ -2850,6 +3027,7 @@
   gint gap_x = 0, gap_width = 0, step = STEP_PREV;
   gboolean is_rtl;
   gint tab_pos;
+  gboolean paint_box_gap = FALSE;
    
   g_return_if_fail (GTK_IS_NOTEBOOK (widget));
   g_return_if_fail (area != NULL);
@@ -2933,15 +3111,37 @@
 	  step = STEP_PREV;
 	  break;
 	}
-      gtk_paint_box_gap (widget->style, widget->window,
-			 GTK_STATE_NORMAL, GTK_SHADOW_OUT,
-			 area, widget, "notebook",
-			 x, y, width, height,
-			 tab_pos, gap_x, gap_width);
+
+      /* hildon hack to postpone painting until it
+         is known if scroll arrows will be drawn */
+      paint_box_gap = TRUE;
     }
 
+  /* first, figure out if arrows should be drawn */
   showarrow = FALSE;
   children = gtk_notebook_search_page (notebook, NULL, step, TRUE);
+  while (children && !showarrow)
+    {
+      page = children->data;
+      children = gtk_notebook_search_page (notebook, children,
+					   step, TRUE);
+      if (!GTK_WIDGET_MAPPED (page->tab_label))
+	showarrow = TRUE;
+    }
+
+  /* then draw content area frame */
+  if (paint_box_gap)
+    gtk_paint_box_gap (widget->style, widget->window,
+                       GTK_STATE_NORMAL, GTK_SHADOW_OUT,
+                       area, widget,
+                       (showarrow && notebook->scrollable)
+                       ? "notebook_show_arrow"
+                       : "notebook",
+                       x, y, width, height,
+                       tab_pos, gap_x, gap_width);
+  
+  /* and finally draw tabs */
+  children = gtk_notebook_search_page (notebook, NULL, step, TRUE);
   while (children)
     {
       page = children->data;
@@ -3069,10 +3269,15 @@
   GdkRectangle arrow_rect;
   GtkArrowType arrow;
   gboolean is_rtl, left;
+  gint arrow_width, arrow_height;
 
   gtk_notebook_get_arrow_rect (notebook, &arrow_rect, nbarrow);
 
   widget = GTK_WIDGET (notebook);
+  gtk_widget_style_get (widget,
+                        "arrow-width", &arrow_width,
+                        "arrow-height", &arrow_height,
+                        NULL);
 
   is_rtl = gtk_widget_get_direction (widget) == GTK_TEXT_DIR_RTL;
   left = (ARROW_IS_LEFT (nbarrow) && !is_rtl) ||
@@ -3112,7 +3317,7 @@
       gtk_paint_arrow (widget->style, widget->window, state_type, 
 		       shadow_type, NULL, widget, "notebook",
 		       arrow, TRUE, arrow_rect.x, arrow_rect.y, 
-		       ARROW_SIZE, ARROW_SIZE);
+		       arrow_width, arrow_height);
     }
 }
 
@@ -3143,13 +3348,25 @@
   gboolean is_rtl = (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_RTL &&
 		     (tab_pos == GTK_POS_TOP || tab_pos == GTK_POS_BOTTOM));
   gint memo_x;
+  gboolean truncate = FALSE;
+  gint arrow_width, arrow_height, arrow_spacing, tab_overlap;
+  gint total_width, ideal_tab_width, n_expanding_tabs;
 
   if (!notebook->show_tabs || !notebook->children || !notebook->cur_page)
     return;
 
+  gtk_widget_style_get (widget,
+                        "arrow-width", &arrow_width,
+                        "arrow-height", &arrow_height,
+                        "arrow-spacing", &arrow_spacing,
+                        "tab-overlap", &tab_overlap,
+                        NULL);
+
   child_allocation.x = widget->allocation.x + container->border_width;
   child_allocation.y = widget->allocation.y + container->border_width;
 
+  total_width = allocation->width - 2 * container->border_width - tab_overlap;
+
   switch (tab_pos)
     {
     case GTK_POS_BOTTOM:
@@ -3198,27 +3415,26 @@
 	      if (GTK_WIDGET_VISIBLE (page->child))
 		tab_space += page->requisition.width;
 	    }
-	  if (tab_space >
-	      allocation->width - 2 * container->border_width - TAB_OVERLAP) 
+	  if (tab_space > total_width)
 	    {
 	      showarrow = TRUE;
 	      page = focus_tab->data; 
 
-	      tab_space = allocation->width - TAB_OVERLAP -
+	      tab_space = allocation->width - tab_overlap -
 		page->requisition.width - 2 * container->border_width;
 	      if (notebook->has_after_previous)
-		tab_space -= ARROW_SPACING + ARROW_SIZE;
+		tab_space -= arrow_spacing + arrow_width;
 	      if (notebook->has_after_next)
-		tab_space -= ARROW_SPACING + ARROW_SIZE;
+		tab_space -= arrow_spacing + arrow_width;
 	      if (notebook->has_before_previous)
 		{
-		  tab_space -= ARROW_SPACING + ARROW_SIZE;
-		  child_allocation.x += ARROW_SPACING + ARROW_SIZE;
+		  tab_space -= arrow_spacing + arrow_width;
+		  child_allocation.x += arrow_spacing + arrow_width;
 		}
 	      if (notebook->has_before_next)
 		{
-		  tab_space -= ARROW_SPACING + ARROW_SIZE;
-		  child_allocation.x += ARROW_SPACING + ARROW_SIZE;
+		  tab_space -= arrow_spacing + arrow_width;
+		  child_allocation.x += arrow_spacing + arrow_width;
 		}
 	    }
 	  break;
@@ -3232,20 +3448,19 @@
 	      if (GTK_WIDGET_VISIBLE (page->child))
 		tab_space += page->requisition.height;
 	    }
-	  if (tab_space >
-	      (allocation->height - 2 * container->border_width - TAB_OVERLAP))
+	  if (tab_space > total_width)
 	    {
 	      showarrow = TRUE;
 	      page = focus_tab->data; 
 	      tab_space = allocation->height
-		- TAB_OVERLAP - 2 * container->border_width
+		- tab_overlap - 2 * container->border_width
 		- page->requisition.height;
 	      if (notebook->has_after_previous || notebook->has_after_next)
-		tab_space -= ARROW_SPACING + ARROW_SIZE;
+		tab_space -= arrow_spacing + arrow_height;
 	      if (notebook->has_before_previous || notebook->has_before_next)
 		{
-		  tab_space -= ARROW_SPACING + ARROW_SIZE;
-		  child_allocation.y += ARROW_SPACING + ARROW_SIZE;
+		  tab_space -= arrow_spacing + arrow_height;
+		  child_allocation.y += arrow_spacing + arrow_height;
 		}
 	    }
 	  break;
@@ -3257,6 +3472,10 @@
 	      notebook->first_tab = focus_tab;
 	      last_child = gtk_notebook_search_page (notebook, focus_tab,
 						     STEP_NEXT, TRUE);
+
+              /* Hildon: there is only one visible tab label
+                 and it doesn't fit unless it is truncated */
+              truncate = TRUE;
 	    }
 	  else
 	    {
@@ -3413,7 +3632,7 @@
 	    }
 	  tab_space -= allocation->height;
 	}
-      tab_space += 2 * container->border_width + TAB_OVERLAP;
+      tab_space += 2 * container->border_width + tab_overlap;
       tab_space *= -1;
       notebook->first_tab = gtk_notebook_search_page (notebook, NULL,
 						      STEP_NEXT, TRUE);
@@ -3432,12 +3651,29 @@
       if (showarrow) 
 	{
 	  if (notebook->has_after_previous)
-	    child_allocation.x -= ARROW_SPACING + ARROW_SIZE;
+	    child_allocation.x -= arrow_spacing + arrow_width;
 	  if (notebook->has_after_next)
-	    child_allocation.x -= ARROW_SPACING + ARROW_SIZE;
+	    child_allocation.x -= arrow_spacing + arrow_width;
 	}
      }
 
+  ideal_tab_width = n ? (total_width / n) : total_width;
+  n_expanding_tabs = 0;
+
+  while (children)
+    {
+      if (children == last_child)
+        break;
+
+      page = children->data;
+      children = gtk_notebook_search_page (notebook, children, STEP_NEXT,TRUE);
+
+      if (page->requisition.width <= ideal_tab_width)
+        n_expanding_tabs++;
+    }
+
+  children = notebook->first_tab;
+
   while (children)
     {
       if (children == last_child)
@@ -3452,9 +3688,11 @@
       children = gtk_notebook_search_page (notebook, children, STEP_NEXT,TRUE);
       
       delta = 0;
-      if (n && (showarrow || page->expand || notebook->homogeneous))
+
+      if (n && (showarrow || page->expand || notebook->homogeneous) &&
+          (page->requisition.width <= ideal_tab_width))
 	{
-	  new_fill = (tab_space * i++) / n;
+	  new_fill = (tab_space * i++) / n_expanding_tabs;
 	  delta = new_fill - old_fill;
 	  old_fill = new_fill;
 	}
@@ -3463,15 +3701,18 @@
 	{
 	case GTK_POS_TOP:
 	case GTK_POS_BOTTOM:
+          if (truncate)
+            delta *= -1;
+
 	  child_allocation.width = (page->requisition.width +
-				    TAB_OVERLAP + delta);
+				    tab_overlap + delta);
           if (is_rtl)
 	      child_allocation.x -= child_allocation.width;
 	  break;
 	case GTK_POS_LEFT:
 	case GTK_POS_RIGHT:
 	  child_allocation.height = (page->requisition.height +
-				     TAB_OVERLAP + delta);
+				     tab_overlap + delta);
 	  break;
 	}
 
@@ -3482,13 +3723,13 @@
 	case GTK_POS_TOP:
 	case GTK_POS_BOTTOM:
           if (!is_rtl)
-	     child_allocation.x += child_allocation.width - TAB_OVERLAP;
+	     child_allocation.x += child_allocation.width - tab_overlap;
           else
-             child_allocation.x += TAB_OVERLAP;
+             child_allocation.x += tab_overlap;
 	  break;
 	case GTK_POS_LEFT:
 	case GTK_POS_RIGHT:
-	  child_allocation.y += child_allocation.height - TAB_OVERLAP;
+	  child_allocation.y += child_allocation.height - tab_overlap;
 	  break;
 	}
 
@@ -3538,14 +3779,14 @@
 	    case GTK_POS_TOP:
 	    case GTK_POS_BOTTOM:
 	      child_allocation.width = (page->requisition.width +
-					TAB_OVERLAP + delta);
+					tab_overlap + delta);
               if (!is_rtl)
 	         child_allocation.x -= child_allocation.width;
 	      break;
 	    case GTK_POS_LEFT:
 	    case GTK_POS_RIGHT:
 	      child_allocation.height = (page->requisition.height +
-					 TAB_OVERLAP + delta);
+					 tab_overlap + delta);
 	      child_allocation.y -= child_allocation.height;
 	      break;
 	    }
@@ -3557,13 +3798,13 @@
 	    case GTK_POS_TOP:
 	    case GTK_POS_BOTTOM:
               if (!is_rtl)
-	         child_allocation.x += TAB_OVERLAP;
+	         child_allocation.x += tab_overlap;
               else
-                 child_allocation.x += child_allocation.width - TAB_OVERLAP;
+                 child_allocation.x += child_allocation.width - tab_overlap;
 	      break;
 	    case GTK_POS_LEFT:
 	    case GTK_POS_RIGHT:
-	      child_allocation.y += TAB_OVERLAP;
+	      child_allocation.y += tab_overlap;
 	      break;
 	    }
 
@@ -3589,8 +3830,12 @@
   gint padding;
   gint focus_width;
   gint tab_pos = get_effective_tab_pos (notebook);
+  gint tab_curvature;
 
-  gtk_widget_style_get (widget, "focus-line-width", &focus_width, NULL);
+  gtk_widget_style_get (widget,
+                        "focus-line-width", &focus_width,
+                        "tab-curvature", &tab_curvature,
+                        NULL);
   
   xthickness = widget->style->xthickness;
   ythickness = widget->style->ythickness;
@@ -3621,7 +3866,7 @@
     {
     case GTK_POS_TOP:
     case GTK_POS_BOTTOM:
-      padding = TAB_CURVATURE + focus_width + notebook->tab_hborder;
+      padding = tab_curvature + focus_width + notebook->tab_hborder;
       if (page->fill)
 	{
 	  child_allocation.x = (xthickness + focus_width +
@@ -3646,7 +3891,7 @@
       break;
     case GTK_POS_LEFT:
     case GTK_POS_RIGHT:
-      padding = TAB_CURVATURE + focus_width + notebook->tab_vborder;
+      padding = tab_curvature + focus_width + notebook->tab_vborder;
       if (page->fill)
 	{
 	  child_allocation.y = ythickness + padding;
@@ -3796,7 +4041,7 @@
   g_return_if_fail (page != NULL);
 
   if (notebook->cur_page == page || !GTK_WIDGET_VISIBLE (page->child))
-    return;
+      return;
 
   if (notebook->cur_page)
     gtk_widget_set_child_visible (notebook->cur_page->child, FALSE);
@@ -3818,10 +4063,10 @@
     {
       if (notebook->cur_page->last_focus_child &&
 	  gtk_widget_is_ancestor (notebook->cur_page->last_focus_child, notebook->cur_page->child))
-	gtk_widget_grab_focus (notebook->cur_page->last_focus_child);
+          gtk_widget_grab_focus (notebook->cur_page->last_focus_child);
       else
 	if (!gtk_widget_child_focus (notebook->cur_page->child, GTK_DIR_TAB_FORWARD))
-	  gtk_widget_grab_focus (GTK_WIDGET (notebook));
+          gtk_widget_grab_focus (notebook->cur_page->child);
     }
   
   gtk_notebook_update_tab_states (notebook);
@@ -4340,7 +4585,7 @@
     }
   page->tab_label = tab_label;
   page->menu_label = menu_label;
-  page->expand = FALSE;
+  page->expand = TRUE;
   page->fill = TRUE;
   page->pack = GTK_PACK_START; 
 
@@ -5046,6 +5291,7 @@
     {
       page->default_tab = FALSE;
       page->tab_label = tab_label;
+
       gtk_widget_set_parent (page->tab_label, GTK_WIDGET (notebook));
     }
   else
--- gtk+/gtk/gtkvseparator.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkvseparator.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -91,13 +91,34 @@
 gtk_vseparator_expose (GtkWidget      *widget,
 		       GdkEventExpose *event)
 {
-  if (GTK_WIDGET_DRAWABLE (widget))
-    gtk_paint_vline (widget->style, widget->window, GTK_WIDGET_STATE (widget),
-		     &event->area, widget, "vseparator",
-		     widget->allocation.y,
-		     widget->allocation.y + widget->allocation.height - 1,
-		     widget->allocation.x + (widget->allocation.width -
-					     widget->style->xthickness) / 2);
+	gboolean hildonlike_drawing = FALSE;
 
-  return FALSE;
+
+	gtk_widget_style_get ( widget, "hildonlike-drawing", &hildonlike_drawing, NULL );
+
+	if (GTK_WIDGET_DRAWABLE (widget))
+	{
+		if(hildonlike_drawing)
+			gtk_paint_box   (widget->style, widget->window, GTK_STATE_NORMAL,
+					GTK_SHADOW_NONE, &event->area, widget, "vseparator",
+					widget->allocation.x + (widget->allocation.width -
+						widget->style->xthickness) / 2,
+					widget->allocation.y,
+
+					widget->style->xthickness,
+					widget->allocation.height - 1);
+		else
+			gtk_paint_vline (widget->style, widget->window, GTK_STATE_NORMAL,
+					&event->area, widget, "vseparator",
+					widget->allocation.y,
+					widget->allocation.y + widget->allocation.height - 1,
+					widget->allocation.x + (widget->allocation.width -
+						widget->style->xthickness) / 2);
+	}
+
+
+
+
+
+	return FALSE;
 }
--- gtk+/gtk/gtkradiobutton.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkradiobutton.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -31,6 +31,7 @@
 #include "gtkradiobutton.h"
 #include "gtkintl.h"
 
+#define TOGGLE_ON_CLICK "toggle-on-click"
 
 enum {
   PROP_0,
@@ -506,6 +507,9 @@
 	{
 	  tmp_list = tmp_list->next;
 	  
+    if( !tmp_list )
+      return FALSE;
+    
 	  while (tmp_list)
 	    {
 	      GtkWidget *child = tmp_list->data;
@@ -543,7 +547,10 @@
       if (new_focus)
 	{
 	  gtk_widget_grab_focus (new_focus);
-	  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (new_focus), TRUE);
+
+	/* arrow keys select the button ? CHECK THIS!!
+     gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (new_focus), TRUE);
+   */
 	}
 
       return TRUE;
@@ -579,7 +586,7 @@
   GtkToggleButton *toggle_button;
   GtkRadioButton *radio_button;
   GtkToggleButton *tmp_button;
-  GtkStateType new_state;
+  GtkStateType new_state = GTK_WIDGET_STATE( button );
   GSList *tmp_list;
   gint toggled;
   gboolean depressed;
@@ -591,52 +598,54 @@
   g_object_ref (GTK_WIDGET (button));
 
   if (toggle_button->active)
-    {
-      tmp_button = NULL;
-      tmp_list = radio_button->group;
-
-      while (tmp_list)
-	{
-	  tmp_button = tmp_list->data;
-	  tmp_list = tmp_list->next;
+  	{
+	  tmp_button = NULL;
+	  tmp_list = radio_button->group;
 
-	  if (tmp_button->active && tmp_button != toggle_button)
-	    break;
+	  while (tmp_list)
+	    {
+	      tmp_button = tmp_list->data;
+	      tmp_list = tmp_list->next;
+	      
+	      if (tmp_button->active && tmp_button != toggle_button)
+		break;
 
-	  tmp_button = NULL;
-	}
+	      tmp_button = NULL;
+	    }
 
-      if (!tmp_button)
-	{
-	  new_state = (button->in_button ? GTK_STATE_PRELIGHT : GTK_STATE_ACTIVE);
+	  if (!tmp_button)
+	    {
+	      new_state = (button->in_button ? 
+			   GTK_STATE_PRELIGHT : GTK_STATE_ACTIVE);
+	    }
+	  else
+	    {
+	      toggled = TRUE;
+	      toggle_button->active = !toggle_button->active;
+	      new_state = (button->in_button ? GTK_STATE_PRELIGHT : GTK_STATE_NORMAL);
+	    }
 	}
       else
 	{
 	  toggled = TRUE;
 	  toggle_button->active = !toggle_button->active;
-	  new_state = (button->in_button ? GTK_STATE_PRELIGHT : GTK_STATE_NORMAL);
-	}
-    }
-  else
-    {
-      toggled = TRUE;
-      toggle_button->active = !toggle_button->active;
 
-      tmp_list = radio_button->group;
-      while (tmp_list)
-	{
-	  tmp_button = tmp_list->data;
-	  tmp_list = tmp_list->next;
-
-	  if (tmp_button->active && (tmp_button != toggle_button))
+	  tmp_list = radio_button->group;
+	  while (tmp_list)
 	    {
-	      gtk_button_clicked (GTK_BUTTON (tmp_button));
-	      break;
+	      tmp_button = tmp_list->data;
+	      tmp_list = tmp_list->next;
+	      
+	      if (tmp_button->active && (tmp_button != toggle_button))
+		{
+		  gtk_button_clicked (GTK_BUTTON (tmp_button));
+		  break;
+		}
 	    }
+
+  	  new_state = (button->in_button ? GTK_STATE_PRELIGHT : GTK_STATE_ACTIVE);
 	}
 
-      new_state = (button->in_button ? GTK_STATE_PRELIGHT : GTK_STATE_ACTIVE);
-    }
 
   if (toggle_button->inconsistent)
     depressed = FALSE;
@@ -663,7 +672,6 @@
 				 GdkRectangle   *area)
 {
   GtkWidget *widget;
-  GtkWidget *child;
   GtkButton *button;
   GtkToggleButton *toggle_button;
   GtkStateType state_type;
@@ -686,54 +694,80 @@
 			    "focus-padding", &focus_pad,
 			    NULL);
 
-      _gtk_check_button_get_props (check_button, &indicator_size, &indicator_spacing);
-
-      x = widget->allocation.x + indicator_spacing + GTK_CONTAINER (widget)->border_width;
-      y = widget->allocation.y + (widget->allocation.height - indicator_size) / 2;
-
-      child = GTK_BIN (check_button)->child;
-      if (!interior_focus || !(child && GTK_WIDGET_VISIBLE (child)))
-	x += focus_width + focus_pad;      
+      _gtk_check_button_get_props (check_button, 
+				   &indicator_size, &indicator_spacing);
 
+      x = widget->allocation.x + indicator_spacing + 
+	GTK_CONTAINER (widget)->border_width;
+      y = widget->allocation.y + (widget->allocation.height - 
+				  indicator_size + focus_width + 
+				  focus_pad) / 2;
+
+      /* Hildon - always add space for the padding
+      */
+      x += focus_width + focus_pad;
+      
       if (toggle_button->inconsistent)
-	shadow_type = GTK_SHADOW_ETCHED_IN;
+   shadow_type = GTK_SHADOW_ETCHED_IN;
+
       else if (toggle_button->active)
-	shadow_type = GTK_SHADOW_IN;
+   shadow_type = GTK_SHADOW_IN;
+
       else
-	shadow_type = GTK_SHADOW_OUT;
+   shadow_type = GTK_SHADOW_OUT;
+
+      if (button->activate_timeout || 
+         (button->button_down && button->in_button) )
+  state_type = GTK_STATE_ACTIVE;
 
-      if (button->activate_timeout || (button->button_down && button->in_button))
-	state_type = GTK_STATE_ACTIVE;
       else if (button->in_button)
-	state_type = GTK_STATE_PRELIGHT;
+   state_type = GTK_STATE_PRELIGHT;
+
       else if (!GTK_WIDGET_IS_SENSITIVE (widget))
 	state_type = GTK_STATE_INSENSITIVE;
+
       else
-	state_type = GTK_STATE_NORMAL;
+  state_type = GTK_STATE_NORMAL;
 
+      /* Hildon change. We want to draw active image always when we have
+       * focus. */
+      if (GTK_WIDGET_HAS_FOCUS (widget))
+	state_type = GTK_STATE_ACTIVE;
+       
       if (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_RTL)
-	x = widget->allocation.x + widget->allocation.width - (indicator_size + x - widget->allocation.x);
-
+	{
+	  x = widget->allocation.x + widget->allocation.width - 
+	    (indicator_size + x - widget->allocation.x);
+	}
+      /* Well, commenting this out fixes bug #280, 
+	 without apparent side effects.
+       *
       if (GTK_WIDGET_STATE (toggle_button) == GTK_STATE_PRELIGHT)
 	{
 	  GdkRectangle restrict_area;
 	  GdkRectangle new_area;
 	      
-	  restrict_area.x = widget->allocation.x + GTK_CONTAINER (widget)->border_width;
-	  restrict_area.y = widget->allocation.y + GTK_CONTAINER (widget)->border_width;
-	  restrict_area.width = widget->allocation.width - (2 * GTK_CONTAINER (widget)->border_width);
-	  restrict_area.height = widget->allocation.height - (2 * GTK_CONTAINER (widget)->border_width);
+	  restrict_area.x = widget->allocation.x + 
+	  GTK_CONTAINER (widget)->border_width;
+	  restrict_area.y = widget->allocation.y + 
+	  GTK_CONTAINER (widget)->border_width;
+	  restrict_area.width = widget->allocation.width - 
+	  (2 * GTK_CONTAINER (widget)->border_width);
+	  restrict_area.height = widget->allocation.height - 
+	  (2 * GTK_CONTAINER (widget)->border_width);
 	  
 	  if (gdk_rectangle_intersect (area, &restrict_area, &new_area))
 	    {
-	      gtk_paint_flat_box (widget->style, widget->window, GTK_STATE_PRELIGHT,
-				  GTK_SHADOW_ETCHED_OUT, 
-				  area, widget, "checkbutton",
-				  new_area.x, new_area.y,
-				  new_area.width, new_area.height);
+	      gtk_paint_flat_box (widget->style, widget->window, 
+	      GTK_STATE_PRELIGHT,
+	      GTK_SHADOW_ETCHED_OUT, 
+	      area, widget, "checkbutton",
+	      new_area.x, new_area.y,
+	      new_area.width, new_area.height);
 	    }
 	}
 
+      */
       gtk_paint_option (widget->style, widget->window,
 			state_type, shadow_type,
 			area, widget, "radiobutton",
--- gtk+/gtk/gtkenums.h	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkenums.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -133,7 +133,11 @@
   GTK_ICON_SIZE_LARGE_TOOLBAR,
   GTK_ICON_SIZE_BUTTON,
   GTK_ICON_SIZE_DND,
-  GTK_ICON_SIZE_DIALOG
+  GTK_ICON_SIZE_DIALOG,
+  HILDON_ICON_SIZE_26,
+  HILDON_ICON_SIZE_40,
+  HILDON_ICON_SIZE_50,
+  HILDON_ICON_SIZE_64
 } GtkIconSize;
 
 #ifndef GTK_DISABLE_DEPRECATED
@@ -453,6 +457,13 @@
   GTK_IM_STATUS_NONE
 } GtkIMStatusStyle;
 
+/* Input validation */
+typedef enum
+{
+  GTK_INVALID_INPUT_MAX_CHARS_REACHED,
+  GTK_INVALID_INPUT_MODE_RESTRICTION
+} GtkInvalidInputType;
+
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
--- gtk+/gtk/gtkcombobox.c	(.../2.6.4)	(revision 904)
+++ gtk+/gtk/gtkcombobox.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -17,6 +17,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* Modified by Nokia Corporation - 2005.
+ * 
+ */
+
 #include <config.h>
 #include "gtkalias.h"
 #include "gtkcombobox.h"
@@ -39,6 +43,8 @@
 #include "gtktreeselection.h"
 #include "gtkvseparator.h"
 #include "gtkwindow.h"
+#include "gtkcomboboxentry.h"
+#include "gtktoolbar.h"
 
 #include <gdk/gdkkeysyms.h>
 
@@ -52,6 +58,20 @@
 
 #include "gtktreeprivate.h"
 
+#define HILDON_MAX_WIDTH 406
+#define HILDON_MAX_HEIGHT 305
+#define HILDON_MAX_ITEMS 8
+
+/* maximum sizes for menus when attached to comboboxes */
+#define HILDON_MENU_COMBO_MAX_WIDTH 406
+#define HILDON_MENU_COMBO_MIN_WIDTH 66
+#define HILDON_MENU_COMBO_MAX_HEIGHT 305
+#define HILDON_MENU_COMBO_MIN_HEIGHT 70
+
+/* this is also defined in gtkmenu.c and should be replaced with
+  a style property */
+#define MENU_SCROLL_ARROW_HEIGHT 20 
+
 /* WELCOME, to THE house of evil code */
 
 typedef struct _ComboCellInfo ComboCellInfo;
@@ -115,10 +135,14 @@
   guint editing_canceled : 1;
   guint auto_scroll : 1;
   guint focus_on_click : 1;
+  guint propagate_lr_keys : 1;
 
   GtkTreeViewRowSeparatorFunc row_separator_func;
   gpointer                    row_separator_data;
   GtkDestroyNotify            row_separator_destroy;
+
+  /* Hildon hack: state of our style property */
+  gboolean autodimmed_button;
 };
 
 /* While debugging this evil code, I have learned that
@@ -193,7 +217,8 @@
   PROP_ACTIVE,
   PROP_ADD_TEAROFFS,
   PROP_HAS_FRAME,
-  PROP_FOCUS_ON_CLICK
+  PROP_FOCUS_ON_CLICK,
+  PROP_PROPAGATE_LR_KEYS
 };
 
 static GtkBinClass *parent_class = NULL;
@@ -201,6 +226,7 @@
 
 #define BONUS_PADDING 4
 #define SCROLL_TIME  100
+#define HILDON_PADDING 25
 
 /* common */
 static void     gtk_combo_box_class_init           (GtkComboBoxClass *klass);
@@ -240,6 +266,9 @@
                                                     gpointer          user_data);
 static void     gtk_combo_box_menu_hide            (GtkWidget        *menu,
                                                     gpointer          user_data);
+static gboolean gtk_combo_box_menu_size_request    (GtkWidget        *menu,
+                                                    GtkRequisition   *requisition,
+                                                    gpointer          user_data);
 
 static void     gtk_combo_box_set_popup_widget     (GtkComboBox      *combo_box,
                                                     GtkWidget        *popup);
@@ -273,6 +302,14 @@
                                                     gboolean          include_internals,
                                                     GtkCallback       callback,
                                                     gpointer          callback_data);
+static gboolean gtk_combo_box_focus_in             (GtkWidget        *widget,
+                                                    GdkEventFocus    *event);
+static gint gtk_combo_box_focus             (GtkWidget        *widget,
+                                                    GtkDirectionType dir);
+static void gtk_combo_box_child_focus_in            (GtkWidget        *widget,
+                                                    GdkEventFocus    *event);
+static void gtk_combo_box_child_focus_out            (GtkWidget        *widget,
+                                                    GdkEventFocus    *event);
 static gboolean gtk_combo_box_expose_event         (GtkWidget        *widget,
                                                     GdkEventExpose   *event);
 static gboolean gtk_combo_box_scroll_event         (GtkWidget        *widget,
@@ -285,6 +322,12 @@
 
 static void     gtk_combo_box_check_appearance     (GtkComboBox      *combo_box);
 
+/* <Hildon addition> */
+extern void     gtk_grab_combo_box_entry_focus   (GtkComboBoxEntry *entry_box);
+
+static void    gtk_combo_box_grab_focus         (GtkWidget         *focus_widget);
+/* </hildon addition> */
+
 /* listening to the model */
 static void     gtk_combo_box_model_row_inserted   (GtkTreeModel     *model,
 						    GtkTreePath      *path,
@@ -424,6 +467,9 @@
 static void gtk_combo_box_start_editing (GtkCellEditable *cell_editable,
 					 GdkEvent        *event);
 
+static void gtk_combo_box_menu_position_above (GtkMenu  *menu, gint     *x,
+					       gint     *y, gboolean *push_in,
+					       gpointer  user_data);
 
 GType
 gtk_combo_box_get_type (void)
@@ -479,6 +525,25 @@
   return combo_box_type;
 }
 
+/* Hildon addition: Check if the button needs to be dimmed */
+static void hildon_check_autodim(GtkComboBox *combo_box)
+{
+  GtkWidget *widget;
+  GtkTreeModel *model;
+  GtkTreeIter iter;
+
+  widget = combo_box->priv->button;
+  model = combo_box->priv->model;
+
+  if (combo_box->priv->autodimmed_button && widget != NULL)
+    {
+      if (model && gtk_tree_model_get_iter_first(model, &iter))
+        gtk_widget_set_sensitive(widget, TRUE);
+      else 
+        gtk_widget_set_sensitive(widget, FALSE);
+    }
+}
+
 /* common */
 static void
 gtk_combo_box_class_init (GtkComboBoxClass *klass)
@@ -504,6 +569,11 @@
   widget_class->mnemonic_activate = gtk_combo_box_mnemonic_activate;
   widget_class->style_set = gtk_combo_box_style_set;
   widget_class->state_changed = gtk_combo_box_state_changed;
+  
+  /* Hildon addition */
+  widget_class->grab_focus = gtk_combo_box_grab_focus;
+  widget_class->focus_in_event = gtk_combo_box_focus_in;
+  widget_class->focus = gtk_combo_box_focus;
 
   gtk_object_class = (GtkObjectClass *)klass;
   gtk_object_class->destroy = gtk_combo_box_destroy;
@@ -680,6 +750,14 @@
 							 TRUE,
 							 G_PARAM_READWRITE));
 
+  g_object_class_install_property (object_class,
+                                   PROP_PROPAGATE_LR_KEYS,
+                                   g_param_spec_boolean ("propagate-lr-keys",
+                                                         P_("Propagate L&R keys"),
+                                                         P_("Whether to propagate key-press events from left and right arrow keys further"),
+                                                         FALSE,
+                                                         G_PARAM_READWRITE));
+
   gtk_widget_class_install_style_property (widget_class,
                                            g_param_spec_boolean ("appears-as-list",
                                                                  P_("Appears as list"),
@@ -687,6 +765,49 @@
                                                                  FALSE,
                                                                  G_PARAM_READABLE));
 
+  gtk_widget_class_install_style_property (widget_class,
+                                  g_param_spec_boolean ("hildonlike",
+                                  _("Size request"),
+				  _("Size allocate"),
+                                  FALSE,
+                                  G_PARAM_READABLE));
+
+  gtk_widget_class_install_style_property (widget_class,
+                                          g_param_spec_int ("arrow-height",
+							      P_("Arrow height for option menu"),
+							      P_("Sets arrow height"),
+							      0,
+							      G_MAXINT,
+							      28,
+							      G_PARAM_READWRITE));
+
+  gtk_widget_class_install_style_property (widget_class,
+                                          g_param_spec_int ("arrow-width",
+							      P_("Arrow width for option menu"),
+							      P_("Sets arrow width"),
+							      0,
+							      G_MAXINT,
+							      26,
+							      G_PARAM_READWRITE));
+
+  gtk_widget_class_install_style_property (widget_class,
+                                          g_param_spec_int ("separator-width",
+							      P_("Separator Width"),
+							      P_("Number of pixels between the button and entry field"),
+							      0,
+							      G_MAXINT,
+							      6,
+							      G_PARAM_READWRITE));
+
+  /* Hildon hack: style property for enabling the autodimming hack */
+  gtk_widget_class_install_style_property (
+    widget_class,
+    g_param_spec_boolean ("autodimmed_button",
+    _("Autodimmed button"),
+    _("Automatically dims the button if the list is empty"),
+    FALSE,
+    G_PARAM_READABLE));
+
   g_type_class_add_private (object_class, sizeof (GtkComboBoxPrivate));
 }
 
@@ -731,6 +852,12 @@
   combo_box->priv->editing_canceled = FALSE;
   combo_box->priv->auto_scroll = FALSE;
   combo_box->priv->focus_on_click = TRUE;
+  combo_box->priv->propagate_lr_keys = FALSE;
+
+  /* Hildon hack: default value for our style property if it is queried before
+   *              the style is set */
+  combo_box->priv->autodimmed_button = FALSE;
+  GTK_WIDGET_SET_FLAGS ( combo_box, GTK_CAN_FOCUS );
 }
 
 static void
@@ -775,6 +902,10 @@
         combo_box->priv->focus_on_click = g_value_get_boolean (value);
         break;
 
+      case PROP_PROPAGATE_LR_KEYS:
+        combo_box->priv->propagate_lr_keys = g_value_get_boolean (value);
+        break;
+
       default:
         break;
     }
@@ -822,6 +953,10 @@
         g_value_set_boolean (value, combo_box->priv->focus_on_click);
         break;
 
+      case PROP_PROPAGATE_LR_KEYS:
+        g_value_set_boolean (value, combo_box->priv->propagate_lr_keys);
+        break;
+
       default:
         G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
         break;
@@ -911,7 +1046,19 @@
 {
   GtkComboBox *combo_box = GTK_COMBO_BOX (widget);
 
+  /* Hildon hack: read the state of our style property */
+  gtk_widget_style_get (GTK_WIDGET(combo_box),
+    "autodimmed_button", &(combo_box->priv->autodimmed_button), NULL);
+  
   gtk_combo_box_check_appearance (combo_box);
+  
+  /* Hildon hack: handle the dimmed state of the button in regards whether
+   *              the list is empty or not. This has to be done here because
+   *              in the callback functions of GtkTreeModel the button widget
+   *              may have not yet been set. However, we repeat this stuff in
+   *              those functions, because later the button will be set and
+   *              we want to update our state. */
+  hildon_check_autodim(combo_box);
 
   if (combo_box->priv->tree_view && combo_box->priv->cell_view)
     gtk_cell_view_set_background_color (GTK_CELL_VIEW (combo_box->priv->cell_view), 
@@ -922,10 +1069,17 @@
 gtk_combo_box_button_toggled (GtkWidget *widget,
                               gpointer   data)
 {
+  gboolean hildonlike;
   GtkComboBox *combo_box = GTK_COMBO_BOX (data);
+  
+  gtk_widget_style_get (GTK_WIDGET (combo_box), "hildonlike", &hildonlike, NULL);
 
   if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget)))
     {
+       if (hildonlike) {
+	  gtk_combo_box_grab_focus(GTK_WIDGET(combo_box));
+       }
+      
       if (!combo_box->priv->popup_in_progress)
         gtk_combo_box_popup (combo_box);
     }
@@ -1069,6 +1223,26 @@
                                 FALSE);
 }
 
+static gboolean
+gtk_combo_box_menu_size_request (GtkWidget      *menu,
+                                 GtkRequisition *requisition,
+                                 gpointer        user_data)
+{
+  GtkWidget *combo_box = GTK_WIDGET (user_data);
+
+  if ( combo_box->allocation.width < HILDON_MENU_COMBO_MAX_WIDTH )
+      requisition->width = MAX (MIN (requisition->width, HILDON_MENU_COMBO_MAX_WIDTH),
+              HILDON_MENU_COMBO_MIN_WIDTH);
+  else
+      requisition->width = MAX (MIN (requisition->width, combo_box->allocation.width),
+              HILDON_MENU_COMBO_MIN_WIDTH);
+  
+  requisition->height = MAX (MIN (requisition->height, HILDON_MENU_COMBO_MAX_HEIGHT),
+                             HILDON_MENU_COMBO_MIN_HEIGHT);
+
+  return TRUE;
+}
+
 static void
 gtk_combo_box_detacher (GtkWidget *widget,
 			GtkMenu	  *menu)
@@ -1103,7 +1277,7 @@
     {
       gtk_container_remove (GTK_CONTAINER (combo_box->priv->popup_frame),
                             combo_box->priv->popup_widget);
-      g_object_unref (combo_box->priv->popup_widget);
+      g_object_unref (G_OBJECT (combo_box->priv->popup_widget));
       combo_box->priv->popup_widget = NULL;
     }
 
@@ -1127,6 +1301,8 @@
                         G_CALLBACK (gtk_combo_box_menu_show), combo_box);
       g_signal_connect (GTK_MENU (popup)->toplevel, "hide",
                         G_CALLBACK (gtk_combo_box_menu_hide), combo_box);
+      g_signal_connect (GTK_MENU (popup)->toplevel, "size_request",
+                        G_CALLBACK (gtk_combo_box_menu_size_request), combo_box);
 
       gtk_menu_attach_to_widget (GTK_MENU (popup),
 				 GTK_WIDGET (combo_box),
@@ -1175,7 +1351,7 @@
                          popup);
 
       gtk_widget_show (popup);
-      g_object_ref (popup);
+      g_object_ref (G_OBJECT (popup));
       combo_box->priv->popup_widget = popup;
     }
 }
@@ -1243,69 +1419,223 @@
 				  gboolean *push_in,
 				  gpointer  user_data)
 {
-  GtkComboBox *combo_box;
-  GtkWidget *active;
   GtkWidget *child;
   GtkWidget *widget;
+  GtkWidget *active;
   GtkRequisition requisition;
-  GList *children;
-  gint screen_width;
+  gint screen_width, screen_height;
   gint menu_xpos;
   gint menu_ypos;
-  gint menu_width;
+  gint menu_width, menu_height;
+  gint menu_ypad;
+  gint full_menu_height;
+  gint total_y_padding;
 
   g_return_if_fail (GTK_IS_COMBO_BOX (user_data));
-  
-  combo_box = GTK_COMBO_BOX (user_data);
-  widget = GTK_WIDGET (combo_box);
 
-  gtk_widget_get_child_requisition (GTK_WIDGET (menu), &requisition);
+  widget = GTK_WIDGET (user_data);
+  child = GTK_BIN (user_data)->child;
+
+  /* We need to realize the menu, as we are playing with menu item coordinates
+   * inside. */
+  gtk_widget_realize (GTK_WIDGET (menu));
+
+  gtk_widget_get_child_requisition (menu->toplevel, &requisition);
   menu_width = requisition.width;
+  menu_height = requisition.height;
+
+  gtk_widget_get_child_requisition (GTK_WIDGET (menu), &requisition);
+  full_menu_height = requisition.height;
+
+  screen_width = gdk_screen_get_width (gtk_widget_get_screen (widget));
+  screen_height = gdk_screen_get_height (gtk_widget_get_screen (widget));
+
+  active = gtk_menu_get_active (menu);
 
-  active = gtk_menu_get_active (GTK_MENU (combo_box->priv->popup_widget));
   gdk_window_get_origin (widget->window, &menu_xpos, &menu_ypos);
 
   menu_xpos += widget->allocation.x;
-  menu_ypos += widget->allocation.y + widget->allocation.height / 2 - 2;
+  menu_ypos += widget->allocation.y;
 
-  if (active != NULL)
+  /* RTL */
+  if (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_RTL)
+    menu_xpos = menu_xpos + widget->allocation.width - menu_width;
+
+  /* Substract borders */
+  gtk_widget_style_get (GTK_WIDGET (menu),
+                        "vertical-padding", &menu_ypad,
+                        NULL);
+
+  total_y_padding = menu_ypad + GTK_CONTAINER (menu)->border_width +
+                    GTK_WIDGET (menu)->style->ythickness;
+
+  /* Substract scroll arrow height if needed, and calculate
+   * scroll_offset. */
+  if (full_menu_height > HILDON_MENU_COMBO_MAX_HEIGHT)
     {
-      gtk_widget_get_child_requisition (active, &requisition);
-      menu_ypos -= requisition.height / 2;
+      GList *child;
+      int pos;
+
+      total_y_padding += MENU_SCROLL_ARROW_HEIGHT;
+
+      child = GTK_MENU_SHELL (menu)->children;
+      pos = 0;
+
+      while (child)
+        {
+          GtkWidget *child_widget = GTK_WIDGET (child->data);
+
+          if (active == child_widget)
+            break;
+
+          if (GTK_WIDGET_VISIBLE (child))
+            {
+              pos += child_widget->allocation.height;
+
+              if (pos > HILDON_MENU_COMBO_MAX_HEIGHT)
+                menu->scroll_offset += child_widget->allocation.height;
+            }
+
+          child = child->next;
+        }
     }
 
-  children = GTK_MENU_SHELL (combo_box->priv->popup_widget)->children;
-  while (children)
+  /* Try to get active item and widget lined up */
+  if (active != NULL)
     {
-      child = children->data;
-
-      if (active == child)
-	break;
+      gint new_menu_ypos;
 
-      if (GTK_WIDGET_VISIBLE (child))
-	{
-	  gtk_widget_get_child_requisition (child, &requisition);
-	  menu_ypos -= requisition.height;
-	}
+      new_menu_ypos = menu_ypos - active->allocation.y - total_y_padding +
+                      menu->scroll_offset;
+      if (new_menu_ypos < 0 || (new_menu_ypos + menu_height) > screen_height)
+        {
+          /* Menu doesn't fit - try to get the last item lined up. */
+          /* This makes the incorrect assumption that all menu items
+           * are guaranteed to have the same height. But this will work
+           * fine for 99 % of all cases and 100 % of all Hildon cases */
+          new_menu_ypos = menu_ypos - menu_height + total_y_padding +
+                          active->allocation.height;
+        }
 
-      children = children->next;
+      menu_ypos = new_menu_ypos;
     }
+  else
+    menu_ypos -= total_y_padding; /* Line up with first item */
+
+  /* Clamp the position on screen */
+  if (menu_xpos < 0)
+    menu_xpos = 0;
+  else if ((menu_xpos + menu_width) > screen_width)
+    menu_xpos -= ((menu_xpos + menu_width) - screen_width);
+
+  if (menu_ypos < 0)
+    menu_ypos = 0;
+  else if ((menu_ypos + menu_height) > screen_height)
+    menu_ypos -= ((menu_ypos + menu_height) - screen_height);
+
+  *x = menu_xpos;
+  *y = menu_ypos;
+
+  *push_in = FALSE;
+}
+
+static void 
+gtk_combo_box_menu_position_above (GtkMenu  *menu,
+				   gint     *x,
+				   gint     *y,
+				   gboolean *push_in,
+				   gpointer  user_data)
+{
+  /* 
+   * This function positiones the menu above widgets.
+   * This is a modified version of the position function 
+   * gtk_combo_box_position_over. 
+   * NB: This is only used when gtkcombobox is in toolbar!
+   */
+
+  GtkRequisition requisition;
+  gint screen_width, screen_height;
+  gint menu_xpos;
+  gint menu_ypos;
+  gint menu_width, menu_height;
+  gint full_menu_height;
+  GtkWidget *widget;
+  GtkWidget *child;
+  GtkWidget *active;
+
+  widget = GTK_WIDGET (user_data);
+  child = GTK_BIN (user_data)->child;
+
+  /* We need to realize the menu, as we are playing with menu item coordinates
+   * inside. */
+  gtk_widget_realize (GTK_WIDGET (menu));
+
+  gtk_widget_get_child_requisition (menu->toplevel, &requisition);
+  menu_width = requisition.width;
+  menu_height = requisition.height;
+
+  gtk_widget_get_child_requisition (GTK_WIDGET (menu), &requisition);
+  full_menu_height = requisition.height;
+
+  active = gtk_menu_get_active (menu);
+
+  gdk_window_get_origin (GDK_WINDOW (widget->window), &menu_xpos, &menu_ypos);
+
+  menu_xpos += widget->allocation.x;
+  menu_ypos += widget->allocation.y;
 
+  /* RTL */
   if (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_RTL)
     menu_xpos = menu_xpos + widget->allocation.width - menu_width;
 
+  /* Position above */
+  menu_ypos -= menu_height;
+
   /* Clamp the position on screen */
   screen_width = gdk_screen_get_width (gtk_widget_get_screen (widget));
-  
+  screen_height = gdk_screen_get_height (gtk_widget_get_screen (widget));
+
   if (menu_xpos < 0)
     menu_xpos = 0;
   else if ((menu_xpos + menu_width) > screen_width)
     menu_xpos -= ((menu_xpos + menu_width) - screen_width);
 
+  if (menu_ypos < 0)
+    menu_ypos = 0;
+  else if ((menu_ypos + menu_height) > screen_height)
+    menu_xpos -= ((menu_ypos + menu_height) - screen_height);
+
   *x = menu_xpos;
   *y = menu_ypos;
+  *push_in = FALSE;
+
+  /* Calculate scroll offset */
+  if (full_menu_height > HILDON_MENU_COMBO_MAX_HEIGHT)
+    {
+      GList *child;
+      int pos;
+
+      child = GTK_MENU_SHELL (menu)->children;
+      pos = 0;
+
+      while (child)
+        {
+          GtkWidget *child_widget = GTK_WIDGET (child->data);
+
+          if (active == child_widget)
+            break;
+
+          if (GTK_WIDGET_VISIBLE (child))
+            {
+              pos += child_widget->allocation.height;
 
-  *push_in = TRUE;
+              if (pos > HILDON_MENU_COMBO_MAX_HEIGHT)
+                menu->scroll_offset += child_widget->allocation.height;
+            }
+
+          child = child->next;
+        }
+    }
 }
 
 static void
@@ -1318,21 +1648,44 @@
   GtkComboBox *combo_box;
   GtkWidget *menu_item;
 
+  gboolean hildonlike;
+
   combo_box = GTK_COMBO_BOX (user_data);
 
-  if (combo_box->priv->wrap_width > 0 || combo_box->priv->cell_view == NULL)	
-    gtk_combo_box_menu_position_below (menu, x, y, push_in, user_data);
-  else
+  gtk_widget_style_get (GTK_WIDGET (combo_box), "hildonlike", &hildonlike, NULL);
+
+  if (!(combo_box->priv->wrap_width > 0 || combo_box->priv->cell_view == NULL))
     {
       /* FIXME handle nested menus better */
       menu_item = gtk_menu_get_active (GTK_MENU (combo_box->priv->popup_widget));
       if (menu_item)
 	gtk_menu_shell_select_item (GTK_MENU_SHELL (combo_box->priv->popup_widget), 
 				    menu_item);
+    }
 
-      gtk_combo_box_menu_position_over (menu, x, y, push_in, user_data);
+  if (hildonlike) 
+    {
+      /* HILDON: we check if combobox is in a toolbar */
+      gboolean in_toolbar = gtk_widget_get_ancestor(GTK_WIDGET(combo_box), GTK_TYPE_TOOLBAR) != NULL;
+      if (in_toolbar)
+	{
+	  /*due to limits in combo's sizes we use position_over here also*/
+          gtk_combo_box_menu_position_above (menu, x, y, push_in, user_data);
+	  return;
+	}
     }
 
+  if (combo_box->priv->wrap_width > 0 || combo_box->priv->cell_view == NULL)	
+/*
+ * Changed because we always want the combo box position to be over
+ * the combo box, unless it's in toolbar.
+ *
+    gtk_combo_box_menu_position_below (menu, x, y, push_in, user_data);
+*/
+    gtk_combo_box_menu_position_over (menu, x, y, push_in, user_data);	      
+  else
+    gtk_combo_box_menu_position_over (menu, x, y, push_in, user_data);	      
+
 }
 
 static void
@@ -1430,7 +1783,7 @@
   list = cells;
   while (list)
     {
-      g_object_get (list->data, "sensitive", &sensitive, NULL);
+      g_object_get (G_OBJECT (list->data), "sensitive", &sensitive, NULL);
       
       if (sensitive)
 	break;
@@ -1469,7 +1822,7 @@
   list = cells;
   while (list)
     {
-      g_object_get (list->data, "sensitive", &sensitive, NULL);
+      g_object_get (G_OBJECT (list->data), "sensitive", &sensitive, NULL);
       
       if (sensitive)
 	break;
@@ -1516,8 +1869,8 @@
 	  if (menu != combo_box->priv->popup_widget && child == children)
 	    {
 	      separator = GTK_WIDGET (child->next->data);
-	      g_object_set (item, "visible", sensitive, NULL);
-	      g_object_set (separator, "visible", sensitive, NULL);
+	      g_object_set (G_OBJECT (item), "visible", sensitive, NULL);
+	      g_object_set (G_OBJECT (separator), "visible", sensitive, NULL);
 	    }
 	  else
 	    gtk_widget_set_sensitive (item, sensitive);
@@ -1534,8 +1887,6 @@
 {
   GtkTreePath *path;
   gint active_item;
-  GtkRequisition requisition;
-  gint width;
   
   update_menu_sensitivity (combo_box, combo_box->priv->popup_widget);
 
@@ -1543,26 +1894,19 @@
   if (gtk_tree_row_reference_valid (combo_box->priv->active_row))
     {
       path = gtk_tree_row_reference_get_path (combo_box->priv->active_row);
-      active_item = gtk_tree_path_get_indices (path)[0];
-      gtk_tree_path_free (path);
-      
-      if (combo_box->priv->add_tearoffs)
-	active_item++;
+      if (path)
+	{
+	  active_item = gtk_tree_path_get_indices (path)[0];
+	  gtk_tree_path_free (path);
+
+	  if (combo_box->priv->add_tearoffs)
+	    active_item++;
+	}
     }
 
   /* FIXME handle nested menus better */
-  gtk_menu_set_active (GTK_MENU (combo_box->priv->popup_widget), active_item);
-  
-  if (combo_box->priv->wrap_width == 0)
-    {
-      width = GTK_WIDGET (combo_box)->allocation.width;
-      gtk_widget_set_size_request (combo_box->priv->popup_widget, -1, -1);
-      gtk_widget_size_request (combo_box->priv->popup_widget, &requisition);
-      
-      gtk_widget_set_size_request (combo_box->priv->popup_widget,
-				   MAX (width, requisition.width), -1);
-    }
-  
+  gtk_menu_set_active (GTK_MENU (combo_box->priv->popup_widget), active_item);  
+
   gtk_menu_popup (GTK_MENU (combo_box->priv->popup_widget),
 		  NULL, NULL,
 		  gtk_combo_box_menu_position, combo_box,
@@ -1684,6 +2028,7 @@
 {
   gint padding;
   GtkRequisition req;
+  gboolean hildonlike;
 
   if (combo_box->priv->cell_view)
     gtk_widget_style_get (combo_box->priv->cell_view,
@@ -1691,9 +2036,17 @@
                           NULL);
   else
     padding = 0;
+  
+   gtk_widget_style_get (GTK_WIDGET (combo_box), "hildonlike", &hildonlike,
+			 NULL);
 
   /* add some pixels for good measure */
-  padding += BONUS_PADDING;
+  /* Hildon: we need more padding because our theming
+   * Not elegent way to do it anyway ... */
+  if (hildonlike)
+    padding += HILDON_PADDING;
+  else
+    padding += BONUS_PADDING;
 
   if (combo_box->priv->cell_view)
     gtk_cell_view_get_size_of_row (GTK_CELL_VIEW (combo_box->priv->cell_view),
@@ -1709,6 +2062,7 @@
 {
   GtkTreeIter iter;
   GtkTreePath *path;
+  gboolean hildonlike;
 
   if (!combo_box->priv->model ||
       !gtk_tree_model_get_iter_first (combo_box->priv->model, &iter))
@@ -1717,6 +2071,7 @@
   combo_box->priv->width = 0;
 
   path = gtk_tree_path_new_from_indices (0, -1);
+  gtk_widget_style_get (GTK_WIDGET (combo_box), "hildonlike", &hildonlike, NULL);
 
   do
     {
@@ -1727,8 +2082,11 @@
                                        path, &req);
       else
         req.width = 0;
+  /* Hildon: we need more padding because our theming
+   * Not elegent way to do it anyway ... */
 
-      combo_box->priv->width = MAX (combo_box->priv->width, req.width);
+      combo_box->priv->width = MAX (combo_box->priv->width,
+                                    req.width + (hildonlike == 1) ? HILDON_PADDING : 0 );
 
       gtk_tree_path_next (path);
     }
@@ -1744,10 +2102,19 @@
   gint width, height;
   gint focus_width, focus_pad;
   GtkRequisition bin_req;
+  gboolean hildonlike;
+  gint arrow_width;
+  gint arrow_height;
 
   GtkComboBox *combo_box = GTK_COMBO_BOX (widget);
 
   gtk_combo_box_check_appearance (combo_box);
+  
+  /* get hildonlike style property */
+  gtk_widget_style_get (widget, "hildonlike",
+		        &hildonlike, "arrow-width",
+			&arrow_width, "arrow-height",
+			&arrow_height, NULL);
 
   /* common */
   gtk_widget_size_request (GTK_BIN (widget)->child, &bin_req);
@@ -1829,6 +2196,13 @@
       requisition->height = MAX (requisition->height, button_req.height);
       requisition->width += button_req.width;
     }
+
+  requisition->width = MIN (requisition->width, HILDON_MAX_WIDTH);
+  
+  /* HILDON quick fix: height forced to be 28px as specified by Hildon specs. */
+  if (hildonlike)
+    if (requisition->height > arrow_height)
+      requisition->height = arrow_height;
 }
 
 static void
@@ -1839,17 +2213,34 @@
   gint focus_width, focus_pad;
   GtkAllocation child;
   GtkRequisition req;
+  GtkRequisition child_req;
   gboolean is_rtl = gtk_widget_get_direction (widget) == GTK_TEXT_DIR_RTL;
+  gboolean hildonlike;
+  gint arrow_width;
+  gint arrow_height;
+  gint separator_width;
 
   gtk_combo_box_check_appearance (combo_box);
 
-  widget->allocation = *allocation;
-
   gtk_widget_style_get (GTK_WIDGET (widget),
 			"focus-line-width", &focus_width,
 			"focus-padding", &focus_pad,
+			"hildonlike", &hildonlike,
+			"arrow-width", &arrow_width,
+			"arrow-height", &arrow_height,
+			"separator-width", &separator_width,
 			NULL);
 
+  /* HILDON: set height to fixed value */
+  if (hildonlike)
+    if (allocation->height > arrow_height)
+    {
+      allocation->y += (allocation->height - arrow_height) / 2;
+      allocation->height = arrow_height;
+    }
+
+  widget->allocation = *allocation;
+
   if (!combo_box->priv->tree_view)
     {
       if (combo_box->priv->cell_view)
@@ -1895,6 +2286,7 @@
             child.x -= req.width;
 	  child.width = MAX (1, child.width);
 	  child.height = MAX (1, child.height);
+	  child.width = separator_width;
           gtk_widget_size_allocate (combo_box->priv->separator, &child);
 
           if (is_rtl)
@@ -1909,7 +2301,16 @@
               child.width = child.x;
               child.x = allocation->x 
 		+ border_width + xthickness + focus_width + focus_pad;
-              child.width -= child.x;
+              child.width -= child.x + xthickness;
+            }
+            
+          if (hildonlike)
+            {
+		          gtk_widget_size_request(GTK_BIN(widget)->child, &child_req);
+		          child.y += (child.height - child_req.height) / 2;
+			        child.height = child_req.height;
+              gtk_widget_hide(combo_box->priv->separator);
+              gtk_widget_hide(combo_box->priv->arrow);
             }
 
 	  child.width = MAX (1, child.width);
@@ -1928,16 +2329,28 @@
           child.height = allocation->height;
 	  child.width = MAX (1, child.width);
 	  child.height = MAX (1, child.height);
+
+          /* HILDON quick fix */
+	  if (hildonlike)
+	    child.width = arrow_width;
+
           gtk_widget_size_allocate (combo_box->priv->button, &child);
 
           if (is_rtl)
-            child.x = allocation->x + req.width;
+            child.x = allocation->x + req.width + separator_width;
           else
             child.x = allocation->x;
           child.y = allocation->y;
-          child.width = allocation->width - req.width;
+          child.width = allocation->width - req.width - separator_width;
 	  child.width = MAX (1, child.width);
 	  child.height = MAX (1, child.height);
+
+          if (hildonlike)
+          {
+            gtk_widget_size_request(GTK_BIN(widget)->child, &child_req);
+            child.y += (child.height - child_req.height) / 2;
+			child.height = child_req.height;
+          }
           gtk_widget_size_allocate (GTK_BIN (widget)->child, &child);
         }
     }
@@ -1990,6 +2403,11 @@
 				   GTK_WIDGET (combo_box->priv->cell_view_frame)->style->ythickness);
 	    }
         }
+
+      gtk_widget_size_request(GTK_BIN(widget)->child, &child_req);
+
+      child.y += (child.height - child_req.height) / 2;
+      child.height = child_req.height;
       
       child.width = MAX (1, child.width);
       child.height = MAX (1, child.height);
@@ -2036,6 +2454,8 @@
     gtk_cell_view_set_displayed_row (GTK_CELL_VIEW (combo_box->priv->cell_view), NULL);
 }
 
+
+
 static void
 gtk_combo_box_forall (GtkContainer *container,
                       gboolean      include_internals,
@@ -2057,6 +2477,46 @@
 }
 
 static gboolean
+gtk_combo_box_focus_in (GtkWidget          *widget,
+			GdkEventFocus      *event)
+{
+   g_return_val_if_fail( widget, FALSE );
+   
+   if ( !GTK_CONTAINER( widget )->focus_child )
+     {
+	gtk_combo_box_grab_focus ( GTK_WIDGET(widget) );
+	return TRUE;
+     }
+   return FALSE;  
+}
+
+static gint
+gtk_combo_box_focus (GtkWidget          *widget,
+			GtkDirectionType dir)
+{
+   g_return_val_if_fail (widget, FALSE);
+   if (GTK_WIDGET_HAS_FOCUS(widget)||GTK_CONTAINER(widget)->focus_child)
+     return FALSE;
+
+   gtk_widget_grab_focus (widget);
+   return TRUE;
+}
+
+static void
+gtk_combo_box_child_focus_in (GtkWidget  * widget,
+			      GdkEventFocus *event)
+{
+   gtk_widget_event( widget, (GdkEvent*)event );
+}
+
+static void
+gtk_combo_box_child_focus_out (GtkWidget  * widget,
+			      GdkEventFocus *event)
+{
+   gtk_widget_event( widget, (GdkEvent*)event );
+}
+
+static gboolean
 gtk_combo_box_expose_event (GtkWidget      *widget,
                             GdkEventExpose *event)
 {
@@ -2357,11 +2817,13 @@
                           gboolean     add_children)
 {
   GtkWidget *menu;
+  gboolean hildonlike;
+
+  gtk_widget_style_get (GTK_WIDGET (combo_box), "hildonlike", &hildonlike, NULL);
 
   if (combo_box->priv->cell_view)
     {
       combo_box->priv->button = gtk_toggle_button_new ();
-
       g_signal_connect (combo_box->priv->button, "toggled",
                         G_CALLBACK (gtk_combo_box_button_toggled), combo_box);
       g_signal_connect_after (combo_box->priv->button, 
@@ -2400,6 +2862,9 @@
       gtk_widget_show_all (combo_box->priv->button);
     }
 
+  g_signal_connect_swapped (combo_box->priv->button, "focus_in_event", G_CALLBACK (gtk_combo_box_child_focus_in), combo_box);
+  g_signal_connect_swapped (combo_box->priv->button, "focus_out_event", G_CALLBACK (gtk_combo_box_child_focus_out), combo_box);
+
   g_signal_connect (combo_box->priv->button, "button_press_event",
                     G_CALLBACK (gtk_combo_box_menu_button_press),
                     combo_box);
@@ -2749,6 +3214,9 @@
 {
   GtkComboBox *combo_box = GTK_COMBO_BOX (user_data);
 
+  /* Hildon hack: sets the popup button sensitive if we have items in the list */
+  hildon_check_autodim(combo_box);
+
   gtk_tree_row_reference_inserted (G_OBJECT (user_data), path);
     
   if (combo_box->priv->tree_view)
@@ -2783,7 +3251,10 @@
   if (combo_box->priv->tree_view)
     gtk_combo_box_list_popup_resize (combo_box);
   else
-    gtk_combo_box_menu_row_deleted (model, path, user_data);  
+    gtk_combo_box_menu_row_deleted (model, path, user_data);        
+ 
+  /* Hildon hack: dim the popup button in case item count reaches 0 */
+  hildon_check_autodim(combo_box);
 }
 
 static void
@@ -3458,10 +3929,46 @@
   gboolean found;
   GtkTreeIter iter;
   GtkTreeIter new_iter;
+  gboolean hildonlike;
+  gint index = gtk_combo_box_get_active (combo_box);
+  gint new_index;
+  gint items = 0;
 
   if (combo_box->priv->model == NULL)
     return FALSE;
 
+  items = gtk_tree_model_iter_n_children (combo_box->priv->model, NULL);
+
+  gtk_widget_style_get (GTK_WIDGET (combo_box), "hildonlike",
+			&hildonlike, NULL);
+
+  /* Hildon select key */
+  if (hildonlike)
+    {
+      if (event->keyval == GDK_KP_Enter || event->keyval == GDK_Return)
+        {
+          gtk_combo_box_popup (combo_box);
+          return TRUE;
+        }
+      else if (event->keyval == GDK_Left && items != 0)
+        {
+          new_index = (index == 0) ? items - 1 : index - 1;
+          gtk_combo_box_set_active (combo_box, new_index);
+          return !combo_box->priv->propagate_lr_keys;
+        }
+      else if (event->keyval == GDK_Right && items != 0)
+        {
+          new_index = (index == items - 1) ? 0 : index + 1;
+          gtk_combo_box_set_active (combo_box, new_index);
+          return !combo_box->priv->propagate_lr_keys;
+        }
+      else if ((event->keyval == GDK_Down || event->keyval == GDK_KP_Down)
+                || (event->keyval == GDK_Up || event->keyval == GDK_KP_Up))
+        {
+          return FALSE;
+        }
+    }
+
   if ((event->keyval == GDK_Down || event->keyval == GDK_KP_Down) && 
       state == GDK_MOD1_MASK)
     {
@@ -3714,7 +4221,7 @@
 
   combo_box = GTK_COMBO_BOX (layout);
 
-  g_object_ref (cell);
+  g_object_ref (G_OBJECT (cell));
   gtk_object_sink (GTK_OBJECT (cell));
 
   info = g_new0 (ComboCellInfo, 1);
@@ -3771,7 +4278,7 @@
 
   combo_box = GTK_COMBO_BOX (layout);
 
-  g_object_ref (cell);
+  g_object_ref (G_OBJECT (cell));
   gtk_object_sink (GTK_OBJECT (cell));
 
   info = g_new0 (ComboCellInfo, 1);
@@ -3833,7 +4340,7 @@
      ComboCellInfo *info = (ComboCellInfo *)i->data;
 
       gtk_combo_box_cell_layout_clear_attributes (layout, info->cell);
-      g_object_unref (info->cell);
+      g_object_unref (G_OBJECT (info->cell));
       g_free (info);
       i->data = NULL;
     }
@@ -3922,7 +4429,7 @@
   
   if (GTK_IS_MENU_ITEM (parent) && 
       gtk_menu_item_get_submenu (GTK_MENU_ITEM (parent)))
-    g_object_set (cell, "sensitive", TRUE, NULL);
+    g_object_set (G_OBJECT (cell), "sensitive", TRUE, NULL);
 }
 
 
@@ -4137,7 +4644,7 @@
 GtkWidget *
 gtk_combo_box_new (void)
 {
-  return g_object_new (GTK_TYPE_COMBO_BOX, NULL);
+  return GTK_WIDGET (g_object_new (GTK_TYPE_COMBO_BOX, NULL));
 }
 
 /**
@@ -4157,7 +4664,9 @@
 
   g_return_val_if_fail (GTK_IS_TREE_MODEL (model), NULL);
 
-  combo_box = g_object_new (GTK_TYPE_COMBO_BOX, "model", model, NULL);
+  combo_box = GTK_COMBO_BOX (g_object_new (GTK_TYPE_COMBO_BOX,
+                                           "model", model,
+                                           NULL));
 
   return GTK_WIDGET (combo_box);
 }
@@ -4512,6 +5021,7 @@
   if (!model)
     {
       gtk_combo_box_unset_model (combo_box);
+      hildon_check_autodim(combo_box);
       return;
     }
 
@@ -4524,7 +5034,7 @@
     gtk_combo_box_unset_model (combo_box);
 
   combo_box->priv->model = model;
-  g_object_ref (combo_box->priv->model);
+  g_object_ref (G_OBJECT (combo_box->priv->model));
 
   combo_box->priv->inserted_id =
     g_signal_connect (combo_box->priv->model, "row_inserted",
@@ -4561,6 +5071,8 @@
   if (combo_box->priv->cell_view)
     gtk_cell_view_set_model (GTK_CELL_VIEW (combo_box->priv->cell_view),
                              combo_box->priv->model);
+
+  hildon_check_autodim(combo_box);
 }
 
 /**
@@ -4610,6 +5122,9 @@
   g_object_unref (store);
 
   cell = gtk_cell_renderer_text_new ();
+
+  g_object_set (cell, "ellipsize", PANGO_ELLIPSIZE_END, NULL);
+
   gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (combo_box), cell, TRUE);
   gtk_cell_layout_set_attributes (GTK_CELL_LAYOUT (combo_box), cell,
                                   "text", 0,
@@ -5140,3 +5655,33 @@
   
   return combo->priv->focus_on_click;
 }
+/* Hildon addition:
+ * This is added, because we need to be able grab focus for our widget.
+ * Focus grabbing can happen it two ways: If we are using combobox entry
+ * we grab entry widget focus, otherwise togglebutton focus
+ */
+static void	gtk_combo_box_grab_focus	 (GtkWidget         *focus_widget)
+{
+  GtkComboBox *combo_box;
+  GtkComboBoxEntry *combo_entry;
+  gboolean hildonlike;
+
+  combo_box = GTK_COMBO_BOX (focus_widget);
+  
+  gtk_widget_style_get (focus_widget, "hildonlike",
+			&hildonlike, NULL);
+
+  if (hildonlike)
+    {
+      /* Are we in entry mode ? */
+      if ( GTK_IS_COMBO_BOX_ENTRY(combo_box))
+        {
+	   combo_entry = GTK_COMBO_BOX_ENTRY (combo_box);
+	   gtk_grab_combo_box_entry_focus (combo_entry);
+        }
+      else
+        {
+	   gtk_widget_grab_focus (combo_box->priv->button);
+        }
+    }
+}
--- gtk+/gdk-pixbuf/ChangeLog	(.../2.6.4)	(revision 904)
+++ gtk+/gdk-pixbuf/ChangeLog	(.../2.6.4-1.osso62)	(revision 904)
@@ -1,3 +1,21 @@
+2005-09-01  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	Merge patches by Matthias Clasen and Manish Singh from GNOME CVS:
+
+	* io-bmp.c (DecodeColormap): Initialize the colormap to
+	zero.  (#171762, David Costanzo)
+	* io-bmp.c (DoCompressed): Use the correct update regions for
+	compressed bmps.  (#150664, Owen Taylor, test images provided
+	by David Costanzo)
+	* io-bmp.c (grow_buffer): reject 0-sized buffers as corrupt header
+	data. Fixes bug #171707.
+	N#18487
+
+2005-08-18  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* io-ico.c (DecodeHeader): Check for header size overflow.
+	N#17078
+
 2005-03-01  Matthias Clasen  <mclasen@redhat.com>
 
 	* === Released 2.6.4 ===
--- gtk+/gdk-pixbuf/io-xpm.c	(.../2.6.4)	(revision 904)
+++ gtk+/gdk-pixbuf/io-xpm.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -113,769 +113,7 @@
  * terms specified in this license.
  */
 
-typedef struct {
-    const char *name;
-    unsigned char red;
-    unsigned char green;
-    unsigned char blue;
-} XPMColorEntry;
-
-static XPMColorEntry xColors[] = {
-    { "alice blue", 240, 248, 255 },
-    { "AliceBlue", 240, 248, 255 },
-    { "antique white", 250, 235, 215 },
-    { "AntiqueWhite", 250, 235, 215 },
-    { "AntiqueWhite1", 255, 239, 219 },
-    { "AntiqueWhite2", 238, 223, 204 },
-    { "AntiqueWhite3", 205, 192, 176 },
-    { "AntiqueWhite4", 139, 131, 120 },
-    { "aquamarine", 127, 255, 212 },
-    { "aquamarine1", 127, 255, 212 },
-    { "aquamarine2", 118, 238, 198 },
-    { "aquamarine3", 102, 205, 170 },
-    { "aquamarine4", 69, 139, 116 },
-    { "azure", 240, 255, 255 },
-    { "azure1", 240, 255, 255 },
-    { "azure2", 224, 238, 238 },
-    { "azure3", 193, 205, 205 },
-    { "azure4", 131, 139, 139 },
-    { "beige", 245, 245, 220 },
-    { "bisque", 255, 228, 196 },
-    { "bisque1", 255, 228, 196 },
-    { "bisque2", 238, 213, 183 },
-    { "bisque3", 205, 183, 158 },
-    { "bisque4", 139, 125, 107 },
-    { "black", 0, 0, 0 },
-    { "blanched almond", 255, 235, 205 },
-    { "BlanchedAlmond", 255, 235, 205 },
-    { "blue", 0, 0, 255 },
-    { "blue violet", 138, 43, 226 },
-    { "blue1", 0, 0, 255 },
-    { "blue2", 0, 0, 238 },
-    { "blue3", 0, 0, 205 },
-    { "blue4", 0, 0, 139 },
-    { "BlueViolet", 138, 43, 226 },
-    { "brown", 165, 42, 42 },
-    { "brown1", 255, 64, 64 },
-    { "brown2", 238, 59, 59 },
-    { "brown3", 205, 51, 51 },
-    { "brown4", 139, 35, 35 },
-    { "burlywood", 222, 184, 135 },
-    { "burlywood1", 255, 211, 155 },
-    { "burlywood2", 238, 197, 145 },
-    { "burlywood3", 205, 170, 125 },
-    { "burlywood4", 139, 115, 85 },
-    { "cadet blue", 95, 158, 160 },
-    { "CadetBlue", 95, 158, 160 },
-    { "CadetBlue1", 152, 245, 255 },
-    { "CadetBlue2", 142, 229, 238 },
-    { "CadetBlue3", 122, 197, 205 },
-    { "CadetBlue4", 83, 134, 139 },
-    { "chartreuse", 127, 255, 0 },
-    { "chartreuse1", 127, 255, 0 },
-    { "chartreuse2", 118, 238, 0 },
-    { "chartreuse3", 102, 205, 0 },
-    { "chartreuse4", 69, 139, 0 },
-    { "chocolate", 210, 105, 30 },
-    { "chocolate1", 255, 127, 36 },
-    { "chocolate2", 238, 118, 33 },
-    { "chocolate3", 205, 102, 29 },
-    { "chocolate4", 139, 69, 19 },
-    { "coral", 255, 127, 80 },
-    { "coral1", 255, 114, 86 },
-    { "coral2", 238, 106, 80 },
-    { "coral3", 205, 91, 69 },
-    { "coral4", 139, 62, 47 },
-    { "cornflower blue", 100, 149, 237 },
-    { "CornflowerBlue", 100, 149, 237 },
-    { "cornsilk", 255, 248, 220 },
-    { "cornsilk1", 255, 248, 220 },
-    { "cornsilk2", 238, 232, 205 },
-    { "cornsilk3", 205, 200, 177 },
-    { "cornsilk4", 139, 136, 120 },
-    { "cyan", 0, 255, 255 },
-    { "cyan1", 0, 255, 255 },
-    { "cyan2", 0, 238, 238 },
-    { "cyan3", 0, 205, 205 },
-    { "cyan4", 0, 139, 139 },
-    { "dark blue", 0, 0, 139 },
-    { "dark cyan", 0, 139, 139 },
-    { "dark goldenrod", 184, 134, 11 },
-    { "dark gray", 169, 169, 169 },
-    { "dark green", 0, 100, 0 },
-    { "dark grey", 169, 169, 169 },
-    { "dark khaki", 189, 183, 107 },
-    { "dark magenta", 139, 0, 139 },
-    { "dark olive green", 85, 107, 47 },
-    { "dark orange", 255, 140, 0 },
-    { "dark orchid", 153, 50, 204 },
-    { "dark red", 139, 0, 0 },
-    { "dark salmon", 233, 150, 122 },
-    { "dark sea green", 143, 188, 143 },
-    { "dark slate blue", 72, 61, 139 },
-    { "dark slate gray", 47, 79, 79 },
-    { "dark slate grey", 47, 79, 79 },
-    { "dark turquoise", 0, 206, 209 },
-    { "dark violet", 148, 0, 211 },
-    { "DarkBlue", 0, 0, 139 },
-    { "DarkCyan", 0, 139, 139 },
-    { "DarkGoldenrod", 184, 134, 11 },
-    { "DarkGoldenrod1", 255, 185, 15 },
-    { "DarkGoldenrod2", 238, 173, 14 },
-    { "DarkGoldenrod3", 205, 149, 12 },
-    { "DarkGoldenrod4", 139, 101, 8 },
-    { "DarkGray", 169, 169, 169 },
-    { "DarkGreen", 0, 100, 0 },
-    { "DarkGrey", 169, 169, 169 },
-    { "DarkKhaki", 189, 183, 107 },
-    { "DarkMagenta", 139, 0, 139 },
-    { "DarkOliveGreen", 85, 107, 47 },
-    { "DarkOliveGreen1", 202, 255, 112 },
-    { "DarkOliveGreen2", 188, 238, 104 },
-    { "DarkOliveGreen3", 162, 205, 90 },
-    { "DarkOliveGreen4", 110, 139, 61 },
-    { "DarkOrange", 255, 140, 0 },
-    { "DarkOrange1", 255, 127, 0 },
-    { "DarkOrange2", 238, 118, 0 },
-    { "DarkOrange3", 205, 102, 0 },
-    { "DarkOrange4", 139, 69, 0 },
-    { "DarkOrchid", 153, 50, 204 },
-    { "DarkOrchid1", 191, 62, 255 },
-    { "DarkOrchid2", 178, 58, 238 },
-    { "DarkOrchid3", 154, 50, 205 },
-    { "DarkOrchid4", 104, 34, 139 },
-    { "DarkRed", 139, 0, 0 },
-    { "DarkSalmon", 233, 150, 122 },
-    { "DarkSeaGreen", 143, 188, 143 },
-    { "DarkSeaGreen1", 193, 255, 193 },
-    { "DarkSeaGreen2", 180, 238, 180 },
-    { "DarkSeaGreen3", 155, 205, 155 },
-    { "DarkSeaGreen4", 105, 139, 105 },
-    { "DarkSlateBlue", 72, 61, 139 },
-    { "DarkSlateGray", 47, 79, 79 },
-    { "DarkSlateGray1", 151, 255, 255 },
-    { "DarkSlateGray2", 141, 238, 238 },
-    { "DarkSlateGray3", 121, 205, 205 },
-    { "DarkSlateGray4", 82, 139, 139 },
-    { "DarkSlateGrey", 47, 79, 79 },
-    { "DarkTurquoise", 0, 206, 209 },
-    { "DarkViolet", 148, 0, 211 },
-    { "deep pink", 255, 20, 147 },
-    { "deep sky blue", 0, 191, 255 },
-    { "DeepPink", 255, 20, 147 },
-    { "DeepPink1", 255, 20, 147 },
-    { "DeepPink2", 238, 18, 137 },
-    { "DeepPink3", 205, 16, 118 },
-    { "DeepPink4", 139, 10, 80 },
-    { "DeepSkyBlue", 0, 191, 255 },
-    { "DeepSkyBlue1", 0, 191, 255 },
-    { "DeepSkyBlue2", 0, 178, 238 },
-    { "DeepSkyBlue3", 0, 154, 205 },
-    { "DeepSkyBlue4", 0, 104, 139 },
-    { "dim gray", 105, 105, 105 },
-    { "dim grey", 105, 105, 105 },
-    { "DimGray", 105, 105, 105 },
-    { "DimGrey", 105, 105, 105 },
-    { "dodger blue", 30, 144, 255 },
-    { "DodgerBlue", 30, 144, 255 },
-    { "DodgerBlue1", 30, 144, 255 },
-    { "DodgerBlue2", 28, 134, 238 },
-    { "DodgerBlue3", 24, 116, 205 },
-    { "DodgerBlue4", 16, 78, 139 },
-    { "firebrick", 178, 34, 34 },
-    { "firebrick1", 255, 48, 48 },
-    { "firebrick2", 238, 44, 44 },
-    { "firebrick3", 205, 38, 38 },
-    { "firebrick4", 139, 26, 26 },
-    { "floral white", 255, 250, 240 },
-    { "FloralWhite", 255, 250, 240 },
-    { "forest green", 34, 139, 34 },
-    { "ForestGreen", 34, 139, 34 },
-    { "gainsboro", 220, 220, 220 },
-    { "ghost white", 248, 248, 255 },
-    { "GhostWhite", 248, 248, 255 },
-    { "gold", 255, 215, 0 },
-    { "gold1", 255, 215, 0 },
-    { "gold2", 238, 201, 0 },
-    { "gold3", 205, 173, 0 },
-    { "gold4", 139, 117, 0 },
-    { "goldenrod", 218, 165, 32 },
-    { "goldenrod1", 255, 193, 37 },
-    { "goldenrod2", 238, 180, 34 },
-    { "goldenrod3", 205, 155, 29 },
-    { "goldenrod4", 139, 105, 20 },
-    { "gray", 190, 190, 190 },
-    { "gray0", 0, 0, 0 },
-    { "gray1", 3, 3, 3 },
-    { "gray10", 26, 26, 26 },
-    { "gray100", 255, 255, 255 },
-    { "gray11", 28, 28, 28 },
-    { "gray12", 31, 31, 31 },
-    { "gray13", 33, 33, 33 },
-    { "gray14", 36, 36, 36 },
-    { "gray15", 38, 38, 38 },
-    { "gray16", 41, 41, 41 },
-    { "gray17", 43, 43, 43 },
-    { "gray18", 46, 46, 46 },
-    { "gray19", 48, 48, 48 },
-    { "gray2", 5, 5, 5 },
-    { "gray20", 51, 51, 51 },
-    { "gray21", 54, 54, 54 },
-    { "gray22", 56, 56, 56 },
-    { "gray23", 59, 59, 59 },
-    { "gray24", 61, 61, 61 },
-    { "gray25", 64, 64, 64 },
-    { "gray26", 66, 66, 66 },
-    { "gray27", 69, 69, 69 },
-    { "gray28", 71, 71, 71 },
-    { "gray29", 74, 74, 74 },
-    { "gray3", 8, 8, 8 },
-    { "gray30", 77, 77, 77 },
-    { "gray31", 79, 79, 79 },
-    { "gray32", 82, 82, 82 },
-    { "gray33", 84, 84, 84 },
-    { "gray34", 87, 87, 87 },
-    { "gray35", 89, 89, 89 },
-    { "gray36", 92, 92, 92 },
-    { "gray37", 94, 94, 94 },
-    { "gray38", 97, 97, 97 },
-    { "gray39", 99, 99, 99 },
-    { "gray4", 10, 10, 10 },
-    { "gray40", 102, 102, 102 },
-    { "gray41", 105, 105, 105 },
-    { "gray42", 107, 107, 107 },
-    { "gray43", 110, 110, 110 },
-    { "gray44", 112, 112, 112 },
-    { "gray45", 115, 115, 115 },
-    { "gray46", 117, 117, 117 },
-    { "gray47", 120, 120, 120 },
-    { "gray48", 122, 122, 122 },
-    { "gray49", 125, 125, 125 },
-    { "gray5", 13, 13, 13 },
-    { "gray50", 127, 127, 127 },
-    { "gray51", 130, 130, 130 },
-    { "gray52", 133, 133, 133 },
-    { "gray53", 135, 135, 135 },
-    { "gray54", 138, 138, 138 },
-    { "gray55", 140, 140, 140 },
-    { "gray56", 143, 143, 143 },
-    { "gray57", 145, 145, 145 },
-    { "gray58", 148, 148, 148 },
-    { "gray59", 150, 150, 150 },
-    { "gray6", 15, 15, 15 },
-    { "gray60", 153, 153, 153 },
-    { "gray61", 156, 156, 156 },
-    { "gray62", 158, 158, 158 },
-    { "gray63", 161, 161, 161 },
-    { "gray64", 163, 163, 163 },
-    { "gray65", 166, 166, 166 },
-    { "gray66", 168, 168, 168 },
-    { "gray67", 171, 171, 171 },
-    { "gray68", 173, 173, 173 },
-    { "gray69", 176, 176, 176 },
-    { "gray7", 18, 18, 18 },
-    { "gray70", 179, 179, 179 },
-    { "gray71", 181, 181, 181 },
-    { "gray72", 184, 184, 184 },
-    { "gray73", 186, 186, 186 },
-    { "gray74", 189, 189, 189 },
-    { "gray75", 191, 191, 191 },
-    { "gray76", 194, 194, 194 },
-    { "gray77", 196, 196, 196 },
-    { "gray78", 199, 199, 199 },
-    { "gray79", 201, 201, 201 },
-    { "gray8", 20, 20, 20 },
-    { "gray80", 204, 204, 204 },
-    { "gray81", 207, 207, 207 },
-    { "gray82", 209, 209, 209 },
-    { "gray83", 212, 212, 212 },
-    { "gray84", 214, 214, 214 },
-    { "gray85", 217, 217, 217 },
-    { "gray86", 219, 219, 219 },
-    { "gray87", 222, 222, 222 },
-    { "gray88", 224, 224, 224 },
-    { "gray89", 227, 227, 227 },
-    { "gray9", 23, 23, 23 },
-    { "gray90", 229, 229, 229 },
-    { "gray91", 232, 232, 232 },
-    { "gray92", 235, 235, 235 },
-    { "gray93", 237, 237, 237 },
-    { "gray94", 240, 240, 240 },
-    { "gray95", 242, 242, 242 },
-    { "gray96", 245, 245, 245 },
-    { "gray97", 247, 247, 247 },
-    { "gray98", 250, 250, 250 },
-    { "gray99", 252, 252, 252 },
-    { "green", 0, 255, 0 },
-    { "green yellow", 173, 255, 47 },
-    { "green1", 0, 255, 0 },
-    { "green2", 0, 238, 0 },
-    { "green3", 0, 205, 0 },
-    { "green4", 0, 139, 0 },
-    { "GreenYellow", 173, 255, 47 },
-    { "grey", 190, 190, 190 },
-    { "grey0", 0, 0, 0 },
-    { "grey1", 3, 3, 3 },
-    { "grey10", 26, 26, 26 },
-    { "grey100", 255, 255, 255 },
-    { "grey11", 28, 28, 28 },
-    { "grey12", 31, 31, 31 },
-    { "grey13", 33, 33, 33 },
-    { "grey14", 36, 36, 36 },
-    { "grey15", 38, 38, 38 },
-    { "grey16", 41, 41, 41 },
-    { "grey17", 43, 43, 43 },
-    { "grey18", 46, 46, 46 },
-    { "grey19", 48, 48, 48 },
-    { "grey2", 5, 5, 5 },
-    { "grey20", 51, 51, 51 },
-    { "grey21", 54, 54, 54 },
-    { "grey22", 56, 56, 56 },
-    { "grey23", 59, 59, 59 },
-    { "grey24", 61, 61, 61 },
-    { "grey25", 64, 64, 64 },
-    { "grey26", 66, 66, 66 },
-    { "grey27", 69, 69, 69 },
-    { "grey28", 71, 71, 71 },
-    { "grey29", 74, 74, 74 },
-    { "grey3", 8, 8, 8 },
-    { "grey30", 77, 77, 77 },
-    { "grey31", 79, 79, 79 },
-    { "grey32", 82, 82, 82 },
-    { "grey33", 84, 84, 84 },
-    { "grey34", 87, 87, 87 },
-    { "grey35", 89, 89, 89 },
-    { "grey36", 92, 92, 92 },
-    { "grey37", 94, 94, 94 },
-    { "grey38", 97, 97, 97 },
-    { "grey39", 99, 99, 99 },
-    { "grey4", 10, 10, 10 },
-    { "grey40", 102, 102, 102 },
-    { "grey41", 105, 105, 105 },
-    { "grey42", 107, 107, 107 },
-    { "grey43", 110, 110, 110 },
-    { "grey44", 112, 112, 112 },
-    { "grey45", 115, 115, 115 },
-    { "grey46", 117, 117, 117 },
-    { "grey47", 120, 120, 120 },
-    { "grey48", 122, 122, 122 },
-    { "grey49", 125, 125, 125 },
-    { "grey5", 13, 13, 13 },
-    { "grey50", 127, 127, 127 },
-    { "grey51", 130, 130, 130 },
-    { "grey52", 133, 133, 133 },
-    { "grey53", 135, 135, 135 },
-    { "grey54", 138, 138, 138 },
-    { "grey55", 140, 140, 140 },
-    { "grey56", 143, 143, 143 },
-    { "grey57", 145, 145, 145 },
-    { "grey58", 148, 148, 148 },
-    { "grey59", 150, 150, 150 },
-    { "grey6", 15, 15, 15 },
-    { "grey60", 153, 153, 153 },
-    { "grey61", 156, 156, 156 },
-    { "grey62", 158, 158, 158 },
-    { "grey63", 161, 161, 161 },
-    { "grey64", 163, 163, 163 },
-    { "grey65", 166, 166, 166 },
-    { "grey66", 168, 168, 168 },
-    { "grey67", 171, 171, 171 },
-    { "grey68", 173, 173, 173 },
-    { "grey69", 176, 176, 176 },
-    { "grey7", 18, 18, 18 },
-    { "grey70", 179, 179, 179 },
-    { "grey71", 181, 181, 181 },
-    { "grey72", 184, 184, 184 },
-    { "grey73", 186, 186, 186 },
-    { "grey74", 189, 189, 189 },
-    { "grey75", 191, 191, 191 },
-    { "grey76", 194, 194, 194 },
-    { "grey77", 196, 196, 196 },
-    { "grey78", 199, 199, 199 },
-    { "grey79", 201, 201, 201 },
-    { "grey8", 20, 20, 20 },
-    { "grey80", 204, 204, 204 },
-    { "grey81", 207, 207, 207 },
-    { "grey82", 209, 209, 209 },
-    { "grey83", 212, 212, 212 },
-    { "grey84", 214, 214, 214 },
-    { "grey85", 217, 217, 217 },
-    { "grey86", 219, 219, 219 },
-    { "grey87", 222, 222, 222 },
-    { "grey88", 224, 224, 224 },
-    { "grey89", 227, 227, 227 },
-    { "grey9", 23, 23, 23 },
-    { "grey90", 229, 229, 229 },
-    { "grey91", 232, 232, 232 },
-    { "grey92", 235, 235, 235 },
-    { "grey93", 237, 237, 237 },
-    { "grey94", 240, 240, 240 },
-    { "grey95", 242, 242, 242 },
-    { "grey96", 245, 245, 245 },
-    { "grey97", 247, 247, 247 },
-    { "grey98", 250, 250, 250 },
-    { "grey99", 252, 252, 252 },
-    { "honeydew", 240, 255, 240 },
-    { "honeydew1", 240, 255, 240 },
-    { "honeydew2", 224, 238, 224 },
-    { "honeydew3", 193, 205, 193 },
-    { "honeydew4", 131, 139, 131 },
-    { "hot pink", 255, 105, 180 },
-    { "HotPink", 255, 105, 180 },
-    { "HotPink1", 255, 110, 180 },
-    { "HotPink2", 238, 106, 167 },
-    { "HotPink3", 205, 96, 144 },
-    { "HotPink4", 139, 58, 98 },
-    { "indian red", 205, 92, 92 },
-    { "IndianRed", 205, 92, 92 },
-    { "IndianRed1", 255, 106, 106 },
-    { "IndianRed2", 238, 99, 99 },
-    { "IndianRed3", 205, 85, 85 },
-    { "IndianRed4", 139, 58, 58 },
-    { "ivory", 255, 255, 240 },
-    { "ivory1", 255, 255, 240 },
-    { "ivory2", 238, 238, 224 },
-    { "ivory3", 205, 205, 193 },
-    { "ivory4", 139, 139, 131 },
-    { "khaki", 240, 230, 140 },
-    { "khaki1", 255, 246, 143 },
-    { "khaki2", 238, 230, 133 },
-    { "khaki3", 205, 198, 115 },
-    { "khaki4", 139, 134, 78 },
-    { "lavender", 230, 230, 250 },
-    { "lavender blush", 255, 240, 245 },
-    { "LavenderBlush", 255, 240, 245 },
-    { "LavenderBlush1", 255, 240, 245 },
-    { "LavenderBlush2", 238, 224, 229 },
-    { "LavenderBlush3", 205, 193, 197 },
-    { "LavenderBlush4", 139, 131, 134 },
-    { "lawn green", 124, 252, 0 },
-    { "LawnGreen", 124, 252, 0 },
-    { "lemon chiffon", 255, 250, 205 },
-    { "LemonChiffon", 255, 250, 205 },
-    { "LemonChiffon1", 255, 250, 205 },
-    { "LemonChiffon2", 238, 233, 191 },
-    { "LemonChiffon3", 205, 201, 165 },
-    { "LemonChiffon4", 139, 137, 112 },
-    { "light blue", 173, 216, 230 },
-    { "light coral", 240, 128, 128 },
-    { "light cyan", 224, 255, 255 },
-    { "light goldenrod", 238, 221, 130 },
-    { "light goldenrod yellow", 250, 250, 210 },
-    { "light gray", 211, 211, 211 },
-    { "light green", 144, 238, 144 },
-    { "light grey", 211, 211, 211 },
-    { "light pink", 255, 182, 193 },
-    { "light salmon", 255, 160, 122 },
-    { "light sea green", 32, 178, 170 },
-    { "light sky blue", 135, 206, 250 },
-    { "light slate blue", 132, 112, 255 },
-    { "light slate gray", 119, 136, 153 },
-    { "light slate grey", 119, 136, 153 },
-    { "light steel blue", 176, 196, 222 },
-    { "light yellow", 255, 255, 224 },
-    { "LightBlue", 173, 216, 230 },
-    { "LightBlue1", 191, 239, 255 },
-    { "LightBlue2", 178, 223, 238 },
-    { "LightBlue3", 154, 192, 205 },
-    { "LightBlue4", 104, 131, 139 },
-    { "LightCoral", 240, 128, 128 },
-    { "LightCyan", 224, 255, 255 },
-    { "LightCyan1", 224, 255, 255 },
-    { "LightCyan2", 209, 238, 238 },
-    { "LightCyan3", 180, 205, 205 },
-    { "LightCyan4", 122, 139, 139 },
-    { "LightGoldenrod", 238, 221, 130 },
-    { "LightGoldenrod1", 255, 236, 139 },
-    { "LightGoldenrod2", 238, 220, 130 },
-    { "LightGoldenrod3", 205, 190, 112 },
-    { "LightGoldenrod4", 139, 129, 76 },
-    { "LightGoldenrodYellow", 250, 250, 210 },
-    { "LightGray", 211, 211, 211 },
-    { "LightGreen", 144, 238, 144 },
-    { "LightGrey", 211, 211, 211 },
-    { "LightPink", 255, 182, 193 },
-    { "LightPink1", 255, 174, 185 },
-    { "LightPink2", 238, 162, 173 },
-    { "LightPink3", 205, 140, 149 },
-    { "LightPink4", 139, 95, 101 },
-    { "LightSalmon", 255, 160, 122 },
-    { "LightSalmon1", 255, 160, 122 },
-    { "LightSalmon2", 238, 149, 114 },
-    { "LightSalmon3", 205, 129, 98 },
-    { "LightSalmon4", 139, 87, 66 },
-    { "LightSeaGreen", 32, 178, 170 },
-    { "LightSkyBlue", 135, 206, 250 },
-    { "LightSkyBlue1", 176, 226, 255 },
-    { "LightSkyBlue2", 164, 211, 238 },
-    { "LightSkyBlue3", 141, 182, 205 },
-    { "LightSkyBlue4", 96, 123, 139 },
-    { "LightSlateBlue", 132, 112, 255 },
-    { "LightSlateGray", 119, 136, 153 },
-    { "LightSlateGrey", 119, 136, 153 },
-    { "LightSteelBlue", 176, 196, 222 },
-    { "LightSteelBlue1", 202, 225, 255 },
-    { "LightSteelBlue2", 188, 210, 238 },
-    { "LightSteelBlue3", 162, 181, 205 },
-    { "LightSteelBlue4", 110, 123, 139 },
-    { "LightYellow", 255, 255, 224 },
-    { "LightYellow1", 255, 255, 224 },
-    { "LightYellow2", 238, 238, 209 },
-    { "LightYellow3", 205, 205, 180 },
-    { "LightYellow4", 139, 139, 122 },
-    { "lime green", 50, 205, 50 },
-    { "LimeGreen", 50, 205, 50 },
-    { "linen", 250, 240, 230 },
-    { "magenta", 255, 0, 255 },
-    { "magenta1", 255, 0, 255 },
-    { "magenta2", 238, 0, 238 },
-    { "magenta3", 205, 0, 205 },
-    { "magenta4", 139, 0, 139 },
-    { "maroon", 176, 48, 96 },
-    { "maroon1", 255, 52, 179 },
-    { "maroon2", 238, 48, 167 },
-    { "maroon3", 205, 41, 144 },
-    { "maroon4", 139, 28, 98 },
-    { "medium aquamarine", 102, 205, 170 },
-    { "medium blue", 0, 0, 205 },
-    { "medium orchid", 186, 85, 211 },
-    { "medium purple", 147, 112, 219 },
-    { "medium sea green", 60, 179, 113 },
-    { "medium slate blue", 123, 104, 238 },
-    { "medium spring green", 0, 250, 154 },
-    { "medium turquoise", 72, 209, 204 },
-    { "medium violet red", 199, 21, 133 },
-    { "MediumAquamarine", 102, 205, 170 },
-    { "MediumBlue", 0, 0, 205 },
-    { "MediumOrchid", 186, 85, 211 },
-    { "MediumOrchid1", 224, 102, 255 },
-    { "MediumOrchid2", 209, 95, 238 },
-    { "MediumOrchid3", 180, 82, 205 },
-    { "MediumOrchid4", 122, 55, 139 },
-    { "MediumPurple", 147, 112, 219 },
-    { "MediumPurple1", 171, 130, 255 },
-    { "MediumPurple2", 159, 121, 238 },
-    { "MediumPurple3", 137, 104, 205 },
-    { "MediumPurple4", 93, 71, 139 },
-    { "MediumSeaGreen", 60, 179, 113 },
-    { "MediumSlateBlue", 123, 104, 238 },
-    { "MediumSpringGreen", 0, 250, 154 },
-    { "MediumTurquoise", 72, 209, 204 },
-    { "MediumVioletRed", 199, 21, 133 },
-    { "midnight blue", 25, 25, 112 },
-    { "MidnightBlue", 25, 25, 112 },
-    { "mint cream", 245, 255, 250 },
-    { "MintCream", 245, 255, 250 },
-    { "misty rose", 255, 228, 225 },
-    { "MistyRose", 255, 228, 225 },
-    { "MistyRose1", 255, 228, 225 },
-    { "MistyRose2", 238, 213, 210 },
-    { "MistyRose3", 205, 183, 181 },
-    { "MistyRose4", 139, 125, 123 },
-    { "moccasin", 255, 228, 181 },
-    { "navajo white", 255, 222, 173 },
-    { "NavajoWhite", 255, 222, 173 },
-    { "NavajoWhite1", 255, 222, 173 },
-    { "NavajoWhite2", 238, 207, 161 },
-    { "NavajoWhite3", 205, 179, 139 },
-    { "NavajoWhite4", 139, 121, 94 },
-    { "navy", 0, 0, 128 },
-    { "navy blue", 0, 0, 128 },
-    { "NavyBlue", 0, 0, 128 },
-    { "old lace", 253, 245, 230 },
-    { "OldLace", 253, 245, 230 },
-    { "olive drab", 107, 142, 35 },
-    { "OliveDrab", 107, 142, 35 },
-    { "OliveDrab1", 192, 255, 62 },
-    { "OliveDrab2", 179, 238, 58 },
-    { "OliveDrab3", 154, 205, 50 },
-    { "OliveDrab4", 105, 139, 34 },
-    { "orange", 255, 165, 0 },
-    { "orange red", 255, 69, 0 },
-    { "orange1", 255, 165, 0 },
-    { "orange2", 238, 154, 0 },
-    { "orange3", 205, 133, 0 },
-    { "orange4", 139, 90, 0 },
-    { "OrangeRed", 255, 69, 0 },
-    { "OrangeRed1", 255, 69, 0 },
-    { "OrangeRed2", 238, 64, 0 },
-    { "OrangeRed3", 205, 55, 0 },
-    { "OrangeRed4", 139, 37, 0 },
-    { "orchid", 218, 112, 214 },
-    { "orchid1", 255, 131, 250 },
-    { "orchid2", 238, 122, 233 },
-    { "orchid3", 205, 105, 201 },
-    { "orchid4", 139, 71, 137 },
-    { "pale goldenrod", 238, 232, 170 },
-    { "pale green", 152, 251, 152 },
-    { "pale turquoise", 175, 238, 238 },
-    { "pale violet red", 219, 112, 147 },
-    { "PaleGoldenrod", 238, 232, 170 },
-    { "PaleGreen", 152, 251, 152 },
-    { "PaleGreen1", 154, 255, 154 },
-    { "PaleGreen2", 144, 238, 144 },
-    { "PaleGreen3", 124, 205, 124 },
-    { "PaleGreen4", 84, 139, 84 },
-    { "PaleTurquoise", 175, 238, 238 },
-    { "PaleTurquoise1", 187, 255, 255 },
-    { "PaleTurquoise2", 174, 238, 238 },
-    { "PaleTurquoise3", 150, 205, 205 },
-    { "PaleTurquoise4", 102, 139, 139 },
-    { "PaleVioletRed", 219, 112, 147 },
-    { "PaleVioletRed1", 255, 130, 171 },
-    { "PaleVioletRed2", 238, 121, 159 },
-    { "PaleVioletRed3", 205, 104, 137 },
-    { "PaleVioletRed4", 139, 71, 93 },
-    { "papaya whip", 255, 239, 213 },
-    { "PapayaWhip", 255, 239, 213 },
-    { "peach puff", 255, 218, 185 },
-    { "PeachPuff", 255, 218, 185 },
-    { "PeachPuff1", 255, 218, 185 },
-    { "PeachPuff2", 238, 203, 173 },
-    { "PeachPuff3", 205, 175, 149 },
-    { "PeachPuff4", 139, 119, 101 },
-    { "peru", 205, 133, 63 },
-    { "pink", 255, 192, 203 },
-    { "pink1", 255, 181, 197 },
-    { "pink2", 238, 169, 184 },
-    { "pink3", 205, 145, 158 },
-    { "pink4", 139, 99, 108 },
-    { "plum", 221, 160, 221 },
-    { "plum1", 255, 187, 255 },
-    { "plum2", 238, 174, 238 },
-    { "plum3", 205, 150, 205 },
-    { "plum4", 139, 102, 139 },
-    { "powder blue", 176, 224, 230 },
-    { "PowderBlue", 176, 224, 230 },
-    { "purple", 160, 32, 240 },
-    { "purple1", 155, 48, 255 },
-    { "purple2", 145, 44, 238 },
-    { "purple3", 125, 38, 205 },
-    { "purple4", 85, 26, 139 },
-    { "red", 255, 0, 0 },
-    { "red1", 255, 0, 0 },
-    { "red2", 238, 0, 0 },
-    { "red3", 205, 0, 0 },
-    { "red4", 139, 0, 0 },
-    { "rosy brown", 188, 143, 143 },
-    { "RosyBrown", 188, 143, 143 },
-    { "RosyBrown1", 255, 193, 193 },
-    { "RosyBrown2", 238, 180, 180 },
-    { "RosyBrown3", 205, 155, 155 },
-    { "RosyBrown4", 139, 105, 105 },
-    { "royal blue", 65, 105, 225 },
-    { "RoyalBlue", 65, 105, 225 },
-    { "RoyalBlue1", 72, 118, 255 },
-    { "RoyalBlue2", 67, 110, 238 },
-    { "RoyalBlue3", 58, 95, 205 },
-    { "RoyalBlue4", 39, 64, 139 },
-    { "saddle brown", 139, 69, 19 },
-    { "SaddleBrown", 139, 69, 19 },
-    { "salmon", 250, 128, 114 },
-    { "salmon1", 255, 140, 105 },
-    { "salmon2", 238, 130, 98 },
-    { "salmon3", 205, 112, 84 },
-    { "salmon4", 139, 76, 57 },
-    { "sandy brown", 244, 164, 96 },
-    { "SandyBrown", 244, 164, 96 },
-    { "sea green", 46, 139, 87 },
-    { "SeaGreen", 46, 139, 87 },
-    { "SeaGreen1", 84, 255, 159 },
-    { "SeaGreen2", 78, 238, 148 },
-    { "SeaGreen3", 67, 205, 128 },
-    { "SeaGreen4", 46, 139, 87 },
-    { "seashell", 255, 245, 238 },
-    { "seashell1", 255, 245, 238 },
-    { "seashell2", 238, 229, 222 },
-    { "seashell3", 205, 197, 191 },
-    { "seashell4", 139, 134, 130 },
-    { "sienna", 160, 82, 45 },
-    { "sienna1", 255, 130, 71 },
-    { "sienna2", 238, 121, 66 },
-    { "sienna3", 205, 104, 57 },
-    { "sienna4", 139, 71, 38 },
-    { "sky blue", 135, 206, 235 },
-    { "SkyBlue", 135, 206, 235 },
-    { "SkyBlue1", 135, 206, 255 },
-    { "SkyBlue2", 126, 192, 238 },
-    { "SkyBlue3", 108, 166, 205 },
-    { "SkyBlue4", 74, 112, 139 },
-    { "slate blue", 106, 90, 205 },
-    { "slate gray", 112, 128, 144 },
-    { "slate grey", 112, 128, 144 },
-    { "SlateBlue", 106, 90, 205 },
-    { "SlateBlue1", 131, 111, 255 },
-    { "SlateBlue2", 122, 103, 238 },
-    { "SlateBlue3", 105, 89, 205 },
-    { "SlateBlue4", 71, 60, 139 },
-    { "SlateGray", 112, 128, 144 },
-    { "SlateGray1", 198, 226, 255 },
-    { "SlateGray2", 185, 211, 238 },
-    { "SlateGray3", 159, 182, 205 },
-    { "SlateGray4", 108, 123, 139 },
-    { "SlateGrey", 112, 128, 144 },
-    { "snow", 255, 250, 250 },
-    { "snow1", 255, 250, 250 },
-    { "snow2", 238, 233, 233 },
-    { "snow3", 205, 201, 201 },
-    { "snow4", 139, 137, 137 },
-    { "spring green", 0, 255, 127 },
-    { "SpringGreen", 0, 255, 127 },
-    { "SpringGreen1", 0, 255, 127 },
-    { "SpringGreen2", 0, 238, 118 },
-    { "SpringGreen3", 0, 205, 102 },
-    { "SpringGreen4", 0, 139, 69 },
-    { "steel blue", 70, 130, 180 },
-    { "SteelBlue", 70, 130, 180 },
-    { "SteelBlue1", 99, 184, 255 },
-    { "SteelBlue2", 92, 172, 238 },
-    { "SteelBlue3", 79, 148, 205 },
-    { "SteelBlue4", 54, 100, 139 },
-    { "tan", 210, 180, 140 },
-    { "tan1", 255, 165, 79 },
-    { "tan2", 238, 154, 73 },
-    { "tan3", 205, 133, 63 },
-    { "tan4", 139, 90, 43 },
-    { "thistle", 216, 191, 216 },
-    { "thistle1", 255, 225, 255 },
-    { "thistle2", 238, 210, 238 },
-    { "thistle3", 205, 181, 205 },
-    { "thistle4", 139, 123, 139 },
-    { "tomato", 255, 99, 71 },
-    { "tomato1", 255, 99, 71 },
-    { "tomato2", 238, 92, 66 },
-    { "tomato3", 205, 79, 57 },
-    { "tomato4", 139, 54, 38 },
-    { "turquoise", 64, 224, 208 },
-    { "turquoise1", 0, 245, 255 },
-    { "turquoise2", 0, 229, 238 },
-    { "turquoise3", 0, 197, 205 },
-    { "turquoise4", 0, 134, 139 },
-    { "violet", 238, 130, 238 },
-    { "violet red", 208, 32, 144 },
-    { "VioletRed", 208, 32, 144 },
-    { "VioletRed1", 255, 62, 150 },
-    { "VioletRed2", 238, 58, 140 },
-    { "VioletRed3", 205, 50, 120 },
-    { "VioletRed4", 139, 34, 82 },
-    { "wheat", 245, 222, 179 },
-    { "wheat1", 255, 231, 186 },
-    { "wheat2", 238, 216, 174 },
-    { "wheat3", 205, 186, 150 },
-    { "wheat4", 139, 126, 102 },
-    { "white", 255, 255, 255 },
-    { "white smoke", 245, 245, 245 },
-    { "WhiteSmoke", 245, 245, 245 },
-    { "yellow", 255, 255, 0 },
-    { "yellow green", 154, 205, 50 },
-    { "yellow1", 255, 255, 0 },
-    { "yellow2", 238, 238, 0 },
-    { "yellow3", 205, 205, 0 },
-    { "yellow4", 139, 139, 0 },
-    { "YellowGreen", 154, 205, 50 }
-};
- 
-#define numXColors (sizeof (xColors) / sizeof (*xColors))
+#include "xpm-color-table.h"
  
 /*
  *----------------------------------------------------------------------
@@ -899,7 +137,7 @@
 compare_xcolor_entries (const void *a, const void *b)
 {
   return g_ascii_strcasecmp ((const char *) a, 
-			     ((const XPMColorEntry *) b)->name);
+			     color_names + ((const XPMColorEntry *)b)->name_offset);
 }
 
 static gboolean
@@ -908,7 +146,7 @@
 {
 	XPMColorEntry *found;
 
-	found = bsearch (name, xColors, numXColors, sizeof (XPMColorEntry),
+	found = bsearch (name, xColors, G_N_ELEMENTS (xColors), sizeof (XPMColorEntry),
 			 compare_xcolor_entries);
 	if (found == NULL)
 	  return FALSE;
@@ -1230,6 +468,15 @@
 		return NULL;
 	}
 	items = sscanf (buffer, "%d %d %d %d %d %d", &w, &h, &n_col, &cpp, &x_hot, &y_hot);
+
+	if (items != 4 && items != 6) {
+		g_set_error (error,
+                             GDK_PIXBUF_ERROR,
+                             GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
+                             _("Invalid XPM header"));
+		return NULL;
+	}
+
 	if (w <= 0) {
                 g_set_error (error,
                              GDK_PIXBUF_ERROR,
--- gtk+/gdk-pixbuf/io-gif.c	(.../2.6.4)	(revision 904)
+++ gtk+/gdk-pixbuf/io-gif.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -920,6 +920,34 @@
 
                         gdk_pixbuf_gif_anim_frame_composite (context->animation, prev_frame);
 
+                        /* Composite failed */
+                        if (prev_frame->composited == NULL) {
+                                GdkPixbufFrame *frame = NULL;
+                                link = g_list_first (context->animation->frames);
+                                while (link != NULL) {
+                                        frame = (GdkPixbufFrame *)link->data;
+                                        if (frame != NULL) {
+                                                if (frame->pixbuf != NULL)
+                                                        g_object_unref (frame->pixbuf);
+                                                if (frame->composited != NULL)
+                                                        g_object_unref (frame->composited);
+                                                if (frame->revert != NULL)
+                                                        g_object_unref (frame->revert);
+                                                g_free (frame);
+                                        }
+                                        link = link->next;
+                                }
+                                
+                                g_list_free (context->animation->frames);
+                                context->animation->frames = NULL;
+                                
+                                g_set_error (context->error,
+                                             GDK_PIXBUF_ERROR,
+                                             GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY,
+                                             _("Not enough memory to composite a frame in GIF file"));
+                                return -2;
+                        }
+                    
                         x = context->frame->x_offset;
                         y = context->frame->y_offset;
                         w = gdk_pixbuf_get_width (context->frame->pixbuf);
--- gtk+/gdk-pixbuf/io-ico.c	(.../2.6.4)	(revision 904)
+++ gtk+/gdk-pixbuf/io-ico.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -210,6 +210,14 @@
 	
  	State->HeaderSize = 6 + IconCount*16;
 
+	if (State->HeaderSize < 0) {
+		g_set_error (error,
+			     GDK_PIXBUF_ERROR,
+			     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
+			     _("Invalid header in icon"));
+		return;
+	}
+
  	if (State->HeaderSize>State->BytesInHeaderBuf) {
  		guchar *tmp=g_try_realloc(State->HeaderBuf,State->HeaderSize);
 		if (!tmp) {
@@ -261,6 +269,13 @@
 	   so we know how many bytes are in the "header" part. */
 	      
 	State->HeaderSize = State->DIBoffset + 40; /* 40 = sizeof(InfoHeader) */
+	if (State->HeaderSize < 0) {
+		g_set_error (error,
+			     GDK_PIXBUF_ERROR,
+			     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
+			     _("Invalid header in icon"));
+		return;
+	}
 	
  	if (State->HeaderSize>State->BytesInHeaderBuf) {
  		guchar *tmp=g_try_realloc(State->HeaderBuf,State->HeaderSize);
--- gtk+/gdk-pixbuf/gdk-pixbuf-features.h	(.../2.6.4)	(revision 904)
+++ gtk+/gdk-pixbuf/gdk-pixbuf-features.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -36,6 +36,6 @@
 GDK_PIXBUF_VAR const guint gdk_pixbuf_major_version;
 GDK_PIXBUF_VAR const guint gdk_pixbuf_minor_version;
 GDK_PIXBUF_VAR const guint gdk_pixbuf_micro_version;
-GDK_PIXBUF_VAR const char *gdk_pixbuf_version;
+GDK_PIXBUF_VAR const char gdk_pixbuf_version[];
 
 #endif
--- gtk+/gdk-pixbuf/io-bmp.c	(.../2.6.4)	(revision 904)
+++ gtk+/gdk-pixbuf/io-bmp.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -219,7 +219,19 @@
 static gboolean grow_buffer (struct bmp_progressive_state *State,
                              GError **error)
 {
-  guchar *tmp = g_try_realloc (State->buff, State->BufferSize);
+  guchar *tmp;
+
+  if (State->BufferSize == 0) {
+    g_set_error (error,
+		 GDK_PIXBUF_ERROR,
+		 GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
+		 _("BMP image has bogus header data"));
+    State->read_state = READ_STATE_ERROR;
+    return FALSE;
+  }
+
+  tmp = g_try_realloc (State->buff, State->BufferSize);
+
   if (!tmp) {
     g_set_error (error,
 		 GDK_PIXBUF_ERROR,
@@ -449,7 +461,7 @@
 		return TRUE;
 	}
 
-	State->Colormap = g_malloc ((1 << State->Header.depth) * sizeof (*State->Colormap));
+	State->Colormap = g_malloc0 ((1 << State->Header.depth) * sizeof (*State->Colormap));
 	for (i = 0; i < State->Header.n_colors; i++)
 
 	{
@@ -1031,7 +1043,7 @@
 			gint new_y = MIN (context->compr.y, context->Header.height);
 			(*context->updated_func) (context->pixbuf,
 						  0,
-						  y,
+						  context->Header.height - new_y,
 						  context->Header.width,
 						  new_y - y,
 						  context->user_data);
--- gtk+/gdk-pixbuf/io-jpeg.c	(.../2.6.4)	(revision 904)
+++ gtk+/gdk-pixbuf/io-jpeg.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -33,6 +33,7 @@
 #include <string.h>
 #include <setjmp.h>
 #include <jpeglib.h>
+#include <jerror.h>
 #include "gdk-pixbuf-private.h"
 #include "gdk-pixbuf-io.h"
 
@@ -110,7 +111,7 @@
         if (errmgr->error && *errmgr->error == NULL) {
                 g_set_error (errmgr->error,
                              GDK_PIXBUF_ERROR,
-                             GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
+                             cinfo->err->msg_code == JERR_OUT_OF_MEMORY ? GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY : GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
                              _("Error interpreting JPEG image file (%s)"),
                              buffer);
         }
--- gtk+/gdk-pixbuf/xpm-color-table.h	(.../2.6.4)	(revision 0)
+++ gtk+/gdk-pixbuf/xpm-color-table.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -0,0 +1,1521 @@
+/* xpm-color-table.h: Generated by gen-color-table.pl from rgb.txt
+ *
+ *  Date: Tue Mar  8 03:54:56 2005
+ *
+ * Do not edit.   
+ */
+static const char color_names[] =
+  "alice blue\0"
+  "AliceBlue\0"
+  "antique white\0"
+  "AntiqueWhite\0"
+  "AntiqueWhite1\0"
+  "AntiqueWhite2\0"
+  "AntiqueWhite3\0"
+  "AntiqueWhite4\0"
+  "aquamarine\0"
+  "aquamarine1\0"
+  "aquamarine2\0"
+  "aquamarine3\0"
+  "aquamarine4\0"
+  "azure\0"
+  "azure1\0"
+  "azure2\0"
+  "azure3\0"
+  "azure4\0"
+  "beige\0"
+  "bisque\0"
+  "bisque1\0"
+  "bisque2\0"
+  "bisque3\0"
+  "bisque4\0"
+  "black\0"
+  "blanched almond\0"
+  "BlanchedAlmond\0"
+  "blue\0"
+  "blue violet\0"
+  "blue1\0"
+  "blue2\0"
+  "blue3\0"
+  "blue4\0"
+  "BlueViolet\0"
+  "brown\0"
+  "brown1\0"
+  "brown2\0"
+  "brown3\0"
+  "brown4\0"
+  "burlywood\0"
+  "burlywood1\0"
+  "burlywood2\0"
+  "burlywood3\0"
+  "burlywood4\0"
+  "cadet blue\0"
+  "CadetBlue\0"
+  "CadetBlue1\0"
+  "CadetBlue2\0"
+  "CadetBlue3\0"
+  "CadetBlue4\0"
+  "chartreuse\0"
+  "chartreuse1\0"
+  "chartreuse2\0"
+  "chartreuse3\0"
+  "chartreuse4\0"
+  "chocolate\0"
+  "chocolate1\0"
+  "chocolate2\0"
+  "chocolate3\0"
+  "chocolate4\0"
+  "coral\0"
+  "coral1\0"
+  "coral2\0"
+  "coral3\0"
+  "coral4\0"
+  "cornflower blue\0"
+  "CornflowerBlue\0"
+  "cornsilk\0"
+  "cornsilk1\0"
+  "cornsilk2\0"
+  "cornsilk3\0"
+  "cornsilk4\0"
+  "cyan\0"
+  "cyan1\0"
+  "cyan2\0"
+  "cyan3\0"
+  "cyan4\0"
+  "dark blue\0"
+  "dark cyan\0"
+  "dark goldenrod\0"
+  "dark gray\0"
+  "dark green\0"
+  "dark grey\0"
+  "dark khaki\0"
+  "dark magenta\0"
+  "dark olive green\0"
+  "dark orange\0"
+  "dark orchid\0"
+  "dark red\0"
+  "dark salmon\0"
+  "dark sea green\0"
+  "dark slate blue\0"
+  "dark slate gray\0"
+  "dark slate grey\0"
+  "dark turquoise\0"
+  "dark violet\0"
+  "DarkBlue\0"
+  "DarkCyan\0"
+  "DarkGoldenrod\0"
+  "DarkGoldenrod1\0"
+  "DarkGoldenrod2\0"
+  "DarkGoldenrod3\0"
+  "DarkGoldenrod4\0"
+  "DarkGray\0"
+  "DarkGreen\0"
+  "DarkGrey\0"
+  "DarkKhaki\0"
+  "DarkMagenta\0"
+  "DarkOliveGreen\0"
+  "DarkOliveGreen1\0"
+  "DarkOliveGreen2\0"
+  "DarkOliveGreen3\0"
+  "DarkOliveGreen4\0"
+  "DarkOrange\0"
+  "DarkOrange1\0"
+  "DarkOrange2\0"
+  "DarkOrange3\0"
+  "DarkOrange4\0"
+  "DarkOrchid\0"
+  "DarkOrchid1\0"
+  "DarkOrchid2\0"
+  "DarkOrchid3\0"
+  "DarkOrchid4\0"
+  "DarkRed\0"
+  "DarkSalmon\0"
+  "DarkSeaGreen\0"
+  "DarkSeaGreen1\0"
+  "DarkSeaGreen2\0"
+  "DarkSeaGreen3\0"
+  "DarkSeaGreen4\0"
+  "DarkSlateBlue\0"
+  "DarkSlateGray\0"
+  "DarkSlateGray1\0"
+  "DarkSlateGray2\0"
+  "DarkSlateGray3\0"
+  "DarkSlateGray4\0"
+  "DarkSlateGrey\0"
+  "DarkTurquoise\0"
+  "DarkViolet\0"
+  "deep pink\0"
+  "deep sky blue\0"
+  "DeepPink\0"
+  "DeepPink1\0"
+  "DeepPink2\0"
+  "DeepPink3\0"
+  "DeepPink4\0"
+  "DeepSkyBlue\0"
+  "DeepSkyBlue1\0"
+  "DeepSkyBlue2\0"
+  "DeepSkyBlue3\0"
+  "DeepSkyBlue4\0"
+  "dim gray\0"
+  "dim grey\0"
+  "DimGray\0"
+  "DimGrey\0"
+  "dodger blue\0"
+  "DodgerBlue\0"
+  "DodgerBlue1\0"
+  "DodgerBlue2\0"
+  "DodgerBlue3\0"
+  "DodgerBlue4\0"
+  "firebrick\0"
+  "firebrick1\0"
+  "firebrick2\0"
+  "firebrick3\0"
+  "firebrick4\0"
+  "floral white\0"
+  "FloralWhite\0"
+  "forest green\0"
+  "ForestGreen\0"
+  "gainsboro\0"
+  "ghost white\0"
+  "GhostWhite\0"
+  "gold\0"
+  "gold1\0"
+  "gold2\0"
+  "gold3\0"
+  "gold4\0"
+  "goldenrod\0"
+  "goldenrod1\0"
+  "goldenrod2\0"
+  "goldenrod3\0"
+  "goldenrod4\0"
+  "gray\0"
+  "gray0\0"
+  "gray1\0"
+  "gray10\0"
+  "gray100\0"
+  "gray11\0"
+  "gray12\0"
+  "gray13\0"
+  "gray14\0"
+  "gray15\0"
+  "gray16\0"
+  "gray17\0"
+  "gray18\0"
+  "gray19\0"
+  "gray2\0"
+  "gray20\0"
+  "gray21\0"
+  "gray22\0"
+  "gray23\0"
+  "gray24\0"
+  "gray25\0"
+  "gray26\0"
+  "gray27\0"
+  "gray28\0"
+  "gray29\0"
+  "gray3\0"
+  "gray30\0"
+  "gray31\0"
+  "gray32\0"
+  "gray33\0"
+  "gray34\0"
+  "gray35\0"
+  "gray36\0"
+  "gray37\0"
+  "gray38\0"
+  "gray39\0"
+  "gray4\0"
+  "gray40\0"
+  "gray41\0"
+  "gray42\0"
+  "gray43\0"
+  "gray44\0"
+  "gray45\0"
+  "gray46\0"
+  "gray47\0"
+  "gray48\0"
+  "gray49\0"
+  "gray5\0"
+  "gray50\0"
+  "gray51\0"
+  "gray52\0"
+  "gray53\0"
+  "gray54\0"
+  "gray55\0"
+  "gray56\0"
+  "gray57\0"
+  "gray58\0"
+  "gray59\0"
+  "gray6\0"
+  "gray60\0"
+  "gray61\0"
+  "gray62\0"
+  "gray63\0"
+  "gray64\0"
+  "gray65\0"
+  "gray66\0"
+  "gray67\0"
+  "gray68\0"
+  "gray69\0"
+  "gray7\0"
+  "gray70\0"
+  "gray71\0"
+  "gray72\0"
+  "gray73\0"
+  "gray74\0"
+  "gray75\0"
+  "gray76\0"
+  "gray77\0"
+  "gray78\0"
+  "gray79\0"
+  "gray8\0"
+  "gray80\0"
+  "gray81\0"
+  "gray82\0"
+  "gray83\0"
+  "gray84\0"
+  "gray85\0"
+  "gray86\0"
+  "gray87\0"
+  "gray88\0"
+  "gray89\0"
+  "gray9\0"
+  "gray90\0"
+  "gray91\0"
+  "gray92\0"
+  "gray93\0"
+  "gray94\0"
+  "gray95\0"
+  "gray96\0"
+  "gray97\0"
+  "gray98\0"
+  "gray99\0"
+  "green\0"
+  "green yellow\0"
+  "green1\0"
+  "green2\0"
+  "green3\0"
+  "green4\0"
+  "GreenYellow\0"
+  "grey\0"
+  "grey0\0"
+  "grey1\0"
+  "grey10\0"
+  "grey100\0"
+  "grey11\0"
+  "grey12\0"
+  "grey13\0"
+  "grey14\0"
+  "grey15\0"
+  "grey16\0"
+  "grey17\0"
+  "grey18\0"
+  "grey19\0"
+  "grey2\0"
+  "grey20\0"
+  "grey21\0"
+  "grey22\0"
+  "grey23\0"
+  "grey24\0"
+  "grey25\0"
+  "grey26\0"
+  "grey27\0"
+  "grey28\0"
+  "grey29\0"
+  "grey3\0"
+  "grey30\0"
+  "grey31\0"
+  "grey32\0"
+  "grey33\0"
+  "grey34\0"
+  "grey35\0"
+  "grey36\0"
+  "grey37\0"
+  "grey38\0"
+  "grey39\0"
+  "grey4\0"
+  "grey40\0"
+  "grey41\0"
+  "grey42\0"
+  "grey43\0"
+  "grey44\0"
+  "grey45\0"
+  "grey46\0"
+  "grey47\0"
+  "grey48\0"
+  "grey49\0"
+  "grey5\0"
+  "grey50\0"
+  "grey51\0"
+  "grey52\0"
+  "grey53\0"
+  "grey54\0"
+  "grey55\0"
+  "grey56\0"
+  "grey57\0"
+  "grey58\0"
+  "grey59\0"
+  "grey6\0"
+  "grey60\0"
+  "grey61\0"
+  "grey62\0"
+  "grey63\0"
+  "grey64\0"
+  "grey65\0"
+  "grey66\0"
+  "grey67\0"
+  "grey68\0"
+  "grey69\0"
+  "grey7\0"
+  "grey70\0"
+  "grey71\0"
+  "grey72\0"
+  "grey73\0"
+  "grey74\0"
+  "grey75\0"
+  "grey76\0"
+  "grey77\0"
+  "grey78\0"
+  "grey79\0"
+  "grey8\0"
+  "grey80\0"
+  "grey81\0"
+  "grey82\0"
+  "grey83\0"
+  "grey84\0"
+  "grey85\0"
+  "grey86\0"
+  "grey87\0"
+  "grey88\0"
+  "grey89\0"
+  "grey9\0"
+  "grey90\0"
+  "grey91\0"
+  "grey92\0"
+  "grey93\0"
+  "grey94\0"
+  "grey95\0"
+  "grey96\0"
+  "grey97\0"
+  "grey98\0"
+  "grey99\0"
+  "honeydew\0"
+  "honeydew1\0"
+  "honeydew2\0"
+  "honeydew3\0"
+  "honeydew4\0"
+  "hot pink\0"
+  "HotPink\0"
+  "HotPink1\0"
+  "HotPink2\0"
+  "HotPink3\0"
+  "HotPink4\0"
+  "indian red\0"
+  "IndianRed\0"
+  "IndianRed1\0"
+  "IndianRed2\0"
+  "IndianRed3\0"
+  "IndianRed4\0"
+  "ivory\0"
+  "ivory1\0"
+  "ivory2\0"
+  "ivory3\0"
+  "ivory4\0"
+  "khaki\0"
+  "khaki1\0"
+  "khaki2\0"
+  "khaki3\0"
+  "khaki4\0"
+  "lavender\0"
+  "lavender blush\0"
+  "LavenderBlush\0"
+  "LavenderBlush1\0"
+  "LavenderBlush2\0"
+  "LavenderBlush3\0"
+  "LavenderBlush4\0"
+  "lawn green\0"
+  "LawnGreen\0"
+  "lemon chiffon\0"
+  "LemonChiffon\0"
+  "LemonChiffon1\0"
+  "LemonChiffon2\0"
+  "LemonChiffon3\0"
+  "LemonChiffon4\0"
+  "light blue\0"
+  "light coral\0"
+  "light cyan\0"
+  "light goldenrod\0"
+  "light goldenrod yellow\0"
+  "light gray\0"
+  "light green\0"
+  "light grey\0"
+  "light pink\0"
+  "light salmon\0"
+  "light sea green\0"
+  "light sky blue\0"
+  "light slate blue\0"
+  "light slate gray\0"
+  "light slate grey\0"
+  "light steel blue\0"
+  "light yellow\0"
+  "LightBlue\0"
+  "LightBlue1\0"
+  "LightBlue2\0"
+  "LightBlue3\0"
+  "LightBlue4\0"
+  "LightCoral\0"
+  "LightCyan\0"
+  "LightCyan1\0"
+  "LightCyan2\0"
+  "LightCyan3\0"
+  "LightCyan4\0"
+  "LightGoldenrod\0"
+  "LightGoldenrod1\0"
+  "LightGoldenrod2\0"
+  "LightGoldenrod3\0"
+  "LightGoldenrod4\0"
+  "LightGoldenrodYellow\0"
+  "LightGray\0"
+  "LightGreen\0"
+  "LightGrey\0"
+  "LightPink\0"
+  "LightPink1\0"
+  "LightPink2\0"
+  "LightPink3\0"
+  "LightPink4\0"
+  "LightSalmon\0"
+  "LightSalmon1\0"
+  "LightSalmon2\0"
+  "LightSalmon3\0"
+  "LightSalmon4\0"
+  "LightSeaGreen\0"
+  "LightSkyBlue\0"
+  "LightSkyBlue1\0"
+  "LightSkyBlue2\0"
+  "LightSkyBlue3\0"
+  "LightSkyBlue4\0"
+  "LightSlateBlue\0"
+  "LightSlateGray\0"
+  "LightSlateGrey\0"
+  "LightSteelBlue\0"
+  "LightSteelBlue1\0"
+  "LightSteelBlue2\0"
+  "LightSteelBlue3\0"
+  "LightSteelBlue4\0"
+  "LightYellow\0"
+  "LightYellow1\0"
+  "LightYellow2\0"
+  "LightYellow3\0"
+  "LightYellow4\0"
+  "lime green\0"
+  "LimeGreen\0"
+  "linen\0"
+  "magenta\0"
+  "magenta1\0"
+  "magenta2\0"
+  "magenta3\0"
+  "magenta4\0"
+  "maroon\0"
+  "maroon1\0"
+  "maroon2\0"
+  "maroon3\0"
+  "maroon4\0"
+  "medium aquamarine\0"
+  "medium blue\0"
+  "medium orchid\0"
+  "medium purple\0"
+  "medium sea green\0"
+  "medium slate blue\0"
+  "medium spring green\0"
+  "medium turquoise\0"
+  "medium violet red\0"
+  "MediumAquamarine\0"
+  "MediumBlue\0"
+  "MediumOrchid\0"
+  "MediumOrchid1\0"
+  "MediumOrchid2\0"
+  "MediumOrchid3\0"
+  "MediumOrchid4\0"
+  "MediumPurple\0"
+  "MediumPurple1\0"
+  "MediumPurple2\0"
+  "MediumPurple3\0"
+  "MediumPurple4\0"
+  "MediumSeaGreen\0"
+  "MediumSlateBlue\0"
+  "MediumSpringGreen\0"
+  "MediumTurquoise\0"
+  "MediumVioletRed\0"
+  "midnight blue\0"
+  "MidnightBlue\0"
+  "mint cream\0"
+  "MintCream\0"
+  "misty rose\0"
+  "MistyRose\0"
+  "MistyRose1\0"
+  "MistyRose2\0"
+  "MistyRose3\0"
+  "MistyRose4\0"
+  "moccasin\0"
+  "navajo white\0"
+  "NavajoWhite\0"
+  "NavajoWhite1\0"
+  "NavajoWhite2\0"
+  "NavajoWhite3\0"
+  "NavajoWhite4\0"
+  "navy\0"
+  "navy blue\0"
+  "NavyBlue\0"
+  "old lace\0"
+  "OldLace\0"
+  "olive drab\0"
+  "OliveDrab\0"
+  "OliveDrab1\0"
+  "OliveDrab2\0"
+  "OliveDrab3\0"
+  "OliveDrab4\0"
+  "orange\0"
+  "orange red\0"
+  "orange1\0"
+  "orange2\0"
+  "orange3\0"
+  "orange4\0"
+  "OrangeRed\0"
+  "OrangeRed1\0"
+  "OrangeRed2\0"
+  "OrangeRed3\0"
+  "OrangeRed4\0"
+  "orchid\0"
+  "orchid1\0"
+  "orchid2\0"
+  "orchid3\0"
+  "orchid4\0"
+  "pale goldenrod\0"
+  "pale green\0"
+  "pale turquoise\0"
+  "pale violet red\0"
+  "PaleGoldenrod\0"
+  "PaleGreen\0"
+  "PaleGreen1\0"
+  "PaleGreen2\0"
+  "PaleGreen3\0"
+  "PaleGreen4\0"
+  "PaleTurquoise\0"
+  "PaleTurquoise1\0"
+  "PaleTurquoise2\0"
+  "PaleTurquoise3\0"
+  "PaleTurquoise4\0"
+  "PaleVioletRed\0"
+  "PaleVioletRed1\0"
+  "PaleVioletRed2\0"
+  "PaleVioletRed3\0"
+  "PaleVioletRed4\0"
+  "papaya whip\0"
+  "PapayaWhip\0"
+  "peach puff\0"
+  "PeachPuff\0"
+  "PeachPuff1\0"
+  "PeachPuff2\0"
+  "PeachPuff3\0"
+  "PeachPuff4\0"
+  "peru\0"
+  "pink\0"
+  "pink1\0"
+  "pink2\0"
+  "pink3\0"
+  "pink4\0"
+  "plum\0"
+  "plum1\0"
+  "plum2\0"
+  "plum3\0"
+  "plum4\0"
+  "powder blue\0"
+  "PowderBlue\0"
+  "purple\0"
+  "purple1\0"
+  "purple2\0"
+  "purple3\0"
+  "purple4\0"
+  "red\0"
+  "red1\0"
+  "red2\0"
+  "red3\0"
+  "red4\0"
+  "rosy brown\0"
+  "RosyBrown\0"
+  "RosyBrown1\0"
+  "RosyBrown2\0"
+  "RosyBrown3\0"
+  "RosyBrown4\0"
+  "royal blue\0"
+  "RoyalBlue\0"
+  "RoyalBlue1\0"
+  "RoyalBlue2\0"
+  "RoyalBlue3\0"
+  "RoyalBlue4\0"
+  "saddle brown\0"
+  "SaddleBrown\0"
+  "salmon\0"
+  "salmon1\0"
+  "salmon2\0"
+  "salmon3\0"
+  "salmon4\0"
+  "sandy brown\0"
+  "SandyBrown\0"
+  "sea green\0"
+  "SeaGreen\0"
+  "SeaGreen1\0"
+  "SeaGreen2\0"
+  "SeaGreen3\0"
+  "SeaGreen4\0"
+  "seashell\0"
+  "seashell1\0"
+  "seashell2\0"
+  "seashell3\0"
+  "seashell4\0"
+  "sienna\0"
+  "sienna1\0"
+  "sienna2\0"
+  "sienna3\0"
+  "sienna4\0"
+  "sky blue\0"
+  "SkyBlue\0"
+  "SkyBlue1\0"
+  "SkyBlue2\0"
+  "SkyBlue3\0"
+  "SkyBlue4\0"
+  "slate blue\0"
+  "slate gray\0"
+  "slate grey\0"
+  "SlateBlue\0"
+  "SlateBlue1\0"
+  "SlateBlue2\0"
+  "SlateBlue3\0"
+  "SlateBlue4\0"
+  "SlateGray\0"
+  "SlateGray1\0"
+  "SlateGray2\0"
+  "SlateGray3\0"
+  "SlateGray4\0"
+  "SlateGrey\0"
+  "snow\0"
+  "snow1\0"
+  "snow2\0"
+  "snow3\0"
+  "snow4\0"
+  "spring green\0"
+  "SpringGreen\0"
+  "SpringGreen1\0"
+  "SpringGreen2\0"
+  "SpringGreen3\0"
+  "SpringGreen4\0"
+  "steel blue\0"
+  "SteelBlue\0"
+  "SteelBlue1\0"
+  "SteelBlue2\0"
+  "SteelBlue3\0"
+  "SteelBlue4\0"
+  "tan\0"
+  "tan1\0"
+  "tan2\0"
+  "tan3\0"
+  "tan4\0"
+  "thistle\0"
+  "thistle1\0"
+  "thistle2\0"
+  "thistle3\0"
+  "thistle4\0"
+  "tomato\0"
+  "tomato1\0"
+  "tomato2\0"
+  "tomato3\0"
+  "tomato4\0"
+  "turquoise\0"
+  "turquoise1\0"
+  "turquoise2\0"
+  "turquoise3\0"
+  "turquoise4\0"
+  "violet\0"
+  "violet red\0"
+  "VioletRed\0"
+  "VioletRed1\0"
+  "VioletRed2\0"
+  "VioletRed3\0"
+  "VioletRed4\0"
+  "wheat\0"
+  "wheat1\0"
+  "wheat2\0"
+  "wheat3\0"
+  "wheat4\0"
+  "white\0"
+  "white smoke\0"
+  "WhiteSmoke\0"
+  "yellow\0"
+  "yellow green\0"
+  "yellow1\0"
+  "yellow2\0"
+  "yellow3\0"
+  "yellow4\0"
+  "YellowGreen\0";
+
+typedef struct {
+    guint16 name_offset;
+    guchar red;
+    guchar green;
+    guchar blue;
+} XPMColorEntry;
+
+static const XPMColorEntry xColors[] = {
+  { 0, 240, 248, 255 },
+  { 11, 240, 248, 255 },
+  { 21, 250, 235, 215 },
+  { 35, 250, 235, 215 },
+  { 48, 255, 239, 219 },
+  { 62, 238, 223, 204 },
+  { 76, 205, 192, 176 },
+  { 90, 139, 131, 120 },
+  { 104, 127, 255, 212 },
+  { 115, 127, 255, 212 },
+  { 127, 118, 238, 198 },
+  { 139, 102, 205, 170 },
+  { 151, 69, 139, 116 },
+  { 163, 240, 255, 255 },
+  { 169, 240, 255, 255 },
+  { 176, 224, 238, 238 },
+  { 183, 193, 205, 205 },
+  { 190, 131, 139, 139 },
+  { 197, 245, 245, 220 },
+  { 203, 255, 228, 196 },
+  { 210, 255, 228, 196 },
+  { 218, 238, 213, 183 },
+  { 226, 205, 183, 158 },
+  { 234, 139, 125, 107 },
+  { 242, 0, 0, 0 },
+  { 248, 255, 235, 205 },
+  { 264, 255, 235, 205 },
+  { 279, 0, 0, 255 },
+  { 284, 138, 43, 226 },
+  { 296, 0, 0, 255 },
+  { 302, 0, 0, 238 },
+  { 308, 0, 0, 205 },
+  { 314, 0, 0, 139 },
+  { 320, 138, 43, 226 },
+  { 331, 165, 42, 42 },
+  { 337, 255, 64, 64 },
+  { 344, 238, 59, 59 },
+  { 351, 205, 51, 51 },
+  { 358, 139, 35, 35 },
+  { 365, 222, 184, 135 },
+  { 375, 255, 211, 155 },
+  { 386, 238, 197, 145 },
+  { 397, 205, 170, 125 },
+  { 408, 139, 115, 85 },
+  { 419, 95, 158, 160 },
+  { 430, 95, 158, 160 },
+  { 440, 152, 245, 255 },
+  { 451, 142, 229, 238 },
+  { 462, 122, 197, 205 },
+  { 473, 83, 134, 139 },
+  { 484, 127, 255, 0 },
+  { 495, 127, 255, 0 },
+  { 507, 118, 238, 0 },
+  { 519, 102, 205, 0 },
+  { 531, 69, 139, 0 },
+  { 543, 210, 105, 30 },
+  { 553, 255, 127, 36 },
+  { 564, 238, 118, 33 },
+  { 575, 205, 102, 29 },
+  { 586, 139, 69, 19 },
+  { 597, 255, 127, 80 },
+  { 603, 255, 114, 86 },
+  { 610, 238, 106, 80 },
+  { 617, 205, 91, 69 },
+  { 624, 139, 62, 47 },
+  { 631, 100, 149, 237 },
+  { 647, 100, 149, 237 },
+  { 662, 255, 248, 220 },
+  { 671, 255, 248, 220 },
+  { 681, 238, 232, 205 },
+  { 691, 205, 200, 177 },
+  { 701, 139, 136, 120 },
+  { 711, 0, 255, 255 },
+  { 716, 0, 255, 255 },
+  { 722, 0, 238, 238 },
+  { 728, 0, 205, 205 },
+  { 734, 0, 139, 139 },
+  { 740, 0, 0, 139 },
+  { 750, 0, 139, 139 },
+  { 760, 184, 134, 11 },
+  { 775, 169, 169, 169 },
+  { 785, 0, 100, 0 },
+  { 796, 169, 169, 169 },
+  { 806, 189, 183, 107 },
+  { 817, 139, 0, 139 },
+  { 830, 85, 107, 47 },
+  { 847, 255, 140, 0 },
+  { 859, 153, 50, 204 },
+  { 871, 139, 0, 0 },
+  { 880, 233, 150, 122 },
+  { 892, 143, 188, 143 },
+  { 907, 72, 61, 139 },
+  { 923, 47, 79, 79 },
+  { 939, 47, 79, 79 },
+  { 955, 0, 206, 209 },
+  { 970, 148, 0, 211 },
+  { 982, 0, 0, 139 },
+  { 991, 0, 139, 139 },
+  { 1000, 184, 134, 11 },
+  { 1014, 255, 185, 15 },
+  { 1029, 238, 173, 14 },
+  { 1044, 205, 149, 12 },
+  { 1059, 139, 101, 8 },
+  { 1074, 169, 169, 169 },
+  { 1083, 0, 100, 0 },
+  { 1093, 169, 169, 169 },
+  { 1102, 189, 183, 107 },
+  { 1112, 139, 0, 139 },
+  { 1124, 85, 107, 47 },
+  { 1139, 202, 255, 112 },
+  { 1155, 188, 238, 104 },
+  { 1171, 162, 205, 90 },
+  { 1187, 110, 139, 61 },
+  { 1203, 255, 140, 0 },
+  { 1214, 255, 127, 0 },
+  { 1226, 238, 118, 0 },
+  { 1238, 205, 102, 0 },
+  { 1250, 139, 69, 0 },
+  { 1262, 153, 50, 204 },
+  { 1273, 191, 62, 255 },
+  { 1285, 178, 58, 238 },
+  { 1297, 154, 50, 205 },
+  { 1309, 104, 34, 139 },
+  { 1321, 139, 0, 0 },
+  { 1329, 233, 150, 122 },
+  { 1340, 143, 188, 143 },
+  { 1353, 193, 255, 193 },
+  { 1367, 180, 238, 180 },
+  { 1381, 155, 205, 155 },
+  { 1395, 105, 139, 105 },
+  { 1409, 72, 61, 139 },
+  { 1423, 47, 79, 79 },
+  { 1437, 151, 255, 255 },
+  { 1452, 141, 238, 238 },
+  { 1467, 121, 205, 205 },
+  { 1482, 82, 139, 139 },
+  { 1497, 47, 79, 79 },
+  { 1511, 0, 206, 209 },
+  { 1525, 148, 0, 211 },
+  { 1536, 255, 20, 147 },
+  { 1546, 0, 191, 255 },
+  { 1560, 255, 20, 147 },
+  { 1569, 255, 20, 147 },
+  { 1579, 238, 18, 137 },
+  { 1589, 205, 16, 118 },
+  { 1599, 139, 10, 80 },
+  { 1609, 0, 191, 255 },
+  { 1621, 0, 191, 255 },
+  { 1634, 0, 178, 238 },
+  { 1647, 0, 154, 205 },
+  { 1660, 0, 104, 139 },
+  { 1673, 105, 105, 105 },
+  { 1682, 105, 105, 105 },
+  { 1691, 105, 105, 105 },
+  { 1699, 105, 105, 105 },
+  { 1707, 30, 144, 255 },
+  { 1719, 30, 144, 255 },
+  { 1730, 30, 144, 255 },
+  { 1742, 28, 134, 238 },
+  { 1754, 24, 116, 205 },
+  { 1766, 16, 78, 139 },
+  { 1778, 178, 34, 34 },
+  { 1788, 255, 48, 48 },
+  { 1799, 238, 44, 44 },
+  { 1810, 205, 38, 38 },
+  { 1821, 139, 26, 26 },
+  { 1832, 255, 250, 240 },
+  { 1845, 255, 250, 240 },
+  { 1857, 34, 139, 34 },
+  { 1870, 34, 139, 34 },
+  { 1882, 220, 220, 220 },
+  { 1892, 248, 248, 255 },
+  { 1904, 248, 248, 255 },
+  { 1915, 255, 215, 0 },
+  { 1920, 255, 215, 0 },
+  { 1926, 238, 201, 0 },
+  { 1932, 205, 173, 0 },
+  { 1938, 139, 117, 0 },
+  { 1944, 218, 165, 32 },
+  { 1954, 255, 193, 37 },
+  { 1965, 238, 180, 34 },
+  { 1976, 205, 155, 29 },
+  { 1987, 139, 105, 20 },
+  { 1998, 190, 190, 190 },
+  { 2003, 0, 0, 0 },
+  { 2009, 3, 3, 3 },
+  { 2015, 26, 26, 26 },
+  { 2022, 255, 255, 255 },
+  { 2030, 28, 28, 28 },
+  { 2037, 31, 31, 31 },
+  { 2044, 33, 33, 33 },
+  { 2051, 36, 36, 36 },
+  { 2058, 38, 38, 38 },
+  { 2065, 41, 41, 41 },
+  { 2072, 43, 43, 43 },
+  { 2079, 46, 46, 46 },
+  { 2086, 48, 48, 48 },
+  { 2093, 5, 5, 5 },
+  { 2099, 51, 51, 51 },
+  { 2106, 54, 54, 54 },
+  { 2113, 56, 56, 56 },
+  { 2120, 59, 59, 59 },
+  { 2127, 61, 61, 61 },
+  { 2134, 64, 64, 64 },
+  { 2141, 66, 66, 66 },
+  { 2148, 69, 69, 69 },
+  { 2155, 71, 71, 71 },
+  { 2162, 74, 74, 74 },
+  { 2169, 8, 8, 8 },
+  { 2175, 77, 77, 77 },
+  { 2182, 79, 79, 79 },
+  { 2189, 82, 82, 82 },
+  { 2196, 84, 84, 84 },
+  { 2203, 87, 87, 87 },
+  { 2210, 89, 89, 89 },
+  { 2217, 92, 92, 92 },
+  { 2224, 94, 94, 94 },
+  { 2231, 97, 97, 97 },
+  { 2238, 99, 99, 99 },
+  { 2245, 10, 10, 10 },
+  { 2251, 102, 102, 102 },
+  { 2258, 105, 105, 105 },
+  { 2265, 107, 107, 107 },
+  { 2272, 110, 110, 110 },
+  { 2279, 112, 112, 112 },
+  { 2286, 115, 115, 115 },
+  { 2293, 117, 117, 117 },
+  { 2300, 120, 120, 120 },
+  { 2307, 122, 122, 122 },
+  { 2314, 125, 125, 125 },
+  { 2321, 13, 13, 13 },
+  { 2327, 127, 127, 127 },
+  { 2334, 130, 130, 130 },
+  { 2341, 133, 133, 133 },
+  { 2348, 135, 135, 135 },
+  { 2355, 138, 138, 138 },
+  { 2362, 140, 140, 140 },
+  { 2369, 143, 143, 143 },
+  { 2376, 145, 145, 145 },
+  { 2383, 148, 148, 148 },
+  { 2390, 150, 150, 150 },
+  { 2397, 15, 15, 15 },
+  { 2403, 153, 153, 153 },
+  { 2410, 156, 156, 156 },
+  { 2417, 158, 158, 158 },
+  { 2424, 161, 161, 161 },
+  { 2431, 163, 163, 163 },
+  { 2438, 166, 166, 166 },
+  { 2445, 168, 168, 168 },
+  { 2452, 171, 171, 171 },
+  { 2459, 173, 173, 173 },
+  { 2466, 176, 176, 176 },
+  { 2473, 18, 18, 18 },
+  { 2479, 179, 179, 179 },
+  { 2486, 181, 181, 181 },
+  { 2493, 184, 184, 184 },
+  { 2500, 186, 186, 186 },
+  { 2507, 189, 189, 189 },
+  { 2514, 191, 191, 191 },
+  { 2521, 194, 194, 194 },
+  { 2528, 196, 196, 196 },
+  { 2535, 199, 199, 199 },
+  { 2542, 201, 201, 201 },
+  { 2549, 20, 20, 20 },
+  { 2555, 204, 204, 204 },
+  { 2562, 207, 207, 207 },
+  { 2569, 209, 209, 209 },
+  { 2576, 212, 212, 212 },
+  { 2583, 214, 214, 214 },
+  { 2590, 217, 217, 217 },
+  { 2597, 219, 219, 219 },
+  { 2604, 222, 222, 222 },
+  { 2611, 224, 224, 224 },
+  { 2618, 227, 227, 227 },
+  { 2625, 23, 23, 23 },
+  { 2631, 229, 229, 229 },
+  { 2638, 232, 232, 232 },
+  { 2645, 235, 235, 235 },
+  { 2652, 237, 237, 237 },
+  { 2659, 240, 240, 240 },
+  { 2666, 242, 242, 242 },
+  { 2673, 245, 245, 245 },
+  { 2680, 247, 247, 247 },
+  { 2687, 250, 250, 250 },
+  { 2694, 252, 252, 252 },
+  { 2701, 0, 255, 0 },
+  { 2707, 173, 255, 47 },
+  { 2720, 0, 255, 0 },
+  { 2727, 0, 238, 0 },
+  { 2734, 0, 205, 0 },
+  { 2741, 0, 139, 0 },
+  { 2748, 173, 255, 47 },
+  { 2760, 190, 190, 190 },
+  { 2765, 0, 0, 0 },
+  { 2771, 3, 3, 3 },
+  { 2777, 26, 26, 26 },
+  { 2784, 255, 255, 255 },
+  { 2792, 28, 28, 28 },
+  { 2799, 31, 31, 31 },
+  { 2806, 33, 33, 33 },
+  { 2813, 36, 36, 36 },
+  { 2820, 38, 38, 38 },
+  { 2827, 41, 41, 41 },
+  { 2834, 43, 43, 43 },
+  { 2841, 46, 46, 46 },
+  { 2848, 48, 48, 48 },
+  { 2855, 5, 5, 5 },
+  { 2861, 51, 51, 51 },
+  { 2868, 54, 54, 54 },
+  { 2875, 56, 56, 56 },
+  { 2882, 59, 59, 59 },
+  { 2889, 61, 61, 61 },
+  { 2896, 64, 64, 64 },
+  { 2903, 66, 66, 66 },
+  { 2910, 69, 69, 69 },
+  { 2917, 71, 71, 71 },
+  { 2924, 74, 74, 74 },
+  { 2931, 8, 8, 8 },
+  { 2937, 77, 77, 77 },
+  { 2944, 79, 79, 79 },
+  { 2951, 82, 82, 82 },
+  { 2958, 84, 84, 84 },
+  { 2965, 87, 87, 87 },
+  { 2972, 89, 89, 89 },
+  { 2979, 92, 92, 92 },
+  { 2986, 94, 94, 94 },
+  { 2993, 97, 97, 97 },
+  { 3000, 99, 99, 99 },
+  { 3007, 10, 10, 10 },
+  { 3013, 102, 102, 102 },
+  { 3020, 105, 105, 105 },
+  { 3027, 107, 107, 107 },
+  { 3034, 110, 110, 110 },
+  { 3041, 112, 112, 112 },
+  { 3048, 115, 115, 115 },
+  { 3055, 117, 117, 117 },
+  { 3062, 120, 120, 120 },
+  { 3069, 122, 122, 122 },
+  { 3076, 125, 125, 125 },
+  { 3083, 13, 13, 13 },
+  { 3089, 127, 127, 127 },
+  { 3096, 130, 130, 130 },
+  { 3103, 133, 133, 133 },
+  { 3110, 135, 135, 135 },
+  { 3117, 138, 138, 138 },
+  { 3124, 140, 140, 140 },
+  { 3131, 143, 143, 143 },
+  { 3138, 145, 145, 145 },
+  { 3145, 148, 148, 148 },
+  { 3152, 150, 150, 150 },
+  { 3159, 15, 15, 15 },
+  { 3165, 153, 153, 153 },
+  { 3172, 156, 156, 156 },
+  { 3179, 158, 158, 158 },
+  { 3186, 161, 161, 161 },
+  { 3193, 163, 163, 163 },
+  { 3200, 166, 166, 166 },
+  { 3207, 168, 168, 168 },
+  { 3214, 171, 171, 171 },
+  { 3221, 173, 173, 173 },
+  { 3228, 176, 176, 176 },
+  { 3235, 18, 18, 18 },
+  { 3241, 179, 179, 179 },
+  { 3248, 181, 181, 181 },
+  { 3255, 184, 184, 184 },
+  { 3262, 186, 186, 186 },
+  { 3269, 189, 189, 189 },
+  { 3276, 191, 191, 191 },
+  { 3283, 194, 194, 194 },
+  { 3290, 196, 196, 196 },
+  { 3297, 199, 199, 199 },
+  { 3304, 201, 201, 201 },
+  { 3311, 20, 20, 20 },
+  { 3317, 204, 204, 204 },
+  { 3324, 207, 207, 207 },
+  { 3331, 209, 209, 209 },
+  { 3338, 212, 212, 212 },
+  { 3345, 214, 214, 214 },
+  { 3352, 217, 217, 217 },
+  { 3359, 219, 219, 219 },
+  { 3366, 222, 222, 222 },
+  { 3373, 224, 224, 224 },
+  { 3380, 227, 227, 227 },
+  { 3387, 23, 23, 23 },
+  { 3393, 229, 229, 229 },
+  { 3400, 232, 232, 232 },
+  { 3407, 235, 235, 235 },
+  { 3414, 237, 237, 237 },
+  { 3421, 240, 240, 240 },
+  { 3428, 242, 242, 242 },
+  { 3435, 245, 245, 245 },
+  { 3442, 247, 247, 247 },
+  { 3449, 250, 250, 250 },
+  { 3456, 252, 252, 252 },
+  { 3463, 240, 255, 240 },
+  { 3472, 240, 255, 240 },
+  { 3482, 224, 238, 224 },
+  { 3492, 193, 205, 193 },
+  { 3502, 131, 139, 131 },
+  { 3512, 255, 105, 180 },
+  { 3521, 255, 105, 180 },
+  { 3529, 255, 110, 180 },
+  { 3538, 238, 106, 167 },
+  { 3547, 205, 96, 144 },
+  { 3556, 139, 58, 98 },
+  { 3565, 205, 92, 92 },
+  { 3576, 205, 92, 92 },
+  { 3586, 255, 106, 106 },
+  { 3597, 238, 99, 99 },
+  { 3608, 205, 85, 85 },
+  { 3619, 139, 58, 58 },
+  { 3630, 255, 255, 240 },
+  { 3636, 255, 255, 240 },
+  { 3643, 238, 238, 224 },
+  { 3650, 205, 205, 193 },
+  { 3657, 139, 139, 131 },
+  { 3664, 240, 230, 140 },
+  { 3670, 255, 246, 143 },
+  { 3677, 238, 230, 133 },
+  { 3684, 205, 198, 115 },
+  { 3691, 139, 134, 78 },
+  { 3698, 230, 230, 250 },
+  { 3707, 255, 240, 245 },
+  { 3722, 255, 240, 245 },
+  { 3736, 255, 240, 245 },
+  { 3751, 238, 224, 229 },
+  { 3766, 205, 193, 197 },
+  { 3781, 139, 131, 134 },
+  { 3796, 124, 252, 0 },
+  { 3807, 124, 252, 0 },
+  { 3817, 255, 250, 205 },
+  { 3831, 255, 250, 205 },
+  { 3844, 255, 250, 205 },
+  { 3858, 238, 233, 191 },
+  { 3872, 205, 201, 165 },
+  { 3886, 139, 137, 112 },
+  { 3900, 173, 216, 230 },
+  { 3911, 240, 128, 128 },
+  { 3923, 224, 255, 255 },
+  { 3934, 238, 221, 130 },
+  { 3950, 250, 250, 210 },
+  { 3973, 211, 211, 211 },
+  { 3984, 144, 238, 144 },
+  { 3996, 211, 211, 211 },
+  { 4007, 255, 182, 193 },
+  { 4018, 255, 160, 122 },
+  { 4031, 32, 178, 170 },
+  { 4047, 135, 206, 250 },
+  { 4062, 132, 112, 255 },
+  { 4079, 119, 136, 153 },
+  { 4096, 119, 136, 153 },
+  { 4113, 176, 196, 222 },
+  { 4130, 255, 255, 224 },
+  { 4143, 173, 216, 230 },
+  { 4153, 191, 239, 255 },
+  { 4164, 178, 223, 238 },
+  { 4175, 154, 192, 205 },
+  { 4186, 104, 131, 139 },
+  { 4197, 240, 128, 128 },
+  { 4208, 224, 255, 255 },
+  { 4218, 224, 255, 255 },
+  { 4229, 209, 238, 238 },
+  { 4240, 180, 205, 205 },
+  { 4251, 122, 139, 139 },
+  { 4262, 238, 221, 130 },
+  { 4277, 255, 236, 139 },
+  { 4293, 238, 220, 130 },
+  { 4309, 205, 190, 112 },
+  { 4325, 139, 129, 76 },
+  { 4341, 250, 250, 210 },
+  { 4362, 211, 211, 211 },
+  { 4372, 144, 238, 144 },
+  { 4383, 211, 211, 211 },
+  { 4393, 255, 182, 193 },
+  { 4403, 255, 174, 185 },
+  { 4414, 238, 162, 173 },
+  { 4425, 205, 140, 149 },
+  { 4436, 139, 95, 101 },
+  { 4447, 255, 160, 122 },
+  { 4459, 255, 160, 122 },
+  { 4472, 238, 149, 114 },
+  { 4485, 205, 129, 98 },
+  { 4498, 139, 87, 66 },
+  { 4511, 32, 178, 170 },
+  { 4525, 135, 206, 250 },
+  { 4538, 176, 226, 255 },
+  { 4552, 164, 211, 238 },
+  { 4566, 141, 182, 205 },
+  { 4580, 96, 123, 139 },
+  { 4594, 132, 112, 255 },
+  { 4609, 119, 136, 153 },
+  { 4624, 119, 136, 153 },
+  { 4639, 176, 196, 222 },
+  { 4654, 202, 225, 255 },
+  { 4670, 188, 210, 238 },
+  { 4686, 162, 181, 205 },
+  { 4702, 110, 123, 139 },
+  { 4718, 255, 255, 224 },
+  { 4730, 255, 255, 224 },
+  { 4743, 238, 238, 209 },
+  { 4756, 205, 205, 180 },
+  { 4769, 139, 139, 122 },
+  { 4782, 50, 205, 50 },
+  { 4793, 50, 205, 50 },
+  { 4803, 250, 240, 230 },
+  { 4809, 255, 0, 255 },
+  { 4817, 255, 0, 255 },
+  { 4826, 238, 0, 238 },
+  { 4835, 205, 0, 205 },
+  { 4844, 139, 0, 139 },
+  { 4853, 176, 48, 96 },
+  { 4860, 255, 52, 179 },
+  { 4868, 238, 48, 167 },
+  { 4876, 205, 41, 144 },
+  { 4884, 139, 28, 98 },
+  { 4892, 102, 205, 170 },
+  { 4910, 0, 0, 205 },
+  { 4922, 186, 85, 211 },
+  { 4936, 147, 112, 219 },
+  { 4950, 60, 179, 113 },
+  { 4967, 123, 104, 238 },
+  { 4985, 0, 250, 154 },
+  { 5005, 72, 209, 204 },
+  { 5022, 199, 21, 133 },
+  { 5040, 102, 205, 170 },
+  { 5057, 0, 0, 205 },
+  { 5068, 186, 85, 211 },
+  { 5081, 224, 102, 255 },
+  { 5095, 209, 95, 238 },
+  { 5109, 180, 82, 205 },
+  { 5123, 122, 55, 139 },
+  { 5137, 147, 112, 219 },
+  { 5150, 171, 130, 255 },
+  { 5164, 159, 121, 238 },
+  { 5178, 137, 104, 205 },
+  { 5192, 93, 71, 139 },
+  { 5206, 60, 179, 113 },
+  { 5221, 123, 104, 238 },
+  { 5237, 0, 250, 154 },
+  { 5255, 72, 209, 204 },
+  { 5271, 199, 21, 133 },
+  { 5287, 25, 25, 112 },
+  { 5301, 25, 25, 112 },
+  { 5314, 245, 255, 250 },
+  { 5325, 245, 255, 250 },
+  { 5335, 255, 228, 225 },
+  { 5346, 255, 228, 225 },
+  { 5356, 255, 228, 225 },
+  { 5367, 238, 213, 210 },
+  { 5378, 205, 183, 181 },
+  { 5389, 139, 125, 123 },
+  { 5400, 255, 228, 181 },
+  { 5409, 255, 222, 173 },
+  { 5422, 255, 222, 173 },
+  { 5434, 255, 222, 173 },
+  { 5447, 238, 207, 161 },
+  { 5460, 205, 179, 139 },
+  { 5473, 139, 121, 94 },
+  { 5486, 0, 0, 128 },
+  { 5491, 0, 0, 128 },
+  { 5501, 0, 0, 128 },
+  { 5510, 253, 245, 230 },
+  { 5519, 253, 245, 230 },
+  { 5527, 107, 142, 35 },
+  { 5538, 107, 142, 35 },
+  { 5548, 192, 255, 62 },
+  { 5559, 179, 238, 58 },
+  { 5570, 154, 205, 50 },
+  { 5581, 105, 139, 34 },
+  { 5592, 255, 165, 0 },
+  { 5599, 255, 69, 0 },
+  { 5610, 255, 165, 0 },
+  { 5618, 238, 154, 0 },
+  { 5626, 205, 133, 0 },
+  { 5634, 139, 90, 0 },
+  { 5642, 255, 69, 0 },
+  { 5652, 255, 69, 0 },
+  { 5663, 238, 64, 0 },
+  { 5674, 205, 55, 0 },
+  { 5685, 139, 37, 0 },
+  { 5696, 218, 112, 214 },
+  { 5703, 255, 131, 250 },
+  { 5711, 238, 122, 233 },
+  { 5719, 205, 105, 201 },
+  { 5727, 139, 71, 137 },
+  { 5735, 238, 232, 170 },
+  { 5750, 152, 251, 152 },
+  { 5761, 175, 238, 238 },
+  { 5776, 219, 112, 147 },
+  { 5792, 238, 232, 170 },
+  { 5806, 152, 251, 152 },
+  { 5816, 154, 255, 154 },
+  { 5827, 144, 238, 144 },
+  { 5838, 124, 205, 124 },
+  { 5849, 84, 139, 84 },
+  { 5860, 175, 238, 238 },
+  { 5874, 187, 255, 255 },
+  { 5889, 174, 238, 238 },
+  { 5904, 150, 205, 205 },
+  { 5919, 102, 139, 139 },
+  { 5934, 219, 112, 147 },
+  { 5948, 255, 130, 171 },
+  { 5963, 238, 121, 159 },
+  { 5978, 205, 104, 137 },
+  { 5993, 139, 71, 93 },
+  { 6008, 255, 239, 213 },
+  { 6020, 255, 239, 213 },
+  { 6031, 255, 218, 185 },
+  { 6042, 255, 218, 185 },
+  { 6052, 255, 218, 185 },
+  { 6063, 238, 203, 173 },
+  { 6074, 205, 175, 149 },
+  { 6085, 139, 119, 101 },
+  { 6096, 205, 133, 63 },
+  { 6101, 255, 192, 203 },
+  { 6106, 255, 181, 197 },
+  { 6112, 238, 169, 184 },
+  { 6118, 205, 145, 158 },
+  { 6124, 139, 99, 108 },
+  { 6130, 221, 160, 221 },
+  { 6135, 255, 187, 255 },
+  { 6141, 238, 174, 238 },
+  { 6147, 205, 150, 205 },
+  { 6153, 139, 102, 139 },
+  { 6159, 176, 224, 230 },
+  { 6171, 176, 224, 230 },
+  { 6182, 160, 32, 240 },
+  { 6189, 155, 48, 255 },
+  { 6197, 145, 44, 238 },
+  { 6205, 125, 38, 205 },
+  { 6213, 85, 26, 139 },
+  { 6221, 255, 0, 0 },
+  { 6225, 255, 0, 0 },
+  { 6230, 238, 0, 0 },
+  { 6235, 205, 0, 0 },
+  { 6240, 139, 0, 0 },
+  { 6245, 188, 143, 143 },
+  { 6256, 188, 143, 143 },
+  { 6266, 255, 193, 193 },
+  { 6277, 238, 180, 180 },
+  { 6288, 205, 155, 155 },
+  { 6299, 139, 105, 105 },
+  { 6310, 65, 105, 225 },
+  { 6321, 65, 105, 225 },
+  { 6331, 72, 118, 255 },
+  { 6342, 67, 110, 238 },
+  { 6353, 58, 95, 205 },
+  { 6364, 39, 64, 139 },
+  { 6375, 139, 69, 19 },
+  { 6388, 139, 69, 19 },
+  { 6400, 250, 128, 114 },
+  { 6407, 255, 140, 105 },
+  { 6415, 238, 130, 98 },
+  { 6423, 205, 112, 84 },
+  { 6431, 139, 76, 57 },
+  { 6439, 244, 164, 96 },
+  { 6451, 244, 164, 96 },
+  { 6462, 46, 139, 87 },
+  { 6472, 46, 139, 87 },
+  { 6481, 84, 255, 159 },
+  { 6491, 78, 238, 148 },
+  { 6501, 67, 205, 128 },
+  { 6511, 46, 139, 87 },
+  { 6521, 255, 245, 238 },
+  { 6530, 255, 245, 238 },
+  { 6540, 238, 229, 222 },
+  { 6550, 205, 197, 191 },
+  { 6560, 139, 134, 130 },
+  { 6570, 160, 82, 45 },
+  { 6577, 255, 130, 71 },
+  { 6585, 238, 121, 66 },
+  { 6593, 205, 104, 57 },
+  { 6601, 139, 71, 38 },
+  { 6609, 135, 206, 235 },
+  { 6618, 135, 206, 235 },
+  { 6626, 135, 206, 255 },
+  { 6635, 126, 192, 238 },
+  { 6644, 108, 166, 205 },
+  { 6653, 74, 112, 139 },
+  { 6662, 106, 90, 205 },
+  { 6673, 112, 128, 144 },
+  { 6684, 112, 128, 144 },
+  { 6695, 106, 90, 205 },
+  { 6705, 131, 111, 255 },
+  { 6716, 122, 103, 238 },
+  { 6727, 105, 89, 205 },
+  { 6738, 71, 60, 139 },
+  { 6749, 112, 128, 144 },
+  { 6759, 198, 226, 255 },
+  { 6770, 185, 211, 238 },
+  { 6781, 159, 182, 205 },
+  { 6792, 108, 123, 139 },
+  { 6803, 112, 128, 144 },
+  { 6813, 255, 250, 250 },
+  { 6818, 255, 250, 250 },
+  { 6824, 238, 233, 233 },
+  { 6830, 205, 201, 201 },
+  { 6836, 139, 137, 137 },
+  { 6842, 0, 255, 127 },
+  { 6855, 0, 255, 127 },
+  { 6867, 0, 255, 127 },
+  { 6880, 0, 238, 118 },
+  { 6893, 0, 205, 102 },
+  { 6906, 0, 139, 69 },
+  { 6919, 70, 130, 180 },
+  { 6930, 70, 130, 180 },
+  { 6940, 99, 184, 255 },
+  { 6951, 92, 172, 238 },
+  { 6962, 79, 148, 205 },
+  { 6973, 54, 100, 139 },
+  { 6984, 210, 180, 140 },
+  { 6988, 255, 165, 79 },
+  { 6993, 238, 154, 73 },
+  { 6998, 205, 133, 63 },
+  { 7003, 139, 90, 43 },
+  { 7008, 216, 191, 216 },
+  { 7016, 255, 225, 255 },
+  { 7025, 238, 210, 238 },
+  { 7034, 205, 181, 205 },
+  { 7043, 139, 123, 139 },
+  { 7052, 255, 99, 71 },
+  { 7059, 255, 99, 71 },
+  { 7067, 238, 92, 66 },
+  { 7075, 205, 79, 57 },
+  { 7083, 139, 54, 38 },
+  { 7091, 64, 224, 208 },
+  { 7101, 0, 245, 255 },
+  { 7112, 0, 229, 238 },
+  { 7123, 0, 197, 205 },
+  { 7134, 0, 134, 139 },
+  { 7145, 238, 130, 238 },
+  { 7152, 208, 32, 144 },
+  { 7163, 208, 32, 144 },
+  { 7173, 255, 62, 150 },
+  { 7184, 238, 58, 140 },
+  { 7195, 205, 50, 120 },
+  { 7206, 139, 34, 82 },
+  { 7217, 245, 222, 179 },
+  { 7223, 255, 231, 186 },
+  { 7230, 238, 216, 174 },
+  { 7237, 205, 186, 150 },
+  { 7244, 139, 126, 102 },
+  { 7251, 255, 255, 255 },
+  { 7257, 245, 245, 245 },
+  { 7269, 245, 245, 245 },
+  { 7280, 255, 255, 0 },
+  { 7287, 154, 205, 50 },
+  { 7300, 255, 255, 0 },
+  { 7308, 238, 238, 0 },
+  { 7316, 205, 205, 0 },
+  { 7324, 139, 139, 0 },
+  { 7332, 154, 205, 50 }
+};
--- gtk+/gdk-pixbuf/io-gif-animation.c	(.../2.6.4)	(revision 904)
+++ gtk+/gdk-pixbuf/io-gif-animation.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -391,6 +391,11 @@
                 
                 while (tmp != NULL) {
                         GdkPixbufFrame *f = tmp->data;
+
+                        if (f->pixbuf == NULL) {
+                                return;
+                        }
+
                         gint clipped_width = MIN (gif_anim->width - f->x_offset, gdk_pixbuf_get_width (f->pixbuf));
                         gint clipped_height = MIN (gif_anim->height - f->y_offset, gdk_pixbuf_get_height (f->pixbuf));
   
@@ -414,6 +419,10 @@
                                                                 TRUE,
                                                                 8, gif_anim->width, gif_anim->height);
 
+                                if (f->composited == NULL) {
+                                        return;
+                                }
+
                                 /* alpha gets dumped if f->composited has no alpha */
                                 
                                 gdk_pixbuf_fill (f->composited,
@@ -453,9 +462,18 @@
                                 
                                 if (prev_frame->action == GDK_PIXBUF_FRAME_RETAIN) {
                                         f->composited = gdk_pixbuf_copy (prev_frame->composited);
+
+                                        if (f->composited == NULL) {
+                                                return;
+                                        }
                                         
                                 } else if (prev_frame->action == GDK_PIXBUF_FRAME_DISPOSE) {
                                         f->composited = gdk_pixbuf_copy (prev_frame->composited);
+
+                                        if (f->composited == NULL) {
+                                                return;
+                                        }
+
                                         if (prev_clipped_width > 0 && prev_clipped_height > 0) {
                                                 /* Clear area of previous frame to background */
                                                 GdkPixbuf *area;
@@ -465,6 +483,10 @@
                                                                                  prev_frame->y_offset,
                                                                                  prev_clipped_width,
                                                                                  prev_clipped_height);
+
+                                                if (area == NULL) {
+                                                        return;
+                                                }
                                                 
                                                 gdk_pixbuf_fill (area,
                                                                  (gif_anim->bg_red << 24) |
@@ -475,7 +497,13 @@
                                         }                                        
                                 } else if (prev_frame->action == GDK_PIXBUF_FRAME_REVERT) {
                                         f->composited = gdk_pixbuf_copy (prev_frame->composited);
-                                        if (prev_clipped_width > 0 && prev_clipped_height > 0) {
+
+                                        if (f->composited == NULL) {
+                                                return;
+                                        }
+
+                                        if (prev_frame->revert != NULL &&
+                                            prev_clipped_width > 0 && prev_clipped_height > 0) {
                                                 /* Copy in the revert frame */
                                                 gdk_pixbuf_copy_area (prev_frame->revert,
                                                                       0, 0,
@@ -500,14 +528,23 @@
                                                                                  f->y_offset,
                                                                                  clipped_width,
                                                                                  clipped_height);
-                                                
+                                            
+                                                if (area == NULL) {
+                                                        return;
+                                                }
+    
                                                 f->revert = gdk_pixbuf_copy (area);
-                                                
+
                                                 g_object_unref (area);
+
+                                                if (f->revert == NULL) {
+                                                        return;
+                                                }
                                         }
                                 }
 
-                                if (clipped_width > 0 && clipped_height > 0) {
+                                if (clipped_width > 0 && clipped_height > 0 &&
+                                    f->pixbuf != NULL && f->composited != NULL) {
                                         /* Put current frame onto f->composited */
                                         gdk_pixbuf_composite (f->pixbuf,
                                                               f->composited,
@@ -531,10 +568,6 @@
                         tmp = tmp->next;
                 }
         }
-
-        g_assert (frame->composited != NULL);
-        g_assert (gdk_pixbuf_get_width (frame->composited) == gif_anim->width);
-        g_assert (gdk_pixbuf_get_height (frame->composited) == gif_anim->height);
 }
 
 GdkPixbuf*
--- gtk+/modules/input/Makefile.in	(.../2.6.4)	(revision 904)
+++ gtk+/modules/input/Makefile.in	(.../2.6.4-1.osso62)	(revision 904)
@@ -812,7 +812,11 @@
 	rm -f $(DESTDIR)$(sysconfdir)/gtk-2.0/gtk.immodules
 
 gtk.immodules: Makefile.am $(module_LTLIBRARIES)
-	$(top_builddir)/gtk/gtk-query-immodules-2.0 $(module_LTLIBRARIES) > gtk.immodules
+	@if $(RUN_QUERY_IMMODULES_TEST) ; then \
+	  $(top_builddir)/gtk/gtk-query-immodules-2.0 $(module_LTLIBRARIES) > gtk.immodules ; \
+	else \
+	  touch $@ ; \
+	fi
 
 @CROSS_COMPILING_FALSE@all-local: gtk.immodules
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
--- gtk+/modules/input/Makefile.am	(.../2.6.4)	(revision 904)
+++ gtk+/modules/input/Makefile.am	(.../2.6.4-1.osso62)	(revision 904)
@@ -131,7 +131,12 @@
 	$(IM_IME_MODULE)
 
 gtk.immodules: Makefile.am $(module_LTLIBRARIES)
-	$(top_builddir)/gtk/gtk-query-immodules-2.0 $(module_LTLIBRARIES) > gtk.immodules
+	@if $(RUN_QUERY_IMMODULES_TEST) ; then \
+	  $(top_builddir)/gtk/gtk-query-immodules-2.0 $(module_LTLIBRARIES) > gtk.immodules ; \
+	else \
+	  touch $@ ; \
+	fi
+
 
 CLEANFILES = gtk.immodules
 
--- gtk+/configure.in	(.../2.6.4)	(revision 904)
+++ gtk+/configure.in	(.../2.6.4-1.osso62)	(revision 904)
@@ -202,6 +202,15 @@
               [AC_HELP_STRING([--disable-visibility],
                               [don't use ELF visibility attributes])],,
               [enable_visibility=yes])
+# Modification for Nokia 770 to disable keyboard shortcuts
+AC_ARG_ENABLE(shortcuts,
+	      [AC_HELP_STRING([--disable-shortcuts],
+	                      [disable keyboard shortcuts])],,
+	      [enable_shortcuts=yes])
+
+if test "x$enable_shortcuts" = "xno"; then
+  GTK_EXTRA_CFLAGS="$GTK_EXTRA_CFLAGS -DDISABLE_KEYBOARD_SHORTCUTS"
+fi;
 
 AC_ARG_WITH(xinput,
             [AC_HELP_STRING([--with-xinput=@<:@no/yes@:>@], [support XInput])])
@@ -347,7 +356,8 @@
 if test "$os_win32" != yes; then
     # libtool option to control which symbols are exported
     # right now, symbols starting with _ are not exported
-    LIBTOOL_EXPORT_OPTIONS='-export-symbols-regex "^[[^_]].*"'
+    # Disabled until -export-symbols-regex works (RH patch)
+    LIBTOOL_EXPORT_OPTIONS=
 else
     # We currently use .def files on Windows (for gdk-pixbuf, gdk and gtk)
     LIBTOOL_EXPORT_OPTIONS=
@@ -417,7 +427,7 @@
 # sure that both po/ and po-properties/ have .po files that correspond
 # to your language.  If you only add one to po/, the build will break
 # in po-properties/.
-ALL_LINGUAS="af am ar az az_IR be bg bn br bs ca cs cy da de el en_CA en_GB es et eu fa fi fr ga gl gu he hi hr hu ia id is it ja ko li lt lv mi mk ml mn mr ms nb ne nl nn no nso pa pl pt pt_BR ro ru rw sk sl sq sr sr@ije sr@Latn sv ta th tk tr uk uz uz@Latn vi wa xh yi zh_CN zh_TW"
+ALL_LINGUAS=""
 AM_GLIB_GNU_GETTEXT
 LIBS="$LIBS $INTLLIBS"
 AC_OUTPUT_COMMANDS([case "$CONFIG_FILES" in *po-properties/Makefile.in*)
@@ -1282,6 +1292,17 @@
     GDK_EXTRA_CFLAGS="`$PKG_CONFIG --cflags xfixes` $GDK_EXTRA_CFLAGS"
     GDK_EXTRA_LIBS="`$PKG_CONFIG --libs xfixes` $GDK_EXTRA_LIBS"
   fi
+
+  # Checks for XFixes extension
+
+  have_xfixes=false
+  PKG_CHECK_MODULES(XFIXES, xfixes, have_xfixes=true, :)
+
+  if $have_xfixes ; then
+    AC_DEFINE(HAVE_XFIXES, 1, Have the XFIXES X extension)
+    GDK_EXTRA_CFLAGS="`$PKG_CONFIG --cflags xfixes` $GDK_EXTRA_CFLAGS"
+    GDK_EXTRA_LIBS="`$PKG_CONFIG --libs xfixes` $GDK_EXTRA_LIBS"
+  fi
     
   # Xshm checks
 
@@ -1491,7 +1512,6 @@
 
 GTK_PACKAGES=atk
 GTK_EXTRA_LIBS=
-GTK_EXTRA_CFLAGS= 
 GTK_DEP_LIBS="$GDK_EXTRA_LIBS $GTK_DEP_LIBS_FOR_X `$PKG_CONFIG --libs $GDK_PIXBUF_PACKAGES $GDK_PACKAGES $GTK_PACKAGES` $GTK_EXTRA_LIBS $GDK_PIXBUF_EXTRA_LIBS"
 GTK_DEP_CFLAGS="`$PKG_CONFIG --cflags  gthread-2.0 $GDK_PIXBUF_PACKAGES $GDK_PACKAGES $GTK_PACKAGES` $GDK_PIXBUF_EXTRA_CFLAGS $GDK_EXTRA_CFLAGS $GTK_EXTRA_CFLAGS"
 
--- gtk+/ChangeLog	(.../2.6.4)	(revision 904)
+++ gtk+/ChangeLog	(.../2.6.4-1.osso62)	(revision 904)
@@ -1,3 +1,319 @@
+2005-09-14  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* gtk/gtkmenu.c (gtk_menu_window_visibility_notify_event): Reapply the
+	fix and now also ignore unmapped 10x10+10+10 windows which for some
+	reason seem to be included in the window list.
+	N#18455 
+
+2005-09-14  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* gtk/gtktreemodelfilter.c
+	* gtk/gtktreemodelsort.c: ...and revert it because of crashes
+
+2005-09-13  Kristian Rietveld  <kris@imendio.com>
+
+	* gtk/gtktreemodelfilter.c (gtk_tree_model_filter_build_level),
+	(gtk_tree_model_filter_free_level), (gtk_tree_model_filter_row_changed),
+	(gtk_tree_model_filter_row_inserted),
+	(gtk_tree_model_filter_row_deleted): have the filter model maintain
+	a reference on all nodes in the child model which do have a
+	parent node (ie not the nodes in the root level). See GNOME
+	#311955 for discussion.
+	(gtk_tree_model_filter_row_has_child_toggled): remove call
+	to _free_level().
+
+	* gtk/gtktreemodelsort.c (gtk_tree_model_sort_row_changed),
+	(gtk_tree_model_sort_row_inserted), (gtk_tree_model_sort_row_deleted),
+	(gtk_tree_model_sort_ref_node), (gtk_tree_model_sort_unref_node),
+	(gtk_tree_model_sort_sort_level), (gtk_tree_model_sort_build_level),
+	(gtk_tree_model_sort_free_level): bring back in sync with the
+	version found upstream, reverts changes in ref counting mechanism,
+	(gtk_tree_model_sort_row_inserted): don't insert new rows in a
+	level with zero refcount, free the level instead.
+
+	N#17314
+
+2005-09-13  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* gtk/gtkmenu.c (gtk_menu_window_visibility_notify_event): Revert last
+	change as it introduces other bugs.
+	N#19120
+
+2005-09-13  Tommi Komulainen  <tommi.komulainen@nokia.com>
+	
+	* gtk/gtktreemodelsort.c (gtk_tree_model_sort_increment_stamp):
+	Revert the optimization as it introduces a crasher.
+	N#19117
+
+2005-09-09  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* gtk/gtkimmulticontext.c (gtk_im_multicontext_set_slave): Free
+	context_id to fix memory leak.
+	N#17648
+
+2005-09-08  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* gtk/gtkcellview.c (gtk_cell_view_size_allocate): improved width
+	computation incase there is less space available than requested
+	N#18597
+
+2005-09-08  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* gtk/gtktreemodelsort.c (gtk_tree_model_sort_increment_stamp):
+	Removed cache clear that was useless and highly inefficient.
+	N#17314
+
+2005-09-08  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* gtk/gtkentry.c:
+	* gtk/gtktextview.c: Instead of 'hide' use 'unmap' to hide the IM so
+	that it works also when parent gets hidden.
+	N#16761
+
+2005-09-08  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* gtk/gtkmenu.c (gtk_menu_window_visibility_notify_event): Close the
+	menu if it overlaps even partially with non-menu/message windows. Also
+	removed a check to make only root menu close the menu, since the root
+	menu doesn't receive partial visibility notification again once a
+	submenu has already partially obscured it.
+	N#18455
+
+2005-09-07  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* gtk/gtkentry.c (gtk_entry_hide):
+	* gtk/gtktextview.c (gtk_text_view_hide): Override the hide virtual
+	function to hide the input method as well.
+	N#16761
+
+2005-09-07  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* gtk/gtktreeview.c (gtk_tree_view_row_changed): Added validity check
+	before using cursor row reference.
+	N#18433
+
+2005-09-07  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* gtk/gtkwidget.c (gtk_widget_enter_notify, gtk_widget_leave_notify):
+	Don't call gtk_widget_activate() handler, which are about focus
+	handling.
+	N#11711
+
+2005-09-07  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* gtk/gtkwindow.c (gtk_window_focus_weak_notify): When
+	prev_focus_widget gets destroyed and we recieve the destroy
+	notification, make sure that it gets changed or set to NULL.
+	N#16744
+
+2005-09-05  Tommi Komulainen  <tommi.komulainen@nokia.com>
+	
+	Implement global IM module runtime switching using
+	"gtk-global-immodule" root window property.
+
+	* gtk/Makefile.am:
+	* gtk/maemo-gtk-im-switch.c: Add program to set the root window
+	property from command line.
+	* gtk/gtkimmulticontext.h (GtkIMMulticontext::context_id): remove
+	const
+	* gtk/gtkimmulticontext.c (global_context_id, get_global_context_id):
+	Replace static global context id string with a function getting it
+	from the root window property on runtime.
+	* gtk/gtkimmulticontext.c (gtk_im_multicontext_get_slave,
+	gtk_im_multicontext_focus_in, gtk_im_multicontext_append_menuitems,
+	gtk_im_multicontext_show): Adapt to use the function instead.
+
+2005-08-29  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* gtk/gtktreemodelsort.c (gtk_tree_model_sort_row_inserted): Revert
+	the optimization as it breaks file chooser (Memory Card is not shown
+	initially if a subfolder is selected.)
+	N#18260
+
+2005-08-29  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* gdk/x11/gdkim-x11.c (_gdk_x11_initialize_locale): Comment out X
+	locale initialization.  We know it would fail anyway.
+
+2005-08-29  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* gtk/gtklabel.c (gtk_label_ensure_layout_full): New function,
+	extended to take additional parameter for optionally clamping the
+	layout width to current allocation width.
+	(gtk_label_ensure_layout_full, gtk_label_size_request): Set label
+	layout's maximum width correctly when wrapping is enabled.
+	(get_layout_location): Use the layout's actual width and height when
+	calculating the label alignmentation.
+	N#17117
+
+2005-08-29  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* gtk/gtkfilesystem.h (GtkFileSystemError): Add
+	GTK_FILE_SYSTEM_ERROR_TIMEOUT to be able to differentiate (non-local)
+	timeouts from generic errors.
+
+2005-08-25  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* gtk/gtkrc.c (gtk_rc_reparse_all_for_settings): When determining
+	whether gtkrc files have been modified check whether timestamps
+	differ, otherwise turning back time will make theme switching go
+	unnoticed.
+	N#17568
+
+2005-08-25  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* gtk/gtkmenu.c (gtk_menu_window_visibility_notify_event): Changed
+	logic in when menu is closed when another window comes on top of it,
+	and added explanation comment about it.
+	N#16593
+
+2005-08-23  Kristian Rietveld  <kris@gtk.org>
+
+	* gtk/gtktreemodelsort.c (gtk_tree_model_sort_row_inserted): don't
+	bother inserting new rows in a level with a zero refcount and
+	immediately free the level. (Fixes #312350, reported by Markku Vire).
+	N#17314
+
+2005-08-22  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* gtk/gtkviewport.c ("shadow-type" property): Change default to
+	GTK_SHADOW_NONE to not draw extra borders.  N#17723
+
+2005-08-22  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* gtk/gtkentry.c (gtk_entry_set_visibility): Disable
+	autocapitalization in secret mode.  N#17717
+
+2005-08-22  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* gtk/gtktreeview.c (gtk_tree_view_tap_and_hold_query): Don't crash if
+	the tree is empty.  N#16485
+
+2005-08-22  Tommi Komulainen  <tommi.komulainen@nokia.com>
+	
+	* gtk/gtkcalendar.c (gtk_calendar_init): Stock GTK+ mechanism for
+	determining the first day of the week with PO files replaced
+	determining it with nl_langinfo.  N#12176
+
+2005-08-16  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* gtktextview.c (gtk_text_view_retrieve_surrounding_handler): change
+	from character count to byte count.  Fixes autocapitalization behavior
+	with inverted question and exclamation marks.  N#16733
+
+2005-08-16  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* gtk/gtkmenu.c (gtk_menu_window_visibility_notify_event): Allow other
+	menu windows to cover other menu windows to avoid unwanted closing
+	caused by wrong window stack order. N#11711
+
+2005-08-16  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* gtk/gtktreeview.c (gtk_tree_view_bin_expose): Drag drop indicator
+	painting refactored to a new function draw_drop_indicator; painting
+	order rearranged so that drag drop indicator is painted before the
+	cell is rendered to avoid cell being covered by the drop indicator.
+	N#10856
+
+2005-08-10  Kristian Rietveld  <kris@imendio.com>
+
+	* gtk/gtkhbbox.c (gtk_hbutton_box_size_allocate): don't access
+	children_h before we check whether children_h is non-NULL, remove
+	useless check if we are at the end of the list inside the while
+	loop. Fixes crashes with empty hbboxes. 
+
+2005-08-10  Luc Pionchon  <luc.pionchon@nokia.com>
+
+	* gtk/gtktreeview.c (gtk_tree_view_insert_column)
+	(gtk_tree_view_remove_column) Added allow_checkbox_mode checks
+	N#16571 
+
+2005-08-09  Luc Pionchon  <luc.pionchon@nokia.com>
+
+	Backported upstream fix
+	* gtk/gtkdialog.c (gtk_dialog_map): Don't
+	try to focus the default_widget if there is 
+	none.  (#169881, Thomas Leonard)  N#16576
+	
+2005-08-05  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* gdk-pixbuf/io-jpeg.c (fatal_error_handler): Report out of memory
+	error correctly instead of as corrupt image.  (#312674, Tommi
+	Komulainen)  N#15422
+
+2005-08-05  Tommi Komulainen  <tommi.komulainen@nokia.com>
+	
+	Merge patch by Kristian Rietveld from GNOME CVS:
+
+	* gtk/gtkentry.c (gtk_entry_move_forward_word): don't iterate
+	past the end of the string, so pango_layout_get_cursor_pos() won't
+	complain. (#309211, Tommi Komulainen). N#13757
+
+2005-08-05  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* gtk/gtktextbuffer.c(clipboard_text_view_markup_received): Do not try
+	to deserialize rich text if the clipboard request failed. Stop leaking
+	the error. N#16736
+
+2005-08-03  Luc Pionchon  <luc.pionchon@nokia.com>
+
+	* gtk/gtktreemodelfilter.c
+	(gtk_tree_model_filter_row_has_child_toggled): keep
+	GtkTreeModelFilter and GtkTreeModelSort cache in
+	sync. http://bugzilla.gnome.org/show_bug.cgi?id=311955
+	N#8307
+	
+	* gtk/gtkmenushell.[ch]: Added new "close" signal which closes
+	only current menu level and not its parent.
+
+2005-08-01  Luc Pionchon  <luc.pionchon@nokia.com>
+
+	* gtk/gtkcombobox.c: Adds a new boolean property called
+	"propagate-lr-keys" to GtkComboBox. When set to TRUE (its default
+	value is FALSE), the key-press events for GDK_Left and GDK_Right
+	keys are propagated further as in stock GTK+. However, the default
+	behaviour for GtkComboBox must be to eat up key-press events for
+	left/right hardkeys, because otherwise focus might be shifted away
+	from the choice list when items contained in it are browsed using
+	left/right hardkeys. The added property allows overriding this
+	default behaviour in special occasions such as this.
+	
+	* gtk/gtkcombobox.c (gtk_combo_box_menu_size_request): width of
+	popup can now be as large as the combo's width
+
+	* gtk/gtkmenuitem.c: Added a delay for showing submenus.
+
+	* gtk/gtktreeview.c: fix "Mark all does not select all (passive
+	focus makes item look unselected)". Passive focus is now replaced
+	with the selection indicator whenever treeview is in multiple
+	selection mode without checkboxes.
+
+	* gtk/gtktreeview.c: (check_if_can_focus) Added NULL checks to prevent
+	access to deleted rows.
+
+	* gtk/gtktextbuffer.c (clipboard_clipboard_buffer_received):
+	* gtk/gtktextbufferserialize.c: improved clipboard, handle anonymous
+	tags.
+
+	* gtk/gtkmenushell.c (gtk_real_menu_shell_move_current): Added 
+	comment to document reason for commenting out a block of code
+
+	* gtk/gtktextview.c: All text before cursor isn't needed to be set to
+	surroundings, only the last non-whitespace character before the
+	cursor (we'll use the last non-whitespace before the beginning of
+	current line though)
+
+	* gtk/gtkcellrenderertoggle.c: Code cleanup
+
+2005-07-26  Luc Pionchon  <luc.pionchon@nokia.com>
+
+	* gtk/gtkcellview.c (gtk_cell_view_size_allocate): adjust cell
+	width to avoid truncation issues.
+
+2005-07-13  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* apply all patches from 2.6.4-1.osso34.1
+
 2005-03-01  Matthias Clasen  <mclasen@redhat.com>
 
 	* === Released 2.6.4 ===
--- gtk+/gdk/gdkpango.c	(.../2.6.4)	(revision 904)
+++ gtk+/gdk/gdkpango.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -603,6 +603,7 @@
 
 static void
 on_renderer_display_closed (GdkDisplay       *display,
+                            gboolean          is_error,
 			    GdkPangoRenderer *renderer)
 {
   g_signal_handlers_disconnect_by_func (renderer->priv->screen,
--- gtk+/gdk/keyname-table.h	(.../2.6.4)	(revision 0)
+++ gtk+/gdk/keyname-table.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -0,0 +1,3936 @@
+/* keyname-table.h: Generated by gen-keyname-table.pl from keynames.txt
+ *
+ *  Date: Tue Mar  8 04:19:59 2005
+ *
+ * Do not edit.   
+ */
+static const char keynames[] =
+  "space\0"
+  "exclam\0"
+  "quotedbl\0"
+  "numbersign\0"
+  "dollar\0"
+  "percent\0"
+  "ampersand\0"
+  "apostrophe\0"
+  "quoteright\0"
+  "parenleft\0"
+  "parenright\0"
+  "asterisk\0"
+  "plus\0"
+  "comma\0"
+  "minus\0"
+  "period\0"
+  "slash\0"
+  "0\0"
+  "1\0"
+  "2\0"
+  "3\0"
+  "4\0"
+  "5\0"
+  "6\0"
+  "7\0"
+  "8\0"
+  "9\0"
+  "colon\0"
+  "semicolon\0"
+  "less\0"
+  "equal\0"
+  "greater\0"
+  "question\0"
+  "at\0"
+  "A\0"
+  "B\0"
+  "C\0"
+  "D\0"
+  "E\0"
+  "F\0"
+  "G\0"
+  "H\0"
+  "I\0"
+  "J\0"
+  "K\0"
+  "L\0"
+  "M\0"
+  "N\0"
+  "O\0"
+  "P\0"
+  "Q\0"
+  "R\0"
+  "S\0"
+  "T\0"
+  "U\0"
+  "V\0"
+  "W\0"
+  "X\0"
+  "Y\0"
+  "Z\0"
+  "bracketleft\0"
+  "backslash\0"
+  "bracketright\0"
+  "asciicircum\0"
+  "underscore\0"
+  "grave\0"
+  "quoteleft\0"
+  "a\0"
+  "b\0"
+  "c\0"
+  "d\0"
+  "e\0"
+  "f\0"
+  "g\0"
+  "h\0"
+  "i\0"
+  "j\0"
+  "k\0"
+  "l\0"
+  "m\0"
+  "n\0"
+  "o\0"
+  "p\0"
+  "q\0"
+  "r\0"
+  "s\0"
+  "t\0"
+  "u\0"
+  "v\0"
+  "w\0"
+  "x\0"
+  "y\0"
+  "z\0"
+  "braceleft\0"
+  "bar\0"
+  "braceright\0"
+  "asciitilde\0"
+  "nobreakspace\0"
+  "exclamdown\0"
+  "cent\0"
+  "sterling\0"
+  "currency\0"
+  "yen\0"
+  "brokenbar\0"
+  "section\0"
+  "diaeresis\0"
+  "copyright\0"
+  "ordfeminine\0"
+  "guillemotleft\0"
+  "notsign\0"
+  "hyphen\0"
+  "registered\0"
+  "macron\0"
+  "degree\0"
+  "plusminus\0"
+  "twosuperior\0"
+  "threesuperior\0"
+  "acute\0"
+  "mu\0"
+  "paragraph\0"
+  "periodcentered\0"
+  "cedilla\0"
+  "onesuperior\0"
+  "masculine\0"
+  "guillemotright\0"
+  "onequarter\0"
+  "onehalf\0"
+  "threequarters\0"
+  "questiondown\0"
+  "Agrave\0"
+  "Aacute\0"
+  "Acircumflex\0"
+  "Atilde\0"
+  "Adiaeresis\0"
+  "Aring\0"
+  "AE\0"
+  "Ccedilla\0"
+  "Egrave\0"
+  "Eacute\0"
+  "Ecircumflex\0"
+  "Ediaeresis\0"
+  "Igrave\0"
+  "Iacute\0"
+  "Icircumflex\0"
+  "Idiaeresis\0"
+  "ETH\0"
+  "Eth\0"
+  "Ntilde\0"
+  "Ograve\0"
+  "Oacute\0"
+  "Ocircumflex\0"
+  "Otilde\0"
+  "Odiaeresis\0"
+  "multiply\0"
+  "Ooblique\0"
+  "Ugrave\0"
+  "Uacute\0"
+  "Ucircumflex\0"
+  "Udiaeresis\0"
+  "Yacute\0"
+  "THORN\0"
+  "Thorn\0"
+  "ssharp\0"
+  "agrave\0"
+  "aacute\0"
+  "acircumflex\0"
+  "atilde\0"
+  "adiaeresis\0"
+  "aring\0"
+  "ae\0"
+  "ccedilla\0"
+  "egrave\0"
+  "eacute\0"
+  "ecircumflex\0"
+  "ediaeresis\0"
+  "igrave\0"
+  "iacute\0"
+  "icircumflex\0"
+  "idiaeresis\0"
+  "eth\0"
+  "ntilde\0"
+  "ograve\0"
+  "oacute\0"
+  "ocircumflex\0"
+  "otilde\0"
+  "odiaeresis\0"
+  "division\0"
+  "oslash\0"
+  "ugrave\0"
+  "uacute\0"
+  "ucircumflex\0"
+  "udiaeresis\0"
+  "yacute\0"
+  "thorn\0"
+  "ydiaeresis\0"
+  "Aogonek\0"
+  "breve\0"
+  "Lstroke\0"
+  "Lcaron\0"
+  "Sacute\0"
+  "Scaron\0"
+  "Scedilla\0"
+  "Tcaron\0"
+  "Zacute\0"
+  "Zcaron\0"
+  "Zabovedot\0"
+  "aogonek\0"
+  "ogonek\0"
+  "lstroke\0"
+  "lcaron\0"
+  "sacute\0"
+  "caron\0"
+  "scaron\0"
+  "scedilla\0"
+  "tcaron\0"
+  "zacute\0"
+  "doubleacute\0"
+  "zcaron\0"
+  "zabovedot\0"
+  "Racute\0"
+  "Abreve\0"
+  "Lacute\0"
+  "Cacute\0"
+  "Ccaron\0"
+  "Eogonek\0"
+  "Ecaron\0"
+  "Dcaron\0"
+  "Dstroke\0"
+  "Nacute\0"
+  "Ncaron\0"
+  "Odoubleacute\0"
+  "Rcaron\0"
+  "Uring\0"
+  "Udoubleacute\0"
+  "Tcedilla\0"
+  "racute\0"
+  "abreve\0"
+  "lacute\0"
+  "cacute\0"
+  "ccaron\0"
+  "eogonek\0"
+  "ecaron\0"
+  "dcaron\0"
+  "dstroke\0"
+  "nacute\0"
+  "ncaron\0"
+  "odoubleacute\0"
+  "rcaron\0"
+  "uring\0"
+  "udoubleacute\0"
+  "tcedilla\0"
+  "abovedot\0"
+  "Hstroke\0"
+  "Hcircumflex\0"
+  "Iabovedot\0"
+  "Gbreve\0"
+  "Jcircumflex\0"
+  "hstroke\0"
+  "hcircumflex\0"
+  "idotless\0"
+  "gbreve\0"
+  "jcircumflex\0"
+  "Cabovedot\0"
+  "Ccircumflex\0"
+  "Gabovedot\0"
+  "Gcircumflex\0"
+  "Ubreve\0"
+  "Scircumflex\0"
+  "cabovedot\0"
+  "ccircumflex\0"
+  "gabovedot\0"
+  "gcircumflex\0"
+  "ubreve\0"
+  "scircumflex\0"
+  "kappa\0"
+  "kra\0"
+  "Rcedilla\0"
+  "Itilde\0"
+  "Lcedilla\0"
+  "Emacron\0"
+  "Gcedilla\0"
+  "Tslash\0"
+  "rcedilla\0"
+  "itilde\0"
+  "lcedilla\0"
+  "emacron\0"
+  "gcedilla\0"
+  "tslash\0"
+  "ENG\0"
+  "eng\0"
+  "Amacron\0"
+  "Iogonek\0"
+  "Eabovedot\0"
+  "Imacron\0"
+  "Ncedilla\0"
+  "Omacron\0"
+  "Kcedilla\0"
+  "Uogonek\0"
+  "Utilde\0"
+  "Umacron\0"
+  "amacron\0"
+  "iogonek\0"
+  "eabovedot\0"
+  "imacron\0"
+  "ncedilla\0"
+  "omacron\0"
+  "kcedilla\0"
+  "uogonek\0"
+  "utilde\0"
+  "umacron\0"
+  "overline\0"
+  "kana_fullstop\0"
+  "kana_openingbracket\0"
+  "kana_closingbracket\0"
+  "kana_comma\0"
+  "kana_conjunctive\0"
+  "kana_middledot\0"
+  "kana_WO\0"
+  "kana_a\0"
+  "kana_i\0"
+  "kana_u\0"
+  "kana_e\0"
+  "kana_o\0"
+  "kana_ya\0"
+  "kana_yu\0"
+  "kana_yo\0"
+  "kana_tsu\0"
+  "kana_tu\0"
+  "prolongedsound\0"
+  "kana_A\0"
+  "kana_I\0"
+  "kana_U\0"
+  "kana_E\0"
+  "kana_O\0"
+  "kana_KA\0"
+  "kana_KI\0"
+  "kana_KU\0"
+  "kana_KE\0"
+  "kana_KO\0"
+  "kana_SA\0"
+  "kana_SHI\0"
+  "kana_SU\0"
+  "kana_SE\0"
+  "kana_SO\0"
+  "kana_TA\0"
+  "kana_CHI\0"
+  "kana_TI\0"
+  "kana_TSU\0"
+  "kana_TU\0"
+  "kana_TE\0"
+  "kana_TO\0"
+  "kana_NA\0"
+  "kana_NI\0"
+  "kana_NU\0"
+  "kana_NE\0"
+  "kana_NO\0"
+  "kana_HA\0"
+  "kana_HI\0"
+  "kana_FU\0"
+  "kana_HU\0"
+  "kana_HE\0"
+  "kana_HO\0"
+  "kana_MA\0"
+  "kana_MI\0"
+  "kana_MU\0"
+  "kana_ME\0"
+  "kana_MO\0"
+  "kana_YA\0"
+  "kana_YU\0"
+  "kana_YO\0"
+  "kana_RA\0"
+  "kana_RI\0"
+  "kana_RU\0"
+  "kana_RE\0"
+  "kana_RO\0"
+  "kana_WA\0"
+  "kana_N\0"
+  "voicedsound\0"
+  "semivoicedsound\0"
+  "Arabic_comma\0"
+  "Arabic_semicolon\0"
+  "Arabic_question_mark\0"
+  "Arabic_hamza\0"
+  "Arabic_maddaonalef\0"
+  "Arabic_hamzaonalef\0"
+  "Arabic_hamzaonwaw\0"
+  "Arabic_hamzaunderalef\0"
+  "Arabic_hamzaonyeh\0"
+  "Arabic_alef\0"
+  "Arabic_beh\0"
+  "Arabic_tehmarbuta\0"
+  "Arabic_teh\0"
+  "Arabic_theh\0"
+  "Arabic_jeem\0"
+  "Arabic_hah\0"
+  "Arabic_khah\0"
+  "Arabic_dal\0"
+  "Arabic_thal\0"
+  "Arabic_ra\0"
+  "Arabic_zain\0"
+  "Arabic_seen\0"
+  "Arabic_sheen\0"
+  "Arabic_sad\0"
+  "Arabic_dad\0"
+  "Arabic_tah\0"
+  "Arabic_zah\0"
+  "Arabic_ain\0"
+  "Arabic_ghain\0"
+  "Arabic_tatweel\0"
+  "Arabic_feh\0"
+  "Arabic_qaf\0"
+  "Arabic_kaf\0"
+  "Arabic_lam\0"
+  "Arabic_meem\0"
+  "Arabic_noon\0"
+  "Arabic_ha\0"
+  "Arabic_heh\0"
+  "Arabic_waw\0"
+  "Arabic_alefmaksura\0"
+  "Arabic_yeh\0"
+  "Arabic_fathatan\0"
+  "Arabic_dammatan\0"
+  "Arabic_kasratan\0"
+  "Arabic_fatha\0"
+  "Arabic_damma\0"
+  "Arabic_kasra\0"
+  "Arabic_shadda\0"
+  "Arabic_sukun\0"
+  "Serbian_dje\0"
+  "Macedonia_gje\0"
+  "Cyrillic_io\0"
+  "Ukrainian_ie\0"
+  "Ukranian_je\0"
+  "Macedonia_dse\0"
+  "Ukrainian_i\0"
+  "Ukranian_i\0"
+  "Ukrainian_yi\0"
+  "Ukranian_yi\0"
+  "Cyrillic_je\0"
+  "Serbian_je\0"
+  "Cyrillic_lje\0"
+  "Serbian_lje\0"
+  "Cyrillic_nje\0"
+  "Serbian_nje\0"
+  "Serbian_tshe\0"
+  "Macedonia_kje\0"
+  "Byelorussian_shortu\0"
+  "Cyrillic_dzhe\0"
+  "Serbian_dze\0"
+  "numerosign\0"
+  "Serbian_DJE\0"
+  "Macedonia_GJE\0"
+  "Cyrillic_IO\0"
+  "Ukrainian_IE\0"
+  "Ukranian_JE\0"
+  "Macedonia_DSE\0"
+  "Ukrainian_I\0"
+  "Ukranian_I\0"
+  "Ukrainian_YI\0"
+  "Ukranian_YI\0"
+  "Cyrillic_JE\0"
+  "Serbian_JE\0"
+  "Cyrillic_LJE\0"
+  "Serbian_LJE\0"
+  "Cyrillic_NJE\0"
+  "Serbian_NJE\0"
+  "Serbian_TSHE\0"
+  "Macedonia_KJE\0"
+  "Byelorussian_SHORTU\0"
+  "Cyrillic_DZHE\0"
+  "Serbian_DZE\0"
+  "Cyrillic_yu\0"
+  "Cyrillic_a\0"
+  "Cyrillic_be\0"
+  "Cyrillic_tse\0"
+  "Cyrillic_de\0"
+  "Cyrillic_ie\0"
+  "Cyrillic_ef\0"
+  "Cyrillic_ghe\0"
+  "Cyrillic_ha\0"
+  "Cyrillic_i\0"
+  "Cyrillic_shorti\0"
+  "Cyrillic_ka\0"
+  "Cyrillic_el\0"
+  "Cyrillic_em\0"
+  "Cyrillic_en\0"
+  "Cyrillic_o\0"
+  "Cyrillic_pe\0"
+  "Cyrillic_ya\0"
+  "Cyrillic_er\0"
+  "Cyrillic_es\0"
+  "Cyrillic_te\0"
+  "Cyrillic_u\0"
+  "Cyrillic_zhe\0"
+  "Cyrillic_ve\0"
+  "Cyrillic_softsign\0"
+  "Cyrillic_yeru\0"
+  "Cyrillic_ze\0"
+  "Cyrillic_sha\0"
+  "Cyrillic_e\0"
+  "Cyrillic_shcha\0"
+  "Cyrillic_che\0"
+  "Cyrillic_hardsign\0"
+  "Cyrillic_YU\0"
+  "Cyrillic_A\0"
+  "Cyrillic_BE\0"
+  "Cyrillic_TSE\0"
+  "Cyrillic_DE\0"
+  "Cyrillic_IE\0"
+  "Cyrillic_EF\0"
+  "Cyrillic_GHE\0"
+  "Cyrillic_HA\0"
+  "Cyrillic_I\0"
+  "Cyrillic_SHORTI\0"
+  "Cyrillic_KA\0"
+  "Cyrillic_EL\0"
+  "Cyrillic_EM\0"
+  "Cyrillic_EN\0"
+  "Cyrillic_O\0"
+  "Cyrillic_PE\0"
+  "Cyrillic_YA\0"
+  "Cyrillic_ER\0"
+  "Cyrillic_ES\0"
+  "Cyrillic_TE\0"
+  "Cyrillic_U\0"
+  "Cyrillic_ZHE\0"
+  "Cyrillic_VE\0"
+  "Cyrillic_SOFTSIGN\0"
+  "Cyrillic_YERU\0"
+  "Cyrillic_ZE\0"
+  "Cyrillic_SHA\0"
+  "Cyrillic_E\0"
+  "Cyrillic_SHCHA\0"
+  "Cyrillic_CHE\0"
+  "Cyrillic_HARDSIGN\0"
+  "Greek_ALPHAaccent\0"
+  "Greek_EPSILONaccent\0"
+  "Greek_ETAaccent\0"
+  "Greek_IOTAaccent\0"
+  "Greek_IOTAdieresis\0"
+  "Greek_IOTAdiaeresis\0"
+  "Greek_OMICRONaccent\0"
+  "Greek_UPSILONaccent\0"
+  "Greek_UPSILONdieresis\0"
+  "Greek_OMEGAaccent\0"
+  "Greek_accentdieresis\0"
+  "Greek_horizbar\0"
+  "Greek_alphaaccent\0"
+  "Greek_epsilonaccent\0"
+  "Greek_etaaccent\0"
+  "Greek_iotaaccent\0"
+  "Greek_iotadieresis\0"
+  "Greek_iotaaccentdieresis\0"
+  "Greek_omicronaccent\0"
+  "Greek_upsilonaccent\0"
+  "Greek_upsilondieresis\0"
+  "Greek_upsilonaccentdieresis\0"
+  "Greek_omegaaccent\0"
+  "Greek_ALPHA\0"
+  "Greek_BETA\0"
+  "Greek_GAMMA\0"
+  "Greek_DELTA\0"
+  "Greek_EPSILON\0"
+  "Greek_ZETA\0"
+  "Greek_ETA\0"
+  "Greek_THETA\0"
+  "Greek_IOTA\0"
+  "Greek_KAPPA\0"
+  "Greek_LAMBDA\0"
+  "Greek_LAMDA\0"
+  "Greek_MU\0"
+  "Greek_NU\0"
+  "Greek_XI\0"
+  "Greek_OMICRON\0"
+  "Greek_PI\0"
+  "Greek_RHO\0"
+  "Greek_SIGMA\0"
+  "Greek_TAU\0"
+  "Greek_UPSILON\0"
+  "Greek_PHI\0"
+  "Greek_CHI\0"
+  "Greek_PSI\0"
+  "Greek_OMEGA\0"
+  "Greek_alpha\0"
+  "Greek_beta\0"
+  "Greek_gamma\0"
+  "Greek_delta\0"
+  "Greek_epsilon\0"
+  "Greek_zeta\0"
+  "Greek_eta\0"
+  "Greek_theta\0"
+  "Greek_iota\0"
+  "Greek_kappa\0"
+  "Greek_lambda\0"
+  "Greek_lamda\0"
+  "Greek_mu\0"
+  "Greek_nu\0"
+  "Greek_xi\0"
+  "Greek_omicron\0"
+  "Greek_pi\0"
+  "Greek_rho\0"
+  "Greek_sigma\0"
+  "Greek_finalsmallsigma\0"
+  "Greek_tau\0"
+  "Greek_upsilon\0"
+  "Greek_phi\0"
+  "Greek_chi\0"
+  "Greek_psi\0"
+  "Greek_omega\0"
+  "leftradical\0"
+  "topleftradical\0"
+  "horizconnector\0"
+  "topintegral\0"
+  "botintegral\0"
+  "vertconnector\0"
+  "topleftsqbracket\0"
+  "botleftsqbracket\0"
+  "toprightsqbracket\0"
+  "botrightsqbracket\0"
+  "topleftparens\0"
+  "botleftparens\0"
+  "toprightparens\0"
+  "botrightparens\0"
+  "leftmiddlecurlybrace\0"
+  "rightmiddlecurlybrace\0"
+  "topleftsummation\0"
+  "botleftsummation\0"
+  "topvertsummationconnector\0"
+  "botvertsummationconnector\0"
+  "toprightsummation\0"
+  "botrightsummation\0"
+  "rightmiddlesummation\0"
+  "lessthanequal\0"
+  "notequal\0"
+  "greaterthanequal\0"
+  "integral\0"
+  "therefore\0"
+  "variation\0"
+  "infinity\0"
+  "nabla\0"
+  "approximate\0"
+  "similarequal\0"
+  "ifonlyif\0"
+  "implies\0"
+  "identical\0"
+  "radical\0"
+  "includedin\0"
+  "includes\0"
+  "intersection\0"
+  "union\0"
+  "logicaland\0"
+  "logicalor\0"
+  "partialderivative\0"
+  "function\0"
+  "leftarrow\0"
+  "uparrow\0"
+  "rightarrow\0"
+  "downarrow\0"
+  "blank\0"
+  "soliddiamond\0"
+  "checkerboard\0"
+  "ht\0"
+  "ff\0"
+  "cr\0"
+  "lf\0"
+  "nl\0"
+  "vt\0"
+  "lowrightcorner\0"
+  "uprightcorner\0"
+  "upleftcorner\0"
+  "lowleftcorner\0"
+  "crossinglines\0"
+  "horizlinescan1\0"
+  "horizlinescan3\0"
+  "horizlinescan5\0"
+  "horizlinescan7\0"
+  "horizlinescan9\0"
+  "leftt\0"
+  "rightt\0"
+  "bott\0"
+  "topt\0"
+  "vertbar\0"
+  "emspace\0"
+  "enspace\0"
+  "em3space\0"
+  "em4space\0"
+  "digitspace\0"
+  "punctspace\0"
+  "thinspace\0"
+  "hairspace\0"
+  "emdash\0"
+  "endash\0"
+  "signifblank\0"
+  "ellipsis\0"
+  "doubbaselinedot\0"
+  "onethird\0"
+  "twothirds\0"
+  "onefifth\0"
+  "twofifths\0"
+  "threefifths\0"
+  "fourfifths\0"
+  "onesixth\0"
+  "fivesixths\0"
+  "careof\0"
+  "figdash\0"
+  "leftanglebracket\0"
+  "decimalpoint\0"
+  "rightanglebracket\0"
+  "marker\0"
+  "oneeighth\0"
+  "threeeighths\0"
+  "fiveeighths\0"
+  "seveneighths\0"
+  "trademark\0"
+  "signaturemark\0"
+  "trademarkincircle\0"
+  "leftopentriangle\0"
+  "rightopentriangle\0"
+  "emopencircle\0"
+  "emopenrectangle\0"
+  "leftsinglequotemark\0"
+  "rightsinglequotemark\0"
+  "leftdoublequotemark\0"
+  "rightdoublequotemark\0"
+  "prescription\0"
+  "minutes\0"
+  "seconds\0"
+  "latincross\0"
+  "hexagram\0"
+  "filledrectbullet\0"
+  "filledlefttribullet\0"
+  "filledrighttribullet\0"
+  "emfilledcircle\0"
+  "emfilledrect\0"
+  "enopencircbullet\0"
+  "enopensquarebullet\0"
+  "openrectbullet\0"
+  "opentribulletup\0"
+  "opentribulletdown\0"
+  "openstar\0"
+  "enfilledcircbullet\0"
+  "enfilledsqbullet\0"
+  "filledtribulletup\0"
+  "filledtribulletdown\0"
+  "leftpointer\0"
+  "rightpointer\0"
+  "club\0"
+  "diamond\0"
+  "heart\0"
+  "maltesecross\0"
+  "dagger\0"
+  "doubledagger\0"
+  "checkmark\0"
+  "ballotcross\0"
+  "musicalsharp\0"
+  "musicalflat\0"
+  "malesymbol\0"
+  "femalesymbol\0"
+  "telephone\0"
+  "telephonerecorder\0"
+  "phonographcopyright\0"
+  "caret\0"
+  "singlelowquotemark\0"
+  "doublelowquotemark\0"
+  "cursor\0"
+  "leftcaret\0"
+  "rightcaret\0"
+  "downcaret\0"
+  "upcaret\0"
+  "overbar\0"
+  "downtack\0"
+  "upshoe\0"
+  "downstile\0"
+  "underbar\0"
+  "jot\0"
+  "quad\0"
+  "uptack\0"
+  "circle\0"
+  "upstile\0"
+  "downshoe\0"
+  "rightshoe\0"
+  "leftshoe\0"
+  "lefttack\0"
+  "righttack\0"
+  "hebrew_doublelowline\0"
+  "hebrew_aleph\0"
+  "hebrew_bet\0"
+  "hebrew_beth\0"
+  "hebrew_gimel\0"
+  "hebrew_gimmel\0"
+  "hebrew_dalet\0"
+  "hebrew_daleth\0"
+  "hebrew_he\0"
+  "hebrew_waw\0"
+  "hebrew_zain\0"
+  "hebrew_zayin\0"
+  "hebrew_chet\0"
+  "hebrew_het\0"
+  "hebrew_tet\0"
+  "hebrew_teth\0"
+  "hebrew_yod\0"
+  "hebrew_finalkaph\0"
+  "hebrew_kaph\0"
+  "hebrew_lamed\0"
+  "hebrew_finalmem\0"
+  "hebrew_mem\0"
+  "hebrew_finalnun\0"
+  "hebrew_nun\0"
+  "hebrew_samech\0"
+  "hebrew_samekh\0"
+  "hebrew_ayin\0"
+  "hebrew_finalpe\0"
+  "hebrew_pe\0"
+  "hebrew_finalzade\0"
+  "hebrew_finalzadi\0"
+  "hebrew_zade\0"
+  "hebrew_zadi\0"
+  "hebrew_kuf\0"
+  "hebrew_qoph\0"
+  "hebrew_resh\0"
+  "hebrew_shin\0"
+  "hebrew_taf\0"
+  "hebrew_taw\0"
+  "Thai_kokai\0"
+  "Thai_khokhai\0"
+  "Thai_khokhuat\0"
+  "Thai_khokhwai\0"
+  "Thai_khokhon\0"
+  "Thai_khorakhang\0"
+  "Thai_ngongu\0"
+  "Thai_chochan\0"
+  "Thai_choching\0"
+  "Thai_chochang\0"
+  "Thai_soso\0"
+  "Thai_chochoe\0"
+  "Thai_yoying\0"
+  "Thai_dochada\0"
+  "Thai_topatak\0"
+  "Thai_thothan\0"
+  "Thai_thonangmontho\0"
+  "Thai_thophuthao\0"
+  "Thai_nonen\0"
+  "Thai_dodek\0"
+  "Thai_totao\0"
+  "Thai_thothung\0"
+  "Thai_thothahan\0"
+  "Thai_thothong\0"
+  "Thai_nonu\0"
+  "Thai_bobaimai\0"
+  "Thai_popla\0"
+  "Thai_phophung\0"
+  "Thai_fofa\0"
+  "Thai_phophan\0"
+  "Thai_fofan\0"
+  "Thai_phosamphao\0"
+  "Thai_moma\0"
+  "Thai_yoyak\0"
+  "Thai_rorua\0"
+  "Thai_ru\0"
+  "Thai_loling\0"
+  "Thai_lu\0"
+  "Thai_wowaen\0"
+  "Thai_sosala\0"
+  "Thai_sorusi\0"
+  "Thai_sosua\0"
+  "Thai_hohip\0"
+  "Thai_lochula\0"
+  "Thai_oang\0"
+  "Thai_honokhuk\0"
+  "Thai_paiyannoi\0"
+  "Thai_saraa\0"
+  "Thai_maihanakat\0"
+  "Thai_saraaa\0"
+  "Thai_saraam\0"
+  "Thai_sarai\0"
+  "Thai_saraii\0"
+  "Thai_saraue\0"
+  "Thai_sarauee\0"
+  "Thai_sarau\0"
+  "Thai_sarauu\0"
+  "Thai_phinthu\0"
+  "Thai_maihanakat_maitho\0"
+  "Thai_baht\0"
+  "Thai_sarae\0"
+  "Thai_saraae\0"
+  "Thai_sarao\0"
+  "Thai_saraaimaimuan\0"
+  "Thai_saraaimaimalai\0"
+  "Thai_lakkhangyao\0"
+  "Thai_maiyamok\0"
+  "Thai_maitaikhu\0"
+  "Thai_maiek\0"
+  "Thai_maitho\0"
+  "Thai_maitri\0"
+  "Thai_maichattawa\0"
+  "Thai_thanthakhat\0"
+  "Thai_nikhahit\0"
+  "Thai_leksun\0"
+  "Thai_leknung\0"
+  "Thai_leksong\0"
+  "Thai_leksam\0"
+  "Thai_leksi\0"
+  "Thai_lekha\0"
+  "Thai_lekhok\0"
+  "Thai_lekchet\0"
+  "Thai_lekpaet\0"
+  "Thai_lekkao\0"
+  "Hangul_Kiyeog\0"
+  "Hangul_SsangKiyeog\0"
+  "Hangul_KiyeogSios\0"
+  "Hangul_Nieun\0"
+  "Hangul_NieunJieuj\0"
+  "Hangul_NieunHieuh\0"
+  "Hangul_Dikeud\0"
+  "Hangul_SsangDikeud\0"
+  "Hangul_Rieul\0"
+  "Hangul_RieulKiyeog\0"
+  "Hangul_RieulMieum\0"
+  "Hangul_RieulPieub\0"
+  "Hangul_RieulSios\0"
+  "Hangul_RieulTieut\0"
+  "Hangul_RieulPhieuf\0"
+  "Hangul_RieulHieuh\0"
+  "Hangul_Mieum\0"
+  "Hangul_Pieub\0"
+  "Hangul_SsangPieub\0"
+  "Hangul_PieubSios\0"
+  "Hangul_Sios\0"
+  "Hangul_SsangSios\0"
+  "Hangul_Ieung\0"
+  "Hangul_Jieuj\0"
+  "Hangul_SsangJieuj\0"
+  "Hangul_Cieuc\0"
+  "Hangul_Khieuq\0"
+  "Hangul_Tieut\0"
+  "Hangul_Phieuf\0"
+  "Hangul_Hieuh\0"
+  "Hangul_A\0"
+  "Hangul_AE\0"
+  "Hangul_YA\0"
+  "Hangul_YAE\0"
+  "Hangul_EO\0"
+  "Hangul_E\0"
+  "Hangul_YEO\0"
+  "Hangul_YE\0"
+  "Hangul_O\0"
+  "Hangul_WA\0"
+  "Hangul_WAE\0"
+  "Hangul_OE\0"
+  "Hangul_YO\0"
+  "Hangul_U\0"
+  "Hangul_WEO\0"
+  "Hangul_WE\0"
+  "Hangul_WI\0"
+  "Hangul_YU\0"
+  "Hangul_EU\0"
+  "Hangul_YI\0"
+  "Hangul_I\0"
+  "Hangul_J_Kiyeog\0"
+  "Hangul_J_SsangKiyeog\0"
+  "Hangul_J_KiyeogSios\0"
+  "Hangul_J_Nieun\0"
+  "Hangul_J_NieunJieuj\0"
+  "Hangul_J_NieunHieuh\0"
+  "Hangul_J_Dikeud\0"
+  "Hangul_J_Rieul\0"
+  "Hangul_J_RieulKiyeog\0"
+  "Hangul_J_RieulMieum\0"
+  "Hangul_J_RieulPieub\0"
+  "Hangul_J_RieulSios\0"
+  "Hangul_J_RieulTieut\0"
+  "Hangul_J_RieulPhieuf\0"
+  "Hangul_J_RieulHieuh\0"
+  "Hangul_J_Mieum\0"
+  "Hangul_J_Pieub\0"
+  "Hangul_J_PieubSios\0"
+  "Hangul_J_Sios\0"
+  "Hangul_J_SsangSios\0"
+  "Hangul_J_Ieung\0"
+  "Hangul_J_Jieuj\0"
+  "Hangul_J_Cieuc\0"
+  "Hangul_J_Khieuq\0"
+  "Hangul_J_Tieut\0"
+  "Hangul_J_Phieuf\0"
+  "Hangul_J_Hieuh\0"
+  "Hangul_RieulYeorinHieuh\0"
+  "Hangul_SunkyeongeumMieum\0"
+  "Hangul_SunkyeongeumPieub\0"
+  "Hangul_PanSios\0"
+  "Hangul_KkogjiDalrinIeung\0"
+  "Hangul_SunkyeongeumPhieuf\0"
+  "Hangul_YeorinHieuh\0"
+  "Hangul_AraeA\0"
+  "Hangul_AraeAE\0"
+  "Hangul_J_PanSios\0"
+  "Hangul_J_KkogjiDalrinIeung\0"
+  "Hangul_J_YeorinHieuh\0"
+  "Korean_Won\0"
+  "OE\0"
+  "oe\0"
+  "Ydiaeresis\0"
+  "EcuSign\0"
+  "ColonSign\0"
+  "CruzeiroSign\0"
+  "FFrancSign\0"
+  "LiraSign\0"
+  "MillSign\0"
+  "NairaSign\0"
+  "PesetaSign\0"
+  "RupeeSign\0"
+  "WonSign\0"
+  "NewSheqelSign\0"
+  "DongSign\0"
+  "EuroSign\0"
+  "3270_Duplicate\0"
+  "3270_FieldMark\0"
+  "3270_Right2\0"
+  "3270_Left2\0"
+  "3270_BackTab\0"
+  "3270_EraseEOF\0"
+  "3270_EraseInput\0"
+  "3270_Reset\0"
+  "3270_Quit\0"
+  "3270_PA1\0"
+  "3270_PA2\0"
+  "3270_PA3\0"
+  "3270_Test\0"
+  "3270_Attn\0"
+  "3270_CursorBlink\0"
+  "3270_AltCursor\0"
+  "3270_KeyClick\0"
+  "3270_Jump\0"
+  "3270_Ident\0"
+  "3270_Rule\0"
+  "3270_Copy\0"
+  "3270_Play\0"
+  "3270_Setup\0"
+  "3270_Record\0"
+  "3270_ChangeScreen\0"
+  "3270_DeleteWord\0"
+  "3270_ExSelect\0"
+  "3270_CursorSelect\0"
+  "3270_PrintScreen\0"
+  "3270_Enter\0"
+  "ISO_Lock\0"
+  "ISO_Level2_Latch\0"
+  "ISO_Level3_Shift\0"
+  "ISO_Level3_Latch\0"
+  "ISO_Level3_Lock\0"
+  "ISO_Group_Latch\0"
+  "ISO_Group_Lock\0"
+  "ISO_Next_Group\0"
+  "ISO_Next_Group_Lock\0"
+  "ISO_Prev_Group\0"
+  "ISO_Prev_Group_Lock\0"
+  "ISO_First_Group\0"
+  "ISO_First_Group_Lock\0"
+  "ISO_Last_Group\0"
+  "ISO_Last_Group_Lock\0"
+  "ISO_Left_Tab\0"
+  "ISO_Move_Line_Up\0"
+  "ISO_Move_Line_Down\0"
+  "ISO_Partial_Line_Up\0"
+  "ISO_Partial_Line_Down\0"
+  "ISO_Partial_Space_Left\0"
+  "ISO_Partial_Space_Right\0"
+  "ISO_Set_Margin_Left\0"
+  "ISO_Set_Margin_Right\0"
+  "ISO_Release_Margin_Left\0"
+  "ISO_Release_Margin_Right\0"
+  "ISO_Release_Both_Margins\0"
+  "ISO_Fast_Cursor_Left\0"
+  "ISO_Fast_Cursor_Right\0"
+  "ISO_Fast_Cursor_Up\0"
+  "ISO_Fast_Cursor_Down\0"
+  "ISO_Continuous_Underline\0"
+  "ISO_Discontinuous_Underline\0"
+  "ISO_Emphasize\0"
+  "ISO_Center_Object\0"
+  "ISO_Enter\0"
+  "dead_grave\0"
+  "dead_acute\0"
+  "dead_circumflex\0"
+  "dead_tilde\0"
+  "dead_macron\0"
+  "dead_breve\0"
+  "dead_abovedot\0"
+  "dead_diaeresis\0"
+  "dead_abovering\0"
+  "dead_doubleacute\0"
+  "dead_caron\0"
+  "dead_cedilla\0"
+  "dead_ogonek\0"
+  "dead_iota\0"
+  "dead_voiced_sound\0"
+  "dead_semivoiced_sound\0"
+  "dead_belowdot\0"
+  "dead_hook\0"
+  "dead_horn\0"
+  "AccessX_Enable\0"
+  "AccessX_Feedback_Enable\0"
+  "RepeatKeys_Enable\0"
+  "SlowKeys_Enable\0"
+  "BounceKeys_Enable\0"
+  "StickyKeys_Enable\0"
+  "MouseKeys_Enable\0"
+  "MouseKeys_Accel_Enable\0"
+  "Overlay1_Enable\0"
+  "Overlay2_Enable\0"
+  "AudibleBell_Enable\0"
+  "First_Virtual_Screen\0"
+  "Prev_Virtual_Screen\0"
+  "Next_Virtual_Screen\0"
+  "Last_Virtual_Screen\0"
+  "Terminate_Server\0"
+  "Pointer_Left\0"
+  "Pointer_Right\0"
+  "Pointer_Up\0"
+  "Pointer_Down\0"
+  "Pointer_UpLeft\0"
+  "Pointer_UpRight\0"
+  "Pointer_DownLeft\0"
+  "Pointer_DownRight\0"
+  "Pointer_Button_Dflt\0"
+  "Pointer_Button1\0"
+  "Pointer_Button2\0"
+  "Pointer_Button3\0"
+  "Pointer_Button4\0"
+  "Pointer_Button5\0"
+  "Pointer_DblClick_Dflt\0"
+  "Pointer_DblClick1\0"
+  "Pointer_DblClick2\0"
+  "Pointer_DblClick3\0"
+  "Pointer_DblClick4\0"
+  "Pointer_DblClick5\0"
+  "Pointer_Drag_Dflt\0"
+  "Pointer_Drag1\0"
+  "Pointer_Drag2\0"
+  "Pointer_Drag3\0"
+  "Pointer_Drag4\0"
+  "Pointer_EnableKeys\0"
+  "Pointer_Accelerate\0"
+  "Pointer_DfltBtnNext\0"
+  "Pointer_DfltBtnPrev\0"
+  "Pointer_Drag5\0"
+  "BackSpace\0"
+  "Tab\0"
+  "Linefeed\0"
+  "Clear\0"
+  "Return\0"
+  "Pause\0"
+  "Scroll_Lock\0"
+  "Sys_Req\0"
+  "Escape\0"
+  "Multi_key\0"
+  "Kanji\0"
+  "Muhenkan\0"
+  "Henkan\0"
+  "Henkan_Mode\0"
+  "Romaji\0"
+  "Hiragana\0"
+  "Katakana\0"
+  "Hiragana_Katakana\0"
+  "Zenkaku\0"
+  "Hankaku\0"
+  "Zenkaku_Hankaku\0"
+  "Touroku\0"
+  "Massyo\0"
+  "Kana_Lock\0"
+  "Kana_Shift\0"
+  "Eisu_Shift\0"
+  "Eisu_toggle\0"
+  "Hangul\0"
+  "Hangul_Start\0"
+  "Hangul_End\0"
+  "Hangul_Hanja\0"
+  "Hangul_Jamo\0"
+  "Hangul_Romaja\0"
+  "Codeinput\0"
+  "Hangul_Jeonja\0"
+  "Hangul_Banja\0"
+  "Hangul_PreHanja\0"
+  "Hangul_PostHanja\0"
+  "SingleCandidate\0"
+  "MultipleCandidate\0"
+  "PreviousCandidate\0"
+  "Hangul_Special\0"
+  "Home\0"
+  "Left\0"
+  "Up\0"
+  "Right\0"
+  "Down\0"
+  "Page_Up\0"
+  "Prior\0"
+  "Page_Down\0"
+  "Next\0"
+  "End\0"
+  "Begin\0"
+  "Select\0"
+  "Print\0"
+  "Execute\0"
+  "Insert\0"
+  "Undo\0"
+  "Redo\0"
+  "Menu\0"
+  "Find\0"
+  "Cancel\0"
+  "Help\0"
+  "Break\0"
+  "Arabic_switch\0"
+  "Greek_switch\0"
+  "Hangul_switch\0"
+  "Hebrew_switch\0"
+  "ISO_Group_Shift\0"
+  "Mode_switch\0"
+  "kana_switch\0"
+  "script_switch\0"
+  "Num_Lock\0"
+  "KP_Space\0"
+  "KP_Tab\0"
+  "KP_Enter\0"
+  "KP_F1\0"
+  "KP_F2\0"
+  "KP_F3\0"
+  "KP_F4\0"
+  "KP_Home\0"
+  "KP_Left\0"
+  "KP_Up\0"
+  "KP_Right\0"
+  "KP_Down\0"
+  "KP_Page_Up\0"
+  "KP_Prior\0"
+  "KP_Page_Down\0"
+  "KP_Next\0"
+  "KP_End\0"
+  "KP_Begin\0"
+  "KP_Insert\0"
+  "KP_Delete\0"
+  "KP_Multiply\0"
+  "KP_Add\0"
+  "KP_Separator\0"
+  "KP_Subtract\0"
+  "KP_Decimal\0"
+  "KP_Divide\0"
+  "KP_0\0"
+  "KP_1\0"
+  "KP_2\0"
+  "KP_3\0"
+  "KP_4\0"
+  "KP_5\0"
+  "KP_6\0"
+  "KP_7\0"
+  "KP_8\0"
+  "KP_9\0"
+  "KP_Equal\0"
+  "F1\0"
+  "F2\0"
+  "F3\0"
+  "F4\0"
+  "F5\0"
+  "F6\0"
+  "F7\0"
+  "F8\0"
+  "F9\0"
+  "F10\0"
+  "F11\0"
+  "F12\0"
+  "F13\0"
+  "F14\0"
+  "F15\0"
+  "F16\0"
+  "F17\0"
+  "F18\0"
+  "F19\0"
+  "F20\0"
+  "F21\0"
+  "F22\0"
+  "F23\0"
+  "F24\0"
+  "F25\0"
+  "F26\0"
+  "F27\0"
+  "F28\0"
+  "F29\0"
+  "F30\0"
+  "F31\0"
+  "F32\0"
+  "F33\0"
+  "F34\0"
+  "F35\0"
+  "Shift_L\0"
+  "Shift_R\0"
+  "Control_L\0"
+  "Control_R\0"
+  "Caps_Lock\0"
+  "Shift_Lock\0"
+  "Meta_L\0"
+  "Meta_R\0"
+  "Alt_L\0"
+  "Alt_R\0"
+  "Super_L\0"
+  "Super_R\0"
+  "Hyper_L\0"
+  "Hyper_R\0"
+  "Delete\0"
+  "VoidSymbol\0";
+
+typedef struct {
+    guint  keyval;
+    guint  offset;
+} gdk_key;
+
+static const gdk_key gdk_keys_by_keyval[] = {
+  { 0x000020, 0 },
+  { 0x000021, 6 },
+  { 0x000022, 13 },
+  { 0x000023, 22 },
+  { 0x000024, 33 },
+  { 0x000025, 40 },
+  { 0x000026, 48 },
+  { 0x000027, 58 },
+  { 0x000027, 69 },
+  { 0x000028, 80 },
+  { 0x000029, 90 },
+  { 0x00002a, 101 },
+  { 0x00002b, 110 },
+  { 0x00002c, 115 },
+  { 0x00002d, 121 },
+  { 0x00002e, 127 },
+  { 0x00002f, 134 },
+  { 0x000030, 140 },
+  { 0x000031, 142 },
+  { 0x000032, 144 },
+  { 0x000033, 146 },
+  { 0x000034, 148 },
+  { 0x000035, 150 },
+  { 0x000036, 152 },
+  { 0x000037, 154 },
+  { 0x000038, 156 },
+  { 0x000039, 158 },
+  { 0x00003a, 160 },
+  { 0x00003b, 166 },
+  { 0x00003c, 176 },
+  { 0x00003d, 181 },
+  { 0x00003e, 187 },
+  { 0x00003f, 195 },
+  { 0x000040, 204 },
+  { 0x000041, 207 },
+  { 0x000042, 209 },
+  { 0x000043, 211 },
+  { 0x000044, 213 },
+  { 0x000045, 215 },
+  { 0x000046, 217 },
+  { 0x000047, 219 },
+  { 0x000048, 221 },
+  { 0x000049, 223 },
+  { 0x00004a, 225 },
+  { 0x00004b, 227 },
+  { 0x00004c, 229 },
+  { 0x00004d, 231 },
+  { 0x00004e, 233 },
+  { 0x00004f, 235 },
+  { 0x000050, 237 },
+  { 0x000051, 239 },
+  { 0x000052, 241 },
+  { 0x000053, 243 },
+  { 0x000054, 245 },
+  { 0x000055, 247 },
+  { 0x000056, 249 },
+  { 0x000057, 251 },
+  { 0x000058, 253 },
+  { 0x000059, 255 },
+  { 0x00005a, 257 },
+  { 0x00005b, 259 },
+  { 0x00005c, 271 },
+  { 0x00005d, 281 },
+  { 0x00005e, 294 },
+  { 0x00005f, 306 },
+  { 0x000060, 317 },
+  { 0x000060, 323 },
+  { 0x000061, 333 },
+  { 0x000062, 335 },
+  { 0x000063, 337 },
+  { 0x000064, 339 },
+  { 0x000065, 341 },
+  { 0x000066, 343 },
+  { 0x000067, 345 },
+  { 0x000068, 347 },
+  { 0x000069, 349 },
+  { 0x00006a, 351 },
+  { 0x00006b, 353 },
+  { 0x00006c, 355 },
+  { 0x00006d, 357 },
+  { 0x00006e, 359 },
+  { 0x00006f, 361 },
+  { 0x000070, 363 },
+  { 0x000071, 365 },
+  { 0x000072, 367 },
+  { 0x000073, 369 },
+  { 0x000074, 371 },
+  { 0x000075, 373 },
+  { 0x000076, 375 },
+  { 0x000077, 377 },
+  { 0x000078, 379 },
+  { 0x000079, 381 },
+  { 0x00007a, 383 },
+  { 0x00007b, 385 },
+  { 0x00007c, 395 },
+  { 0x00007d, 399 },
+  { 0x00007e, 410 },
+  { 0x0000a0, 421 },
+  { 0x0000a1, 434 },
+  { 0x0000a2, 445 },
+  { 0x0000a3, 450 },
+  { 0x0000a4, 459 },
+  { 0x0000a5, 468 },
+  { 0x0000a6, 472 },
+  { 0x0000a7, 482 },
+  { 0x0000a8, 490 },
+  { 0x0000a9, 500 },
+  { 0x0000aa, 510 },
+  { 0x0000ab, 522 },
+  { 0x0000ac, 536 },
+  { 0x0000ad, 544 },
+  { 0x0000ae, 551 },
+  { 0x0000af, 562 },
+  { 0x0000b0, 569 },
+  { 0x0000b1, 576 },
+  { 0x0000b2, 586 },
+  { 0x0000b3, 598 },
+  { 0x0000b4, 612 },
+  { 0x0000b5, 618 },
+  { 0x0000b6, 621 },
+  { 0x0000b7, 631 },
+  { 0x0000b8, 646 },
+  { 0x0000b9, 654 },
+  { 0x0000ba, 666 },
+  { 0x0000bb, 676 },
+  { 0x0000bc, 691 },
+  { 0x0000bd, 702 },
+  { 0x0000be, 710 },
+  { 0x0000bf, 724 },
+  { 0x0000c0, 737 },
+  { 0x0000c1, 744 },
+  { 0x0000c2, 751 },
+  { 0x0000c3, 763 },
+  { 0x0000c4, 770 },
+  { 0x0000c5, 781 },
+  { 0x0000c6, 787 },
+  { 0x0000c7, 790 },
+  { 0x0000c8, 799 },
+  { 0x0000c9, 806 },
+  { 0x0000ca, 813 },
+  { 0x0000cb, 825 },
+  { 0x0000cc, 836 },
+  { 0x0000cd, 843 },
+  { 0x0000ce, 850 },
+  { 0x0000cf, 862 },
+  { 0x0000d0, 873 },
+  { 0x0000d0, 877 },
+  { 0x0000d1, 881 },
+  { 0x0000d2, 888 },
+  { 0x0000d3, 895 },
+  { 0x0000d4, 902 },
+  { 0x0000d5, 914 },
+  { 0x0000d6, 921 },
+  { 0x0000d7, 932 },
+  { 0x0000d8, 941 },
+  { 0x0000d9, 950 },
+  { 0x0000da, 957 },
+  { 0x0000db, 964 },
+  { 0x0000dc, 976 },
+  { 0x0000dd, 987 },
+  { 0x0000de, 994 },
+  { 0x0000de, 1000 },
+  { 0x0000df, 1006 },
+  { 0x0000e0, 1013 },
+  { 0x0000e1, 1020 },
+  { 0x0000e2, 1027 },
+  { 0x0000e3, 1039 },
+  { 0x0000e4, 1046 },
+  { 0x0000e5, 1057 },
+  { 0x0000e6, 1063 },
+  { 0x0000e7, 1066 },
+  { 0x0000e8, 1075 },
+  { 0x0000e9, 1082 },
+  { 0x0000ea, 1089 },
+  { 0x0000eb, 1101 },
+  { 0x0000ec, 1112 },
+  { 0x0000ed, 1119 },
+  { 0x0000ee, 1126 },
+  { 0x0000ef, 1138 },
+  { 0x0000f0, 1149 },
+  { 0x0000f1, 1153 },
+  { 0x0000f2, 1160 },
+  { 0x0000f3, 1167 },
+  { 0x0000f4, 1174 },
+  { 0x0000f5, 1186 },
+  { 0x0000f6, 1193 },
+  { 0x0000f7, 1204 },
+  { 0x0000f8, 1213 },
+  { 0x0000f9, 1220 },
+  { 0x0000fa, 1227 },
+  { 0x0000fb, 1234 },
+  { 0x0000fc, 1246 },
+  { 0x0000fd, 1257 },
+  { 0x0000fe, 1264 },
+  { 0x0000ff, 1270 },
+  { 0x0001a1, 1281 },
+  { 0x0001a2, 1289 },
+  { 0x0001a3, 1295 },
+  { 0x0001a5, 1303 },
+  { 0x0001a6, 1310 },
+  { 0x0001a9, 1317 },
+  { 0x0001aa, 1324 },
+  { 0x0001ab, 1333 },
+  { 0x0001ac, 1340 },
+  { 0x0001ae, 1347 },
+  { 0x0001af, 1354 },
+  { 0x0001b1, 1364 },
+  { 0x0001b2, 1372 },
+  { 0x0001b3, 1379 },
+  { 0x0001b5, 1387 },
+  { 0x0001b6, 1394 },
+  { 0x0001b7, 1401 },
+  { 0x0001b9, 1407 },
+  { 0x0001ba, 1414 },
+  { 0x0001bb, 1423 },
+  { 0x0001bc, 1430 },
+  { 0x0001bd, 1437 },
+  { 0x0001be, 1449 },
+  { 0x0001bf, 1456 },
+  { 0x0001c0, 1466 },
+  { 0x0001c3, 1473 },
+  { 0x0001c5, 1480 },
+  { 0x0001c6, 1487 },
+  { 0x0001c8, 1494 },
+  { 0x0001ca, 1501 },
+  { 0x0001cc, 1509 },
+  { 0x0001cf, 1516 },
+  { 0x0001d0, 1523 },
+  { 0x0001d1, 1531 },
+  { 0x0001d2, 1538 },
+  { 0x0001d5, 1545 },
+  { 0x0001d8, 1558 },
+  { 0x0001d9, 1565 },
+  { 0x0001db, 1571 },
+  { 0x0001de, 1584 },
+  { 0x0001e0, 1593 },
+  { 0x0001e3, 1600 },
+  { 0x0001e5, 1607 },
+  { 0x0001e6, 1614 },
+  { 0x0001e8, 1621 },
+  { 0x0001ea, 1628 },
+  { 0x0001ec, 1636 },
+  { 0x0001ef, 1643 },
+  { 0x0001f0, 1650 },
+  { 0x0001f1, 1658 },
+  { 0x0001f2, 1665 },
+  { 0x0001f5, 1672 },
+  { 0x0001f8, 1685 },
+  { 0x0001f9, 1692 },
+  { 0x0001fb, 1698 },
+  { 0x0001fe, 1711 },
+  { 0x0001ff, 1720 },
+  { 0x0002a1, 1729 },
+  { 0x0002a6, 1737 },
+  { 0x0002a9, 1749 },
+  { 0x0002ab, 1759 },
+  { 0x0002ac, 1766 },
+  { 0x0002b1, 1778 },
+  { 0x0002b6, 1786 },
+  { 0x0002b9, 1798 },
+  { 0x0002bb, 1807 },
+  { 0x0002bc, 1814 },
+  { 0x0002c5, 1826 },
+  { 0x0002c6, 1836 },
+  { 0x0002d5, 1848 },
+  { 0x0002d8, 1858 },
+  { 0x0002dd, 1870 },
+  { 0x0002de, 1877 },
+  { 0x0002e5, 1889 },
+  { 0x0002e6, 1899 },
+  { 0x0002f5, 1911 },
+  { 0x0002f8, 1921 },
+  { 0x0002fd, 1933 },
+  { 0x0002fe, 1940 },
+  { 0x0003a2, 1952 },
+  { 0x0003a2, 1958 },
+  { 0x0003a3, 1962 },
+  { 0x0003a5, 1971 },
+  { 0x0003a6, 1978 },
+  { 0x0003aa, 1987 },
+  { 0x0003ab, 1995 },
+  { 0x0003ac, 2004 },
+  { 0x0003b3, 2011 },
+  { 0x0003b5, 2020 },
+  { 0x0003b6, 2027 },
+  { 0x0003ba, 2036 },
+  { 0x0003bb, 2044 },
+  { 0x0003bc, 2053 },
+  { 0x0003bd, 2060 },
+  { 0x0003bf, 2064 },
+  { 0x0003c0, 2068 },
+  { 0x0003c7, 2076 },
+  { 0x0003cc, 2084 },
+  { 0x0003cf, 2094 },
+  { 0x0003d1, 2102 },
+  { 0x0003d2, 2111 },
+  { 0x0003d3, 2119 },
+  { 0x0003d9, 2128 },
+  { 0x0003dd, 2136 },
+  { 0x0003de, 2143 },
+  { 0x0003e0, 2151 },
+  { 0x0003e7, 2159 },
+  { 0x0003ec, 2167 },
+  { 0x0003ef, 2177 },
+  { 0x0003f1, 2185 },
+  { 0x0003f2, 2194 },
+  { 0x0003f3, 2202 },
+  { 0x0003f9, 2211 },
+  { 0x0003fd, 2219 },
+  { 0x0003fe, 2226 },
+  { 0x00047e, 2234 },
+  { 0x0004a1, 2243 },
+  { 0x0004a2, 2257 },
+  { 0x0004a3, 2277 },
+  { 0x0004a4, 2297 },
+  { 0x0004a5, 2308 },
+  { 0x0004a5, 2325 },
+  { 0x0004a6, 2340 },
+  { 0x0004a7, 2348 },
+  { 0x0004a8, 2355 },
+  { 0x0004a9, 2362 },
+  { 0x0004aa, 2369 },
+  { 0x0004ab, 2376 },
+  { 0x0004ac, 2383 },
+  { 0x0004ad, 2391 },
+  { 0x0004ae, 2399 },
+  { 0x0004af, 2407 },
+  { 0x0004af, 2416 },
+  { 0x0004b0, 2424 },
+  { 0x0004b1, 2439 },
+  { 0x0004b2, 2446 },
+  { 0x0004b3, 2453 },
+  { 0x0004b4, 2460 },
+  { 0x0004b5, 2467 },
+  { 0x0004b6, 2474 },
+  { 0x0004b7, 2482 },
+  { 0x0004b8, 2490 },
+  { 0x0004b9, 2498 },
+  { 0x0004ba, 2506 },
+  { 0x0004bb, 2514 },
+  { 0x0004bc, 2522 },
+  { 0x0004bd, 2531 },
+  { 0x0004be, 2539 },
+  { 0x0004bf, 2547 },
+  { 0x0004c0, 2555 },
+  { 0x0004c1, 2563 },
+  { 0x0004c1, 2572 },
+  { 0x0004c2, 2580 },
+  { 0x0004c2, 2589 },
+  { 0x0004c3, 2597 },
+  { 0x0004c4, 2605 },
+  { 0x0004c5, 2613 },
+  { 0x0004c6, 2621 },
+  { 0x0004c7, 2629 },
+  { 0x0004c8, 2637 },
+  { 0x0004c9, 2645 },
+  { 0x0004ca, 2653 },
+  { 0x0004cb, 2661 },
+  { 0x0004cc, 2669 },
+  { 0x0004cc, 2677 },
+  { 0x0004cd, 2685 },
+  { 0x0004ce, 2693 },
+  { 0x0004cf, 2701 },
+  { 0x0004d0, 2709 },
+  { 0x0004d1, 2717 },
+  { 0x0004d2, 2725 },
+  { 0x0004d3, 2733 },
+  { 0x0004d4, 2741 },
+  { 0x0004d5, 2749 },
+  { 0x0004d6, 2757 },
+  { 0x0004d7, 2765 },
+  { 0x0004d8, 2773 },
+  { 0x0004d9, 2781 },
+  { 0x0004da, 2789 },
+  { 0x0004db, 2797 },
+  { 0x0004dc, 2805 },
+  { 0x0004dd, 2813 },
+  { 0x0004de, 2820 },
+  { 0x0004df, 2832 },
+  { 0x0005ac, 2848 },
+  { 0x0005bb, 2861 },
+  { 0x0005bf, 2878 },
+  { 0x0005c1, 2899 },
+  { 0x0005c2, 2912 },
+  { 0x0005c3, 2931 },
+  { 0x0005c4, 2950 },
+  { 0x0005c5, 2968 },
+  { 0x0005c6, 2990 },
+  { 0x0005c7, 3008 },
+  { 0x0005c8, 3020 },
+  { 0x0005c9, 3031 },
+  { 0x0005ca, 3049 },
+  { 0x0005cb, 3060 },
+  { 0x0005cc, 3072 },
+  { 0x0005cd, 3084 },
+  { 0x0005ce, 3095 },
+  { 0x0005cf, 3107 },
+  { 0x0005d0, 3118 },
+  { 0x0005d1, 3130 },
+  { 0x0005d2, 3140 },
+  { 0x0005d3, 3152 },
+  { 0x0005d4, 3164 },
+  { 0x0005d5, 3177 },
+  { 0x0005d6, 3188 },
+  { 0x0005d7, 3199 },
+  { 0x0005d8, 3210 },
+  { 0x0005d9, 3221 },
+  { 0x0005da, 3232 },
+  { 0x0005e0, 3245 },
+  { 0x0005e1, 3260 },
+  { 0x0005e2, 3271 },
+  { 0x0005e3, 3282 },
+  { 0x0005e4, 3293 },
+  { 0x0005e5, 3304 },
+  { 0x0005e6, 3316 },
+  { 0x0005e7, 3328 },
+  { 0x0005e7, 3338 },
+  { 0x0005e8, 3349 },
+  { 0x0005e9, 3360 },
+  { 0x0005ea, 3379 },
+  { 0x0005eb, 3390 },
+  { 0x0005ec, 3406 },
+  { 0x0005ed, 3422 },
+  { 0x0005ee, 3438 },
+  { 0x0005ef, 3451 },
+  { 0x0005f0, 3464 },
+  { 0x0005f1, 3477 },
+  { 0x0005f2, 3491 },
+  { 0x0006a1, 3504 },
+  { 0x0006a2, 3516 },
+  { 0x0006a3, 3530 },
+  { 0x0006a4, 3542 },
+  { 0x0006a4, 3555 },
+  { 0x0006a5, 3567 },
+  { 0x0006a6, 3581 },
+  { 0x0006a6, 3593 },
+  { 0x0006a7, 3604 },
+  { 0x0006a7, 3617 },
+  { 0x0006a8, 3629 },
+  { 0x0006a8, 3641 },
+  { 0x0006a9, 3652 },
+  { 0x0006a9, 3665 },
+  { 0x0006aa, 3677 },
+  { 0x0006aa, 3690 },
+  { 0x0006ab, 3702 },
+  { 0x0006ac, 3715 },
+  { 0x0006ae, 3729 },
+  { 0x0006af, 3749 },
+  { 0x0006af, 3763 },
+  { 0x0006b0, 3775 },
+  { 0x0006b1, 3786 },
+  { 0x0006b2, 3798 },
+  { 0x0006b3, 3812 },
+  { 0x0006b4, 3824 },
+  { 0x0006b4, 3837 },
+  { 0x0006b5, 3849 },
+  { 0x0006b6, 3863 },
+  { 0x0006b6, 3875 },
+  { 0x0006b7, 3886 },
+  { 0x0006b7, 3899 },
+  { 0x0006b8, 3911 },
+  { 0x0006b8, 3923 },
+  { 0x0006b9, 3934 },
+  { 0x0006b9, 3947 },
+  { 0x0006ba, 3959 },
+  { 0x0006ba, 3972 },
+  { 0x0006bb, 3984 },
+  { 0x0006bc, 3997 },
+  { 0x0006be, 4011 },
+  { 0x0006bf, 4031 },
+  { 0x0006bf, 4045 },
+  { 0x0006c0, 4057 },
+  { 0x0006c1, 4069 },
+  { 0x0006c2, 4080 },
+  { 0x0006c3, 4092 },
+  { 0x0006c4, 4105 },
+  { 0x0006c5, 4117 },
+  { 0x0006c6, 4129 },
+  { 0x0006c7, 4141 },
+  { 0x0006c8, 4154 },
+  { 0x0006c9, 4166 },
+  { 0x0006ca, 4177 },
+  { 0x0006cb, 4193 },
+  { 0x0006cc, 4205 },
+  { 0x0006cd, 4217 },
+  { 0x0006ce, 4229 },
+  { 0x0006cf, 4241 },
+  { 0x0006d0, 4252 },
+  { 0x0006d1, 4264 },
+  { 0x0006d2, 4276 },
+  { 0x0006d3, 4288 },
+  { 0x0006d4, 4300 },
+  { 0x0006d5, 4312 },
+  { 0x0006d6, 4323 },
+  { 0x0006d7, 4336 },
+  { 0x0006d8, 4348 },
+  { 0x0006d9, 4366 },
+  { 0x0006da, 4380 },
+  { 0x0006db, 4392 },
+  { 0x0006dc, 4405 },
+  { 0x0006dd, 4416 },
+  { 0x0006de, 4431 },
+  { 0x0006df, 4444 },
+  { 0x0006e0, 4462 },
+  { 0x0006e1, 4474 },
+  { 0x0006e2, 4485 },
+  { 0x0006e3, 4497 },
+  { 0x0006e4, 4510 },
+  { 0x0006e5, 4522 },
+  { 0x0006e6, 4534 },
+  { 0x0006e7, 4546 },
+  { 0x0006e8, 4559 },
+  { 0x0006e9, 4571 },
+  { 0x0006ea, 4582 },
+  { 0x0006eb, 4598 },
+  { 0x0006ec, 4610 },
+  { 0x0006ed, 4622 },
+  { 0x0006ee, 4634 },
+  { 0x0006ef, 4646 },
+  { 0x0006f0, 4657 },
+  { 0x0006f1, 4669 },
+  { 0x0006f2, 4681 },
+  { 0x0006f3, 4693 },
+  { 0x0006f4, 4705 },
+  { 0x0006f5, 4717 },
+  { 0x0006f6, 4728 },
+  { 0x0006f7, 4741 },
+  { 0x0006f8, 4753 },
+  { 0x0006f9, 4771 },
+  { 0x0006fa, 4785 },
+  { 0x0006fb, 4797 },
+  { 0x0006fc, 4810 },
+  { 0x0006fd, 4821 },
+  { 0x0006fe, 4836 },
+  { 0x0006ff, 4849 },
+  { 0x0007a1, 4867 },
+  { 0x0007a2, 4885 },
+  { 0x0007a3, 4905 },
+  { 0x0007a4, 4921 },
+  { 0x0007a5, 4938 },
+  { 0x0007a5, 4957 },
+  { 0x0007a7, 4977 },
+  { 0x0007a8, 4997 },
+  { 0x0007a9, 5017 },
+  { 0x0007ab, 5039 },
+  { 0x0007ae, 5057 },
+  { 0x0007af, 5078 },
+  { 0x0007b1, 5093 },
+  { 0x0007b2, 5111 },
+  { 0x0007b3, 5131 },
+  { 0x0007b4, 5147 },
+  { 0x0007b5, 5164 },
+  { 0x0007b6, 5183 },
+  { 0x0007b7, 5208 },
+  { 0x0007b8, 5228 },
+  { 0x0007b9, 5248 },
+  { 0x0007ba, 5270 },
+  { 0x0007bb, 5298 },
+  { 0x0007c1, 5316 },
+  { 0x0007c2, 5328 },
+  { 0x0007c3, 5339 },
+  { 0x0007c4, 5351 },
+  { 0x0007c5, 5363 },
+  { 0x0007c6, 5377 },
+  { 0x0007c7, 5388 },
+  { 0x0007c8, 5398 },
+  { 0x0007c9, 5410 },
+  { 0x0007ca, 5421 },
+  { 0x0007cb, 5433 },
+  { 0x0007cb, 5446 },
+  { 0x0007cc, 5458 },
+  { 0x0007cd, 5467 },
+  { 0x0007ce, 5476 },
+  { 0x0007cf, 5485 },
+  { 0x0007d0, 5499 },
+  { 0x0007d1, 5508 },
+  { 0x0007d2, 5518 },
+  { 0x0007d4, 5530 },
+  { 0x0007d5, 5540 },
+  { 0x0007d6, 5554 },
+  { 0x0007d7, 5564 },
+  { 0x0007d8, 5574 },
+  { 0x0007d9, 5584 },
+  { 0x0007e1, 5596 },
+  { 0x0007e2, 5608 },
+  { 0x0007e3, 5619 },
+  { 0x0007e4, 5631 },
+  { 0x0007e5, 5643 },
+  { 0x0007e6, 5657 },
+  { 0x0007e7, 5668 },
+  { 0x0007e8, 5678 },
+  { 0x0007e9, 5690 },
+  { 0x0007ea, 5701 },
+  { 0x0007eb, 5713 },
+  { 0x0007eb, 5726 },
+  { 0x0007ec, 5738 },
+  { 0x0007ed, 5747 },
+  { 0x0007ee, 5756 },
+  { 0x0007ef, 5765 },
+  { 0x0007f0, 5779 },
+  { 0x0007f1, 5788 },
+  { 0x0007f2, 5798 },
+  { 0x0007f3, 5810 },
+  { 0x0007f4, 5832 },
+  { 0x0007f5, 5842 },
+  { 0x0007f6, 5856 },
+  { 0x0007f7, 5866 },
+  { 0x0007f8, 5876 },
+  { 0x0007f9, 5886 },
+  { 0x0008a1, 5898 },
+  { 0x0008a2, 5910 },
+  { 0x0008a3, 5925 },
+  { 0x0008a4, 5940 },
+  { 0x0008a5, 5952 },
+  { 0x0008a6, 5964 },
+  { 0x0008a7, 5978 },
+  { 0x0008a8, 5995 },
+  { 0x0008a9, 6012 },
+  { 0x0008aa, 6030 },
+  { 0x0008ab, 6048 },
+  { 0x0008ac, 6062 },
+  { 0x0008ad, 6076 },
+  { 0x0008ae, 6091 },
+  { 0x0008af, 6106 },
+  { 0x0008b0, 6127 },
+  { 0x0008b1, 6149 },
+  { 0x0008b2, 6166 },
+  { 0x0008b3, 6183 },
+  { 0x0008b4, 6209 },
+  { 0x0008b5, 6235 },
+  { 0x0008b6, 6253 },
+  { 0x0008b7, 6271 },
+  { 0x0008bc, 6292 },
+  { 0x0008bd, 6306 },
+  { 0x0008be, 6315 },
+  { 0x0008bf, 6332 },
+  { 0x0008c0, 6341 },
+  { 0x0008c1, 6351 },
+  { 0x0008c2, 6361 },
+  { 0x0008c5, 6370 },
+  { 0x0008c8, 6376 },
+  { 0x0008c9, 6388 },
+  { 0x0008cd, 6401 },
+  { 0x0008ce, 6410 },
+  { 0x0008cf, 6418 },
+  { 0x0008d6, 6428 },
+  { 0x0008da, 6436 },
+  { 0x0008db, 6447 },
+  { 0x0008dc, 6456 },
+  { 0x0008dd, 6469 },
+  { 0x0008de, 6475 },
+  { 0x0008df, 6486 },
+  { 0x0008ef, 6496 },
+  { 0x0008f6, 6514 },
+  { 0x0008fb, 6523 },
+  { 0x0008fc, 6533 },
+  { 0x0008fd, 6541 },
+  { 0x0008fe, 6552 },
+  { 0x0009df, 6562 },
+  { 0x0009e0, 6568 },
+  { 0x0009e1, 6581 },
+  { 0x0009e2, 6594 },
+  { 0x0009e3, 6597 },
+  { 0x0009e4, 6600 },
+  { 0x0009e5, 6603 },
+  { 0x0009e8, 6606 },
+  { 0x0009e9, 6609 },
+  { 0x0009ea, 6612 },
+  { 0x0009eb, 6627 },
+  { 0x0009ec, 6641 },
+  { 0x0009ed, 6654 },
+  { 0x0009ee, 6668 },
+  { 0x0009ef, 6682 },
+  { 0x0009f0, 6697 },
+  { 0x0009f1, 6712 },
+  { 0x0009f2, 6727 },
+  { 0x0009f3, 6742 },
+  { 0x0009f4, 6757 },
+  { 0x0009f5, 6763 },
+  { 0x0009f6, 6770 },
+  { 0x0009f7, 6775 },
+  { 0x0009f8, 6780 },
+  { 0x000aa1, 6788 },
+  { 0x000aa2, 6796 },
+  { 0x000aa3, 6804 },
+  { 0x000aa4, 6813 },
+  { 0x000aa5, 6822 },
+  { 0x000aa6, 6833 },
+  { 0x000aa7, 6844 },
+  { 0x000aa8, 6854 },
+  { 0x000aa9, 6864 },
+  { 0x000aaa, 6871 },
+  { 0x000aac, 6878 },
+  { 0x000aae, 6890 },
+  { 0x000aaf, 6899 },
+  { 0x000ab0, 6915 },
+  { 0x000ab1, 6924 },
+  { 0x000ab2, 6934 },
+  { 0x000ab3, 6943 },
+  { 0x000ab4, 6953 },
+  { 0x000ab5, 6965 },
+  { 0x000ab6, 6976 },
+  { 0x000ab7, 6985 },
+  { 0x000ab8, 6996 },
+  { 0x000abb, 7003 },
+  { 0x000abc, 7011 },
+  { 0x000abd, 7028 },
+  { 0x000abe, 7041 },
+  { 0x000abf, 7059 },
+  { 0x000ac3, 7066 },
+  { 0x000ac4, 7076 },
+  { 0x000ac5, 7089 },
+  { 0x000ac6, 7101 },
+  { 0x000ac9, 7114 },
+  { 0x000aca, 7124 },
+  { 0x000acb, 7138 },
+  { 0x000acc, 7156 },
+  { 0x000acd, 7173 },
+  { 0x000ace, 7191 },
+  { 0x000acf, 7204 },
+  { 0x000ad0, 7220 },
+  { 0x000ad1, 7240 },
+  { 0x000ad2, 7261 },
+  { 0x000ad3, 7281 },
+  { 0x000ad4, 7302 },
+  { 0x000ad6, 7315 },
+  { 0x000ad7, 7323 },
+  { 0x000ad9, 7331 },
+  { 0x000ada, 7342 },
+  { 0x000adb, 7351 },
+  { 0x000adc, 7368 },
+  { 0x000add, 7388 },
+  { 0x000ade, 7409 },
+  { 0x000adf, 7424 },
+  { 0x000ae0, 7437 },
+  { 0x000ae1, 7454 },
+  { 0x000ae2, 7473 },
+  { 0x000ae3, 7488 },
+  { 0x000ae4, 7504 },
+  { 0x000ae5, 7522 },
+  { 0x000ae6, 7531 },
+  { 0x000ae7, 7550 },
+  { 0x000ae8, 7567 },
+  { 0x000ae9, 7585 },
+  { 0x000aea, 7605 },
+  { 0x000aeb, 7617 },
+  { 0x000aec, 7630 },
+  { 0x000aed, 7635 },
+  { 0x000aee, 7643 },
+  { 0x000af0, 7649 },
+  { 0x000af1, 7662 },
+  { 0x000af2, 7669 },
+  { 0x000af3, 7682 },
+  { 0x000af4, 7692 },
+  { 0x000af5, 7704 },
+  { 0x000af6, 7717 },
+  { 0x000af7, 7729 },
+  { 0x000af8, 7740 },
+  { 0x000af9, 7753 },
+  { 0x000afa, 7763 },
+  { 0x000afb, 7781 },
+  { 0x000afc, 7801 },
+  { 0x000afd, 7807 },
+  { 0x000afe, 7826 },
+  { 0x000aff, 7845 },
+  { 0x000ba3, 7852 },
+  { 0x000ba6, 7862 },
+  { 0x000ba8, 7873 },
+  { 0x000ba9, 7883 },
+  { 0x000bc0, 7891 },
+  { 0x000bc2, 7899 },
+  { 0x000bc3, 7908 },
+  { 0x000bc4, 7915 },
+  { 0x000bc6, 7925 },
+  { 0x000bca, 7934 },
+  { 0x000bcc, 7938 },
+  { 0x000bce, 7943 },
+  { 0x000bcf, 7950 },
+  { 0x000bd3, 7957 },
+  { 0x000bd6, 7965 },
+  { 0x000bd8, 7974 },
+  { 0x000bda, 7984 },
+  { 0x000bdc, 7993 },
+  { 0x000bfc, 8002 },
+  { 0x000cdf, 8012 },
+  { 0x000ce0, 8033 },
+  { 0x000ce1, 8046 },
+  { 0x000ce1, 8057 },
+  { 0x000ce2, 8069 },
+  { 0x000ce2, 8082 },
+  { 0x000ce3, 8096 },
+  { 0x000ce3, 8109 },
+  { 0x000ce4, 8123 },
+  { 0x000ce5, 8133 },
+  { 0x000ce6, 8144 },
+  { 0x000ce6, 8156 },
+  { 0x000ce7, 8169 },
+  { 0x000ce7, 8181 },
+  { 0x000ce8, 8192 },
+  { 0x000ce8, 8203 },
+  { 0x000ce9, 8215 },
+  { 0x000cea, 8226 },
+  { 0x000ceb, 8243 },
+  { 0x000cec, 8255 },
+  { 0x000ced, 8268 },
+  { 0x000cee, 8284 },
+  { 0x000cef, 8295 },
+  { 0x000cf0, 8311 },
+  { 0x000cf1, 8322 },
+  { 0x000cf1, 8336 },
+  { 0x000cf2, 8350 },
+  { 0x000cf3, 8362 },
+  { 0x000cf4, 8377 },
+  { 0x000cf5, 8387 },
+  { 0x000cf5, 8404 },
+  { 0x000cf6, 8421 },
+  { 0x000cf6, 8433 },
+  { 0x000cf7, 8445 },
+  { 0x000cf7, 8456 },
+  { 0x000cf8, 8468 },
+  { 0x000cf9, 8480 },
+  { 0x000cfa, 8492 },
+  { 0x000cfa, 8503 },
+  { 0x000da1, 8514 },
+  { 0x000da2, 8525 },
+  { 0x000da3, 8538 },
+  { 0x000da4, 8552 },
+  { 0x000da5, 8566 },
+  { 0x000da6, 8579 },
+  { 0x000da7, 8595 },
+  { 0x000da8, 8607 },
+  { 0x000da9, 8620 },
+  { 0x000daa, 8634 },
+  { 0x000dab, 8648 },
+  { 0x000dac, 8658 },
+  { 0x000dad, 8671 },
+  { 0x000dae, 8683 },
+  { 0x000daf, 8696 },
+  { 0x000db0, 8709 },
+  { 0x000db1, 8722 },
+  { 0x000db2, 8741 },
+  { 0x000db3, 8757 },
+  { 0x000db4, 8768 },
+  { 0x000db5, 8779 },
+  { 0x000db6, 8790 },
+  { 0x000db7, 8804 },
+  { 0x000db8, 8819 },
+  { 0x000db9, 8833 },
+  { 0x000dba, 8843 },
+  { 0x000dbb, 8857 },
+  { 0x000dbc, 8868 },
+  { 0x000dbd, 8882 },
+  { 0x000dbe, 8892 },
+  { 0x000dbf, 8905 },
+  { 0x000dc0, 8916 },
+  { 0x000dc1, 8932 },
+  { 0x000dc2, 8942 },
+  { 0x000dc3, 8953 },
+  { 0x000dc4, 8964 },
+  { 0x000dc5, 8972 },
+  { 0x000dc6, 8984 },
+  { 0x000dc7, 8992 },
+  { 0x000dc8, 9004 },
+  { 0x000dc9, 9016 },
+  { 0x000dca, 9028 },
+  { 0x000dcb, 9039 },
+  { 0x000dcc, 9050 },
+  { 0x000dcd, 9063 },
+  { 0x000dce, 9073 },
+  { 0x000dcf, 9087 },
+  { 0x000dd0, 9102 },
+  { 0x000dd1, 9113 },
+  { 0x000dd2, 9129 },
+  { 0x000dd3, 9141 },
+  { 0x000dd4, 9153 },
+  { 0x000dd5, 9164 },
+  { 0x000dd6, 9176 },
+  { 0x000dd7, 9188 },
+  { 0x000dd8, 9201 },
+  { 0x000dd9, 9212 },
+  { 0x000dda, 9224 },
+  { 0x000dde, 9237 },
+  { 0x000ddf, 9260 },
+  { 0x000de0, 9270 },
+  { 0x000de1, 9281 },
+  { 0x000de2, 9293 },
+  { 0x000de3, 9304 },
+  { 0x000de4, 9323 },
+  { 0x000de5, 9343 },
+  { 0x000de6, 9360 },
+  { 0x000de7, 9374 },
+  { 0x000de8, 9389 },
+  { 0x000de9, 9400 },
+  { 0x000dea, 9412 },
+  { 0x000deb, 9424 },
+  { 0x000dec, 9441 },
+  { 0x000ded, 9458 },
+  { 0x000df0, 9472 },
+  { 0x000df1, 9484 },
+  { 0x000df2, 9497 },
+  { 0x000df3, 9510 },
+  { 0x000df4, 9522 },
+  { 0x000df5, 9533 },
+  { 0x000df6, 9544 },
+  { 0x000df7, 9556 },
+  { 0x000df8, 9569 },
+  { 0x000df9, 9582 },
+  { 0x000ea1, 9594 },
+  { 0x000ea2, 9608 },
+  { 0x000ea3, 9627 },
+  { 0x000ea4, 9645 },
+  { 0x000ea5, 9658 },
+  { 0x000ea6, 9676 },
+  { 0x000ea7, 9694 },
+  { 0x000ea8, 9708 },
+  { 0x000ea9, 9727 },
+  { 0x000eaa, 9740 },
+  { 0x000eab, 9759 },
+  { 0x000eac, 9777 },
+  { 0x000ead, 9795 },
+  { 0x000eae, 9812 },
+  { 0x000eaf, 9830 },
+  { 0x000eb0, 9849 },
+  { 0x000eb1, 9867 },
+  { 0x000eb2, 9880 },
+  { 0x000eb3, 9893 },
+  { 0x000eb4, 9911 },
+  { 0x000eb5, 9928 },
+  { 0x000eb6, 9940 },
+  { 0x000eb7, 9957 },
+  { 0x000eb8, 9970 },
+  { 0x000eb9, 9983 },
+  { 0x000eba, 10001 },
+  { 0x000ebb, 10014 },
+  { 0x000ebc, 10028 },
+  { 0x000ebd, 10041 },
+  { 0x000ebe, 10055 },
+  { 0x000ebf, 10068 },
+  { 0x000ec0, 10077 },
+  { 0x000ec1, 10087 },
+  { 0x000ec2, 10097 },
+  { 0x000ec3, 10108 },
+  { 0x000ec4, 10118 },
+  { 0x000ec5, 10127 },
+  { 0x000ec6, 10138 },
+  { 0x000ec7, 10148 },
+  { 0x000ec8, 10157 },
+  { 0x000ec9, 10167 },
+  { 0x000eca, 10178 },
+  { 0x000ecb, 10188 },
+  { 0x000ecc, 10198 },
+  { 0x000ecd, 10207 },
+  { 0x000ece, 10218 },
+  { 0x000ecf, 10228 },
+  { 0x000ed0, 10238 },
+  { 0x000ed1, 10248 },
+  { 0x000ed2, 10258 },
+  { 0x000ed3, 10268 },
+  { 0x000ed4, 10277 },
+  { 0x000ed5, 10293 },
+  { 0x000ed6, 10314 },
+  { 0x000ed7, 10334 },
+  { 0x000ed8, 10349 },
+  { 0x000ed9, 10369 },
+  { 0x000eda, 10389 },
+  { 0x000edb, 10405 },
+  { 0x000edc, 10420 },
+  { 0x000edd, 10441 },
+  { 0x000ede, 10461 },
+  { 0x000edf, 10481 },
+  { 0x000ee0, 10500 },
+  { 0x000ee1, 10520 },
+  { 0x000ee2, 10541 },
+  { 0x000ee3, 10561 },
+  { 0x000ee4, 10576 },
+  { 0x000ee5, 10591 },
+  { 0x000ee6, 10610 },
+  { 0x000ee7, 10624 },
+  { 0x000ee8, 10643 },
+  { 0x000ee9, 10658 },
+  { 0x000eea, 10673 },
+  { 0x000eeb, 10688 },
+  { 0x000eec, 10704 },
+  { 0x000eed, 10719 },
+  { 0x000eee, 10735 },
+  { 0x000eef, 10750 },
+  { 0x000ef0, 10774 },
+  { 0x000ef1, 10799 },
+  { 0x000ef2, 10824 },
+  { 0x000ef3, 10839 },
+  { 0x000ef4, 10864 },
+  { 0x000ef5, 10890 },
+  { 0x000ef6, 10909 },
+  { 0x000ef7, 10922 },
+  { 0x000ef8, 10936 },
+  { 0x000ef9, 10953 },
+  { 0x000efa, 10980 },
+  { 0x000eff, 11001 },
+  { 0x0013bc, 11012 },
+  { 0x0013bd, 11015 },
+  { 0x0013be, 11018 },
+  { 0x0020a0, 11029 },
+  { 0x0020a1, 11037 },
+  { 0x0020a2, 11047 },
+  { 0x0020a3, 11060 },
+  { 0x0020a4, 11071 },
+  { 0x0020a5, 11080 },
+  { 0x0020a6, 11089 },
+  { 0x0020a7, 11099 },
+  { 0x0020a8, 11110 },
+  { 0x0020a9, 11120 },
+  { 0x0020aa, 11128 },
+  { 0x0020ab, 11142 },
+  { 0x0020ac, 11151 },
+  { 0x00fd01, 11160 },
+  { 0x00fd02, 11175 },
+  { 0x00fd03, 11190 },
+  { 0x00fd04, 11202 },
+  { 0x00fd05, 11213 },
+  { 0x00fd06, 11226 },
+  { 0x00fd07, 11240 },
+  { 0x00fd08, 11256 },
+  { 0x00fd09, 11267 },
+  { 0x00fd0a, 11277 },
+  { 0x00fd0b, 11286 },
+  { 0x00fd0c, 11295 },
+  { 0x00fd0d, 11304 },
+  { 0x00fd0e, 11314 },
+  { 0x00fd0f, 11324 },
+  { 0x00fd10, 11341 },
+  { 0x00fd11, 11356 },
+  { 0x00fd12, 11370 },
+  { 0x00fd13, 11380 },
+  { 0x00fd14, 11391 },
+  { 0x00fd15, 11401 },
+  { 0x00fd16, 11411 },
+  { 0x00fd17, 11421 },
+  { 0x00fd18, 11432 },
+  { 0x00fd19, 11444 },
+  { 0x00fd1a, 11462 },
+  { 0x00fd1b, 11478 },
+  { 0x00fd1c, 11492 },
+  { 0x00fd1d, 11510 },
+  { 0x00fd1e, 11527 },
+  { 0x00fe01, 11538 },
+  { 0x00fe02, 11547 },
+  { 0x00fe03, 11564 },
+  { 0x00fe04, 11581 },
+  { 0x00fe05, 11598 },
+  { 0x00fe06, 11614 },
+  { 0x00fe07, 11630 },
+  { 0x00fe08, 11645 },
+  { 0x00fe09, 11660 },
+  { 0x00fe0a, 11680 },
+  { 0x00fe0b, 11695 },
+  { 0x00fe0c, 11715 },
+  { 0x00fe0d, 11731 },
+  { 0x00fe0e, 11752 },
+  { 0x00fe0f, 11767 },
+  { 0x00fe20, 11787 },
+  { 0x00fe21, 11800 },
+  { 0x00fe22, 11817 },
+  { 0x00fe23, 11836 },
+  { 0x00fe24, 11856 },
+  { 0x00fe25, 11878 },
+  { 0x00fe26, 11901 },
+  { 0x00fe27, 11925 },
+  { 0x00fe28, 11945 },
+  { 0x00fe29, 11966 },
+  { 0x00fe2a, 11990 },
+  { 0x00fe2b, 12015 },
+  { 0x00fe2c, 12040 },
+  { 0x00fe2d, 12061 },
+  { 0x00fe2e, 12083 },
+  { 0x00fe2f, 12102 },
+  { 0x00fe30, 12123 },
+  { 0x00fe31, 12148 },
+  { 0x00fe32, 12176 },
+  { 0x00fe33, 12190 },
+  { 0x00fe34, 12208 },
+  { 0x00fe50, 12218 },
+  { 0x00fe51, 12229 },
+  { 0x00fe52, 12240 },
+  { 0x00fe53, 12256 },
+  { 0x00fe54, 12267 },
+  { 0x00fe55, 12279 },
+  { 0x00fe56, 12290 },
+  { 0x00fe57, 12304 },
+  { 0x00fe58, 12319 },
+  { 0x00fe59, 12334 },
+  { 0x00fe5a, 12351 },
+  { 0x00fe5b, 12362 },
+  { 0x00fe5c, 12375 },
+  { 0x00fe5d, 12387 },
+  { 0x00fe5e, 12397 },
+  { 0x00fe5f, 12415 },
+  { 0x00fe60, 12437 },
+  { 0x00fe61, 12451 },
+  { 0x00fe62, 12461 },
+  { 0x00fe70, 12471 },
+  { 0x00fe71, 12486 },
+  { 0x00fe72, 12510 },
+  { 0x00fe73, 12528 },
+  { 0x00fe74, 12544 },
+  { 0x00fe75, 12562 },
+  { 0x00fe76, 12580 },
+  { 0x00fe77, 12597 },
+  { 0x00fe78, 12620 },
+  { 0x00fe79, 12636 },
+  { 0x00fe7a, 12652 },
+  { 0x00fed0, 12671 },
+  { 0x00fed1, 12692 },
+  { 0x00fed2, 12712 },
+  { 0x00fed4, 12732 },
+  { 0x00fed5, 12752 },
+  { 0x00fee0, 12769 },
+  { 0x00fee1, 12782 },
+  { 0x00fee2, 12796 },
+  { 0x00fee3, 12807 },
+  { 0x00fee4, 12820 },
+  { 0x00fee5, 12835 },
+  { 0x00fee6, 12851 },
+  { 0x00fee7, 12868 },
+  { 0x00fee8, 12886 },
+  { 0x00fee9, 12906 },
+  { 0x00feea, 12922 },
+  { 0x00feeb, 12938 },
+  { 0x00feec, 12954 },
+  { 0x00feed, 12970 },
+  { 0x00feee, 12986 },
+  { 0x00feef, 13008 },
+  { 0x00fef0, 13026 },
+  { 0x00fef1, 13044 },
+  { 0x00fef2, 13062 },
+  { 0x00fef3, 13080 },
+  { 0x00fef4, 13098 },
+  { 0x00fef5, 13116 },
+  { 0x00fef6, 13130 },
+  { 0x00fef7, 13144 },
+  { 0x00fef8, 13158 },
+  { 0x00fef9, 13172 },
+  { 0x00fefa, 13191 },
+  { 0x00fefb, 13210 },
+  { 0x00fefc, 13230 },
+  { 0x00fefd, 13250 },
+  { 0x00ff08, 13264 },
+  { 0x00ff09, 13274 },
+  { 0x00ff0a, 13278 },
+  { 0x00ff0b, 13287 },
+  { 0x00ff0d, 13293 },
+  { 0x00ff13, 13300 },
+  { 0x00ff14, 13306 },
+  { 0x00ff15, 13318 },
+  { 0x00ff1b, 13326 },
+  { 0x00ff20, 13333 },
+  { 0x00ff21, 13343 },
+  { 0x00ff22, 13349 },
+  { 0x00ff23, 13358 },
+  { 0x00ff23, 13365 },
+  { 0x00ff24, 13377 },
+  { 0x00ff25, 13384 },
+  { 0x00ff26, 13393 },
+  { 0x00ff27, 13402 },
+  { 0x00ff28, 13420 },
+  { 0x00ff29, 13428 },
+  { 0x00ff2a, 13436 },
+  { 0x00ff2b, 13452 },
+  { 0x00ff2c, 13460 },
+  { 0x00ff2d, 13467 },
+  { 0x00ff2e, 13477 },
+  { 0x00ff2f, 13488 },
+  { 0x00ff30, 13499 },
+  { 0x00ff31, 13511 },
+  { 0x00ff32, 13518 },
+  { 0x00ff33, 13531 },
+  { 0x00ff34, 13542 },
+  { 0x00ff35, 13555 },
+  { 0x00ff36, 13567 },
+  { 0x00ff37, 13581 },
+  { 0x00ff38, 13591 },
+  { 0x00ff39, 13605 },
+  { 0x00ff3a, 13618 },
+  { 0x00ff3b, 13634 },
+  { 0x00ff3c, 13651 },
+  { 0x00ff3d, 13667 },
+  { 0x00ff3e, 13685 },
+  { 0x00ff3f, 13703 },
+  { 0x00ff50, 13718 },
+  { 0x00ff51, 13723 },
+  { 0x00ff52, 13728 },
+  { 0x00ff53, 13731 },
+  { 0x00ff54, 13737 },
+  { 0x00ff55, 13742 },
+  { 0x00ff55, 13750 },
+  { 0x00ff56, 13756 },
+  { 0x00ff56, 13766 },
+  { 0x00ff57, 13771 },
+  { 0x00ff58, 13775 },
+  { 0x00ff60, 13781 },
+  { 0x00ff61, 13788 },
+  { 0x00ff62, 13794 },
+  { 0x00ff63, 13802 },
+  { 0x00ff65, 13809 },
+  { 0x00ff66, 13814 },
+  { 0x00ff67, 13819 },
+  { 0x00ff68, 13824 },
+  { 0x00ff69, 13829 },
+  { 0x00ff6a, 13836 },
+  { 0x00ff6b, 13841 },
+  { 0x00ff7e, 13847 },
+  { 0x00ff7e, 13861 },
+  { 0x00ff7e, 13874 },
+  { 0x00ff7e, 13888 },
+  { 0x00ff7e, 13902 },
+  { 0x00ff7e, 13918 },
+  { 0x00ff7e, 13930 },
+  { 0x00ff7e, 13942 },
+  { 0x00ff7f, 13956 },
+  { 0x00ff80, 13965 },
+  { 0x00ff89, 13974 },
+  { 0x00ff8d, 13981 },
+  { 0x00ff91, 13990 },
+  { 0x00ff92, 13996 },
+  { 0x00ff93, 14002 },
+  { 0x00ff94, 14008 },
+  { 0x00ff95, 14014 },
+  { 0x00ff96, 14022 },
+  { 0x00ff97, 14030 },
+  { 0x00ff98, 14036 },
+  { 0x00ff99, 14045 },
+  { 0x00ff9a, 14053 },
+  { 0x00ff9a, 14064 },
+  { 0x00ff9b, 14073 },
+  { 0x00ff9b, 14086 },
+  { 0x00ff9c, 14094 },
+  { 0x00ff9d, 14101 },
+  { 0x00ff9e, 14110 },
+  { 0x00ff9f, 14120 },
+  { 0x00ffaa, 14130 },
+  { 0x00ffab, 14142 },
+  { 0x00ffac, 14149 },
+  { 0x00ffad, 14162 },
+  { 0x00ffae, 14174 },
+  { 0x00ffaf, 14185 },
+  { 0x00ffb0, 14195 },
+  { 0x00ffb1, 14200 },
+  { 0x00ffb2, 14205 },
+  { 0x00ffb3, 14210 },
+  { 0x00ffb4, 14215 },
+  { 0x00ffb5, 14220 },
+  { 0x00ffb6, 14225 },
+  { 0x00ffb7, 14230 },
+  { 0x00ffb8, 14235 },
+  { 0x00ffb9, 14240 },
+  { 0x00ffbd, 14245 },
+  { 0x00ffbe, 14254 },
+  { 0x00ffbf, 14257 },
+  { 0x00ffc0, 14260 },
+  { 0x00ffc1, 14263 },
+  { 0x00ffc2, 14266 },
+  { 0x00ffc3, 14269 },
+  { 0x00ffc4, 14272 },
+  { 0x00ffc5, 14275 },
+  { 0x00ffc6, 14278 },
+  { 0x00ffc7, 14281 },
+  { 0x00ffc8, 14285 },
+  { 0x00ffc9, 14289 },
+  { 0x00ffca, 14293 },
+  { 0x00ffcb, 14297 },
+  { 0x00ffcc, 14301 },
+  { 0x00ffcd, 14305 },
+  { 0x00ffce, 14309 },
+  { 0x00ffcf, 14313 },
+  { 0x00ffd0, 14317 },
+  { 0x00ffd1, 14321 },
+  { 0x00ffd2, 14325 },
+  { 0x00ffd3, 14329 },
+  { 0x00ffd4, 14333 },
+  { 0x00ffd5, 14337 },
+  { 0x00ffd6, 14341 },
+  { 0x00ffd7, 14345 },
+  { 0x00ffd8, 14349 },
+  { 0x00ffd9, 14353 },
+  { 0x00ffda, 14357 },
+  { 0x00ffdb, 14361 },
+  { 0x00ffdc, 14365 },
+  { 0x00ffdd, 14369 },
+  { 0x00ffde, 14373 },
+  { 0x00ffdf, 14377 },
+  { 0x00ffe0, 14381 },
+  { 0x00ffe1, 14385 },
+  { 0x00ffe2, 14393 },
+  { 0x00ffe3, 14401 },
+  { 0x00ffe4, 14411 },
+  { 0x00ffe5, 14421 },
+  { 0x00ffe6, 14431 },
+  { 0x00ffe7, 14442 },
+  { 0x00ffe8, 14449 },
+  { 0x00ffe9, 14456 },
+  { 0x00ffea, 14462 },
+  { 0x00ffeb, 14468 },
+  { 0x00ffec, 14476 },
+  { 0x00ffed, 14484 },
+  { 0x00ffee, 14492 },
+  { 0x00ffff, 14500 },
+  { 0xffffff, 14507 }
+};
+
+static const gdk_key gdk_keys_by_name[] = {
+  { 0x000030, 140 },
+  { 0x000031, 142 },
+  { 0x000032, 144 },
+  { 0x000033, 146 },
+  { 0x00fd10, 11341 },
+  { 0x00fd0e, 11314 },
+  { 0x00fd05, 11213 },
+  { 0x00fd19, 11444 },
+  { 0x00fd15, 11401 },
+  { 0x00fd0f, 11324 },
+  { 0x00fd1c, 11492 },
+  { 0x00fd1a, 11462 },
+  { 0x00fd01, 11160 },
+  { 0x00fd1e, 11527 },
+  { 0x00fd06, 11226 },
+  { 0x00fd07, 11240 },
+  { 0x00fd1b, 11478 },
+  { 0x00fd02, 11175 },
+  { 0x00fd13, 11380 },
+  { 0x00fd12, 11370 },
+  { 0x00fd11, 11356 },
+  { 0x00fd04, 11202 },
+  { 0x00fd0a, 11277 },
+  { 0x00fd0b, 11286 },
+  { 0x00fd0c, 11295 },
+  { 0x00fd16, 11411 },
+  { 0x00fd1d, 11510 },
+  { 0x00fd09, 11267 },
+  { 0x00fd18, 11432 },
+  { 0x00fd08, 11256 },
+  { 0x00fd03, 11190 },
+  { 0x00fd14, 11391 },
+  { 0x00fd17, 11421 },
+  { 0x00fd0d, 11304 },
+  { 0x000034, 148 },
+  { 0x000035, 150 },
+  { 0x000036, 152 },
+  { 0x000037, 154 },
+  { 0x000038, 156 },
+  { 0x000039, 158 },
+  { 0x000041, 207 },
+  { 0x0000c6, 787 },
+  { 0x0000c1, 744 },
+  { 0x0001c3, 1473 },
+  { 0x00fe70, 12471 },
+  { 0x00fe71, 12486 },
+  { 0x0000c2, 751 },
+  { 0x0000c4, 770 },
+  { 0x0000c0, 737 },
+  { 0x00ffe9, 14456 },
+  { 0x00ffea, 14462 },
+  { 0x0003c0, 2068 },
+  { 0x0001a1, 1281 },
+  { 0x0005d9, 3221 },
+  { 0x0005c7, 3008 },
+  { 0x0005e9, 3360 },
+  { 0x0005c8, 3020 },
+  { 0x0005ac, 2848 },
+  { 0x0005d6, 3188 },
+  { 0x0005cf, 3107 },
+  { 0x0005ef, 3451 },
+  { 0x0005ec, 3406 },
+  { 0x0005ee, 3438 },
+  { 0x0005eb, 3390 },
+  { 0x0005e1, 3260 },
+  { 0x0005da, 3232 },
+  { 0x0005e7, 3328 },
+  { 0x0005cd, 3084 },
+  { 0x0005c1, 2899 },
+  { 0x0005c3, 2931 },
+  { 0x0005c4, 2950 },
+  { 0x0005c6, 2990 },
+  { 0x0005c5, 2968 },
+  { 0x0005e7, 3338 },
+  { 0x0005cc, 3072 },
+  { 0x0005e3, 3282 },
+  { 0x0005f0, 3464 },
+  { 0x0005ed, 3422 },
+  { 0x0005ce, 3095 },
+  { 0x0005e4, 3293 },
+  { 0x0005c2, 2912 },
+  { 0x0005e5, 3304 },
+  { 0x0005e6, 3316 },
+  { 0x0005e2, 3271 },
+  { 0x0005bf, 2878 },
+  { 0x0005d1, 3130 },
+  { 0x0005d5, 3177 },
+  { 0x0005d3, 3152 },
+  { 0x0005bb, 2861 },
+  { 0x0005f1, 3477 },
+  { 0x0005d4, 3164 },
+  { 0x0005f2, 3491 },
+  { 0x00ff7e, 13847 },
+  { 0x0005d7, 3199 },
+  { 0x0005e0, 3245 },
+  { 0x0005ca, 3049 },
+  { 0x0005c9, 3031 },
+  { 0x0005d0, 3118 },
+  { 0x0005cb, 3060 },
+  { 0x0005e8, 3349 },
+  { 0x0005ea, 3379 },
+  { 0x0005d8, 3210 },
+  { 0x0005d2, 3140 },
+  { 0x0000c5, 781 },
+  { 0x0000c3, 763 },
+  { 0x00fe7a, 12652 },
+  { 0x000042, 209 },
+  { 0x00ff08, 13264 },
+  { 0x00ff58, 13775 },
+  { 0x00fe74, 12544 },
+  { 0x00ff6b, 13841 },
+  { 0x0006be, 4011 },
+  { 0x0006ae, 3729 },
+  { 0x000043, 211 },
+  { 0x0002c5, 1826 },
+  { 0x0001c6, 1487 },
+  { 0x00ff69, 13829 },
+  { 0x00ffe5, 14421 },
+  { 0x0001c8, 1494 },
+  { 0x0000c7, 790 },
+  { 0x0002c6, 1836 },
+  { 0x00ff0b, 13287 },
+  { 0x00ff37, 13581 },
+  { 0x0020a1, 11037 },
+  { 0x00ffe3, 14401 },
+  { 0x00ffe4, 14411 },
+  { 0x0020a2, 11047 },
+  { 0x0006e1, 4474 },
+  { 0x0006e2, 4485 },
+  { 0x0006fe, 4836 },
+  { 0x0006e4, 4510 },
+  { 0x0006bf, 4031 },
+  { 0x0006fc, 4810 },
+  { 0x0006e6, 4534 },
+  { 0x0006ec, 4610 },
+  { 0x0006ed, 4622 },
+  { 0x0006ee, 4634 },
+  { 0x0006f2, 4681 },
+  { 0x0006f3, 4693 },
+  { 0x0006e7, 4546 },
+  { 0x0006e8, 4559 },
+  { 0x0006ff, 4849 },
+  { 0x0006e9, 4571 },
+  { 0x0006e5, 4522 },
+  { 0x0006b3, 3812 },
+  { 0x0006b8, 3911 },
+  { 0x0006eb, 4598 },
+  { 0x0006b9, 3934 },
+  { 0x0006ba, 3959 },
+  { 0x0006ef, 4646 },
+  { 0x0006f0, 4657 },
+  { 0x0006fb, 4797 },
+  { 0x0006fd, 4821 },
+  { 0x0006ea, 4582 },
+  { 0x0006f8, 4753 },
+  { 0x0006f4, 4705 },
+  { 0x0006e3, 4497 },
+  { 0x0006f5, 4717 },
+  { 0x0006f7, 4741 },
+  { 0x0006f1, 4669 },
+  { 0x0006f9, 4771 },
+  { 0x0006e0, 4462 },
+  { 0x0006fa, 4785 },
+  { 0x0006f6, 4728 },
+  { 0x0006c1, 4069 },
+  { 0x0006c2, 4080 },
+  { 0x0006de, 4431 },
+  { 0x0006c4, 4105 },
+  { 0x0006af, 3749 },
+  { 0x0006dc, 4405 },
+  { 0x0006c6, 4129 },
+  { 0x0006cc, 4205 },
+  { 0x0006cd, 4217 },
+  { 0x0006ce, 4229 },
+  { 0x0006d2, 4276 },
+  { 0x0006d3, 4288 },
+  { 0x0006c7, 4141 },
+  { 0x0006c8, 4154 },
+  { 0x0006df, 4444 },
+  { 0x0006c9, 4166 },
+  { 0x0006c5, 4117 },
+  { 0x0006a3, 3530 },
+  { 0x0006a8, 3629 },
+  { 0x0006cb, 4193 },
+  { 0x0006a9, 3652 },
+  { 0x0006aa, 3677 },
+  { 0x0006cf, 4241 },
+  { 0x0006d0, 4252 },
+  { 0x0006db, 4392 },
+  { 0x0006dd, 4416 },
+  { 0x0006ca, 4177 },
+  { 0x0006d8, 4348 },
+  { 0x0006d4, 4300 },
+  { 0x0006c3, 4092 },
+  { 0x0006d5, 4312 },
+  { 0x0006d7, 4336 },
+  { 0x0006d1, 4264 },
+  { 0x0006d9, 4366 },
+  { 0x0006c0, 4057 },
+  { 0x0006da, 4380 },
+  { 0x0006d6, 4323 },
+  { 0x000044, 213 },
+  { 0x0001cf, 1516 },
+  { 0x00ffff, 14500 },
+  { 0x0020ab, 11142 },
+  { 0x00ff54, 13737 },
+  { 0x0001d0, 1523 },
+  { 0x000045, 215 },
+  { 0x0003bd, 2060 },
+  { 0x0000d0, 873 },
+  { 0x0003cc, 2084 },
+  { 0x0000c9, 806 },
+  { 0x0001cc, 1509 },
+  { 0x0000ca, 813 },
+  { 0x0020a0, 11029 },
+  { 0x0000cb, 825 },
+  { 0x0000c8, 799 },
+  { 0x00ff2f, 13488 },
+  { 0x00ff30, 13499 },
+  { 0x0003aa, 1987 },
+  { 0x00ff57, 13771 },
+  { 0x0001ca, 1501 },
+  { 0x00ff1b, 13326 },
+  { 0x0000d0, 877 },
+  { 0x0020ac, 11151 },
+  { 0x00ff62, 13794 },
+  { 0x000046, 217 },
+  { 0x00ffbe, 14254 },
+  { 0x00ffc7, 14281 },
+  { 0x00ffc8, 14285 },
+  { 0x00ffc9, 14289 },
+  { 0x00ffca, 14293 },
+  { 0x00ffcb, 14297 },
+  { 0x00ffcc, 14301 },
+  { 0x00ffcd, 14305 },
+  { 0x00ffce, 14309 },
+  { 0x00ffcf, 14313 },
+  { 0x00ffd0, 14317 },
+  { 0x00ffbf, 14257 },
+  { 0x00ffd1, 14321 },
+  { 0x00ffd2, 14325 },
+  { 0x00ffd3, 14329 },
+  { 0x00ffd4, 14333 },
+  { 0x00ffd5, 14337 },
+  { 0x00ffd6, 14341 },
+  { 0x00ffd7, 14345 },
+  { 0x00ffd8, 14349 },
+  { 0x00ffd9, 14353 },
+  { 0x00ffda, 14357 },
+  { 0x00ffc0, 14260 },
+  { 0x00ffdb, 14361 },
+  { 0x00ffdc, 14365 },
+  { 0x00ffdd, 14369 },
+  { 0x00ffde, 14373 },
+  { 0x00ffdf, 14377 },
+  { 0x00ffe0, 14381 },
+  { 0x00ffc1, 14263 },
+  { 0x00ffc2, 14266 },
+  { 0x00ffc3, 14269 },
+  { 0x00ffc4, 14272 },
+  { 0x00ffc5, 14275 },
+  { 0x00ffc6, 14278 },
+  { 0x0020a3, 11060 },
+  { 0x00ff68, 13824 },
+  { 0x00fed0, 12671 },
+  { 0x000047, 219 },
+  { 0x0002d5, 1848 },
+  { 0x0002ab, 1759 },
+  { 0x0003ab, 1995 },
+  { 0x0002d8, 1858 },
+  { 0x0007c1, 5316 },
+  { 0x0007a1, 4867 },
+  { 0x0007c2, 5328 },
+  { 0x0007d7, 5564 },
+  { 0x0007c4, 5351 },
+  { 0x0007c5, 5363 },
+  { 0x0007a2, 4885 },
+  { 0x0007c7, 5388 },
+  { 0x0007a3, 4905 },
+  { 0x0007c3, 5339 },
+  { 0x0007c9, 5410 },
+  { 0x0007a4, 4921 },
+  { 0x0007a5, 4957 },
+  { 0x0007a5, 4938 },
+  { 0x0007ca, 5421 },
+  { 0x0007cb, 5433 },
+  { 0x0007cb, 5446 },
+  { 0x0007cc, 5458 },
+  { 0x0007cd, 5467 },
+  { 0x0007d9, 5584 },
+  { 0x0007ab, 5039 },
+  { 0x0007cf, 5485 },
+  { 0x0007a7, 4977 },
+  { 0x0007d6, 5554 },
+  { 0x0007d0, 5499 },
+  { 0x0007d8, 5574 },
+  { 0x0007d1, 5508 },
+  { 0x0007d2, 5518 },
+  { 0x0007d4, 5530 },
+  { 0x0007c8, 5398 },
+  { 0x0007d5, 5540 },
+  { 0x0007a8, 4997 },
+  { 0x0007a9, 5017 },
+  { 0x0007ce, 5476 },
+  { 0x0007c6, 5377 },
+  { 0x0007ae, 5057 },
+  { 0x0007e1, 5596 },
+  { 0x0007b1, 5093 },
+  { 0x0007e2, 5608 },
+  { 0x0007f7, 5866 },
+  { 0x0007e4, 5631 },
+  { 0x0007e5, 5643 },
+  { 0x0007b2, 5111 },
+  { 0x0007e7, 5668 },
+  { 0x0007b3, 5131 },
+  { 0x0007f3, 5810 },
+  { 0x0007e3, 5619 },
+  { 0x0007af, 5078 },
+  { 0x0007e9, 5690 },
+  { 0x0007b4, 5147 },
+  { 0x0007b6, 5183 },
+  { 0x0007b5, 5164 },
+  { 0x0007ea, 5701 },
+  { 0x0007eb, 5713 },
+  { 0x0007eb, 5726 },
+  { 0x0007ec, 5738 },
+  { 0x0007ed, 5747 },
+  { 0x0007f9, 5886 },
+  { 0x0007bb, 5298 },
+  { 0x0007ef, 5765 },
+  { 0x0007b7, 5208 },
+  { 0x0007f6, 5856 },
+  { 0x0007f0, 5779 },
+  { 0x0007f8, 5876 },
+  { 0x0007f1, 5788 },
+  { 0x0007f2, 5798 },
+  { 0x00ff7e, 13861 },
+  { 0x0007f4, 5832 },
+  { 0x0007e8, 5678 },
+  { 0x0007f5, 5842 },
+  { 0x0007b8, 5228 },
+  { 0x0007ba, 5270 },
+  { 0x0007b9, 5248 },
+  { 0x0007ee, 5756 },
+  { 0x0007e6, 5657 },
+  { 0x000048, 221 },
+  { 0x00ff31, 13511 },
+  { 0x000ebf, 10068 },
+  { 0x000ec0, 10077 },
+  { 0x000ef6, 10909 },
+  { 0x000ef7, 10922 },
+  { 0x00ff39, 13605 },
+  { 0x000eba, 10001 },
+  { 0x000ea7, 9694 },
+  { 0x000ec4, 10118 },
+  { 0x000ec3, 10108 },
+  { 0x000ed1, 10248 },
+  { 0x00ff33, 13531 },
+  { 0x00ff34, 13542 },
+  { 0x000ebe, 10055 },
+  { 0x000ed3, 10268 },
+  { 0x000eb7, 9957 },
+  { 0x000eea, 10673 },
+  { 0x000eda, 10389 },
+  { 0x000eee, 10735 },
+  { 0x000ee8, 10643 },
+  { 0x000ee9, 10658 },
+  { 0x000eeb, 10688 },
+  { 0x000ed4, 10277 },
+  { 0x000ed6, 10314 },
+  { 0x000ef9, 10953 },
+  { 0x000ee3, 10561 },
+  { 0x000ed7, 10334 },
+  { 0x000ed9, 10369 },
+  { 0x000ed8, 10349 },
+  { 0x000ef8, 10936 },
+  { 0x000eed, 10719 },
+  { 0x000ee4, 10576 },
+  { 0x000ee5, 10591 },
+  { 0x000edb, 10405 },
+  { 0x000ee2, 10541 },
+  { 0x000edc, 10420 },
+  { 0x000edd, 10441 },
+  { 0x000ee1, 10520 },
+  { 0x000ede, 10461 },
+  { 0x000edf, 10481 },
+  { 0x000ee0, 10500 },
+  { 0x000ee6, 10610 },
+  { 0x000ed5, 10293 },
+  { 0x000ee7, 10624 },
+  { 0x000eec, 10704 },
+  { 0x000efa, 10980 },
+  { 0x00ff35, 13555 },
+  { 0x00ff38, 13591 },
+  { 0x000eb8, 9970 },
+  { 0x000ebb, 10014 },
+  { 0x000ea1, 9594 },
+  { 0x000ea3, 9627 },
+  { 0x000ef3, 10839 },
+  { 0x000eb1, 9867 },
+  { 0x000ea4, 9645 },
+  { 0x000ea6, 9676 },
+  { 0x000ea5, 9658 },
+  { 0x000ec7, 10148 },
+  { 0x000eca, 10178 },
+  { 0x000ef2, 10824 },
+  { 0x000ebd, 10041 },
+  { 0x000eb2, 9880 },
+  { 0x000eb4, 9911 },
+  { 0x00ff3b, 13634 },
+  { 0x00ff3a, 13618 },
+  { 0x000ea9, 9727 },
+  { 0x000eb0, 9849 },
+  { 0x000eaa, 9740 },
+  { 0x000eab, 9759 },
+  { 0x000eaf, 9830 },
+  { 0x000eac, 9777 },
+  { 0x000ead, 9795 },
+  { 0x000eae, 9812 },
+  { 0x000eef, 10750 },
+  { 0x00ff36, 13567 },
+  { 0x000eb5, 9928 },
+  { 0x00ff3f, 13703 },
+  { 0x000ea8, 9708 },
+  { 0x000eb9, 9983 },
+  { 0x000ea2, 9608 },
+  { 0x000eb3, 9893 },
+  { 0x000eb6, 9940 },
+  { 0x00ff32, 13518 },
+  { 0x000ef0, 10774 },
+  { 0x000ef4, 10864 },
+  { 0x000ef1, 10799 },
+  { 0x000ebc, 10028 },
+  { 0x000ecc, 10198 },
+  { 0x000ec8, 10157 },
+  { 0x000ec9, 10167 },
+  { 0x000ece, 10218 },
+  { 0x000ecd, 10207 },
+  { 0x000ecf, 10228 },
+  { 0x000ec1, 10087 },
+  { 0x000ec2, 10097 },
+  { 0x000ec6, 10138 },
+  { 0x000ec5, 10127 },
+  { 0x000ed2, 10258 },
+  { 0x000ecb, 10188 },
+  { 0x000ed0, 10238 },
+  { 0x000ef5, 10890 },
+  { 0x00ff7e, 13874 },
+  { 0x00ff29, 13428 },
+  { 0x0002a6, 1737 },
+  { 0x00ff7e, 13888 },
+  { 0x00ff6a, 13836 },
+  { 0x00ff23, 13358 },
+  { 0x00ff23, 13365 },
+  { 0x00ff25, 13384 },
+  { 0x00ff27, 13402 },
+  { 0x00ff50, 13718 },
+  { 0x0002a1, 1729 },
+  { 0x00ffed, 14484 },
+  { 0x00ffee, 14492 },
+  { 0x000049, 223 },
+  { 0x00fe33, 12190 },
+  { 0x00fe30, 12123 },
+  { 0x00fe31, 12148 },
+  { 0x00fe32, 12176 },
+  { 0x00fe34, 12208 },
+  { 0x00fe2f, 12102 },
+  { 0x00fe2c, 12040 },
+  { 0x00fe2d, 12061 },
+  { 0x00fe2e, 12083 },
+  { 0x00fe0c, 11715 },
+  { 0x00fe0d, 11731 },
+  { 0x00fe06, 11614 },
+  { 0x00fe07, 11630 },
+  { 0x00ff7e, 13902 },
+  { 0x00fe0e, 11752 },
+  { 0x00fe0f, 11767 },
+  { 0x00fe20, 11787 },
+  { 0x00fe02, 11547 },
+  { 0x00fe04, 11581 },
+  { 0x00fe05, 11598 },
+  { 0x00fe03, 11564 },
+  { 0x00fe01, 11538 },
+  { 0x00fe22, 11817 },
+  { 0x00fe21, 11800 },
+  { 0x00fe08, 11645 },
+  { 0x00fe09, 11660 },
+  { 0x00fe24, 11856 },
+  { 0x00fe23, 11836 },
+  { 0x00fe25, 11878 },
+  { 0x00fe26, 11901 },
+  { 0x00fe0a, 11680 },
+  { 0x00fe0b, 11695 },
+  { 0x00fe2b, 12015 },
+  { 0x00fe29, 11966 },
+  { 0x00fe2a, 11990 },
+  { 0x00fe27, 11925 },
+  { 0x00fe28, 11945 },
+  { 0x0002a9, 1749 },
+  { 0x0000cd, 843 },
+  { 0x0000ce, 850 },
+  { 0x0000cf, 862 },
+  { 0x0000cc, 836 },
+  { 0x0003cf, 2094 },
+  { 0x00ff63, 13802 },
+  { 0x0003c7, 2076 },
+  { 0x0003a5, 1971 },
+  { 0x00004a, 225 },
+  { 0x0002ac, 1766 },
+  { 0x00004b, 227 },
+  { 0x00ffb0, 14195 },
+  { 0x00ffb1, 14200 },
+  { 0x00ffb2, 14205 },
+  { 0x00ffb3, 14210 },
+  { 0x00ffb4, 14215 },
+  { 0x00ffb5, 14220 },
+  { 0x00ffb6, 14225 },
+  { 0x00ffb7, 14230 },
+  { 0x00ffb8, 14235 },
+  { 0x00ffb9, 14240 },
+  { 0x00ffab, 14142 },
+  { 0x00ff9d, 14101 },
+  { 0x00ffae, 14174 },
+  { 0x00ff9f, 14120 },
+  { 0x00ffaf, 14185 },
+  { 0x00ff99, 14045 },
+  { 0x00ff9c, 14094 },
+  { 0x00ff8d, 13981 },
+  { 0x00ffbd, 14245 },
+  { 0x00ff91, 13990 },
+  { 0x00ff92, 13996 },
+  { 0x00ff93, 14002 },
+  { 0x00ff94, 14008 },
+  { 0x00ff95, 14014 },
+  { 0x00ff9e, 14110 },
+  { 0x00ff96, 14022 },
+  { 0x00ffaa, 14130 },
+  { 0x00ff9b, 14086 },
+  { 0x00ff9b, 14073 },
+  { 0x00ff9a, 14053 },
+  { 0x00ff9a, 14064 },
+  { 0x00ff98, 14036 },
+  { 0x00ffac, 14149 },
+  { 0x00ff80, 13965 },
+  { 0x00ffad, 14162 },
+  { 0x00ff89, 13974 },
+  { 0x00ff97, 14030 },
+  { 0x00ff2d, 13467 },
+  { 0x00ff2e, 13477 },
+  { 0x00ff21, 13343 },
+  { 0x00ff26, 13393 },
+  { 0x0003d3, 2119 },
+  { 0x000eff, 11001 },
+  { 0x00004c, 229 },
+  { 0x0001c5, 1480 },
+  { 0x00fed4, 12732 },
+  { 0x0001a5, 1303 },
+  { 0x0003a6, 1978 },
+  { 0x00ff51, 13723 },
+  { 0x00ff0a, 13278 },
+  { 0x0020a4, 11071 },
+  { 0x0001a3, 1295 },
+  { 0x00004d, 231 },
+  { 0x0006b5, 3849 },
+  { 0x0006b2, 3798 },
+  { 0x0006bc, 3997 },
+  { 0x0006a5, 3567 },
+  { 0x0006a2, 3516 },
+  { 0x0006ac, 3715 },
+  { 0x00ff2c, 13460 },
+  { 0x00ff67, 13819 },
+  { 0x00ffe7, 14442 },
+  { 0x00ffe8, 14449 },
+  { 0x0020a5, 11080 },
+  { 0x00ff7e, 13918 },
+  { 0x00fe77, 12597 },
+  { 0x00fe76, 12580 },
+  { 0x00ff22, 13349 },
+  { 0x00ff20, 13333 },
+  { 0x00ff3d, 13667 },
+  { 0x00004e, 233 },
+  { 0x0001d1, 1531 },
+  { 0x0020a6, 11089 },
+  { 0x0001d2, 1538 },
+  { 0x0003d1, 2102 },
+  { 0x0020aa, 11128 },
+  { 0x00ff56, 13766 },
+  { 0x00fed2, 12712 },
+  { 0x0000d1, 881 },
+  { 0x00ff7f, 13956 },
+  { 0x00004f, 235 },
+  { 0x0013bc, 11012 },
+  { 0x0000d3, 895 },
+  { 0x0000d4, 902 },
+  { 0x0000d6, 921 },
+  { 0x0001d5, 1545 },
+  { 0x0000d2, 888 },
+  { 0x0003d2, 2111 },
+  { 0x0000d8, 941 },
+  { 0x0000d5, 914 },
+  { 0x00fe78, 12620 },
+  { 0x00fe79, 12636 },
+  { 0x000050, 237 },
+  { 0x00ff56, 13756 },
+  { 0x00ff55, 13742 },
+  { 0x00ff13, 13300 },
+  { 0x0020a7, 11099 },
+  { 0x00fefa, 13191 },
+  { 0x00fee9, 12906 },
+  { 0x00feea, 12922 },
+  { 0x00feeb, 12938 },
+  { 0x00feec, 12954 },
+  { 0x00feed, 12970 },
+  { 0x00fee8, 12886 },
+  { 0x00feef, 13008 },
+  { 0x00fef0, 13026 },
+  { 0x00fef1, 13044 },
+  { 0x00fef2, 13062 },
+  { 0x00fef3, 13080 },
+  { 0x00feee, 12986 },
+  { 0x00fefb, 13210 },
+  { 0x00fefc, 13230 },
+  { 0x00fee3, 12807 },
+  { 0x00fee6, 12851 },
+  { 0x00fee7, 12868 },
+  { 0x00fef5, 13116 },
+  { 0x00fef6, 13130 },
+  { 0x00fef7, 13144 },
+  { 0x00fef8, 13158 },
+  { 0x00fefd, 13250 },
+  { 0x00fef4, 13098 },
+  { 0x00fef9, 13172 },
+  { 0x00fee0, 12769 },
+  { 0x00fee1, 12782 },
+  { 0x00fee2, 12796 },
+  { 0x00fee4, 12820 },
+  { 0x00fee5, 12835 },
+  { 0x00fed1, 12692 },
+  { 0x00ff3e, 13685 },
+  { 0x00ff61, 13788 },
+  { 0x00ff55, 13750 },
+  { 0x000051, 239 },
+  { 0x000052, 241 },
+  { 0x0001c0, 1466 },
+  { 0x0001d8, 1558 },
+  { 0x0003a3, 1962 },
+  { 0x00ff66, 13814 },
+  { 0x00fe72, 12510 },
+  { 0x00ff0d, 13293 },
+  { 0x00ff53, 13731 },
+  { 0x00ff24, 13377 },
+  { 0x0020a8, 11110 },
+  { 0x000053, 243 },
+  { 0x0001a6, 1310 },
+  { 0x0001a9, 1317 },
+  { 0x0001aa, 1324 },
+  { 0x0002de, 1877 },
+  { 0x00ff14, 13306 },
+  { 0x00ff60, 13781 },
+  { 0x0006b1, 3786 },
+  { 0x0006bf, 4045 },
+  { 0x0006b8, 3923 },
+  { 0x0006b9, 3947 },
+  { 0x0006ba, 3972 },
+  { 0x0006bb, 3984 },
+  { 0x0006a1, 3504 },
+  { 0x0006af, 3763 },
+  { 0x0006a8, 3641 },
+  { 0x0006a9, 3665 },
+  { 0x0006aa, 3690 },
+  { 0x0006ab, 3702 },
+  { 0x00ffe1, 14385 },
+  { 0x00ffe6, 14431 },
+  { 0x00ffe2, 14393 },
+  { 0x00ff3c, 13651 },
+  { 0x00fe73, 12528 },
+  { 0x00fe75, 12562 },
+  { 0x00ffeb, 14468 },
+  { 0x00ffec, 14476 },
+  { 0x00ff15, 13318 },
+  { 0x000054, 245 },
+  { 0x0000de, 994 },
+  { 0x00ff09, 13274 },
+  { 0x0001ab, 1333 },
+  { 0x0001de, 1584 },
+  { 0x00fed5, 12752 },
+  { 0x000ddf, 9260 },
+  { 0x000dba, 8843 },
+  { 0x000da8, 8607 },
+  { 0x000daa, 8634 },
+  { 0x000da9, 8620 },
+  { 0x000dac, 8658 },
+  { 0x000dae, 8683 },
+  { 0x000db4, 8768 },
+  { 0x000dbd, 8882 },
+  { 0x000dbf, 8905 },
+  { 0x000dcb, 9039 },
+  { 0x000dce, 9073 },
+  { 0x000da2, 8525 },
+  { 0x000da5, 8566 },
+  { 0x000da3, 8538 },
+  { 0x000da4, 8552 },
+  { 0x000da6, 8579 },
+  { 0x000da1, 8514 },
+  { 0x000de5, 9343 },
+  { 0x000df7, 9556 },
+  { 0x000df5, 9533 },
+  { 0x000df6, 9544 },
+  { 0x000df9, 9582 },
+  { 0x000df1, 9484 },
+  { 0x000df8, 9569 },
+  { 0x000df3, 9510 },
+  { 0x000df4, 9522 },
+  { 0x000df2, 9497 },
+  { 0x000df0, 9472 },
+  { 0x000dcc, 9050 },
+  { 0x000dc5, 8972 },
+  { 0x000dc6, 8984 },
+  { 0x000deb, 9424 },
+  { 0x000de8, 9389 },
+  { 0x000dd1, 9113 },
+  { 0x000dde, 9237 },
+  { 0x000de7, 9374 },
+  { 0x000de9, 9400 },
+  { 0x000dea, 9412 },
+  { 0x000de6, 9360 },
+  { 0x000dc1, 8932 },
+  { 0x000da7, 8595 },
+  { 0x000ded, 9458 },
+  { 0x000db3, 8757 },
+  { 0x000db9, 8833 },
+  { 0x000dcd, 9063 },
+  { 0x000dcf, 9087 },
+  { 0x000dda, 9224 },
+  { 0x000dbe, 8892 },
+  { 0x000dbc, 8868 },
+  { 0x000dc0, 8916 },
+  { 0x000dbb, 8857 },
+  { 0x000dc3, 8953 },
+  { 0x000dc4, 8964 },
+  { 0x000dd0, 9102 },
+  { 0x000dd2, 9129 },
+  { 0x000de1, 9281 },
+  { 0x000de4, 9323 },
+  { 0x000de3, 9304 },
+  { 0x000dd3, 9141 },
+  { 0x000de0, 9270 },
+  { 0x000dd4, 9153 },
+  { 0x000dd5, 9164 },
+  { 0x000de2, 9293 },
+  { 0x000dd8, 9201 },
+  { 0x000dd6, 9176 },
+  { 0x000dd7, 9188 },
+  { 0x000dd9, 9212 },
+  { 0x000dc9, 9016 },
+  { 0x000dc8, 9004 },
+  { 0x000dab, 8648 },
+  { 0x000dca, 9028 },
+  { 0x000dec, 9441 },
+  { 0x000db1, 8722 },
+  { 0x000db2, 8741 },
+  { 0x000db7, 8804 },
+  { 0x000db0, 8709 },
+  { 0x000db8, 8819 },
+  { 0x000db6, 8790 },
+  { 0x000daf, 8696 },
+  { 0x000db5, 8779 },
+  { 0x000dc7, 8992 },
+  { 0x000dc2, 8942 },
+  { 0x000dad, 8671 },
+  { 0x0000de, 1000 },
+  { 0x00ff2b, 13452 },
+  { 0x0003ac, 2004 },
+  { 0x000055, 247 },
+  { 0x0000da, 957 },
+  { 0x0002dd, 1870 },
+  { 0x0000db, 964 },
+  { 0x0000dc, 976 },
+  { 0x0001db, 1571 },
+  { 0x0000d9, 950 },
+  { 0x0006b6, 3863 },
+  { 0x0006b4, 3824 },
+  { 0x0006b7, 3886 },
+  { 0x0006a6, 3581 },
+  { 0x0006a4, 3542 },
+  { 0x0006a7, 3604 },
+  { 0x0006b6, 3875 },
+  { 0x0006b4, 3837 },
+  { 0x0006b7, 3899 },
+  { 0x0006a6, 3593 },
+  { 0x0006a4, 3555 },
+  { 0x0006a7, 3617 },
+  { 0x0003de, 2143 },
+  { 0x00ff65, 13809 },
+  { 0x0003d9, 2128 },
+  { 0x00ff52, 13728 },
+  { 0x0001d9, 1565 },
+  { 0x0003dd, 2136 },
+  { 0x000056, 249 },
+  { 0xffffff, 14507 },
+  { 0x000057, 251 },
+  { 0x0020a9, 11120 },
+  { 0x000058, 253 },
+  { 0x000059, 255 },
+  { 0x0000dd, 987 },
+  { 0x0013be, 11018 },
+  { 0x00005a, 257 },
+  { 0x0001af, 1354 },
+  { 0x0001ac, 1340 },
+  { 0x0001ae, 1347 },
+  { 0x00ff28, 13420 },
+  { 0x00ff2a, 13436 },
+  { 0x000061, 333 },
+  { 0x0000e1, 1020 },
+  { 0x0001ff, 1720 },
+  { 0x0001e3, 1600 },
+  { 0x0000e2, 1027 },
+  { 0x0000b4, 612 },
+  { 0x0000e4, 1046 },
+  { 0x0000e6, 1063 },
+  { 0x0000e0, 1013 },
+  { 0x0003e0, 2151 },
+  { 0x000026, 48 },
+  { 0x0001b1, 1364 },
+  { 0x000027, 58 },
+  { 0x0008c8, 6376 },
+  { 0x0000e5, 1057 },
+  { 0x00005e, 294 },
+  { 0x00007e, 410 },
+  { 0x00002a, 101 },
+  { 0x000040, 204 },
+  { 0x0000e3, 1039 },
+  { 0x000062, 335 },
+  { 0x00005c, 271 },
+  { 0x000af4, 7692 },
+  { 0x00007c, 395 },
+  { 0x0009df, 6562 },
+  { 0x0008a5, 5952 },
+  { 0x0008ac, 6062 },
+  { 0x0008a8, 5995 },
+  { 0x0008b2, 6166 },
+  { 0x0008ae, 6091 },
+  { 0x0008aa, 6030 },
+  { 0x0008b6, 6253 },
+  { 0x0009f6, 6770 },
+  { 0x0008b4, 6209 },
+  { 0x00007b, 385 },
+  { 0x00007d, 399 },
+  { 0x00005b, 259 },
+  { 0x00005d, 281 },
+  { 0x0001a2, 1289 },
+  { 0x0000a6, 472 },
+  { 0x000063, 337 },
+  { 0x0002e5, 1889 },
+  { 0x0001e6, 1614 },
+  { 0x000ab8, 6996 },
+  { 0x000afc, 7801 },
+  { 0x0001b7, 1401 },
+  { 0x0001e8, 1621 },
+  { 0x0000e7, 1066 },
+  { 0x0002e6, 1899 },
+  { 0x0000b8, 646 },
+  { 0x0000a2, 445 },
+  { 0x0009e1, 6581 },
+  { 0x000af3, 7682 },
+  { 0x000bcf, 7950 },
+  { 0x000aec, 7630 },
+  { 0x00003a, 160 },
+  { 0x00002c, 115 },
+  { 0x0000a9, 500 },
+  { 0x0009e4, 6600 },
+  { 0x0009ee, 6668 },
+  { 0x0000a4, 459 },
+  { 0x000aff, 7845 },
+  { 0x000064, 339 },
+  { 0x000af1, 7662 },
+  { 0x0001ef, 1643 },
+  { 0x00fe56, 12290 },
+  { 0x00fe58, 12319 },
+  { 0x00fe51, 12229 },
+  { 0x00fe60, 12437 },
+  { 0x00fe55, 12279 },
+  { 0x00fe5a, 12351 },
+  { 0x00fe5b, 12362 },
+  { 0x00fe52, 12240 },
+  { 0x00fe57, 12304 },
+  { 0x00fe59, 12334 },
+  { 0x00fe50, 12218 },
+  { 0x00fe61, 12451 },
+  { 0x00fe62, 12461 },
+  { 0x00fe5d, 12387 },
+  { 0x00fe54, 12267 },
+  { 0x00fe5c, 12375 },
+  { 0x00fe5f, 12415 },
+  { 0x00fe53, 12256 },
+  { 0x00fe5e, 12397 },
+  { 0x000abd, 7028 },
+  { 0x0000b0, 569 },
+  { 0x0000a8, 490 },
+  { 0x000aed, 7635 },
+  { 0x000aa5, 6822 },
+  { 0x0000f7, 1204 },
+  { 0x000024, 33 },
+  { 0x000aaf, 6899 },
+  { 0x0001bd, 1437 },
+  { 0x000af2, 7669 },
+  { 0x000afe, 7826 },
+  { 0x0008fe, 6552 },
+  { 0x000ba8, 7873 },
+  { 0x000bd6, 7965 },
+  { 0x000bc4, 7915 },
+  { 0x000bc2, 7899 },
+  { 0x0001f0, 1650 },
+  { 0x000065, 341 },
+  { 0x0003ec, 2167 },
+  { 0x0000e9, 1082 },
+  { 0x0001ec, 1636 },
+  { 0x0000ea, 1089 },
+  { 0x0000eb, 1101 },
+  { 0x0000e8, 1075 },
+  { 0x000aae, 6890 },
+  { 0x000aa3, 6804 },
+  { 0x000aa4, 6813 },
+  { 0x0003ba, 2036 },
+  { 0x000aa9, 6864 },
+  { 0x000ade, 7409 },
+  { 0x000adf, 7424 },
+  { 0x000ace, 7191 },
+  { 0x000acf, 7204 },
+  { 0x000aa1, 6788 },
+  { 0x000aaa, 6871 },
+  { 0x000ae6, 7531 },
+  { 0x000ae7, 7550 },
+  { 0x0003bf, 2064 },
+  { 0x000ae0, 7437 },
+  { 0x000ae1, 7454 },
+  { 0x000aa2, 6796 },
+  { 0x0001ea, 1628 },
+  { 0x00003d, 181 },
+  { 0x0000f0, 1149 },
+  { 0x000021, 6 },
+  { 0x0000a1, 434 },
+  { 0x000066, 343 },
+  { 0x000af8, 7740 },
+  { 0x0009e3, 6597 },
+  { 0x000abb, 7003 },
+  { 0x000adc, 7368 },
+  { 0x000adb, 7351 },
+  { 0x000add, 7388 },
+  { 0x000ae9, 7585 },
+  { 0x000ae8, 7567 },
+  { 0x000ac5, 7089 },
+  { 0x000ab7, 6985 },
+  { 0x000ab5, 6965 },
+  { 0x0008f6, 6514 },
+  { 0x000067, 345 },
+  { 0x0002f5, 1911 },
+  { 0x0002bb, 1807 },
+  { 0x0003bb, 2044 },
+  { 0x0002f8, 1921 },
+  { 0x000060, 317 },
+  { 0x00003e, 187 },
+  { 0x0008be, 6315 },
+  { 0x0000ab, 522 },
+  { 0x0000bb, 676 },
+  { 0x000068, 347 },
+  { 0x000aa8, 6854 },
+  { 0x0002b6, 1786 },
+  { 0x000aee, 7643 },
+  { 0x000ce0, 8033 },
+  { 0x000cf2, 8350 },
+  { 0x000ce1, 8046 },
+  { 0x000ce1, 8057 },
+  { 0x000ce7, 8169 },
+  { 0x000ce3, 8096 },
+  { 0x000ce3, 8109 },
+  { 0x000cdf, 8012 },
+  { 0x000cea, 8226 },
+  { 0x000ced, 8268 },
+  { 0x000cef, 8295 },
+  { 0x000cf3, 8362 },
+  { 0x000cf5, 8387 },
+  { 0x000cf5, 8404 },
+  { 0x000ce2, 8069 },
+  { 0x000ce2, 8082 },
+  { 0x000ce4, 8123 },
+  { 0x000ce7, 8181 },
+  { 0x000ceb, 8243 },
+  { 0x000cf7, 8445 },
+  { 0x000cec, 8255 },
+  { 0x000cee, 8284 },
+  { 0x000cf0, 8311 },
+  { 0x000cf4, 8377 },
+  { 0x000cf7, 8456 },
+  { 0x000cf8, 8468 },
+  { 0x000cf1, 8322 },
+  { 0x000cf1, 8336 },
+  { 0x000cf9, 8480 },
+  { 0x000cfa, 8492 },
+  { 0x000cfa, 8503 },
+  { 0x000ce8, 8192 },
+  { 0x000ce8, 8203 },
+  { 0x000ce5, 8133 },
+  { 0x000ce9, 8215 },
+  { 0x000cf6, 8421 },
+  { 0x000cf6, 8433 },
+  { 0x000ce6, 8144 },
+  { 0x000ce6, 8156 },
+  { 0x000ada, 7342 },
+  { 0x0008a3, 5925 },
+  { 0x0009ef, 6682 },
+  { 0x0009f0, 6697 },
+  { 0x0009f1, 6712 },
+  { 0x0009f2, 6727 },
+  { 0x0009f3, 6742 },
+  { 0x0002b1, 1778 },
+  { 0x0009e2, 6594 },
+  { 0x0000ad, 544 },
+  { 0x000069, 349 },
+  { 0x0000ed, 1119 },
+  { 0x0000ee, 1126 },
+  { 0x0008cf, 6418 },
+  { 0x0000ef, 1138 },
+  { 0x0002b9, 1798 },
+  { 0x0008cd, 6401 },
+  { 0x0000ec, 1112 },
+  { 0x0003ef, 2177 },
+  { 0x0008ce, 6410 },
+  { 0x0008da, 6436 },
+  { 0x0008db, 6447 },
+  { 0x0008c2, 6361 },
+  { 0x0008bf, 6332 },
+  { 0x0008dc, 6456 },
+  { 0x0003e7, 2159 },
+  { 0x0003b5, 2020 },
+  { 0x00006a, 351 },
+  { 0x0002bc, 1814 },
+  { 0x000bca, 7934 },
+  { 0x00006b, 353 },
+  { 0x0004b1, 2439 },
+  { 0x0004c1, 2563 },
+  { 0x0004b4, 2460 },
+  { 0x0004cc, 2669 },
+  { 0x0004ca, 2653 },
+  { 0x0004cd, 2685 },
+  { 0x0004cb, 2661 },
+  { 0x0004ce, 2693 },
+  { 0x0004cc, 2677 },
+  { 0x0004b2, 2446 },
+  { 0x0004b6, 2474 },
+  { 0x0004b9, 2498 },
+  { 0x0004b7, 2482 },
+  { 0x0004ba, 2506 },
+  { 0x0004b8, 2490 },
+  { 0x0004cf, 2701 },
+  { 0x0004d2, 2725 },
+  { 0x0004d0, 2709 },
+  { 0x0004d3, 2733 },
+  { 0x0004d1, 2717 },
+  { 0x0004dd, 2813 },
+  { 0x0004c5, 2613 },
+  { 0x0004c8, 2637 },
+  { 0x0004c6, 2621 },
+  { 0x0004c9, 2645 },
+  { 0x0004c7, 2629 },
+  { 0x0004b5, 2467 },
+  { 0x0004d7, 2765 },
+  { 0x0004da, 2789 },
+  { 0x0004d8, 2773 },
+  { 0x0004db, 2797 },
+  { 0x0004d9, 2781 },
+  { 0x0004bb, 2514 },
+  { 0x0004be, 2539 },
+  { 0x0004bc, 2522 },
+  { 0x0004bf, 2547 },
+  { 0x0004bd, 2531 },
+  { 0x0004c0, 2555 },
+  { 0x0004c3, 2597 },
+  { 0x0004c1, 2572 },
+  { 0x0004c4, 2605 },
+  { 0x0004c2, 2580 },
+  { 0x0004c2, 2589 },
+  { 0x0004b3, 2453 },
+  { 0x0004dc, 2805 },
+  { 0x0004a6, 2340 },
+  { 0x0004d4, 2741 },
+  { 0x0004d6, 2757 },
+  { 0x0004d5, 2749 },
+  { 0x0004a7, 2348 },
+  { 0x0004a3, 2277 },
+  { 0x0004a4, 2297 },
+  { 0x0004a5, 2308 },
+  { 0x0004aa, 2369 },
+  { 0x0004a1, 2243 },
+  { 0x0004a8, 2355 },
+  { 0x0004a5, 2325 },
+  { 0x0004ab, 2376 },
+  { 0x0004a2, 2257 },
+  { 0x00ff7e, 13930 },
+  { 0x0004af, 2407 },
+  { 0x0004af, 2416 },
+  { 0x0004a9, 2362 },
+  { 0x0004ac, 2383 },
+  { 0x0004ae, 2399 },
+  { 0x0004ad, 2391 },
+  { 0x0003a2, 1952 },
+  { 0x0003f3, 2202 },
+  { 0x0003a2, 1958 },
+  { 0x00006c, 355 },
+  { 0x0001e5, 1607 },
+  { 0x000ad9, 7331 },
+  { 0x0001b5, 1387 },
+  { 0x0003b6, 2027 },
+  { 0x000abc, 7011 },
+  { 0x0008fb, 6523 },
+  { 0x000ba3, 7852 },
+  { 0x000ad2, 7261 },
+  { 0x0008af, 6106 },
+  { 0x000acc, 7156 },
+  { 0x000aea, 7605 },
+  { 0x0008a1, 5898 },
+  { 0x000bda, 7984 },
+  { 0x000ad0, 7220 },
+  { 0x0009f4, 6757 },
+  { 0x000bdc, 7993 },
+  { 0x00003c, 176 },
+  { 0x0008bc, 6292 },
+  { 0x0009e5, 6603 },
+  { 0x0008de, 6475 },
+  { 0x0008df, 6486 },
+  { 0x0009ed, 6654 },
+  { 0x0009ea, 6612 },
+  { 0x0001b3, 1379 },
+  { 0x00006d, 357 },
+  { 0x0000af, 562 },
+  { 0x000af7, 7729 },
+  { 0x000af0, 7649 },
+  { 0x000abf, 7059 },
+  { 0x0000ba, 666 },
+  { 0x00002d, 121 },
+  { 0x000ad6, 7315 },
+  { 0x0000b5, 618 },
+  { 0x0000d7, 932 },
+  { 0x000af6, 7717 },
+  { 0x000af5, 7704 },
+  { 0x00006e, 359 },
+  { 0x0008c5, 6370 },
+  { 0x0001f1, 1658 },
+  { 0x0001f2, 1665 },
+  { 0x0003f1, 2185 },
+  { 0x0009e8, 6606 },
+  { 0x0000a0, 421 },
+  { 0x0008bd, 6306 },
+  { 0x0000ac, 536 },
+  { 0x0000f1, 1153 },
+  { 0x000023, 22 },
+  { 0x0006b0, 3775 },
+  { 0x00006f, 361 },
+  { 0x0000f3, 1167 },
+  { 0x0000f4, 1174 },
+  { 0x0000f6, 1193 },
+  { 0x0001f5, 1672 },
+  { 0x0013bd, 11015 },
+  { 0x0001b2, 1372 },
+  { 0x0000f2, 1160 },
+  { 0x0003f2, 2194 },
+  { 0x000ac3, 7066 },
+  { 0x000ab2, 6934 },
+  { 0x0000bd, 702 },
+  { 0x0000bc, 691 },
+  { 0x000ab6, 6976 },
+  { 0x0000b9, 654 },
+  { 0x000ab0, 6915 },
+  { 0x000ae2, 7473 },
+  { 0x000ae5, 7522 },
+  { 0x000ae4, 7504 },
+  { 0x000ae3, 7488 },
+  { 0x0000aa, 510 },
+  { 0x0000f8, 1213 },
+  { 0x0000f5, 1186 },
+  { 0x000bc0, 7891 },
+  { 0x00047e, 2234 },
+  { 0x000070, 363 },
+  { 0x0000b6, 621 },
+  { 0x000028, 80 },
+  { 0x000029, 90 },
+  { 0x0008ef, 6496 },
+  { 0x000025, 40 },
+  { 0x00002e, 127 },
+  { 0x0000b7, 631 },
+  { 0x000afb, 7781 },
+  { 0x00002b, 110 },
+  { 0x0000b1, 576 },
+  { 0x000ad4, 7302 },
+  { 0x0004b0, 2424 },
+  { 0x000aa6, 6833 },
+  { 0x000071, 365 },
+  { 0x000bcc, 7938 },
+  { 0x00003f, 195 },
+  { 0x0000bf, 724 },
+  { 0x000022, 13 },
+  { 0x000060, 323 },
+  { 0x000027, 69 },
+  { 0x000072, 367 },
+  { 0x0001e0, 1593 },
+  { 0x0008d6, 6428 },
+  { 0x0001f8, 1685 },
+  { 0x0003b3, 2011 },
+  { 0x0000ae, 551 },
+  { 0x000abe, 7041 },
+  { 0x0008fd, 6541 },
+  { 0x000ba6, 7862 },
+  { 0x000ad3, 7281 },
+  { 0x0008b0, 6127 },
+  { 0x0008b7, 6271 },
+  { 0x000acd, 7173 },
+  { 0x000aeb, 7617 },
+  { 0x000bd8, 7974 },
+  { 0x000ad1, 7240 },
+  { 0x0009f5, 6763 },
+  { 0x000bfc, 8002 },
+  { 0x000073, 369 },
+  { 0x0001b6, 1394 },
+  { 0x0001b9, 1407 },
+  { 0x0001ba, 1414 },
+  { 0x0002fe, 1940 },
+  { 0x00ff7e, 13942 },
+  { 0x000ad7, 7323 },
+  { 0x0000a7, 482 },
+  { 0x00003b, 166 },
+  { 0x0004df, 2832 },
+  { 0x000ac6, 7101 },
+  { 0x000aca, 7124 },
+  { 0x000aac, 6878 },
+  { 0x0008c9, 6388 },
+  { 0x000afd, 7807 },
+  { 0x00002f, 134 },
+  { 0x0009e0, 6568 },
+  { 0x000020, 0 },
+  { 0x0000df, 1006 },
+  { 0x0000a3, 450 },
+  { 0x000074, 371 },
+  { 0x0001bb, 1423 },
+  { 0x0001fe, 1711 },
+  { 0x000af9, 7753 },
+  { 0x000afa, 7763 },
+  { 0x0008c0, 6341 },
+  { 0x000aa7, 6844 },
+  { 0x0000fe, 1264 },
+  { 0x000ac4, 7076 },
+  { 0x000ab4, 6953 },
+  { 0x0000be, 710 },
+  { 0x0000b3, 598 },
+  { 0x0008a4, 5940 },
+  { 0x0008ab, 6048 },
+  { 0x0008a2, 5910 },
+  { 0x0008a7, 5978 },
+  { 0x0008b1, 6149 },
+  { 0x0008ad, 6076 },
+  { 0x0008a9, 6012 },
+  { 0x0008b5, 6235 },
+  { 0x0009f7, 6775 },
+  { 0x0008b3, 6183 },
+  { 0x000ac9, 7114 },
+  { 0x000acb, 7138 },
+  { 0x0003bc, 2053 },
+  { 0x000ab3, 6943 },
+  { 0x0000b2, 586 },
+  { 0x000ab1, 6924 },
+  { 0x000075, 373 },
+  { 0x0000fa, 1227 },
+  { 0x0002fd, 1933 },
+  { 0x0000fb, 1234 },
+  { 0x0000fc, 1246 },
+  { 0x0001fb, 1698 },
+  { 0x0000f9, 1220 },
+  { 0x0003fe, 2226 },
+  { 0x000bc6, 7925 },
+  { 0x00005f, 306 },
+  { 0x0008dd, 6469 },
+  { 0x0003f9, 2211 },
+  { 0x0008fc, 6533 },
+  { 0x000ba9, 7883 },
+  { 0x0009ec, 6641 },
+  { 0x0009eb, 6627 },
+  { 0x000bc3, 7908 },
+  { 0x000bd3, 7957 },
+  { 0x000bce, 7943 },
+  { 0x0001f9, 1692 },
+  { 0x0003fd, 2219 },
+  { 0x000076, 375 },
+  { 0x0008c1, 6351 },
+  { 0x0009f8, 6780 },
+  { 0x0008a6, 5964 },
+  { 0x0004de, 2820 },
+  { 0x0009e9, 6609 },
+  { 0x000077, 377 },
+  { 0x000078, 379 },
+  { 0x000079, 381 },
+  { 0x0000fd, 1257 },
+  { 0x0000ff, 1270 },
+  { 0x0000a5, 468 },
+  { 0x00007a, 383 },
+  { 0x0001bf, 1456 },
+  { 0x0001bc, 1430 },
+  { 0x0001be, 1449 }
+};
--- gtk+/gdk/gdkinternals.h	(.../2.6.4)	(revision 904)
+++ gtk+/gdk/gdkinternals.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -185,8 +185,8 @@
                                   GdkWindowState unset_flags,
                                   GdkWindowState set_flags);
 
-#define GDK_SCRATCH_IMAGE_WIDTH 256
-#define GDK_SCRATCH_IMAGE_HEIGHT 64
+#define GDK_SCRATCH_IMAGE_WIDTH 128
+#define GDK_SCRATCH_IMAGE_HEIGHT 32
 
 GdkImage* _gdk_image_new_for_depth (GdkScreen    *screen,
 				    GdkImageType  type,
--- gtk+/gdk/gdkscreen.c	(.../2.6.4)	(revision 904)
+++ gtk+/gdk/gdkscreen.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -106,10 +106,16 @@
   for (i = 0; i < 32; ++i)
     {
       if (screen->exposure_gcs[i])
-	g_object_unref (screen->exposure_gcs[i]);
+        {
+          g_object_unref (screen->exposure_gcs[i]);
+          screen->exposure_gcs[i] = NULL;
+        }
 
       if (screen->normal_gcs[i])
-	g_object_unref (screen->normal_gcs[i]);
+        {
+          g_object_unref (screen->normal_gcs[i]);
+          screen->normal_gcs[i] = NULL;
+        }
     }
 
   G_OBJECT_CLASS (parent_class)->dispose (object);
--- gtk+/gdk/gdkscreen.h	(.../2.6.4)	(revision 904)
+++ gtk+/gdk/gdkscreen.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -95,6 +95,9 @@
 				   const gchar *name,
 				   GValue      *value);
 
+GdkWindow *gdk_screen_get_active_window (GdkScreen *screen);
+GList     *gdk_screen_get_window_stack  (GdkScreen *screen);
+
 G_END_DECLS
 
 #endif				/* __GDK_SCREEN_H__ */
--- gtk+/gdk/gdkwindow.c	(.../2.6.4)	(revision 904)
+++ gtk+/gdk/gdkwindow.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -335,6 +335,7 @@
   GdkWindowObject *private;
   GdkWindowObject *temp_private;
   GdkWindow *temp_window;
+  GdkScreen *screen;
   GList *children;
   GList *tmp;
   
@@ -347,6 +348,14 @@
     
   switch (GDK_WINDOW_TYPE (window))
     {
+    case GDK_WINDOW_ROOT:
+      screen = gdk_drawable_get_screen (GDK_DRAWABLE (window));
+      if (!screen->closed)
+	{
+	  g_error ("attempted to destroy root window");
+	  break;
+	}
+      /* else fall thru */
     case GDK_WINDOW_TOPLEVEL:
     case GDK_WINDOW_CHILD:
     case GDK_WINDOW_DIALOG:
@@ -422,10 +431,6 @@
           gdk_drawable_set_colormap (GDK_DRAWABLE (window), NULL);
 	}
       break;
-      
-    case GDK_WINDOW_ROOT:
-      g_error ("attempted to destroy root window");
-      break;
     }
 }
 
--- gtk+/gdk/gdkwindow.h	(.../2.6.4)	(revision 904)
+++ gtk+/gdk/gdkwindow.h	(.../2.6.4-1.osso62)	(revision 904)
@@ -108,7 +108,8 @@
   GDK_WINDOW_TYPE_HINT_SPLASHSCREEN,
   GDK_WINDOW_TYPE_HINT_UTILITY,
   GDK_WINDOW_TYPE_HINT_DOCK,
-  GDK_WINDOW_TYPE_HINT_DESKTOP
+  GDK_WINDOW_TYPE_HINT_DESKTOP,
+  GDK_WINDOW_TYPE_HINT_MESSAGE
 } GdkWindowTypeHint;
 
 
@@ -407,8 +408,10 @@
 					  gint		   max_height,
 					  gint		   flags);
 #endif
-void          gdk_window_set_type_hint    (GdkWindow       *window,
-					   GdkWindowTypeHint hint);
+void              gdk_window_set_type_hint (GdkWindow        *window,
+					    GdkWindowTypeHint hint);
+GdkWindowTypeHint gdk_window_get_type_hint (GdkWindow        *window);
+
 void          gdk_window_set_modal_hint   (GdkWindow       *window,
                                            gboolean         modal);
 
--- gtk+/gdk/x11/gdkim-x11.c	(.../2.6.4)	(revision 904)
+++ gtk+/gdk/x11/gdkim-x11.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -62,11 +62,14 @@
   g_free (last_locale);
   last_locale = g_strdup (current_locale);
 
+#if 0
+  /* Hildon: we know X locales are not there so stop complaining */
   if (!XSupportsLocale ())
     g_warning ("locale not supported by Xlib");
   
   if (!XSetLocaleModifiers (""))
     g_warning ("cannot set locale modifiers");
+#endif
 
   if ((strcmp (current_locale, "C")) && (strcmp (current_locale, "POSIX")))
     {
--- gtk+/gdk/x11/gdkdnd-x11.c	(.../2.6.4)	(revision 904)
+++ gtk+/gdk/x11/gdkdnd-x11.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -136,7 +136,7 @@
 const static struct {
   const char *atom_name;
   GdkFilterFunc func;
-} xdnd_filters[] = {
+} const xdnd_filters[] = {
   { "XdndEnter",    xdnd_enter_filter },
   { "XdndLeave",    xdnd_leave_filter },
   { "XdndPosition", xdnd_position_filter },
--- gtk+/gdk/x11/gdkdisplay-x11.c	(.../2.6.4)	(revision 904)
+++ gtk+/gdk/x11/gdkdisplay-x11.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -697,18 +697,20 @@
 static void
 gdk_display_x11_dispose (GObject *object)
 {
-  GdkDisplayX11 *display_x11;
-  gint i;
-  
-  display_x11 = GDK_DISPLAY_X11 (object);
-  
-  for (i = 0; i < ScreenCount (display_x11->xdisplay); i++)
-    _gdk_screen_close (display_x11->screens[i]);
+  GdkDisplayX11 *display_x11 = GDK_DISPLAY_X11 (object);
+  gint           n_screens;
+  gint           i;
 
-  g_source_destroy (display_x11->event_source);
+  n_screens = ScreenCount (display_x11->xdisplay);
 
-  XCloseDisplay (display_x11->xdisplay);
-  display_x11->xdisplay = NULL;
+  for (i = 0; i < n_screens; i++)
+    _gdk_screen_close (display_x11->screens[i]);
+
+  if (display_x11->event_source)
+    {
+      g_source_destroy (display_x11->event_source);
+      display_x11->event_source = NULL;
+    }
 
   G_OBJECT_CLASS (parent_class)->dispose (object);
 }
@@ -717,11 +719,13 @@
 gdk_display_x11_finalize (GObject *object)
 {
   GdkDisplayX11 *display_x11 = GDK_DISPLAY_X11 (object);
-  int i;
-  GList *tmp;
-  /* FIXME need to write GdkKeymap finalize fct 
-     g_object_unref (display_x11->keymap);
-   */
+  gint           n_screens;
+  gint           i;
+
+  /* Keymap */
+  if (display_x11->keymap)
+    g_object_unref (display_x11->keymap);
+
   /* Free motif Dnd */
   if (display_x11->motif_target_lists)
     {
@@ -733,30 +737,40 @@
   /* Atom Hashtable */
   g_hash_table_destroy (display_x11->atom_from_virtual);
   g_hash_table_destroy (display_x11->atom_to_virtual);
+
   /* Leader Window */
   XDestroyWindow (display_x11->xdisplay, display_x11->leader_window);
+
   /* list of filters for client messages */
+  g_list_foreach (display_x11->client_filters, (GFunc) g_free, NULL);
   g_list_free (display_x11->client_filters);
+
   /* List of event window extraction functions */
   g_slist_foreach (display_x11->event_types, (GFunc)g_free, NULL);
   g_slist_free (display_x11->event_types);
+
   /* X ID hashtable */
   g_hash_table_destroy (display_x11->xid_ht);
+
   /* input GdkDevice list */
   /* FIXME need to write finalize fct */
-  for (tmp = display_x11->input_devices; tmp; tmp = tmp->next)
-    g_object_unref (tmp->data);
+  g_list_foreach (display_x11->input_devices, (GFunc) g_object_unref, NULL);
   g_list_free (display_x11->input_devices);
+
   /* input GdkWindow list */
-  for (tmp = display_x11->input_windows; tmp; tmp = tmp->next)
-    g_object_unref (tmp->data);
+  g_list_foreach (display_x11->input_windows, (GFunc) g_object_unref, NULL);
   g_list_free (display_x11->input_windows);
+
   /* Free all GdkScreens */
+  n_screens = ScreenCount (display_x11->xdisplay);
   for (i = 0; i < ScreenCount (display_x11->xdisplay); i++)
     g_object_unref (display_x11->screens[i]);
   g_free (display_x11->screens);
+
   g_free (display_x11->startup_notification_id);
-  
+
+  XCloseDisplay (display_x11->xdisplay);
+
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
 
@@ -832,10 +846,13 @@
   GdkDisplayX11 *display_x11 = GDK_DISPLAY_X11 (display);
   const gchar *startup_id;
   
-  if (display)
-    gdk_display = GDK_DISPLAY_XDISPLAY (display);
-  else
-    gdk_display = NULL;
+  if (!display)
+    {
+      gdk_display = NULL;
+      return;
+    }
+
+  gdk_display = GDK_DISPLAY_XDISPLAY (display);
 
   g_free (display_x11->startup_notification_id);
   display_x11->startup_notification_id = NULL;
--- gtk+/gdk/x11/gdkkeys-x11.c	(.../2.6.4)	(revision 904)
+++ gtk+/gdk/x11/gdkkeys-x11.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -53,7 +53,8 @@
 #  endif
 #endif /* HAVE_XKB */
 
-typedef struct _GdkKeymapX11 GdkKeymapX11;
+typedef struct _GdkKeymapX11   GdkKeymapX11;
+typedef struct _GdkKeymapClass GdkKeymapX11Class;
 
 #define GDK_TYPE_KEYMAP_X11          (gdk_keymap_x11_get_type ())
 #define GDK_KEYMAP_X11(object)       (G_TYPE_CHECK_INSTANCE_CAST ((object), GDK_TYPE_KEYMAP_X11, GdkKeymapX11))
@@ -102,8 +103,12 @@
 #define KEYMAP_USE_XKB(keymap) GDK_DISPLAY_X11 ((keymap)->display)->use_xkb
 #define KEYMAP_XDISPLAY(keymap) GDK_DISPLAY_XDISPLAY ((keymap)->display)
 
-static GType gdk_keymap_x11_get_type (void);
-static void  gdk_keymap_x11_init     (GdkKeymapX11 *keymap);
+static GType gdk_keymap_x11_get_type   (void);
+static void  gdk_keymap_x11_class_init (GdkKeymapX11Class *klass);
+static void  gdk_keymap_x11_init       (GdkKeymapX11      *keymap);
+static void  gdk_keymap_x11_finalize   (GObject           *object);
+
+static GdkKeymapClass *parent_class = NULL;
 
 static GType
 gdk_keymap_x11_get_type (void)
@@ -117,7 +122,7 @@
 	  sizeof (GdkKeymapClass),
 	  (GBaseInitFunc) NULL,
 	  (GBaseFinalizeFunc) NULL,
-	  (GClassInitFunc) NULL,
+	  (GClassInitFunc) gdk_keymap_x11_class_init,
 	  NULL,           /* class_finalize */
 	  NULL,           /* class_data */
 	  sizeof (GdkKeymapX11),
@@ -134,6 +139,16 @@
 }
 
 static void
+gdk_keymap_x11_class_init (GdkKeymapX11Class *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  parent_class = g_type_class_peek_parent (klass);
+
+  object_class->finalize = gdk_keymap_x11_finalize;
+}
+
+static void
 gdk_keymap_x11_init (GdkKeymapX11 *keymap)
 {
   keymap->min_keycode = 0;
@@ -158,6 +173,25 @@
 
 }
 
+static void
+gdk_keymap_x11_finalize (GObject *object)
+{
+  GdkKeymapX11 *keymap_x11 = GDK_KEYMAP_X11 (object);
+
+  if (keymap_x11->keymap)
+    XFree (keymap_x11->keymap);
+
+  if (keymap_x11->mod_keymap)
+    XFreeModifiermap (keymap_x11->mod_keymap);
+
+#ifdef HAVE_XKB
+  if (keymap_x11->xkb_desc)
+    XkbFreeClientMap (keymap_x11->xkb_desc, 0, True);
+#endif
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
 static inline void
 update_keyrange (GdkKeymapX11 *keymap_x11)
 {
--- gtk+/gdk/x11/gdkscreen-x11.c	(.../2.6.4)	(revision 904)
+++ gtk+/gdk/x11/gdkscreen-x11.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -34,6 +34,8 @@
 #include "gdkdisplay-x11.h"
 #include "gdkx.h"
 
+#include <X11/Xatom.h>
+
 #ifdef HAVE_SOLARIS_XINERAMA
 #include <X11/extensions/xinerama.h>
 #endif
@@ -286,44 +288,55 @@
 
   _gdk_x11_events_uninit_screen (GDK_SCREEN (object));
 
-  g_object_unref (screen_x11->default_colormap);
-  screen_x11->default_colormap = NULL;
-  
-  screen_x11->root_window = NULL;
+  if (screen_x11->default_colormap)
+    {
+      g_object_unref (screen_x11->default_colormap);
+      screen_x11->default_colormap = NULL;
+    }
+
+  if (screen_x11->system_colormap)
+    {
+      g_object_unref (screen_x11->system_colormap);
+      screen_x11->system_colormap = NULL;
+    }
+
+  if (screen_x11->root_window)
+    _gdk_window_destroy (screen_x11->root_window, TRUE);
+
+  G_OBJECT_CLASS (parent_class)->dispose (object);
 
   screen_x11->xdisplay = NULL;
   screen_x11->xscreen = NULL;
   screen_x11->screen_num = -1;
   screen_x11->xroot_window = None;
   screen_x11->wmspec_check_window = None;
-  
-  G_OBJECT_CLASS (parent_class)->dispose (object);
+
 }
 
 static void
 gdk_screen_x11_finalize (GObject *object)
 {
   GdkScreenX11 *screen_x11 = GDK_SCREEN_X11 (object);
-  /* int i; */
-  g_object_unref (screen_x11->root_window);
+  gint          i;
+
+  if (screen_x11->root_window)
+    g_object_unref (screen_x11->root_window);
 
   if (screen_x11->renderer)
     g_object_unref (screen_x11->renderer);
-  
-  /* Visual Part (Need to implement finalize for Visuals for a clean
-   * finalize) */
-  /* for (i=0;i<screen_x11->nvisuals;i++)
-    g_object_unref (screen_x11->visuals[i]);*/
+
+  /* Visual Part */
+  for (i = 0;i < screen_x11->nvisuals; i++)
+    g_object_unref (screen_x11->visuals[i]);
   g_free (screen_x11->visuals);
   g_hash_table_destroy (screen_x11->visual_hash);
 
   g_free (screen_x11->window_manager_name);  
 
   g_hash_table_destroy (screen_x11->colormap_hash);
-  /* X settings */
-  g_free (screen_x11->xsettings_client);
+
   g_free (screen_x11->monitors);
-  
+
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
 
@@ -710,3 +723,122 @@
   return _gdk_windowing_substitute_screen_number (old_display, 
 						  gdk_screen_get_number (screen));
 }
+
+/**
+ * gdk_screen_get_active_window
+ * @screen: a #GdkScreen
+ *
+ * Returns a pointer to the screen's currently active window. On X11,
+ * this is done by inspecting the _NET_ACTIVE_WINDOW property on the root
+ * window. If there is no currently currently active window, or the window
+ * manager does not support the _NET_ACTIVE_WINDOW hint, this function
+ * returns NULL.
+ *
+ * Return value: a #GdkWindow wrapper for the currently active window,
+ * or %NULL.
+ */
+GdkWindow *
+gdk_screen_get_active_window (GdkScreen *screen)
+{
+  GdkScreenX11 *screen_x11;
+  GdkWindow *ret = NULL;
+  Atom type_return;
+  gint format_return;
+  gulong nitems_return;
+  gulong bytes_after_return;
+  guchar *data;
+
+  if (!gdk_x11_screen_supports_net_wm_hint (screen,
+                                            gdk_atom_intern ("_NET_ACTIVE_WINDOW", FALSE)))
+    return NULL;
+
+  screen_x11 = GDK_SCREEN_X11 (screen);
+
+  if (XGetWindowProperty (screen_x11->xdisplay, screen_x11->xroot_window,
+	                  gdk_x11_get_xatom_by_name_for_display (screen_x11->display,
+			                                         "_NET_ACTIVE_WINDOW"),
+		          0, 1, False, XA_WINDOW, &type_return,
+		          &format_return, &nitems_return,
+                          &bytes_after_return, &data)
+      == Success)
+    {
+      if ((type_return == XA_WINDOW) && (format_return == 32) && (data))
+        {
+          GdkNativeWindow window = *(GdkNativeWindow *) data;
+
+          if (window != None)
+            {
+              ret = gdk_window_foreign_new_for_display (screen_x11->display,
+                                                        *(GdkNativeWindow *) data);
+            }
+        }
+    }
+
+  if (type_return != None)
+    XFree (data);
+
+  return ret;
+}
+
+/**
+ * gdk_screen_get_window_stack
+ * @screen: a #GdkScreen
+ *
+ * Returns a list of #GdkWindow wrappers representing the current window stack.
+ * On X11, this is done by inspecting the _NET_CLIENT_LIST_STACKING property on
+ * the root window. If the window manager does not support the
+ * _NET_CLIENT_LIST_STACKING hint, this function returns NULL.
+ *
+ * Return value: a list of #GdkWindow wrappers for the current window stack,
+ * or %NULL.
+ */
+GList *
+gdk_screen_get_window_stack (GdkScreen *screen)
+{
+  GdkScreenX11 *screen_x11;
+  GList *ret = NULL;
+  Atom type_return;
+  gint format_return;
+  gulong nitems_return;
+  gulong bytes_after_return;
+  guchar *data;
+
+  if (!gdk_x11_screen_supports_net_wm_hint (screen,
+                                            gdk_atom_intern ("_NET_CLIENT_LIST_STACKING", FALSE)))
+    return NULL;
+
+  screen_x11 = GDK_SCREEN_X11 (screen);
+
+  if (XGetWindowProperty (screen_x11->xdisplay, screen_x11->xroot_window,
+	                  gdk_x11_get_xatom_by_name_for_display (screen_x11->display,
+			                                         "_NET_CLIENT_LIST_STACKING"),
+		          0, G_MAXLONG, False, XA_WINDOW, &type_return,
+		          &format_return, &nitems_return,
+                          &bytes_after_return, &data)
+      == Success)
+    {
+      if ((type_return == XA_WINDOW) && (format_return == 32) &&
+          (data) && (nitems_return > 0))
+        {
+          GdkNativeWindow *stack;
+          GdkWindow *win;
+          int i;
+
+          stack = (GdkNativeWindow *) data;
+
+          for (i = 0; i < nitems_return; i++)
+            {
+              win = gdk_window_foreign_new_for_display (screen_x11->display, stack[i]);
+
+              if (win != NULL)
+                ret = g_list_append (ret, win);
+            }
+
+        }
+    }
+
+  if (type_return != None)
+    XFree (data);
+
+  return ret;
+}
--- gtk+/gdk/x11/gdkvisual-x11.c	(.../2.6.4)	(revision 904)
+++ gtk+/gdk/x11/gdkvisual-x11.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -62,19 +62,6 @@
 
 #endif /* G_ENABLE_DEBUG */
 
-static void
-gdk_visual_finalize (GObject *object)
-{
-  g_error ("A GdkVisual object was finalized. This should not happen");
-}
-
-static void
-gdk_visual_class_init (GObjectClass *class)
-{
-  class->finalize = gdk_visual_finalize;
-}
-
-
 GType
 gdk_visual_get_type (void)
 {
@@ -87,7 +74,7 @@
         sizeof (GdkVisualClass),
         (GBaseInitFunc) NULL,
         (GBaseFinalizeFunc) NULL,
-        (GClassInitFunc) gdk_visual_class_init,
+        (GClassInitFunc) NULL,
         NULL,           /* class_finalize */
         NULL,           /* class_data */
         sizeof (GdkVisualPrivate),
@@ -593,7 +580,7 @@
   
   if (!screen_x11->visual_hash)
     screen_x11->visual_hash = g_hash_table_new ((GHashFunc) gdk_visual_hash,
-						 (GEqualFunc) gdk_visual_equal);
+                                                (GEqualFunc) gdk_visual_equal);
 
   g_hash_table_insert (screen_x11->visual_hash, private->xvisual, visual);
 }
--- gtk+/gdk/x11/gdkevents-x11.c	(.../2.6.4)	(revision 904)
+++ gtk+/gdk/x11/gdkevents-x11.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -192,8 +192,11 @@
 {
   GdkScreenX11 *screen_x11 = GDK_SCREEN_X11 (screen);
 
-  xsettings_client_destroy (screen_x11->xsettings_client);
-  screen_x11->xsettings_client = NULL;
+  if (screen_x11->xsettings_client)
+    {
+      xsettings_client_destroy (screen_x11->xsettings_client);
+      screen_x11->xsettings_client = NULL;
+    }
 }
 
 void 
--- gtk+/gdk/x11/gdkwindow-x11.c	(.../2.6.4)	(revision 904)
+++ gtk+/gdk/x11/gdkwindow-x11.c	(.../2.6.4-1.osso62)	(revision 904)
@@ -1286,6 +1286,7 @@
   GdkToplevelX11 *toplevel;
   Atom atoms[7];
   gint i;
+  gint propmode;
 
   private = (GdkWindowObject*) window;
   toplevel = _gdk_x11_window_get_toplevel (window);
@@ -1295,6 +1296,12 @@
 
   update_wm_hints (window, TRUE);
   
+  /* If the window has _NET_WM_STATE key specified, use it as the property mode */
+  propmode = (gint)g_object_get_data (G_OBJECT (window), "_NET_WM_STATE");
+
+  if (!propmode) 
+    propmode = PropModeReplace;
+
   /* We set the spec hints regardless of whether the spec is supported,
    * since it can't hurt and it's kind of expensive to check whether
    * it's supported.
@@ -1366,10 +1373,11 @@
       XChangeProperty (xdisplay,
                        xwindow,
 		       gdk_x11_get_xatom_by_name_for_display (display, "_NET_WM_STATE"),
-                       XA_ATOM, 32, PropModeReplace,
+                       XA_ATOM, 32, propmode,
                        (guchar*) atoms, i);
-    }
-  else 
+    } 
+  /* Don't delete the property, unless we are replacing it */
+  else if (propmode == PropModeReplace )
     {
       XDeleteProperty (xdisplay,
                        xwindow,
@@ -2194,6 +2202,9 @@
     case GDK_WINDOW_TYPE_HINT_DESKTOP:
       atom = gdk_x11_get_xatom_by_name_for_display (display, "_NET_WM_WINDOW_TYPE_DESKTOP");
       break;
+    case GDK_WINDOW_TYPE_HINT_MESSAGE:
+      atom = gdk_x11_get_xatom_by_name_for_display (display, "_MB_WM_WINDOW_TYPE_MESSAGE");
+      break;
     default:
       g_warning ("Unknown hint %d passed to gdk_window_set_type_hint", hint);
       /* Fall thru */
@@ -2208,6 +2219,68 @@
 		   (guchar *)&atom, 1);
 }
 
+/**
+ * gdk_window_get_type_hint:
+ * @window: A toplevel #GdkWindow
+ *
+ * This function returns the type hint set for a window.
+ *
+ * Return value: The type hint set for @window
+ **/
+GdkWindowTypeHint
+gdk_window_get_type_hint (GdkWindow *window)
+{
+  GdkDisplay *display;
+  GdkWindowTypeHint type;
+  Atom type_return;
+  gint format_return;
+  gulong nitems_return;
+  gulong bytes_after_return;
+  guchar *data = NULL;
+
+  g_return_val_if_fail (window != NULL, GDK_WINDOW_TYPE_HINT_NORMAL);
+  g_return_val_if_fail (GDK_IS_WINDOW (window), GDK_WINDOW_TYPE_HINT_NORMAL);
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return GDK_WINDOW_TYPE_HINT_NORMAL;
+
+  type = GDK_WINDOW_TYPE_HINT_NORMAL;
+
+  display = gdk_drawable_get_display (window);
+
+  XGetWindowProperty (GDK_DISPLAY_XDISPLAY (display), GDK_WINDOW_XID (window),
+		      gdk_x11_get_xatom_by_name_for_display (display, "_NET_WM_WINDOW_TYPE"),
+                      0, G_MAXLONG, False, XA_ATOM, &type_return,
+                      &format_return, &nitems_return, &bytes_after_return, &data);
+
+  if ((type_return == XA_ATOM) && (format_return == 32) &&
+      (data) && (nitems_return == 1))
+    {
+      Atom atom = (Atom) *data;
+
+      if (atom == gdk_x11_get_xatom_by_name_for_display (display, "_NET_WM_WINDOW_TYPE_DIALOG"))
+        type = GDK_WINDOW_TYPE_HINT_DIALOG;
+      else if (atom == gdk_x11_get_xatom_by_name_for_display (display, "_NET_WM_WINDOW_TYPE_MENU"))
+        type = GDK_WINDOW_TYPE_HINT_MENU;
+      else if (atom == gdk_x11_get_xatom_by_name_for_display (display, "_NET_WM_WINDOW_TYPE_TOOLBAR"))
+        type = GDK_WINDOW_TYPE_HINT_TOOLBAR;
+      else if (atom == gdk_x11_get_xatom_by_name_for_display (display, "_NET_WM_WINDOW_TYPE_UTILITY"))
+        type = GDK_WINDOW_TYPE_HINT_UTILITY;
+      else if (atom == gdk_x11_get_xatom_by_name_for_display (display, "_NET_WM_WINDOW_TYPE_SPLASH"))
+        type = GDK_WINDOW_TYPE_HINT_SPLASHSCREEN;
+      else if (atom == gdk_x11_get_xatom_by_name_for_display (display, "_NET_WM_WINDOW_TYPE_DOCK"))
+        type = GDK_WINDOW_TYPE_HINT_DOCK;
+      else if (atom == gdk_x11_get_xatom_by_name_for_display (display, "_NET_WM_WINDOW_TYPE_DESKTOP"))
+        type = GDK_WINDOW_TYPE_HINT_DESKTOP;
+      else if (atom == gdk_x11_get_xatom_by_name_for_display (display, "_MB_WM_WINDOW_TYPE_MESSAGE"))
+        type = GDK_WINDOW_TYPE_HINT_MESSAGE;
+    }
+
+  if (type_return != None)
+    XFree (data);
+
+  return type;
+}
 
 static void
 gdk_wmspec_change_state (gboolean   add,
