--- gtk+-2.6.4/gdk/x11/gdkscreen-x11.c	2005-02-01 20:07:39.000000000 +0200
+++ gtk+-2.6.4/gdk/x11/gdkscreen-x11.c	2005-06-27 13:41:41.132860000 +0300
@@ -34,6 +34,8 @@
 #include "gdkdisplay-x11.h"
 #include "gdkx.h"
 
+#include <X11/Xatom.h>
+
 #ifdef HAVE_SOLARIS_XINERAMA
 #include <X11/extensions/xinerama.h>
 #endif
@@ -286,44 +288,55 @@
 
   _gdk_x11_events_uninit_screen (GDK_SCREEN (object));
 
-  g_object_unref (screen_x11->default_colormap);
-  screen_x11->default_colormap = NULL;
-  
-  screen_x11->root_window = NULL;
+  if (screen_x11->default_colormap)
+    {
+      g_object_unref (screen_x11->default_colormap);
+      screen_x11->default_colormap = NULL;
+    }
+
+  if (screen_x11->system_colormap)
+    {
+      g_object_unref (screen_x11->system_colormap);
+      screen_x11->system_colormap = NULL;
+    }
+
+  if (screen_x11->root_window)
+    _gdk_window_destroy (screen_x11->root_window, TRUE);
+
+  G_OBJECT_CLASS (parent_class)->dispose (object);
 
   screen_x11->xdisplay = NULL;
   screen_x11->xscreen = NULL;
   screen_x11->screen_num = -1;
   screen_x11->xroot_window = None;
   screen_x11->wmspec_check_window = None;
-  
-  G_OBJECT_CLASS (parent_class)->dispose (object);
+
 }
 
 static void
 gdk_screen_x11_finalize (GObject *object)
 {
   GdkScreenX11 *screen_x11 = GDK_SCREEN_X11 (object);
-  /* int i; */
-  g_object_unref (screen_x11->root_window);
+  gint          i;
+
+  if (screen_x11->root_window)
+    g_object_unref (screen_x11->root_window);
 
   if (screen_x11->renderer)
     g_object_unref (screen_x11->renderer);
-  
-  /* Visual Part (Need to implement finalize for Visuals for a clean
-   * finalize) */
-  /* for (i=0;i<screen_x11->nvisuals;i++)
-    g_object_unref (screen_x11->visuals[i]);*/
+
+  /* Visual Part */
+  for (i = 0;i < screen_x11->nvisuals; i++)
+    g_object_unref (screen_x11->visuals[i]);
   g_free (screen_x11->visuals);
   g_hash_table_destroy (screen_x11->visual_hash);
 
   g_free (screen_x11->window_manager_name);  
 
   g_hash_table_destroy (screen_x11->colormap_hash);
-  /* X settings */
-  g_free (screen_x11->xsettings_client);
+
   g_free (screen_x11->monitors);
-  
+
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
 
@@ -710,3 +723,122 @@
   return _gdk_windowing_substitute_screen_number (old_display, 
 						  gdk_screen_get_number (screen));
 }
+
+/**
+ * gdk_screen_get_active_window
+ * @screen: a #GdkScreen
+ *
+ * Returns a pointer to the screen's currently active window. On X11,
+ * this is done by inspecting the _NET_ACTIVE_WINDOW property on the root
+ * window. If there is no currently currently active window, or the window
+ * manager does not support the _NET_ACTIVE_WINDOW hint, this function
+ * returns NULL.
+ *
+ * Return value: a #GdkWindow wrapper for the currently active window,
+ * or %NULL.
+ */
+GdkWindow *
+gdk_screen_get_active_window (GdkScreen *screen)
+{
+  GdkScreenX11 *screen_x11;
+  GdkWindow *ret = NULL;
+  Atom type_return;
+  gint format_return;
+  gulong nitems_return;
+  gulong bytes_after_return;
+  guchar *data;
+
+  if (!gdk_x11_screen_supports_net_wm_hint (screen,
+                                            gdk_atom_intern ("_NET_ACTIVE_WINDOW", FALSE)))
+    return NULL;
+
+  screen_x11 = GDK_SCREEN_X11 (screen);
+
+  if (XGetWindowProperty (screen_x11->xdisplay, screen_x11->xroot_window,
+	                  gdk_x11_get_xatom_by_name_for_display (screen_x11->display,
+			                                         "_NET_ACTIVE_WINDOW"),
+		          0, 1, False, XA_WINDOW, &type_return,
+		          &format_return, &nitems_return,
+                          &bytes_after_return, &data)
+      == Success)
+    {
+      if ((type_return == XA_WINDOW) && (format_return == 32) && (data))
+        {
+          GdkNativeWindow window = *(GdkNativeWindow *) data;
+
+          if (window != None)
+            {
+              ret = gdk_window_foreign_new_for_display (screen_x11->display,
+                                                        *(GdkNativeWindow *) data);
+            }
+        }
+    }
+
+  if (type_return != None)
+    XFree (data);
+
+  return ret;
+}
+
+/**
+ * gdk_screen_get_window_stack
+ * @screen: a #GdkScreen
+ *
+ * Returns a list of #GdkWindow wrappers representing the current window stack.
+ * On X11, this is done by inspecting the _NET_CLIENT_LIST_STACKING property on
+ * the root window. If the window manager does not support the
+ * _NET_CLIENT_LIST_STACKING hint, this function returns NULL.
+ *
+ * Return value: a list of #GdkWindow wrappers for the current window stack,
+ * or %NULL.
+ */
+GList *
+gdk_screen_get_window_stack (GdkScreen *screen)
+{
+  GdkScreenX11 *screen_x11;
+  GList *ret = NULL;
+  Atom type_return;
+  gint format_return;
+  gulong nitems_return;
+  gulong bytes_after_return;
+  guchar *data;
+
+  if (!gdk_x11_screen_supports_net_wm_hint (screen,
+                                            gdk_atom_intern ("_NET_CLIENT_LIST_STACKING", FALSE)))
+    return NULL;
+
+  screen_x11 = GDK_SCREEN_X11 (screen);
+
+  if (XGetWindowProperty (screen_x11->xdisplay, screen_x11->xroot_window,
+	                  gdk_x11_get_xatom_by_name_for_display (screen_x11->display,
+			                                         "_NET_CLIENT_LIST_STACKING"),
+		          0, G_MAXLONG, False, XA_WINDOW, &type_return,
+		          &format_return, &nitems_return,
+                          &bytes_after_return, &data)
+      == Success)
+    {
+      if ((type_return == XA_WINDOW) && (format_return == 32) &&
+          (data) && (nitems_return > 0))
+        {
+          GdkNativeWindow *stack;
+          GdkWindow *win;
+          int i;
+
+          stack = (GdkNativeWindow *) data;
+
+          for (i = 0; i < nitems_return; i++)
+            {
+              win = gdk_window_foreign_new_for_display (screen_x11->display, stack[i]);
+
+              if (win != NULL)
+                ret = g_list_append (ret, win);
+            }
+
+        }
+    }
+
+  if (type_return != None)
+    XFree (data);
+
+  return ret;
+}
