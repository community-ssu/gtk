--- gtk+-2.6.4/gtk/gtkdialog.c	2005-01-20 21:52:15.000000000 +0200
+++ gtk+-2.6.4/gtk/gtkdialog.c	2005-06-27 13:41:43.367520280 +0300
@@ -24,6 +24,9 @@
  * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
  */
 
+/* Modified by Nokia Corporation - 2005.
+ * 
+ */
 #include <config.h>
 #include "gtkalias.h"
 #include "gtkbutton.h"
@@ -37,11 +40,14 @@
 #include "gtkmain.h"
 #include "gtkintl.h"
 #include "gtkbindings.h"
+#include "gtkalignment.h"
 
 #define GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GTK_TYPE_DIALOG, GtkDialogPrivate))
 
 typedef struct {
   guint ignore_separator : 1;
+  GtkWidget *first;
+  GtkWidget *last;
 } GtkDialogPrivate;
 
 typedef struct _ResponseData ResponseData;
@@ -77,8 +83,14 @@
 static void gtk_dialog_close             (GtkDialog        *dialog);
 
 static ResponseData* get_response_data   (GtkWidget        *widget,
-					  gboolean          create);
+                                          gboolean          create);
+
+static gboolean gtk_dialog_handle_focus (GtkWidget *widget,
+                                         GtkDirectionType dir,
+                                         gpointer user_data);
 
+static gboolean gtk_dialog_move_to_next_active_button (GList *iter,
+                                                       gboolean forward);
 enum {
   PROP_0,
   PROP_HAS_SEPARATOR
@@ -178,6 +190,14 @@
                                                              2,
                                                              G_PARAM_READABLE));
   gtk_widget_class_install_style_property (widget_class,
+					   g_param_spec_int ("content_area_spacing",
+                                                             P_("Content area spacing"),
+                                                             P_("Spacing between elements of the main dialog area"),
+                                                             0,
+                                                             G_MAXINT,
+                                                             0,
+                                                             G_PARAM_READABLE));
+  gtk_widget_class_install_style_property (widget_class,
                                            g_param_spec_int ("button_spacing",
                                                              P_("Button spacing"),
                                                              P_("Spacing between buttons"),
@@ -195,6 +215,23 @@
                                                              5,
                                                              G_PARAM_READABLE));
 
+  gtk_widget_class_install_style_property (widget_class,
+                                           g_param_spec_int ("extended_left_border",
+                                                             _("Content area extra left border"),
+                                                             _("Width of extra left border around the main dialog area"),
+                                                             0,
+                                                             G_MAXINT,
+                                                             0,
+                                                             G_PARAM_READABLE));
+  gtk_widget_class_install_style_property (widget_class,
+                                           g_param_spec_int ("extended_right_border",
+                                                             _("Content area extra right border"),
+                                                             _("Width of extra right border around the main dialog area"),
+                                                             0,
+                                                             G_MAXINT,
+                                                             0,
+                                                             G_PARAM_READABLE));
+
   binding_set = gtk_binding_set_by_class (class);
   
   gtk_binding_entry_add_signal (binding_set, GDK_Escape, 0,
@@ -205,33 +242,72 @@
 update_spacings (GtkDialog *dialog)
 {
   GtkWidget *widget;
+  GtkWidget *hbox;
+  GtkWidget *left_padding;
+  GtkWidget *right_padding;
   gint content_area_border;
+  gint content_area_spacing;
   gint button_spacing;
   gint action_area_border;
+
+	gint extended_left_border;
+  gint extended_right_border;
   
   widget = GTK_WIDGET (dialog);
 
   gtk_widget_style_get (widget,
                         "content_area_border",
                         &content_area_border,
+                        "content_area_spacing",
+                        &content_area_spacing,
                         "button_spacing",
                         &button_spacing,
                         "action_area_border",
                         &action_area_border,
+	"extended_left_border",
+	&extended_left_border,
+	"extended_right_border",
+	&extended_right_border,
                         NULL);
 
+  gtk_box_set_spacing (GTK_BOX (dialog->vbox),
+                       content_area_spacing);
   gtk_container_set_border_width (GTK_CONTAINER (dialog->vbox),
                                   content_area_border);
   gtk_box_set_spacing (GTK_BOX (dialog->action_area),
                        button_spacing);
   gtk_container_set_border_width (GTK_CONTAINER (dialog->action_area),
                                   action_area_border);
+
+  if ((extended_left_border == 0) && (extended_right_border == 0))
+    /* no extended borders, so we are done */
+    return;
+
+  /* extended borders are in use, so reconstruct dialog */
+  hbox = gtk_hbox_new(FALSE, 0);
+  left_padding = gtk_alignment_new(0.0, 0.0, 0.0, 0.0);
+  right_padding = gtk_alignment_new(0.0, 0.0, 0.0, 0.0);
+  gtk_widget_set_size_request(left_padding, extended_left_border, 0);
+  gtk_widget_set_size_request(right_padding, extended_right_border, 0);
+
+  gtk_widget_ref(dialog->vbox);
+  gtk_container_remove(GTK_CONTAINER(dialog), dialog->vbox);
+  gtk_container_add(GTK_CONTAINER(hbox), left_padding);
+  gtk_container_add(GTK_CONTAINER(hbox), dialog->vbox);
+  gtk_container_add(GTK_CONTAINER(hbox), right_padding);
+  gtk_container_add(GTK_CONTAINER(dialog), hbox);
+  gtk_widget_unref(dialog->vbox);
+
+  gtk_widget_show(left_padding);
+  gtk_widget_show(right_padding);
+  gtk_widget_show(hbox);
 }
 
 static void
 gtk_dialog_init (GtkDialog *dialog)
 {
   GtkDialogPrivate *priv;
+  GtkWidget *alignment;
 
   priv = GET_PRIVATE (dialog);
   priv->ignore_separator = FALSE;
@@ -250,14 +326,23 @@
   gtk_container_add (GTK_CONTAINER (dialog), dialog->vbox);
   gtk_widget_show (dialog->vbox);
 
+  /* Hildon : Here we add an alignment widget to gtk because
+   * we want that the dialog buttons are all centered. */
+  alignment = gtk_alignment_new (0.5, 0.5, 0, 0);
+  gtk_box_pack_end (GTK_BOX (dialog->vbox), alignment, FALSE, TRUE, 0);
+
   dialog->action_area = gtk_hbutton_box_new ();
 
   gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog->action_area),
                              GTK_BUTTONBOX_END);  
 
-  gtk_box_pack_end (GTK_BOX (dialog->vbox), dialog->action_area,
-                    FALSE, TRUE, 0);
+  /* we need add-signal to allocate correct area for childs */ 
+  gtk_container_add (GTK_CONTAINER (alignment), dialog->action_area);
+  /* gtk_box_pack_end (GTK_BOX (dialog->vbox), dialog->action_area,
+     FALSE, TRUE, 0); */
+  
   gtk_widget_show (dialog->action_area);
+  gtk_widget_show (alignment);
 
   dialog->separator = gtk_hseparator_new ();
   gtk_box_pack_end (GTK_BOX (dialog->vbox), dialog->separator, FALSE, TRUE, 0);
@@ -616,9 +701,10 @@
   else
     g_warning ("Only 'activatable' widgets can be packed into the action area of a GtkDialog");
 
-  gtk_box_pack_end (GTK_BOX (dialog->action_area),
-                    child,
-                    FALSE, TRUE, 0);
+  gtk_container_add(GTK_CONTAINER(dialog->action_area), child);
+
+  g_signal_connect (child, "focus", 
+                    (GCallback)gtk_dialog_handle_focus, (gpointer)dialog);
   
   if (response_id == GTK_RESPONSE_HELP)
     gtk_button_box_set_child_secondary (GTK_BUTTON_BOX (dialog->action_area), child, TRUE);
@@ -637,7 +723,7 @@
  * you don't need it.
  *
  * Return value: the button widget that was added
- **/
+ **/ 
 GtkWidget*
 gtk_dialog_add_button (GtkDialog   *dialog,
                        const gchar *button_text,
@@ -653,7 +739,7 @@
   GTK_WIDGET_SET_FLAGS (button, GTK_CAN_DEFAULT);
   
   gtk_widget_show (button);
-  
+
   gtk_dialog_add_action_widget (dialog,
                                 button,
                                 response_id);
@@ -1001,7 +1087,7 @@
 
   if (!GTK_WIDGET_VISIBLE (dialog))
     gtk_widget_show (GTK_WIDGET (dialog));
-  
+
   response_handler =
     g_signal_connect (dialog,
                       "response",
@@ -1227,13 +1313,116 @@
 
   screen = gtk_widget_get_screen (GTK_WIDGET (dialog));
   if (!gtk_alternative_dialog_button_order (screen))
-      return;
+    return;
 
   for (position = 0; position < n_params; position++)
   {
-      /* reorder child with response_id to position */
-      child = dialog_find_button (dialog, new_order[position]);
-      gtk_box_reorder_child (GTK_BOX (dialog->action_area), child, position);
+    /* reorder child with response_id to position */
+    child = dialog_find_button (dialog, new_order[position]);
+    gtk_box_reorder_child (GTK_BOX (dialog->action_area), child, position);
+  }
+}
+
+static gboolean
+gtk_dialog_handle_focus (GtkWidget *widget,
+                          GtkDirectionType dir,
+                          gpointer user_data)
+{
+  GtkDialog *dialog = NULL;
+  GList *list = NULL;
+  GList *iter = NULL;
+  gint i = 0;
+  gint list_length = 0;
+  gboolean ret_val = FALSE;
+  GtkDialogPrivate *priv;
+
+  dialog = GTK_DIALOG(user_data);
+  list = gtk_container_get_children (GTK_CONTAINER(
+                                      GTK_DIALOG(user_data)->action_area));
+  iter = list;
+  priv = GET_PRIVATE (dialog);
+
+  if (GTK_WIDGET_HAS_FOCUS (widget))
+  {
+    list_length =  g_list_length(list);
+    while (iter != NULL)
+    {
+      ++i;
+      if (iter->data == widget)
+      {
+        switch (dir) {
+          case GTK_DIR_UP:
+          case GTK_DIR_LEFT:
+
+                /* If not in the first button, but in the first active
+                 * button, the default should do, else handle movement
+                 * by yourself
+                 */
+             ret_val = gtk_dialog_move_to_next_active_button (
+                        g_list_previous (iter),
+                        FALSE);
+            
+             if (!ret_val)
+                {
+                  g_signal_emit_by_name (dialog, "move-focus",
+                            GTK_DIR_TAB_BACKWARD);
+                  ret_val = TRUE;
+                }
+             break;
+
+          /* If in the last item:jump to top, else select previous button */
+          case GTK_DIR_DOWN:
+          case GTK_DIR_RIGHT:
+            ret_val = gtk_dialog_move_to_next_active_button (
+                                            g_list_next (iter),
+                                            TRUE);
+            
+            if (!ret_val)
+              {
+                g_signal_emit_by_name (dialog, "move-focus", 
+                        GTK_DIR_TAB_FORWARD);
+                ret_val = TRUE;
+              }
+            break;
+
+          case GTK_DIR_TAB_BACKWARD:
+          case GTK_DIR_TAB_FORWARD:
+          default:
+            break;
+        }
+        break;
+      }
+      iter = g_list_next(iter);
+    }
+  }
+
+  g_list_free (list);
+
+  return ret_val;
+}
+
+static gboolean
+gtk_dialog_move_to_next_active_button (GList *iter, gboolean forward)
+{
+    gboolean active;
+    gboolean visible;
+
+    while (iter)
+    {
+        g_object_get (G_OBJECT (iter->data), "sensitive", &active, NULL);
+        g_object_get (G_OBJECT (iter->data), "visible", &visible, NULL);
+        if (active && visible)
+        {
+            gtk_widget_grab_focus (GTK_WIDGET (iter->data));
+            return TRUE;
+        }
+
+        if (forward)
+            iter = g_list_next (iter);
+        else
+            iter = g_list_previous (iter);
     }
+
+    return FALSE;
 }
 
