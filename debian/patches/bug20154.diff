--- gtk+/gdk-pixbuf/ChangeLog	(.../2.6.4-1.osso69)	(revision 1056)
+++ gtk+/gdk-pixbuf/ChangeLog	(.../2.6.4-1.osso70)	(revision 1056)
@@ -1,3 +1,10 @@
+2005-10-03  Tommi Komulainen  <tommi.komulainen@nokia.com>
+
+	* io-jpeg.c (gdk_pixbuf__jpeg_image_load_increment): Use buffered mode
+	only with progressive images to avoid excessive memory consumption; it
+	makes no difference to disable it for progressive images.
+	N#20154
+
 2005-09-01  Tommi Komulainen  <tommi.komulainen@nokia.com>
 
 	Merge patches by Matthias Clasen and Manish Singh from GNOME CVS:
--- gtk+/gdk-pixbuf/io-jpeg.c	(.../2.6.4-1.osso69)	(revision 1056)
+++ gtk+/gdk-pixbuf/io-jpeg.c	(.../2.6.4-1.osso70)	(revision 1056)
@@ -692,7 +692,7 @@
 			int rc;			
 			
 			/* start decompression */
-			cinfo->buffered_image = TRUE;
+			cinfo->buffered_image = cinfo->progressive_mode;
 			rc = jpeg_start_decompress (cinfo);
 			cinfo->do_fancy_upsampling = FALSE;
 			cinfo->do_block_smoothing = FALSE;
@@ -701,8 +701,68 @@
 				continue;
 
 			context->did_prescan = TRUE;
+		} else if (!cinfo->buffered_image) {
+			/* we're decompressing so feed jpeg lib scanlines */
+			/* except for handling multiple passes this is
+			 * virtually identical to the next branch */
+			guchar *lines[4];
+			guchar **lptr;
+			guchar *rowptr;
+			gint   nlines, i;
+
+			/* keep going until we've done all scanlines */
+			while (cinfo->output_scanline < cinfo->output_height) {
+				lptr = lines;
+				rowptr = context->dptr;
+				for (i=0; i < cinfo->rec_outbuf_height; i++) {
+					*lptr++ = rowptr;
+					rowptr += context->pixbuf->rowstride;
+				}
+				
+				nlines = jpeg_read_scanlines (cinfo, lines,
+							      cinfo->rec_outbuf_height);
+				if (nlines == 0)
+					break;
+
+				switch (cinfo->out_color_space) {
+				    case JCS_GRAYSCALE:
+					    explode_gray_into_buf (cinfo, lines);
+					    break;
+				    case JCS_RGB:
+					    /* do nothing */
+					    break;
+				    case JCS_CMYK:
+					    convert_cmyk_to_rgb (cinfo, lines);
+					    break;
+				    default:
+					    if (error && *error == NULL) {
+						    g_set_error (error,
+								 GDK_PIXBUF_ERROR,
+								 GDK_PIXBUF_ERROR_UNKNOWN_TYPE,
+								 _("Unsupported JPEG color space (%s)"),
+								 colorspace_name (cinfo->out_color_space)); 
+					    }
+					    
+					    return FALSE;
+				}
+
+				context->dptr += nlines * context->pixbuf->rowstride;
+				
+				/* send updated signal */
+				(* context->updated_func) (context->pixbuf,
+							   0, 
+							   cinfo->output_scanline-1,
+							   cinfo->image_width, 
+							   nlines,
+							   context->user_data);
+			}
+
+			if (cinfo->output_scanline >= cinfo->output_height)
+				return TRUE;
 		} else {
 			/* we're decompressing so feed jpeg lib scanlines */
+			/* except for handling multiple passes this is
+			 * virtually identical to the previous branch */
 			guchar *lines[4];
 			guchar **lptr;
 			guchar *rowptr;
