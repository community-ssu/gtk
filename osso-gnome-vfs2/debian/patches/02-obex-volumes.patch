Index: configure.in
===================================================================
--- configure.in	(revision 13394)
+++ configure.in	(working copy)
@@ -956,6 +956,12 @@
 PKG_CHECK_MODULES(LIBGNOMEVFSDAEMON, glib-2.0 $USE_HAL)
 AC_SUBST(LIBGNOMEVFSDAEMON_CFLAGS)
 AC_SUBST(LIBGNOMEVFSDAEMON_LIBS)
+
+dnl Bluetooth volume monitoring support, gwconnect
+PKG_CHECK_MODULES(GWCONNECT, gwconnect >= 0.95)
+AC_SUBST(GWCONNECT_CFLAGS)
+AC_SUBST(GWCONNECT_LIBS)
+
 					       	
 dnl ****************************
 dnl *** Checks for pty stuff ***
Index: libgnomevfs/Makefile.am
===================================================================
--- libgnomevfs/Makefile.am	(revision 13394)
+++ libgnomevfs/Makefile.am	(working copy)
@@ -14,6 +14,7 @@
 	$(MONIKERS_CFLAGS)			\
 	$(FNMATCH_CFLAGS)			\
 	$(LIBGNOMEVFS_IPC_CFLAGS)               \
+	$(GWCONNECT_CFLAGS)                     \
 	-DXDG_PREFIX=_gnome_vfs_xdg		\
 	-D_FILE_OFFSET_BITS=64			\
 	-D_BSD_SOURCE				\
@@ -132,6 +133,7 @@
 libgnomevfs_2_la_LIBADD =			\
 	$(LIBGNOMEVFS_LIBS)			\
 	$(LIBGNOMEVFS_IPC_LIBS)                 \
+	$(GWCONNECT_LIBS)			\
 	$(FNMATCH_LIBS)				\
 	$(SOCKET_LIBS)				\
 	$(INTLLIBS)				\
Index: libgnomevfs/gnome-vfs-volume-monitor-daemon.c
===================================================================
--- libgnomevfs/gnome-vfs-volume-monitor-daemon.c	(revision 13394)
+++ libgnomevfs/gnome-vfs-volume-monitor-daemon.c	(working copy)
@@ -38,6 +38,16 @@
 #include "gnome-vfs-hal-mounts.h"
 #endif /* USE_HAL */
 
+/* Enable btcond integration. */
+#define USE_BTCOND
+
+#ifdef USE_BTCOND
+static void obex_class_init    (void);
+static void obex_init          (GnomeVFSVolumeMonitorDaemon *daemon);
+static void obex_deinit        (GnomeVFSVolumeMonitorDaemon *daemon);
+static void obex_update_drives (GnomeVFSVolumeMonitorDaemon *daemon);
+#endif /* USE_BTCOND */
+
 static void gnome_vfs_volume_monitor_daemon_class_init (GnomeVFSVolumeMonitorDaemonClass *klass);
 static void gnome_vfs_volume_monitor_daemon_init       (GnomeVFSVolumeMonitorDaemon      *volume_monitor_daemon);
 static void gnome_vfs_volume_monitor_daemon_finalize   (GObject                          *object);
@@ -120,6 +130,10 @@
 	
 	/* GObject signals */
 	o_class->finalize = gnome_vfs_volume_monitor_daemon_finalize;
+
+#ifdef USE_BTCOND
+	obex_class_init ();
+#endif /* USE_BTCOND */
 }
 
 static void
@@ -188,6 +202,11 @@
 	
 	update_fstab_drives (volume_monitor_daemon);
 	update_mtab_volumes (volume_monitor_daemon);
+
+#ifdef USE_BTCOND
+	obex_init (volume_monitor_daemon);
+#endif /* USE_BTCOND */
+	
 	update_connected_servers (volume_monitor_daemon);
 }
 
@@ -205,6 +224,10 @@
 	update_fstab_drives (volume_monitor_daemon);
 	update_mtab_volumes (volume_monitor_daemon);
 	update_connected_servers (volume_monitor_daemon);
+
+#ifdef USE_BTCOND
+	obex_update_drives (volume_monitor_daemon);
+#endif /* USE_BTCOND */
 }
 
 /* Remeber that this could be running on a thread other
@@ -235,6 +258,10 @@
 	}
 #endif /* USE_HAL */
 
+#ifdef USE_BTCOND
+	obex_deinit (volume_monitor_daemon);
+#endif /* USE_BTCOND */
+	
 	g_object_unref (volume_monitor_daemon->gconf_client);
 	
 	if (G_OBJECT_CLASS (parent_class)->finalize)
@@ -1238,3 +1265,589 @@
 	volume_monitor_daemon->last_connected_servers = new_servers;
 }
 
+/************************* obex ***********************************/
+#ifdef USE_BTCOND
+
+#include <bt-dbus.h>
+#include <bt-gconf.h>
+
+#define d(x) 
+
+#define BTCOND_SIGNAL_RULE \
+  "type='signal',sender='" BTCOND_SERVICE "',interface='" BTCOND_SIG_INTERFACE "'"
+
+
+/* This D-BUS connection should only be touched from the main thread and the
+ * D-BUS signals we receive will be in the main thread as well.
+ */
+static DBusConnection *dbus_conn;
+
+
+typedef struct {
+	char *bda;   /* bluetooth address, without ':' */
+	char *uri;   /* obex://[<bda>]/ */
+} GnomeVFSObexDevice;
+
+static void              obex_devices_changed  (GConfClient                 *client,
+						guint                        cnxn_id,
+						GConfEntry                  *entry,
+						gpointer                     data);
+static DBusHandlerResult obex_dbus_filter_func (DBusConnection              *connection,
+						DBusMessage                 *message,
+						void                        *data);
+static void              obex_mount_bda        (GnomeVFSVolumeMonitor       *monitor,
+						const char                  *bda);
+static void              obex_unmount_bda      (GnomeVFSVolumeMonitor       *monitor,
+						const char                  *bda);
+
+
+static void
+obex_class_init (void)
+{
+	DBusError error;
+
+	dbus_error_init (&error);
+	dbus_conn = dbus_bus_get (DBUS_BUS_SYSTEM, &error);
+	if (dbus_error_is_set (&error)) {
+		g_warning ("Failed to open system DBUS connection: %s\n"
+			   "Volume monitoring for bluetooth devices will not work.",
+			   error.message);
+		dbus_error_free (&error);
+	} else {
+		dbus_bus_add_match (dbus_conn, BTCOND_SIGNAL_RULE, NULL);
+		
+		dbus_connection_add_filter (dbus_conn,
+					    obex_dbus_filter_func,
+					    NULL,
+					    NULL);
+		
+		dbus_connection_setup_with_g_main (dbus_conn, NULL);
+	}
+}
+
+static void
+obex_init (GnomeVFSVolumeMonitorDaemon *daemon)
+{
+	gconf_client_add_dir (daemon->gconf_client,
+			      BTCOND_GCONF_PATH,
+			      GCONF_CLIENT_PRELOAD_RECURSIVE,
+			      NULL);
+	
+	daemon->obex_devices_notify_id =
+		gconf_client_notify_add (daemon->gconf_client,
+					 BTCOND_GCONF_SELECTED,
+					 obex_devices_changed,
+					 daemon,
+					 NULL,
+					 NULL);
+	
+	obex_update_drives (daemon);
+}
+
+static void
+obex_deinit (GnomeVFSVolumeMonitorDaemon *daemon)
+{
+	gconf_client_notify_remove (daemon->gconf_client,
+				    daemon->obex_devices_notify_id);
+}
+
+/* This is called from the main thread. */
+static DBusHandlerResult
+obex_dbus_filter_func (DBusConnection *connection,
+		       DBusMessage    *message,
+		       void           *data)
+{
+	GnomeVFSVolumeMonitor *monitor;
+	char                  *bda;
+	char                  *state;
+
+	monitor = gnome_vfs_get_volume_monitor ();
+	
+	if (dbus_message_is_signal (message,
+				    BTCOND_SIG_INTERFACE,
+				    BTCOND_CONNECTION_STATUS_SIG)) {
+		if (dbus_message_get_args (message, NULL,
+					   DBUS_TYPE_STRING, &bda,
+					   DBUS_TYPE_STRING, &state,
+					   DBUS_TYPE_INVALID)) {
+			if (strcmp (state, "connected") == 0) {
+				obex_mount_bda (monitor, bda);
+			}
+			else if (strcmp (state, "disconnected") == 0) {
+				/* We don't do anything here. We unmount on
+				 * connect_failed instead since that gives a
+				 * better behavior.
+				 */
+			}
+			else if (strcmp (state, "bt_disabled") == 0) {
+				obex_unmount_bda (monitor, bda);
+			}
+		}
+	}
+	else if (dbus_message_is_signal (message,
+					 BTCOND_SIG_INTERFACE,
+					 BTCOND_CONNECT_FAILED_SIG)) {
+		if (dbus_message_get_args (message, NULL,
+					   DBUS_TYPE_STRING, &bda,
+					   DBUS_TYPE_INVALID)) {
+			obex_unmount_bda (monitor, bda);
+		}
+	}
+	
+	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+}
+
+static void
+obex_devices_changed (GConfClient *client,
+		      guint        cnxn_id,
+		      GConfEntry  *entry,
+		      gpointer     data)
+{
+	GnomeVFSVolumeMonitorDaemon *daemon;
+
+	daemon = data;
+	obex_update_drives (daemon);
+}
+
+static void
+obex_device_free (GnomeVFSObexDevice *device)
+{
+	g_free (device->bda);
+	g_free (device->uri);
+
+	g_free (device);
+}
+
+static int
+obex_device_compare (GnomeVFSObexDevice *a,
+		     GnomeVFSObexDevice *b)
+{
+	int res;
+
+	res = strcmp (a->bda, b->bda);
+	if (res != 0) {
+		return res;
+	}
+
+	return 0;
+}
+
+static char *
+obex_uri_from_bda (const char *bda)
+{
+	return g_strdup_printf ("obex://[%s]/", bda);
+}
+
+/* Must be called from the main thread only. */
+static gboolean
+obex_bda_has_ftp (const char *bda)
+{
+	DBusMessage  *message;
+	DBusMessage  *reply;
+	DBusError     error;
+	gchar       **array;
+	gint          i, len;
+	gboolean      ret;
+
+	if (!dbus_conn) {
+		return FALSE;
+	}
+	
+	message = dbus_message_new_method_call (BTCOND_SERVICE,
+						BTCOND_REQ_PATH,
+						BTCOND_REQ_INTERFACE,
+						BTCOND_DEV_CAPABILITY_REQ);
+	if (!message) {
+		g_error ("Out of memory");
+	}
+	
+	if (!dbus_message_append_args (message,
+				       DBUS_TYPE_STRING, &bda,
+				       DBUS_TYPE_INVALID)) {
+		g_error ("Out of memory");
+	}
+
+	dbus_error_init (&error);
+	reply = dbus_connection_send_with_reply_and_block (dbus_conn, message, -1, &error);
+	
+	dbus_message_unref (message);
+
+	if (dbus_error_is_set (&error)) {
+		if (strcmp (error.name, BTCOND_ERROR_DISCONNECTED) == 0) {
+			d(g_printerr ("daemon: Dev not connected.\n"));
+		}
+		else if (strcmp (error.name, BTCOND_ERROR_NO_DEV_INFO) == 0) {
+			d(g_printerr ("daemon: No dev info.\n"));
+		}
+		else if (strcmp (error.name, BTCOND_ERROR_INVALID_DEV) == 0) {
+			d(g_printerr ("daemon: Invalid BDA.\n"));
+		}
+		else if (strcmp (error.name, BTCOND_ERROR_INVALID_SVC) == 0) {
+			d(g_printerr ("daemon: Invalid SDP profile.\n"));
+		}
+		else if (strcmp (error.name, DBUS_ERROR_NAME_HAS_NO_OWNER) == 0 ||
+			 strcmp (error.name, DBUS_ERROR_SERVICE_UNKNOWN) == 0) {
+			g_printerr ("daemon: btcond is not running.\n");
+		} else {
+			d(g_printerr ("daemon: %s\n", error.name));
+		}
+		
+		dbus_error_free (&error);
+		return FALSE;
+	}
+	
+	if (!reply) {
+		d(g_printerr ("No reply from btcond.\n"));
+		return FALSE;
+	}
+	
+	array = NULL;
+	
+	if (!dbus_message_get_args (reply,
+				    NULL,
+				    DBUS_TYPE_ARRAY, DBUS_TYPE_STRING,
+				    &array,
+				    &len,
+				    DBUS_TYPE_INVALID)) {
+		dbus_message_unref (reply);
+		return FALSE;
+	}
+	
+	ret = FALSE;
+	for (i = 0; i < len; i++) {
+		if (g_ascii_strcasecmp (array[i], "FTP") || 
+		    g_ascii_strcasecmp (array[i], "NFTP")) {
+			ret = TRUE;
+			break;
+		}
+	}
+		
+	dbus_free_string_array (array);
+
+	return ret;
+}
+
+static gboolean
+obex_bda_is_connected (const char *bda)
+{
+	DBusMessage *message;
+	DBusMessage *reply;
+	DBusError    error;
+	char        *status;
+	gboolean     ret;
+
+	if (!dbus_conn) {
+		return FALSE;
+	}
+
+	message = dbus_message_new_method_call (BTCOND_SERVICE,
+						BTCOND_REQ_PATH,
+						BTCOND_REQ_INTERFACE,
+						BTCOND_CONNECTION_STATUS_REQ);
+	if (!message) {
+		g_error ("Out of memory");
+	}
+
+	if (!dbus_message_append_args (message,
+				       DBUS_TYPE_STRING, &bda,
+				       DBUS_TYPE_INVALID)) {
+		g_error ("Out of memory");
+	}
+	
+	dbus_error_init (&error);
+	reply = dbus_connection_send_with_reply_and_block (dbus_conn, message, -1, &error);
+
+	dbus_message_unref (message);
+
+	if (dbus_error_is_set (&error)) {
+		if (strcmp (error.name, BTCOND_ERROR_DISCONNECTED) == 0) {
+			d(g_printerr ("daemon: Dev not connected.\n"));
+		}
+		else if (strcmp (error.name, BTCOND_ERROR_NO_DEV_INFO) == 0) {
+			d(g_printerr ("daemon: No dev info.\n"));
+		}
+		else if (strcmp (error.name, DBUS_ERROR_NAME_HAS_NO_OWNER) == 0 ||
+			 strcmp (error.name, DBUS_ERROR_SERVICE_UNKNOWN) == 0) {
+			g_printerr ("daemon: btcond is not running.\n");
+		} else {
+			d(g_printerr ("damon: %s\n", error.name));
+		}
+		
+		dbus_error_free (&error);
+		return FALSE;
+	}
+	
+	if (!reply) {
+		g_print ("daemon: No reply from btcond.\n");
+		return FALSE;
+	}
+
+	ret = dbus_message_get_args (reply, NULL,
+				     DBUS_TYPE_STRING, &status,
+				     DBUS_TYPE_INVALID);
+
+	dbus_message_unref (reply);
+	
+	if (!ret) {
+		/* OOM or invalid reply from btcond. */
+		return FALSE;
+	}
+
+	if (strcmp (status, "connected") == 0) {
+		ret = TRUE;
+	} else {
+		ret = FALSE;
+	}
+
+	return ret;
+}
+
+static GList *
+obex_get_devices (GnomeVFSVolumeMonitorDaemon *daemon)
+{
+	GSList             *strings, *l;
+	GList              *devices;
+	GnomeVFSObexDevice *device;
+
+	strings = gconf_client_get_list (daemon->gconf_client,
+					 BTCOND_GCONF_SELECTED,
+					 GCONF_VALUE_STRING,
+					 NULL);
+
+	devices = NULL;
+	for (l = strings; l; l = l->next) {
+		device = g_new0 (GnomeVFSObexDevice, 1);
+
+		device->bda = l->data; /* takes over ownership */
+		device->uri = obex_uri_from_bda (device->bda);
+		
+		devices = g_list_prepend (devices, device);
+	}
+
+	g_slist_free (strings);
+	
+	return devices;
+}
+
+static GnomeVFSDrive *
+obex_create_drive_from_device (GnomeVFSVolumeMonitor *volume_monitor,
+			       GnomeVFSObexDevice    *device)
+{
+	GnomeVFSDrive               *drive;
+	GnomeVFSVolume              *mounted_volume;
+	GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon;
+	char                        *path, *tmp;
+	
+	volume_monitor_daemon = GNOME_VFS_VOLUME_MONITOR_DAEMON (volume_monitor);
+
+	drive = g_object_new (GNOME_VFS_TYPE_DRIVE, NULL);
+
+	drive->priv->activation_uri = g_strdup (device->uri);
+	drive->priv->is_connected = 1;
+
+	drive->priv->device_type = GNOME_VFS_DEVICE_TYPE_BLUETOOTH;
+
+	/* Get icon and display name from gconf. */
+	path = GNOME_BT_DEV_ICON (device->bda);
+	tmp = gconf_client_get_string (volume_monitor_daemon->gconf_client,
+				       path,
+				       NULL);
+	g_free (path);
+
+	if (!tmp) {
+		tmp = g_strdup ("osso-gnome-dev-bluetooth");
+	}
+	
+	drive->priv->icon = tmp;
+
+	path = GNOME_BT_DEV_NAME (device->bda);
+	tmp = gconf_client_get_string (volume_monitor_daemon->gconf_client,
+				       path,
+				       NULL);
+	g_free (path);
+
+	if (!tmp) {
+		tmp = g_strdup ("Bluetooth");
+	}
+
+	drive->priv->display_name =
+		_gnome_vfs_volume_monitor_uniquify_drive_name (volume_monitor,
+							       tmp);
+
+	g_free (tmp);
+
+	drive->priv->is_user_visible = TRUE;
+	drive->priv->volumes = NULL;
+
+	/* Not a unix mount. */
+	drive->priv->is_vfs_drive = TRUE;
+
+	mounted_volume = _gnome_vfs_volume_monitor_find_vfs_volume_by_activation_uri (volume_monitor,
+										      device->uri);
+	
+	if (mounted_volume != NULL &&
+	    mounted_volume->priv->drive == NULL) {
+		drive->priv->volumes = g_list_append (drive->priv->volumes,
+						      gnome_vfs_volume_ref (mounted_volume));
+		_gnome_vfs_volume_set_drive (mounted_volume, drive);
+	}
+
+	return drive;
+}
+
+static GnomeVFSVolume *
+obex_create_volume_from_drive (GnomeVFSVolumeMonitor *volume_monitor,
+			       GnomeVFSDrive         *drive)
+{
+	GnomeVFSVolume *volume;
+	
+	volume = g_object_new (GNOME_VFS_TYPE_VOLUME, NULL);
+
+	volume->priv->volume_type = GNOME_VFS_VOLUME_TYPE_VFS_MOUNT;
+	volume->priv->device_type = GNOME_VFS_DEVICE_TYPE_OBEX_FTP;
+	volume->priv->activation_uri = g_strdup (drive->priv->activation_uri);
+	volume->priv->display_name = g_strdup (drive->priv->display_name);
+
+	volume->priv->icon = g_strdup ("osso-gnome-dev-obexftp");
+
+	volume->priv->is_mounted = 1;
+	volume->priv->is_user_visible = 1;
+
+	/* Note: the drive passed in to this function should be connected at
+	 * this point.
+	 */
+	if (g_list_find (drive->priv->volumes, volume) == NULL) {
+		volume->priv->drive = drive;
+		_gnome_vfs_drive_add_mounted_volume (drive, volume);
+	}
+
+	return volume;
+}
+
+static void
+obex_update_drives (GnomeVFSVolumeMonitorDaemon *daemon)
+{
+	GnomeVFSVolumeMonitor *volume_monitor;
+	GList                 *new_devices;
+	GList                 *removed, *added;
+	GnomeVFSObexDevice    *device;
+	GnomeVFSDrive         *drive;
+	GList                 *l;
+
+	volume_monitor = GNOME_VFS_VOLUME_MONITOR (daemon);
+
+	new_devices = obex_get_devices (daemon);
+	new_devices = g_list_sort (new_devices, (GCompareFunc) obex_device_compare);
+
+	diff_sorted_lists (daemon->last_obex_devices,
+			   new_devices, (GCompareFunc) obex_device_compare,
+			   &added, &removed);
+
+	for (l = removed; l != NULL; l = l->next) {
+		device = l->data;
+
+		drive = _gnome_vfs_volume_monitor_find_vfs_drive_by_activation_uri (volume_monitor,
+										    device->uri);
+
+		d(g_print ("Removing: %s (%p)\n", device->uri, drive));
+		
+		if (drive != NULL) {
+			_gnome_vfs_volume_monitor_disconnected (volume_monitor, drive);
+		}
+	}
+	
+	for (l = added; l != NULL; l = l->next) {
+		device = l->data;
+
+		d(g_print ("Adding: %s\n", device->uri));
+
+		drive = obex_create_drive_from_device (volume_monitor, device);
+		_gnome_vfs_volume_monitor_connected (volume_monitor, drive);
+
+		/* Check if the device is connected at the bluetooth layer, and
+		 * mount the volume if that's the case.
+		 */
+		if (obex_bda_is_connected (device->bda)) {
+			d(g_print ("Device is connected, mounting\n"));
+			obex_mount_bda (volume_monitor, device->bda);
+		}
+		
+		gnome_vfs_drive_unref (drive);
+	}
+	
+	g_list_free (added);
+	g_list_free (removed);
+
+	g_list_foreach (daemon->last_obex_devices,
+			(GFunc) obex_device_free, NULL);
+	g_list_free (daemon->last_obex_devices);
+	daemon->last_obex_devices = new_devices;
+}
+
+static void
+obex_mount_bda (GnomeVFSVolumeMonitor *monitor, const char *bda)
+{
+	char           *uri;
+	GnomeVFSVolume *volume;
+	GnomeVFSDrive  *drive;
+
+	d(g_print ("Trying to create a volume for %s.\n", bda));
+
+	/* First check if we already have a volume for this address. */
+	uri = obex_uri_from_bda (bda);
+	volume = _gnome_vfs_volume_monitor_find_vfs_volume_by_activation_uri (monitor, uri);
+
+	if (volume) {
+		d(g_print ("Already have volume mounted.\n"));
+
+		g_free (uri);
+		return;
+	}
+
+	/* Check if we have a drive for the bda. We don't mount volumes that
+	 * haven't been setup.
+	 */
+	drive = _gnome_vfs_volume_monitor_find_vfs_drive_by_activation_uri (monitor, uri);
+	if (!drive) {
+		d(g_print ("There is no drive for this bda.\n"));
+
+		g_free (uri);
+		return;
+	}
+	
+	g_free (uri);
+
+	if (!obex_bda_has_ftp (bda)) {
+		d(g_print ("Device has no FTP support.\n"));
+		return;
+	}
+	
+	/* Create a volume for this drive and mount it. */
+	volume = obex_create_volume_from_drive (monitor, drive);
+	_gnome_vfs_volume_monitor_mounted (monitor, volume);
+	gnome_vfs_volume_unref (volume);
+}
+
+static void
+obex_unmount_bda (GnomeVFSVolumeMonitor *monitor, const char *bda)
+{
+	char           *uri;
+	GnomeVFSVolume *volume;
+
+	d(g_print ("Trying to unmount volume %s.\n", bda));
+
+	/* First check if we have a volume for this address. */
+	uri = obex_uri_from_bda (bda);
+	volume = _gnome_vfs_volume_monitor_find_vfs_volume_by_activation_uri (monitor, uri);
+
+	g_free (uri);
+	
+	if (!volume) {
+		d(g_print ("Don't have this volume mounted.\n"));
+		return;
+	}
+	
+	/* Unmount the volume. */
+	_gnome_vfs_volume_monitor_unmounted (monitor, volume);
+}
+#endif /* USE_BTCOND */
Index: libgnomevfs/gnome-vfs-volume-monitor-daemon.h
===================================================================
--- libgnomevfs/gnome-vfs-volume-monitor-daemon.h	(revision 13394)
+++ libgnomevfs/gnome-vfs-volume-monitor-daemon.h	(working copy)
@@ -53,9 +53,12 @@
 	GList *last_fstab;
 	GList *last_mtab;
 	GList *last_connected_servers;
+	GList *last_obex_devices;
 	
 	GConfClient *gconf_client;
 	guint connected_id;
+
+	guint obex_devices_notify_id;
 };
 
 struct _GnomeVFSVolumeMonitorDaemonClass {
Index: libgnomevfs/gnome-vfs-volume.h
===================================================================
--- libgnomevfs/gnome-vfs-volume.h	(revision 13394)
+++ libgnomevfs/gnome-vfs-volume.h	(working copy)
@@ -59,7 +59,10 @@
 	GNOME_VFS_DEVICE_TYPE_MUSIC_PLAYER,
 	GNOME_VFS_DEVICE_TYPE_WINDOWS, 
 	GNOME_VFS_DEVICE_TYPE_LOOPBACK, 
-	GNOME_VFS_DEVICE_TYPE_NETWORK 
+	GNOME_VFS_DEVICE_TYPE_NETWORK,
+
+	GNOME_VFS_DEVICE_TYPE_BLUETOOTH,
+	GNOME_VFS_DEVICE_TYPE_OBEX_FTP
 } GnomeVFSDeviceType;
 
 typedef enum {
Index: dbus-daemon/vfs-daemon.c
===================================================================
--- dbus-daemon/vfs-daemon.c	(revision 13394)
+++ dbus-daemon/vfs-daemon.c	(working copy)
@@ -557,6 +557,7 @@
 {
 	GMainLoop             *loop;
 	GnomeVFSVolumeMonitor *monitor;
+        GnomeVFSURI           *uri, *uri_result;
 
 	d(g_print ("Starting daemon.\n"));
 
@@ -579,6 +580,18 @@
 		return 1;
 	}
 
+        /* Load the obex module by doing some work with it. It doesn't implement         * the find_directory method so it's a good way to get the module
+         * loaded.
+         */
+        uri = gnome_vfs_uri_new ("obex:///");
+        if (gnome_vfs_find_directory (uri,
+                                      GNOME_VFS_DIRECTORY_KIND_TRASH,
+                                      &uri_result,
+                                      FALSE, FALSE, 0) == GNOME_VFS_OK) {
+                gnome_vfs_uri_unref (uri_result);
+        }
+        gnome_vfs_uri_unref (uri);
+
 	/* Init the volume monitor. */
 	monitor = gnome_vfs_get_volume_monitor ();
 
